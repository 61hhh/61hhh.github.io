<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Salute</title>
  
  
  <link href="https://61hhh-github-io.vercel.app/atom.xml" rel="self"/>
  
  <link href="https://61hhh-github-io.vercel.app/"/>
  <updated>2024-05-11T06:47:46.611Z</updated>
  <id>https://61hhh-github-io.vercel.app/</id>
  
  <author>
    <name>LY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图床图片迁移</title>
    <link href="https://61hhh-github-io.vercel.app/20240511/c978efd1/"/>
    <id>https://61hhh-github-io.vercel.app/20240511/c978efd1/</id>
    <published>2024-05-11T02:30:36.000Z</published>
    <updated>2024-05-11T06:47:46.611Z</updated>
    
    <content type="html"><![CDATA[<p>之前注册的jihulab仓库做图床，类似于GitHub，但是偶然登录时提示试用期已经结束，需要购买专业或者旗舰版使用，为了避免保留期结束后数据被清空，所以需要迁移图片，之前买的服务器还是腾讯云的，所以这次选择用腾讯云cos。</p><span id="more"></span><h3 id="配置图床"><a href="#配置图床" class="headerlink" title="配置图床"></a>配置图床</h3><h4 id="申请COS"><a href="#申请COS" class="headerlink" title="申请COS"></a>申请COS</h4><p>先登录腾讯云，登录后搜索对象存储进入概览页面，新用户进去会送6个月的标准存储包，按照步骤领取后就可以创建存储桶了（如下图）</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20240511103900585.png" alt="image-20240511103900585"></p><p>创建一个桶，访问权限设置为<strong>公有读私有写</strong>，不然图片上传后不能访问，还得配置账号身份验证（安全问题可以通过设置防盗链）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20240511134020815.png" alt="image-20240511134020815" style="zoom:80%;" /><p>搜索进入 API 密钥管理，创建一个访问密钥</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20240511134304334.png" alt="image-20240511134304334" style="zoom:80%;" /><h4 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h4><p>准备好基本信息后进入picgo，配置腾讯云cos相关参数：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20240511134402945.png" alt="image-20240511134402945" style="zoom:80%;" /><p>此时就可以正常上传图片使用了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20240511135359520.png" alt="image-20240511135359520" style="zoom:80%;" /><h4 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h4><p>默认上传的域名（源站域名）是根据 bucket 名称、地域名称生成的，例如我的是：<code>leslie1-1309334886.cos.ap-shanghai.myqcloud.com</code>，自己有的域名话可以替换一下，存储桶列表点击进入详情，左侧域名与传输管理中添加一条自己的域名，在域名解析里添加CNAME解析即可</p><p><img src="https://cos-md.salute61.top/obsidian/image-20240511140225062.png" alt="image-20240511140225062"></p><p>在picgo出同样添加以下即可，已经上传的图片引用处正则替换一下就行</p><blockquote><p>腾讯云cos注册送的6个月标准存储容量包，但是流量使用也会产生费用，需要买流量包。</p><p>可以考虑又拍云，有免费10G存储和15G流量。操作方式和cos基本一致</p></blockquote><h3 id="图片迁移"><a href="#图片迁移" class="headerlink" title="图片迁移"></a>图片迁移</h3><p>之前在 jihulab 上的图片有几百张，手动一张张下载再重新上传太麻烦，刚好发现 PicGo 运行会启动一个本地 Server，根据他的文档是可以利用 api 上传的，写一个简单的代码去做这个工作逻辑：</p><ul><li>找到文本中 jihulab 的图片；</li><li>下载图片到指定文件夹；</li><li>把图片通过 PicGo 上传；</li><li>替换得到的新 url；</li></ul><p>我在完全没有学习过 python 的情况下，简单写一个 py 程序，工具如下：</p><ul><li>VSCode：编辑器</li><li>Codeium：GPT插件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> urllib.request<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-comment"># 正则</span><br>img_pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;https://jihulab\.com/.*\.gif&#x27;</span>, re.IGNORECASE)<br><span class="hljs-comment"># 目标文件夹</span><br>folder_path = <span class="hljs-string">&#x27;E:\\python-script\\posts&#x27;</span><br><span class="hljs-comment"># 保存文件夹</span><br>image_save_path = <span class="hljs-string">&#x27;E:\\python-script\\image_save&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(image_save_path):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(image_save_path, <span class="hljs-string">&#x27;w&#x27;</span>):<br>        <span class="hljs-keyword">pass</span><br><span class="hljs-comment"># 请求路径</span><br>upload_request = <span class="hljs-string">&#x27;http://127.0.0.1:36677/upload&#x27;</span><br><span class="hljs-comment"># 日志路径</span><br>logging.basicConfig(filename=<span class="hljs-string">&#x27;E:\\python-script\\handle.log&#x27;</span>, level=logging.INFO, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(message)s&#x27;</span>)<br><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">读取单个md文件,遍历其中所有旧url,下载上传得到新url并替换</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">match_and_save</span>(<span class="hljs-params">file_path</span>):<br>    <span class="hljs-keyword">if</span> file_path.endswith(<span class="hljs-string">&#x27;.md&#x27;</span>):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            content = f.read()<br>            matched_urls = img_pattern.findall(content)<br>            logging.info(<span class="hljs-string">&quot;开始处理: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(file_path))<br>            <span class="hljs-comment"># 旧url写入临时目录,然后上传替换url</span><br>            <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> matched_urls:<br>                <span class="hljs-comment"># 下载url到临时目录</span><br>                logging.info(<span class="hljs-string">&quot;\t&gt;&gt;&gt;&gt;原始URL: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(url))<br>                img_name = os.path.basename(url)<br>                img_abPath = os.path.join(image_save_path, img_name)<br>                urllib.request.urlretrieve(url, img_abPath)<br>                <span class="hljs-comment"># 调用上传接口</span><br>                logging.info(<span class="hljs-string">&quot;\t\t本地图片路径: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(img_abPath))<br>                data = &#123;<br>                    <span class="hljs-string">&#x27;list&#x27;</span>: [img_abPath]<br>                &#125;<br>                req = urllib.request.Request(upload_request, json.dumps(data).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json; charset=utf-8&#x27;</span>&#125;)<br>                <span class="hljs-keyword">with</span> urllib.request.urlopen(req) <span class="hljs-keyword">as</span> response:<br>                    res = json.loads(response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>                    logging.info(<span class="hljs-string">&quot;\t\t响应体:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(res))<br>                    <span class="hljs-keyword">if</span> res[<span class="hljs-string">&#x27;success&#x27;</span>]:<br>                        new_url = res[<span class="hljs-string">&#x27;result&#x27;</span>][<span class="hljs-number">0</span>]<br>                        content = content.replace(url, new_url)<br>                        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                            f.write(content)<br>            <span class="hljs-comment"># 清空临时目录</span><br>            <span class="hljs-keyword">for</span> file_name <span class="hljs-keyword">in</span> os.listdir(image_save_path):<br>                file_path = os.path.join(image_save_path, file_name)<br>                <span class="hljs-keyword">if</span> os.path.isfile(file_path):<br>                    os.remove(file_path)<br>            logging.info(<span class="hljs-string">&quot;处理完成: &#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(file_path))<br>    <br>    <span class="hljs-keyword">return</span> []<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">文件则调用方法,文件夹则递归遍历</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">traverse_folder</span>(<span class="hljs-params">folder_path</span>):<br>    <span class="hljs-keyword">if</span> os.path.isdir(folder_path):<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> os.listdir(folder_path):<br>            item_path = os.path.join(folder_path, item)<br>            traverse_folder(item_path)<br>    <span class="hljs-keyword">elif</span> os.path.isfile(folder_path):<br>        match_and_save(folder_path)<br><br><span class="hljs-comment"># 调用方法</span><br>traverse_folder(folder_path)<br></code></pre></td></tr></table></figure><p>代码都是 <code>ctrl + i</code> 快捷键问 GPT 生成的，我只是每个逐个方法校验一遍，调整生成的代码即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前注册的jihulab仓库做图床，类似于GitHub，但是偶然登录时提示试用期已经结束，需要购买专业或者旗舰版使用，为了避免保留期结束后数据被清空，所以需要迁移图片，之前买的服务器还是腾讯云的，所以这次选择用腾讯云cos。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="https://61hhh-github-io.vercel.app/tags/hexo/"/>
    
    <category term="工具" scheme="https://61hhh-github-io.vercel.app/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>7、RabbitMQ延时队列</title>
    <link href="https://61hhh-github-io.vercel.app/20230511/201df3ca/"/>
    <id>https://61hhh-github-io.vercel.app/20230511/201df3ca/</id>
    <published>2023-05-11T02:23:33.000Z</published>
    <updated>2024-04-16T08:42:11.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>延时队列也是一个消息队列，和普通队列区别之处只是它带有<strong>延时功能</strong>。例如实际开发的某些场景中，需要让消息在指定时间才会被消费</p><ol><li>订单下单后指定时间未付款就取消</li><li>用户注册后，指定时间内未登录或验证，发送消息提醒</li><li>某个业务操作失败后，间隔一段时间重试或进行其他操作</li></ol><p>类似的场景其实很多。并且上述情况好像也可以通过定时任务轮询来处理，但是性能不高，并且业务数据量大&amp;存在高并发的场景下，极易导致系统宕掉，另一方面定时任务的轮询也会有较大误差产生。</p><p>RabbitMQ本身是不支持延时队列的，但是可以通过定制方式实现</p><ul><li><strong>改造死信队列的TTL模式</strong>，使消息过期后全部进入死信队列，来达到延时的效果</li><li><strong>使用延时队列插件</strong>，让交换器管理延时消息</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>这里操作按照整合SpringBoot进行，参照整合SpringBoot，先创建SpringBoot模块，并勾选相关依赖，在yml配置文件中添加rabbitmq连接</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.204</span><span class="hljs-number">.127</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ant_path_matcher</span><br></code></pre></td></tr></table></figure><h3 id="队列TTL延时"><a href="#队列TTL延时" class="headerlink" title="队列TTL延时"></a>队列TTL延时</h3><p>创建RabbitMQ配置类，其中队列QA、QB的过期时间分别是10s、40s，再创建交换器X和死信交换器Y，二者都是direct类型，最后创建死信队列QD存放死信消息</p><p>消费者不监听QA、QB队列，使消息进入队列后不被消费导致TTL超时进入延迟队列QD</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657795388413-69a6c47f-75f5-4da2-a15f-0258461d25a5.png" alt="img" style="zoom:80%;" /><p>【注】设计的缺点：每增加一个新的延时时间需求，就需要增加一个队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TTLQueueConfig</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">X_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ex_x&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QA&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_B</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QB&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_C</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QC&quot;</span>;<br>    <span class="hljs-comment">// 死信交换机和队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">Y_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ex_y&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_D</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QD&quot;</span>;<br><br>    <span class="hljs-meta">@Bean(&quot;xExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">xExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(X_EXCHANGE);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;yExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">yExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(Y_EXCHANGE);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;queueA&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueA</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 声明死信队列</span><br>        map.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_EXCHANGE);<br>        map.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;RK_Y&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">10000</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(map).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBindingA</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="hljs-string">&quot;RK_XA&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;queueB&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueB</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 声明死信队列</span><br>        map.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_EXCHANGE);<br>        map.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;RK_Y&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">40000</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(map).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBindingB</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="hljs-string">&quot;RK_XB&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;queueC&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueC</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 声明死信队列</span><br>        map.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_EXCHANGE);<br>        map.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;RK_Y&quot;</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(map).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBindingC</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="hljs-string">&quot;RK_XC&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;queueD&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueD</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(QUEUE_D);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBindingD</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="hljs-string">&quot;RK_Y&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RequestMapping(&quot;ttl&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMsgController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@GetMapping(&quot;sendMsg/&#123;msg&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String msg)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;当前时间-----&gt;&#123;&#125;,发送消息给两个TTL队列-----&gt;&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), msg);<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ex_x&quot;</span>, <span class="hljs-string">&quot;RK_XA&quot;</span>, <span class="hljs-string">&quot;消息存放于ttl=10s队列QA中-----&gt;&quot;</span> + msg);<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ex_x&quot;</span>, <span class="hljs-string">&quot;RK_XB&quot;</span>, <span class="hljs-string">&quot;消息存放于ttl=10s队列QA中-----&gt;&quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLQueueConsumer</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;QD&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveD</span><span class="hljs-params">(Message message, Channel channel)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>        log.info(<span class="hljs-string">&quot;当前时间-----&gt;&#123;&#125;,从死信队列获取到的消息-----&gt;&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动项目访问：<code>http://localhost:8080/ttl/sendMsg/发送消息TTL</code>，看到控制台对应输出</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657796562162-65178fbf-195f-4b8d-8b96-a8ef196fa270.png" alt="img" style="zoom:80%;" /><h3 id="消息TTL延时"><a href="#消息TTL延时" class="headerlink" title="消息TTL延时"></a>消息TTL延时</h3><p>上面的方法缺点很明显，不同的延时时间就需要不同的队列，可见通过队列TTL设置会比较麻烦</p><p>改造一下，在配置列中添加队列QC，不设置TTL</p><p>缺点：如果积压在队列前面的消息延时时长很长，而后面积压的消息延时时长很短，积压时间短的消息并不会被提前放入死信队列；如果QC恰好又设置了积压上限，无法被积压的消息将直接进入延时队列，达不到延时效果</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657795689587-d017a7a4-ee2b-4530-9c65-35b1fdddc47b.png" alt="img" style="zoom:80%;" /><p>生产者添加代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;sendExpirationMsg/&#123;msg&#125;/&#123;ttlTime&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsgWithTTL</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String msg, <span class="hljs-meta">@PathVariable</span> String ttlTime)</span> &#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ex_x&quot;</span>, <span class="hljs-string">&quot;RK_XC&quot;</span>, msg, correlationData -&gt; &#123;<br>        correlationData.getMessageProperties().setExpiration(ttlTime);<br>        <span class="hljs-keyword">return</span> correlationData;<br>    &#125;);<br>    log.info(<span class="hljs-string">&quot;当前时间-----&gt;&#123;&#125;,发送一个TTL为&#123;&#125;的消息给队列C-----&gt;&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), ttlTime, msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>设置消息的TTL，值通过参数传入，实现不同消息具有不同TTL，可以对应到业务中的不同任务。只用了一个队列，但是实现了不同时间的延时</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657796306470-72d82375-4a6e-4a25-aa5d-571d75d5b467.png" alt="img" style="zoom:80%;" /><h3 id="插件延时"><a href="#插件延时" class="headerlink" title="插件延时"></a>插件延时</h3><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>在<a href="https://www.rabbitmq.com/community-plugins.html">RabbitMQ官网-社区插件</a>中下载<code>rabbitmq_delayed_message_exchange</code>插件，通过FileZilla等FTP工具传到虚拟机中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将插件复制到容器对应的plugins目录下</span><br>docker cp /opt/rabbitmq_delayed_message_exchange-3.10.0.ez 容器ID:/plugins<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器内部 需要容器处于运行状态</span><br>docker exec -it 容器ID /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看插件是否成功复制到指定目录</span><br>cd plugins<br>ls -l|grep delay <br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启运行插件</span><br>rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br></code></pre></td></tr></table></figure><p>注意rabbitmq的版本和插件的版本，我的RabbitMQ版本为<code>3.8.34</code>，插件在GitHub上下载<code>3.10.x</code>后运行提示报错，我看报错信息部分写了<code>supported by the plugin: [&quot;3.9.0-3.9.x&quot;, &quot;3.10.0-3.10.x&quot;]</code>所以我把<code>3.9</code>到<code>3.10</code>的版本都试了下但是都不行！</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657851569778-7edd7a28-9ff2-40f4-ad13-dcba855e72e4.png" alt="img" style="zoom:80%;" /><p>关于版本支持的说明，应该去GitHub上看插件说明，可以看到<code>3.9.x</code>的插件对应的是<code>3.9.x</code>的RabbitMQ，我的版本就应该选择<code>3.8.x</code>来适配</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657851815093-9a0eb06f-6fde-4e21-a886-2ac09b8ea220.png" alt="img" style="zoom:80%;" /><p>更换插件版本后即可成功，然后重启rabbitmq，在管理后台界面查看插件是否成功启用</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657851997103-89049ab2-e0d5-4627-b280-0e864015b69c.png" alt="img" style="zoom:80%;" /><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657852033198-97f702f0-394e-440e-9fe0-374202e10eeb.png" alt="img" style="zoom:80%;" /><h4 id="插件延时操作"><a href="#插件延时操作" class="headerlink" title="插件延时操作"></a>插件延时操作</h4><p>这里创建了一个direct交换机和队列，结构如图</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657853374382-88325615-0dc9-4d38-a5aa-9a9ecaa8b891.png" alt="img" style="zoom:80%;" /><p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中</p><p>1、配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedQueueConfig</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.routingKey&quot;</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 创建插件版本的交换器，通过自定义方法创建</span><br><span class="hljs-comment">     * 插件版本非死信队列，不需要路由到不同的交换器指定过期时间，所以可以固定为direct类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CustomExchange <span class="hljs-title function_">delayedExchange</span><span class="hljs-params">()</span> &#123;<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&quot;x-delayed-type&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>); <span class="hljs-comment">// 自定义交换机类型，固定为direct</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomExchange</span>(DELAYED_EXCHANGE, <span class="hljs-string">&quot;x-delayed-message&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, map);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">delayedQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(DELAYED_QUEUE).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">delayedBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue delayedQueue,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange)<br>                .with(DELAYED_ROUTING_KEY)<br>                .noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、生产者，在对应controller中添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 延时插件</span><br><span class="hljs-meta">@RequestMapping(&quot;/plugins/sendMsg/&#123;msg&#125;/&#123;time&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsgByPlugin</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String msg, <span class="hljs-meta">@PathVariable</span> Integer time)</span> &#123;<br>    <span class="hljs-type">MessageProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageProperties</span>();<br>    properties.setDelay(time);<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(msg.getBytes(StandardCharsets.UTF_8), properties);<br>    log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,发送过期时间为&#123;&#125;毫秒的消息到延时插件，内容为：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), time, msg);<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;delayed.exchange&quot;</span>, <span class="hljs-string">&quot;delayed.routingKey&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、消费者，在对应controller添加监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 延时插件消费</span><br><span class="hljs-meta">@RabbitListener(queues = &quot;delayed.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveDelayQueue</span><span class="hljs-params">(Message msg, Channel channel)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody());<br>    log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;，收到延时消息：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), message);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后查看效果</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657853555914-5b835b41-9c83-4651-b7d9-69ef459cf9e3.png" alt="img" style="zoom:80%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;延时队列也是一个消息队列，和普通队列区别之处只是它带有&lt;strong&gt;延时功能&lt;/strong&gt;。例如实际开发的某些场景中，需要让消息在指定</summary>
      
    
    
    
    <category term="消息队列" scheme="https://61hhh-github-io.vercel.app/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RabbitMQ" scheme="https://61hhh-github-io.vercel.app/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>6、SpringBoot整合RabbitMQ</title>
    <link href="https://61hhh-github-io.vercel.app/20230511/ef3b40a7/"/>
    <id>https://61hhh-github-io.vercel.app/20230511/ef3b40a7/</id>
    <published>2023-05-11T02:23:09.000Z</published>
    <updated>2024-04-16T08:42:11.165Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot作为目前后端开发的主流框架，基本上系统都有应用，并且它对其他很多框架提供了非常优秀的集成。</p><p>新建一个springboot工程</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752277077-232a359f-9940-4be4-99a9-cd3e224dde69.png" alt="img" style="zoom: 80%;" /><p>在Messaging选项中勾选RabbitMQ，之后卡一看到mavenpom文件中依赖<code>spring-boot-starter-amqp</code>，它继承了<code>amqp-client</code>依赖实现了amqp协议</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改yaml配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.204</span><span class="hljs-number">.127</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><p>常用的RabbitMQ操作类有RabbitAdmin、RabbitTemplate，其中使用比较广泛的是RabbitTemplate，这里整合的也是以RabbitTemplate使用为主。它提供了编辑、发送、监听消息等一系列功能，通过RabbitTemplate，可以在Springboot中像操作原生API一样进行消息的发送监听操作</p><p>先按照之前的最基础模式，测试Springboot集成RabbitMQ的基础操作API</p><h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>简单模式就是最基础的消息队列，它简化了其他操作，仅模拟生产者、队列、消费者三个部分</p><ol><li>创建三个对象的对应类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 基础的生产者，通过RabbitTemplate操作消息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleSender</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SimpleSender.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.hello&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate template;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        <span class="hljs-built_in">this</span>.template.convertAndSend(queueName, message);<br>        LOGGER.info(<span class="hljs-string">&quot; [x] Sent &#x27;&#123;&#125;&#x27;&quot;</span>, message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 基础的消费者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleReceiver</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SimpleReceiver.class);<br><br>    <span class="hljs-meta">@RabbitHandler</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String in)</span> &#123;<br>        LOGGER.info(<span class="hljs-string">&quot; [x] Received &#x27;&#123;&#125;&#x27;&quot;</span>, in);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建对应配置类，在配置类中设置好队列</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRabbitConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;simple.hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SimpleSender <span class="hljs-title function_">simpleSender</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleSender</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SimpleReceiver <span class="hljs-title function_">simpleReceiver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleReceiver</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>创建controller进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/rabbit&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SimpleSender simpleSender;<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/simple&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            simpleSender.send();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752435417-4cd39d9e-5f56-4ce2-8d23-cb9086870e5a.png" alt="img" style="zoom:80%;" /></h4><h4 id="Work-Queue"><a href="#Work-Queue" class="headerlink" title="Work Queue"></a>Work Queue</h4><p><strong>WorkQueue</strong>模式将多个消费者绑定到一个队列中，默认采取轮询方式分发消息</p><p>操作可以参照上面</p><ol><li>创建对应的对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 生产者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkSender</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(WorkSender.class);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;work&quot;</span>;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">limitIndex</span> <span class="hljs-operator">=</span> index % <span class="hljs-number">3</span>+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; limitIndex; i++) &#123;<br>builder.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>&#125;<br>builder.append(index+<span class="hljs-number">1</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> builder.toString();<br>rabbitTemplate.convertAndSend(QUEUE_NAME, message);<br>LOGGER.info(<span class="hljs-string">&quot; [x] Sent &#x27;&#123;&#125;&#x27;&quot;</span>, message);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 消费者</span><br><span class="hljs-meta">@RabbitListener(queues = &quot;work&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkReceiver</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(WorkReceiver.class);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> instance;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">WorkReceiver</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br><span class="hljs-built_in">this</span>.instance = i;<br>&#125;<br><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String in)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">StopWatch</span> <span class="hljs-variable">watch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();<br>watch.start();<br>LOGGER.info(<span class="hljs-string">&quot;instance &#123;&#125; [x] Received &#x27;&#123;&#125;&#x27;&quot;</span>, <span class="hljs-built_in">this</span>.instance, in);<br>doWork(in); <span class="hljs-comment">// 模拟业务操作</span><br>watch.stop();<br>LOGGER.info(<span class="hljs-string">&quot;instance &#123;&#125; [x] Done in &#123;&#125;s&quot;</span>, <span class="hljs-built_in">this</span>.instance, watch.getTotalTimeSeconds());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(String in)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : in.toCharArray()) &#123;<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkRabbitConfig</span> &#123;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">workQueue</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;work&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 模拟两个消费者</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> WorkReceiver <span class="hljs-title function_">workReceiver1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkReceiver</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> WorkReceiver <span class="hljs-title function_">workReceiver2</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkReceiver</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> WorkSender <span class="hljs-title function_">workSender</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkSender</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>编写controller，调用测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/work&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">workTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            workSender.send(i);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure> <img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752830230-99043ec3-05f8-4e47-b8a5-32752b7cc937.png" alt="img" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SpringBoot作为目前后端开发的主流框架，基本上系统都有应用，并且它对其他很多框架提供了非常优秀的集成。&lt;/p&gt;
&lt;p&gt;新建一个springboot工程&lt;/p&gt;
&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;https://cdn.nl</summary>
      
    
    
    
    <category term="消息队列" scheme="https://61hhh-github-io.vercel.app/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RabbitMQ" scheme="https://61hhh-github-io.vercel.app/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>5、RabbitMQ死信队列</title>
    <link href="https://61hhh-github-io.vercel.app/20230511/9b199b28/"/>
    <id>https://61hhh-github-io.vercel.app/20230511/9b199b28/</id>
    <published>2023-05-11T02:22:45.000Z</published>
    <updated>2024-04-16T08:42:11.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过期时间TTL"><a href="#过期时间TTL" class="headerlink" title="过期时间TTL"></a>过期时间TTL</h2><p>先介绍一下TTL概念</p><p>TTL即<code>Time to Live</code>的简称，表示过期时间。RabbitMQ可以对消息和队列设置对应TTL</p><h3 id="0、消息TTL设置"><a href="#0、消息TTL设置" class="headerlink" title="0、消息TTL设置"></a>0、消息TTL设置</h3><ul><li>通过队列属性设置，<strong>队列中所有消息都有相同的过期时间</strong>。</li><li>通过消息属性设置，<strong>可以实现每个消息都有自己的过期时间</strong>。</li></ul><p>二者可以同时使用，此时则以TTL数值较小的为准</p><h3 id="1、队列上设置"><a href="#1、队列上设置" class="headerlink" title="1、队列上设置"></a>1、队列上设置</h3><p>在定义队列时，添加属性<code>x-message-ttl</code>，单位是毫秒，<strong>这里设置的并不是队列的TTL，而是该队列中所有消息的TTL</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> HashMap&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>args.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">6000</span>);<br>channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, args);<br></code></pre></td></tr></table></figure><p>TTL取值的区分</p><ul><li>不设置TTL：该消息不会过期</li><li>值&#x3D;0：表示除非此时可以直接将消息投递到消费者，不然就丢弃</li><li>值&gt;0：表示将在到值对应时间后过期</li></ul><h3 id="2、消息上设置"><a href="#2、消息上设置" class="headerlink" title="2、消息上设置"></a>2、消息上设置</h3><p>针对单独消息设置TTL是在<code>channel.BasicPublish</code>方法中加入<code>expiration</code>参数，单位为毫秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> AMQP.BasicProperties.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder();<br>builder.deliveryMode(<span class="hljs-number">2</span>);<span class="hljs-comment">//设置消息持久化</span><br>builder.expiration(<span class="hljs-string">&quot;5000&quot;</span>);<span class="hljs-comment">//设置过期时间5000毫秒</span><br><span class="hljs-keyword">final</span> AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> builder.build();<br>channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, properties, msg.getBytes());<br></code></pre></td></tr></table></figure><h3 id="3、对比"><a href="#3、对比" class="headerlink" title="3、对比"></a>3、对比</h3><ol><li>队列设置：时间从消息入队开始计算，一旦超过了队列的超时时间配置，消息会自动清除。</li><li>消息设置：消息即使过期也不一定会被马上丢弃，<strong>因为每条消息是否过期是在即将投递到消费者之前判定的</strong>（ 如果当前队列有严重的消息积压情况，已过期的消息依旧会被积压在队列中，如果队列配置了消息积压上限，将导致后续应当正常消费的消息全部进入死信队列 ）</li></ol><p>队列设置中，队列已过期的消息肯定在队列头部（过期时间一致的前提下，先进先出），RabbitMQ只需要定期从队列头部开始扫描是否有已过期的消息即可。</p><p>消息设置中，每个消息的过期时间不同，如果要删除过期消息就必须扫描整个队列，所以还不如等到消息即将被消费时再判定是否过期，如果过期就删除即可</p><h2 id="死信队列DLX"><a href="#死信队列DLX" class="headerlink" title="死信队列DLX"></a>死信队列DLX</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>死信（Dead Message）：<strong>由于某些特定原因导致无法被消费的消息</strong>。</p><p>按照正常流程消息从producer到broker再到queue，consumer从queue中取出消息消费，由于特定原因queue中的消息无法被消费，这类消费异常的消息就会保存在死信队列中，来避免消息的丢失</p><p>场景：<strong>用户在商城下单后，超过半小时未付款，该订单自动取消</strong></p><p>DLX（Dead-Letter-Exchange）可以成为死信交换器，或死信邮箱。当一个消息成为死信之后，可以被重新发送到另一个交换器即DLX中，而绑定了DLX的队列即为死信队列</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>消息变成死信，一般有以下三种原因</p><ul><li>TTL过期</li><li>队列积压的消息达到最大长度，后续消息无法添加</li><li>消息被拒，消费者调用<code>basic.reject</code>或<code>basic.nack</code>并且<code>requeue=false</code></li></ul><p>DLX 是一个普通的交换器，可以在任何队列上设置，当死信消息出现时，RabbitMQ 自动将这个消息重新发布到设置的 DLX上，从而被路由到另一个队列，即 <strong>死信队列</strong></p><h2 id="死信DEMO"><a href="#死信DEMO" class="headerlink" title="死信DEMO"></a>死信DEMO</h2><p>死信队列架构图</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657438155832-0a0a8239-7d68-4412-9e9c-cf6437f2ae7e.png" alt="img" style="zoom:80%;" /><ul><li>定义一个DLX（其实就是普通交换器，用来绑定正常的交换器），为该DLX绑定队列，用于接收死信消息</li><li>定义正常的交换器，并通过属性设置它所对应的DLX和路由键</li></ul><h3 id="死信之TTL"><a href="#死信之TTL" class="headerlink" title="死信之TTL"></a>死信之TTL</h3><p>生产者代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TTLProducer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normalExchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ZhangSan&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">// 设置消息的TTL为10秒</span><br>        AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="hljs-string">&quot;10000&quot;</span>).build();<br>        <span class="hljs-comment">// 演示队列个数限制</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INFO_&quot;</span> + i;<br>            channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="hljs-literal">null</span>, msg.getBytes());<br>            System.out.println(msg + <span class="hljs-string">&quot;发送完成&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TTL消费者1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TTLConsumer1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NORMAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normalExchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DEAD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;deadExchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NORMAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normalQueue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_DEAD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;deadQueue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ZhangSan&quot;</span>; <span class="hljs-comment">//普通队列routing-key</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LiSi&quot;</span>;     <span class="hljs-comment">//死信队列routing-key</span><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        <span class="hljs-comment">// 声明普通和死信交换机 normal-exchange在生产者处已经声明</span><br>        channel.exchangeDeclare(EXCHANGE_NORMAL, BuiltinExchangeType.DIRECT);<br>        channel.exchangeDeclare(EXCHANGE_DEAD, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 通过额外参数指定在什么条件下讲消息转发到死信队列，其中key值是rabbitmq固定的</span><br><span class="hljs-comment">         * value1：TTL时间，一般由生产者指定</span><br><span class="hljs-comment">         * value2：死信交换机名称</span><br><span class="hljs-comment">         * value3：死信交换机的routing-key</span><br><span class="hljs-comment">         * value4：指定队列能够积压消息的数量，超出该范围的消息将进入死信队列</span><br><span class="hljs-comment">         */</span><br>        HashMap&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//params.put(&quot;x-dead-letter-ttl&quot;, 10000);</span><br>        params.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, EXCHANGE_DEAD);<br>        params.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, ROUTING_KEY2);<br>        <span class="hljs-comment">//params.put(&quot;x-max-length&quot;, 6);</span><br><br>        channel.queueDelete(QUEUE_NORMAL); <span class="hljs-comment">//变更queueDeclare的params参数后，原队列要删除</span><br>        <span class="hljs-comment">// 声明绑定正常队列</span><br>        channel.queueDeclare(QUEUE_NORMAL, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, params);<br>        channel.queueBind(QUEUE_NORMAL, EXCHANGE_NORMAL, ROUTING_KEY1);<br>        <span class="hljs-comment">// 声明绑定死信队列</span><br>        channel.queueDeclare(QUEUE_DEAD, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.queueBind(QUEUE_DEAD, EXCHANGE_DEAD, ROUTING_KEY2);<br><br>        System.out.println(<span class="hljs-string">&quot;----------等待接收消息----------&quot;</span>);<br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot;Consumer01 接收到消息 &quot;</span> + message);<br>        &#125;;<br>        channel.basicConsume(QUEUE_NORMAL, <span class="hljs-literal">false</span>, deliverCallback, consumer -&gt; &#123;&#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>先启动消费者1再关闭，模拟消费者接收不到消息，再启动生产者</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657784417355-1fe19cd7-61ee-4e83-afa6-f29aa73671a0.png" alt="img" style="zoom:80%;" /><p>等到设置的过期时间10s到达后，消息就会送达到死信队列</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657784627848-f85d4922-d27c-46f0-abc7-d3e6ee53fb71.png" alt="img" style="zoom:80%;" /><p>以上操作完成后，启动消费者2，消费死信队列中的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TTLConsumer2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DEAD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;deadExchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_DEAD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;deadQueue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LiSi&quot;</span>;     <span class="hljs-comment">//死信队列routing-key</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_DEAD, BuiltinExchangeType.DIRECT);<br>        channel.queueDeclare(QUEUE_DEAD, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.queueBind(QUEUE_DEAD, EXCHANGE_DEAD, ROUTING_KEY2);<br><br>        System.out.println(<span class="hljs-string">&quot;----------等待接收消息----------&quot;</span>);<br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot;TTLConsumer2接收到-----&gt;&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(QUEUE_DEAD, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657784722560-26360135-54d9-4b23-b401-3d52642e309f.png" alt="img" style="zoom:80%;" /><h3 id="死信之最大长度"><a href="#死信之最大长度" class="headerlink" title="死信之最大长度"></a>死信之最大长度</h3><p>1、将生产者代码设置TTL的部分注释</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657785108809-255e6577-7f9f-4ae3-a044-91480dd085f3.png" alt="img" style="zoom: 80%;" /><p>2、修改消费者1代码，设置队列接收消息的长度</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657785167054-e9f826b1-8b1b-457c-97b1-4e59cae1ea68.png" alt="img" style="zoom:80%;" /><p>3、和上面示例类似，先启动消费者1再关闭，模拟正常队列无法接收消息；再发送消费者，查看消息是否到达了死信队列</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657786705553-2f7fecbd-59d2-4e32-823b-4cd8f1925a8c.png" alt="img" style="zoom:80%;" /><p>4、启动消费者2消费死信队列中的消息即可</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657786766060-55d7b605-9d81-4ab1-8e65-d6b54cabc5c0.png" alt="img" style="zoom:80%;" /><h3 id="死信之消息拒绝"><a href="#死信之消息拒绝" class="headerlink" title="死信之消息拒绝"></a>死信之消息拒绝</h3><p>1、生产者不变，消费者1将队列最大长度限制注释，将<code>DeliverCallback</code>回调重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>    <span class="hljs-keyword">if</span> (msg.equals(<span class="hljs-string">&quot;INFO_5&quot;</span>)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;TTLConsumer1拒收消息-----&gt;&quot;</span> + msg);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * requeue设置为false表示拒绝重新入队</span><br><span class="hljs-comment">         * 该队列如果配置了死信队列，交换机就会将消息发送到死信队列，否则会丢弃</span><br><span class="hljs-comment">         */</span><br>        channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TTLConsumer1接收到-----&gt;&quot;</span> + msg);<br>        channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;;<br>channel.basicConsume(QUEUE_NORMAL, <span class="hljs-literal">false</span>, deliverCallback, consumer -&gt; &#123;<br>&#125;);<br></code></pre></td></tr></table></figure><p>2、启动生产者后，发送10条消息。再启动消费者1和消费者2，可以查看到消费者1拒收了<code>INFO_5</code>，而消费者2消费了<code>INFO_5</code></p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657787046112-42c55314-bdc7-4649-bdb9-2c45b35da533.png" alt="img" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;过期时间TTL&quot;&gt;&lt;a href=&quot;#过期时间TTL&quot; class=&quot;headerlink&quot; title=&quot;过期时间TTL&quot;&gt;&lt;/a&gt;过期时间TTL&lt;/h2&gt;&lt;p&gt;先介绍一下TTL概念&lt;/p&gt;
&lt;p&gt;TTL即&lt;code&gt;Time to Live&lt;/code&gt;的简称</summary>
      
    
    
    
    <category term="消息队列" scheme="https://61hhh-github-io.vercel.app/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RabbitMQ" scheme="https://61hhh-github-io.vercel.app/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>4、RabbitMQ交换机</title>
    <link href="https://61hhh-github-io.vercel.app/20230511/72a21c93/"/>
    <id>https://61hhh-github-io.vercel.app/20230511/72a21c93/</id>
    <published>2023-05-11T02:22:01.000Z</published>
    <updated>2024-04-16T08:42:11.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交换机概念"><a href="#交换机概念" class="headerlink" title="交换机概念"></a>交换机概念</h2><p>之前的示例，都是按照<code>生产者--&gt;消息队列--&gt;消费者</code>的概念进行的</p><p>实际上RabbitMQ消息传递模型的核心思想是：<strong>生产者的消息从来不会直接发送到队列</strong>。事实上，生产者甚至不知道消息会被发到哪个队列</p><p>相反，生产者只能将消息发送到交换器。交换器工作内容非常简单：一方面它接收来自生产者的消息，另一方面它将它们推送到队列中。交换器必须确切地知道如何处理它收到的消息。是推送到特定队列还是多个队列亦或是丢弃，而这就由交换机的类型决定。</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657175708664-46a07f76-04f2-440a-96aa-a3a225aa2738.png" alt="img" style="zoom:80%;" /><p>交换器有几个基本类型：<code>fanout</code>、<code>Direct</code>、<code>topic</code>、<code>headers</code>。其中<code>headers</code>已经基本弃用了</p><p>通常情况下都是生产者发送消息后才会执行消费者操作，因此一般交换机都是由生产者创建，且声明一次即可</p><h3 id="无名exchange"><a href="#无名exchange" class="headerlink" title="无名exchange"></a>无名exchange</h3><p>之前的DEMO好没有明确用过exchange，但是仍能够将消息发到队列中，因为已经指定了默认的交换机。<code>channel.basicPublish</code>的第一个参数即为交换机，之前都用空字符串标识：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br></code></pre></td></tr></table></figure><p>默认交换机会隐式地绑定到每个队列上，RoutingKey即为队列名称。默认交换机不能显式绑定或者解绑，也不能删除</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657266583824-e3d7718d-2881-4a80-be0f-548568758561.png" alt="img" style="zoom: 67%;" /><h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>可以看到上面的<code>basicPublish</code>指定了队列名QUEUE_NAME，用于确定消息会发送到哪个队列。</p><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p><p>可以通过以下方式创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br></code></pre></td></tr></table></figure><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657269026760-961d8b83-a75e-4224-9468-3439ea26aa57.png" alt="img" style="zoom:80%;" /><h3 id="绑定Bindings"><a href="#绑定Bindings" class="headerlink" title="绑定Bindings"></a>绑定Bindings</h3><p>在最上面的图中，交换机X如何将消息发到指定队列上？对应的两个箭头实际上就是两个<code>Binding</code>：它声明了交换机和队列的绑定关系，在绑定时会有一个BindingKey，这样RabbitMQ就知道如何正确将消息路由到指定队列了。</p><p>生产者发送代码到交换机时，会提供一个RoutingKey，当RoutingKey和BindingKey相匹配时，消息就会发到对应的队列中了</p><h2 id="Fanout类型"><a href="#Fanout类型" class="headerlink" title="Fanout类型"></a>Fanout类型</h2><p><code>fanout</code>类型又称广播类型，它会将消息发送到所有队列上</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657268264623-56b3d342-177f-4d96-b300-225f581f3b82.png" alt="img" style="zoom:80%;" /><p>为了说明这种模式，我们将构建一个简单的日志DEMO，生产者生产日志，两个消费者一个将日志输出到文件，一个输出到控制台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutProducer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 声明一个exchange</span><br><span class="hljs-comment">         * 参数一：exchange的名称</span><br><span class="hljs-comment">         * 参数二：exchange的类型</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>            channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>, msg.getBytes(StandardCharsets.UTF_8));<br>            System.out.println(<span class="hljs-string">&quot;生产者EmitLogs发出消息：&quot;</span> + msg);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费者输出日志到文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutConsumer1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 随机生成一个临时队列</span><br><span class="hljs-comment">         * 当消费者与该队列断开连接时，队列自动删除</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">// 把该临时队列绑定到exchange，其中routingkey(也称之为 binding key)为空字符串</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息。。。。。。。。。。保存到文件&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\data\\rabbitmq.txt&quot;</span>);<br>            FileUtils.writeStringToFile(file, msg, StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;数据写入文件成功&quot;</span>);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费者输出日志到控制台</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutConsumer2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 随机生成一个临时队列</span><br><span class="hljs-comment">         * 当消费者与该队列断开连接时，队列自动删除</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">// 把该临时队列绑定到exchange，其中routingkey(也称之为 binding key)为空字符串</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息。。。。。。。。。。输出控制台&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;接收到的消息：&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到消费者1成功将日志写到了指定文件中，而消费者而打印了日志，内容相同</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657268654683-dfd8d446-3946-4994-a620-d02065885fe5.png" alt="img" style="zoom:65%;" /><h2 id="Direct类型"><a href="#Direct类型" class="headerlink" title="Direct类型"></a>Direct类型</h2><p>相比于fanout类型向所有队列广播消息，有时业务场景需要根据日志的不同级别分别输出，比如warning和error输出到文件中，info就打印到控制台，这时就不能广播消息了，此时可以使用<code>Direct</code>类型：它通过对比消息的RoutingKey和队列BindingKey，将消息发送到对应队列中。</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657270482095-66cfc377-1e2f-4483-9f88-a919e129d483.png" alt="img" style="zoom:80%;" /><p>如图的<code>direct交换机</code>绑定到了Q1、Q2，其中Q1的BindingKey是orange，Q2的BindingKey是black和green，即生产者在发送消息是的RoutingKey为orange时会发送到消息Q1、是black或green时会到Q2。加入Q1和Q2用了一样的BindingKey，那么此时的<code>direct</code>就和<code>fanout</code>效果相同了</p><p>代码DEMO如下：生产者创建多个BindingKey，每个BindingKey发送一条消息；消费者1的<code>queueBind</code>绑定error、消费者2的<code>queueBind</code>绑定info和warning，而没有绑定到任何队列的debug级别消息就丢弃</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectProducer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">// 创建多个bindingKey</span><br>        HashMap&lt;String, String&gt; keyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        keyMap.put(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;info信息&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;warning&quot;</span>, <span class="hljs-string">&quot;warning警告&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;error错误&quot;</span>);<br>        <span class="hljs-comment">// debug不设置消费者接收，查看效果是全部丢失</span><br>        keyMap.put(<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-string">&quot;debug调试&quot;</span>);<br><br><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; keyEntry : keyMap.entrySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyEntry.getKey();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> keyEntry.getValue();<br>            channel.basicPublish(EXCHANGE_NAME, key, <span class="hljs-literal">null</span>, value.getBytes(StandardCharsets.UTF_8));<br>            System.out.println(<span class="hljs-string">&quot;生产者发送消息：&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectConsumer1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;disk&quot;</span>;<br>        <span class="hljs-comment">// 队列声明</span><br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 队列绑定</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;error&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;error等待接收消息。。。&quot;</span>);<br><br>        <span class="hljs-comment">// 回调函数</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;接收绑定键：&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="hljs-string">&quot;,消息：&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectConsumer2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;console&quot;</span>;<br>        <span class="hljs-comment">// 队列声明</span><br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 队列绑定</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;info&quot;</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;warning&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;info&amp;&amp;warning等待接收消息。。。&quot;</span>);<br><br>        <span class="hljs-comment">// 回调函数</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;接收绑定键：&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="hljs-string">&quot;,消息：&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如图</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657270418677-9e85644d-a472-486f-bf3a-4cec836605a3.png" alt="img" style="zoom: 67%;" /><h2 id="Topic类型"><a href="#Topic类型" class="headerlink" title="Topic类型"></a>Topic类型</h2><p>上面对广播的消息做了改造，使得可以按照不同的级别(RoutingKey)发送消息到指定队列，实现有选择的接收日志。不过direct也有一定局限性，例如info下可能是不同模块的日志，比如<code>info.common</code>、<code>info.msg</code>之类，如果都通过direct就会定义过多的BindingKey且拓展性较差，这时就可以使用<code>topic</code>类型</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657272750395-78a5e31e-ef63-4757-9a3d-858231f9ed64.png" alt="img" style="zoom:80%;" /><p><code>topic</code>类型相当于”高级版的<code>direct</code>类型“，它支持在队列绑定时对RoutingKey使用通配符，其中RoutingKey由一个或多个单词组成，单词间通过<code>.</code>连接。例如：<code>rabbit.test.hello</code>、<code>kafka.port.what</code> 不过它不能超过255个字节，并且它可以使用通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**   通配符匹配规则</span><br><span class="hljs-comment"> *      * 匹配一个单词</span><br><span class="hljs-comment"> *      # 匹配一个或多个单词</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>以上图为例：</p><ul><li>RoutingKey凡是长度为三且中间单词为orange的消息，都会发到Q1中</li><li>RoutingKey凡是长度为三且最后单词为rabbit的消息，都会发到Q2中</li><li>RoutingKey凡是以lazy开头的消息都会发到Q2中</li></ul><p>【注】消息只会被消费一次，所以如果有消息（例如<code>lazy.test.rabbit</code>）同时满足Q2的两个条件，它也只会被Q2消费一次</p><table><thead><tr><th><strong>RoutingKey类型</strong></th><th><strong>消费情况</strong></th><th></th></tr></thead><tbody><tr><td>quick.orange.rabbit</td><td>被队列 Q1、Q2 接收</td><td></td></tr><tr><td>azy.orange.elephant</td><td>被队列 Q1、Q2 接收</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>quick.orange.fox</td><td>被队列 Q1 接收</td><td>被队列 Q1 接收到</td></tr><tr><td>lazy.brown.fox</td><td>被队列 Q2 接收到</td><td></td></tr><tr><td>lazy.pink.rabbit</td><td>虽然满足两个绑定但只被队列 Q2 接收一次</td><td></td></tr><tr><td>quick.brown.fox</td><td>不匹配任何绑定，不会被接收，会被丢弃</td><td></td></tr><tr><td>quick.orange.male.rabbit</td><td>是四个单词不匹配任何绑定会被丢弃</td><td></td></tr><tr><td>lazy.orange.male.rabbit</td><td>满足Q2条件，被Q2接收</td><td></td></tr></tbody></table><p>参照上面，编写demo代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopicProducer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_exchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Q1绑定：中间带orange的3个单词字符串—&gt; *.orange.*</span><br><span class="hljs-comment">         * Q2绑定：最后一个单词为rabbit的3个单词字符串—&gt; *.*.rabbit 或 首单词为lazy的多单词-&gt; lazy.#</span><br><span class="hljs-comment">         */</span><br>        HashMap&lt;String, String&gt; keyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        keyMap.put(<span class="hljs-string">&quot;quick.orange.rabbit&quot;</span>, <span class="hljs-string">&quot;被队列 Q1Q2 接收到&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;lazy.orange.elephant&quot;</span>, <span class="hljs-string">&quot;被队列 Q1Q2 接收到&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;quick.orange.fox&quot;</span>, <span class="hljs-string">&quot;被队列 Q1 接收到&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;lazy.brown.fox&quot;</span>, <span class="hljs-string">&quot;被队列 Q2 接收到&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;lazy.pink.rabbit&quot;</span>, <span class="hljs-string">&quot;虽然满足 Q2 的两个绑定,但只被队列 Q2 接收一次&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;quick.brown.fox&quot;</span>, <span class="hljs-string">&quot;不匹配任何绑定不会被任何队列接收到 会被丢弃&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;quick.orange.male.rabbit&quot;</span>, <span class="hljs-string">&quot;是四个单词不匹配任何绑定 会被丢弃&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="hljs-string">&quot;是四个单词但匹配 Q2&quot;</span>);<br><br><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; keyEntry : keyMap.entrySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyEntry.getKey();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> keyEntry.getValue();<br>            channel.basicPublish(EXCHANGE_NAME, key, <span class="hljs-literal">null</span>, (key + value).getBytes(StandardCharsets.UTF_8));<br>            System.out.println(<span class="hljs-string">&quot;生产者发送消息：&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费者1  *.orange.*</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopicConsumer1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_exchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Q1&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;*.orange.*&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Q1等待接收消息。。。&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;Q1接收到的消息：&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费者2   *.*.rabbit  lazy.#</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopicConsumer2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_exchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Q2&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;*.*.rabbit&quot;</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;lazy.#&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Q2等待接收消息。。。&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;Q2接收到的消息：&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后可以查看到名为<code>topic_exchange</code>的交换机下，有对应的三个<code>Bindings</code></p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657434093508-7a1ce8c2-bf13-43e7-97c8-a36d9573bbbf.png" alt="img" style="zoom:80%;" /><p>查看消费者1和消费者2的控制台，看到正确获取了响应的消息：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657434360638-f4cc592f-5a61-4bc1-8e7a-d56550f15441.png" alt="img" style="zoom:80%;" /><h2 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化</h2><p>交换机默认是没有持久化的，因此RabbitMQ重启后交换机就会丢失，对于常用的交换机应该设置持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *参数一:  交换机名称</span><br><span class="hljs-comment"> *参数二:  交换机类型</span><br><span class="hljs-comment"> *参数三:  是否持久化</span><br><span class="hljs-comment"> */</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;交换机名称&quot;</span>, BuiltinExchangeType.XXXX,<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h2 id="Return消息机制"><a href="#Return消息机制" class="headerlink" title="Return消息机制"></a>Return消息机制</h2><p>在消息应答一节中提到<code>发送确认</code>——确保消息从生产者到交换机。那么消息从交换机到队列的过程中要怎样保证可靠性呢？这就需要return机制</p><p>Return机制：监控交换机是否将消息发送到指定队列。对于队列不存在或者RoutingKey无法路由到的消息，都需要进行捕获，通过<code>addReturnListener</code>方法添加<code>ReturnListener</code>回调接口，该接口有一个方法<code>handleReturn</code>用于处理交换机到队列路由失败的消息</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657436096461-1ba0e68d-94ab-4319-a1c9-9f9be506b74a.png" alt="img" style="zoom:80%;" /><p>编写简单DEMO测试</p><ul><li>生产者的RoutingKey为vip消息</li><li>消费者的BindingKey为普通用户消息</li><li>观察是否会进入回调方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnProducer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;return_exchange&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">VIP_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;vip&quot;</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        channel.addReturnListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnListener</span>() &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * replyCode：路由是否成功的响应码</span><br><span class="hljs-comment">             * replyText：文本说明</span><br><span class="hljs-comment">             * exchange：具体路由到的交换机</span><br><span class="hljs-comment">             * routingKey：路由键</span><br><span class="hljs-comment">             * properties：消息配置</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReturn</span><span class="hljs-params">(<span class="hljs-type">int</span> replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties basicProperties, <span class="hljs-type">byte</span>[] bytes)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                System.out.println(<span class="hljs-string">&quot;----------------------进入回调方法----------------------&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;Listener获取到无法路由的消息：\n&quot;</span> +<br>                        <span class="hljs-string">&quot;replyCode：&quot;</span> + replyCode + <span class="hljs-string">&quot;\n&quot;</span> +<br>                        <span class="hljs-string">&quot;replyText：&quot;</span> + replyText + <span class="hljs-string">&quot;\n&quot;</span> +<br>                        <span class="hljs-string">&quot;exchange：&quot;</span> + exchange + <span class="hljs-string">&quot;\n&quot;</span> +<br>                        <span class="hljs-string">&quot;routingKey：&quot;</span> + routingKey + <span class="hljs-string">&quot;\n&quot;</span> +<br>                        <span class="hljs-string">&quot;properties：&quot;</span> + basicProperties + <span class="hljs-string">&quot;\n&quot;</span> +<br>                        <span class="hljs-string">&quot;body：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 指定mandatory为true，会将不可路由的消息返回给生产者，设置为false时broker会直接丢弃不可路由的消息</span><br><span class="hljs-comment">         * 指定queue为vip而消费端为normal，无法路由就会触发回调函数</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(EXCHANGE_NAME, NORMAL_KEY, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;测试不可路由的消息文本&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnConsumer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;return_exchange&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">VIP_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;vip&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;queue_vip&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, VIP_KEY);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;VIP接收到的消息：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8));<br>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>        &#125;;<br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> consumer -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;取消消费！&quot;</span>);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">false</span>, deliverCallback, cancelCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如图可以看到成功调用回调方法</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657436841518-bc5f9d03-cff7-4a79-9537-ce77f2a84cab.png" alt="img" style="zoom:80%;" /><p>mandatory 和 immediate 他们都有当消息传递过程中不可达目的地时将消息 <strong>返回给生产者</strong> 的功能</p><p>RabbitMQ 提供的 <strong>备份交换器（Alternate Exchange）</strong> 可以将 <strong>未能被交换器路由</strong>（没有绑定队列或没有匹配的队列） 的消息存储起来，而不用返回给客户端</p><h3 id="mandatory参数"><a href="#mandatory参数" class="headerlink" title="mandatory参数"></a>mandatory参数</h3><ul><li>true：找不到匹配的队列，会将消息返回给生产者</li><li>false：找不到匹配的队列，直接丢弃</li></ul><p>交换机无法根据自身类型和路由键将消息传递到某个队列上时，会调用<code>Basic.Return</code>将消息返回给生产者，生产者通过<code>addReturnListener</code>添加返回监听，来处理未能成功路由的消息</p><h3 id="immediate参数"><a href="#immediate参数" class="headerlink" title="immediate参数"></a>immediate参数</h3><p>当设置immediate参数为 true ，如果交换器在将消息路由到队列时，发现 <strong>队列上并不存在任何消费者</strong>，那么该 <strong>消息将不会存入队列中</strong>。当与路由键匹配的所有队列都没有消费者时，会通过<code>Basic.Return</code>返回给生产者。</p><p>二者对比</p><ul><li>mandatory ：要求消息至少被路由到一个队列中，要么丢弃、要么返回给生产者</li><li>immediate：要求至少有一个订阅者，否则就返回给生产者。</li></ul><p><strong>RabbitMQ 3.+ 版本后不再对immediate支持</strong>，官方解释：该参数会影响镜像队列的性能，增加代码复杂性。建议采用 TTL 和 DLX 的方法替代</p><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p>如果设置了<code>mandatory = false</code>，未被路由的消息会被丢弃，<code>mandatory = true</code>则需要生产者通过Return监听处理未被路由的消息。</p><p>备份交换机（<code>Alternate Exchange</code>简称AE），如果不想丢失消息，又不想自己立即接收处理这些消息，则可以使用这个备份交换器，<strong>在需要的时候再去处理</strong>这些消息</p><p>可以通过两种方式实现：</p><ol><li>可以在声明交换器时，增加<code>alternate-exchange</code>参数实现</li><li>可以通过策略（Policy）</li></ol><p>如果两种方式同时使用，前者的优先级更高，会覆盖掉 Policy 的设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义备份交换器</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;myAe&quot;</span>, <span class="hljs-string">&quot;fanout&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueDeclare(<span class="hljs-string">&quot;unroutedQueue&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind(<span class="hljs-string">&quot;unroutedQueue&quot;</span>, <span class="hljs-string">&quot;myAe&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-keyword">final</span> HashMap&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>arguments.put(<span class="hljs-string">&quot;alternate-exhcange&quot;</span>, <span class="hljs-string">&quot;myAe&quot;</span>);<br><span class="hljs-comment">// 使用备用交换器 myAe</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;normalExchange&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, arguments);<br>channel.queueDeclare(<span class="hljs-string">&quot;normalQueue&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind<span class="hljs-string">&quot;normalQueue&quot;</span>, <span class="hljs-string">&quot;normalExchange&quot;</span>, ROUTING_KEY);<br></code></pre></td></tr></table></figure><p>以上代码的逻辑即为：</p><ul><li>使用部分：定义了一个normal交换机和队列，交换机的参数添加<code>alternate-exhcange</code>，用于声明normal队列的消息不可达时，将消息存放到备份交换机</li><li>定义部分：声明了备份交换机的定义，并绑定到用于存放不可路由消息的队列</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;交换机概念&quot;&gt;&lt;a href=&quot;#交换机概念&quot; class=&quot;headerlink&quot; title=&quot;交换机概念&quot;&gt;&lt;/a&gt;交换机概念&lt;/h2&gt;&lt;p&gt;之前的示例，都是按照&lt;code&gt;生产者--&amp;gt;消息队列--&amp;gt;消费者&lt;/code&gt;的概念进行的&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="消息队列" scheme="https://61hhh-github-io.vercel.app/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RabbitMQ" scheme="https://61hhh-github-io.vercel.app/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>3、RabbitMQ限流&amp;发布确认</title>
    <link href="https://61hhh-github-io.vercel.app/20230511/f2906e60/"/>
    <id>https://61hhh-github-io.vercel.app/20230511/f2906e60/</id>
    <published>2023-05-11T02:21:31.000Z</published>
    <updated>2024-04-16T08:42:11.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息分发策略"><a href="#消息分发策略" class="headerlink" title="消息分发策略"></a>消息分发策略</h2><p>默认的消息分发策略是<strong>轮询</strong>，参照上面的消息应答可以看出会有一定问题——消息处理慢的 <code>AckConsumer1</code> 和消息处理快的 <code>AckConsumer2</code> 分配了同等数量的消息，导致2早就结束空闲了，而1还有好几条消息没开始处理！因此看似公平的轮询分发其实是并不公平的</p><p>因此需要引入<strong>公平分发策略（Fair Dispatch）</strong>——在消费者中引入设置了 <code>prefetchCount=1</code> 参数的 <code>basicQos</code> 方法，它告诉了rabbitmq不要一次向该消费者传递过多消息</p><p>尚硅谷和评论区的两份笔记，都将这个叫做不公平分发，但是我在官方tutorial上看到的介绍时Fair Dispath</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657007480908-b0ed3fd5-57f1-4dfc-b21c-d93e8f3a0352.png" alt="img" style="zoom:80%;" /><p>通过<code>fair dispatch</code>和手动应答来控制消费者每次处理的消息数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// fiar dispatch</span><br><span class="hljs-type">int</span> <span class="hljs-variable">prefetchCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>channel.basicQos(prefetchCount);<br><span class="hljs-comment">// 手动应答</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);<br></code></pre></td></tr></table></figure><p>参数<code>prefecthCount</code>表示该消费者<strong>能积压在信道上的预处理消息数最大值</strong>：</p><ul><li>消费者通过<code>basicQos</code>方法设置了预取值后，对应的信道上最多只能积压<code>prefetchCount</code>条消息</li><li>达到对应数量后，RabbitMQ就不会向该信道传递消息</li><li>如果所有队列都达到积压上限，消息就会积压在队列中撑满队列，这个时候就只能添加新的消费者或者改变存储策略</li><li>通常增加预取值可以提高向消费者传递消息的速度，但是无限制的自动应答或者过大值会导致消费者节点内存消耗过大，因此合理的预取值需要反复试验，通常100-300之间</li></ul><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657008320923-af5cded8-cef3-42a3-8e36-7f49aabe939a.png" alt="img" style="zoom:80%;" /><h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><p>消费者宕机过程中MQ上囤积大量消息，重启消费者服务后消息瞬间涌入，造成消息消费服务压力剧增，因此大流量下消息消费端需要进行限流设置</p><p>在非自动确认消息的前提下，如果一定数量的消息（基于Consumer和Channel设置QOS的值）没有被确认，将不进行消费新的消息</p><p>1、生产者使用线程池模拟大量消息的发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LimitProducer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;slowQueue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fastExchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;limit&quot;</span>);<br><br>        <span class="hljs-comment">// 使用线程池模拟短时间大量消息发送</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Thread.currentThread().getName()+<span class="hljs-string">&quot;_&quot;</span>+i;<br>            <span class="hljs-keyword">try</span> &#123;<br>                channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;limit&quot;</span>, <span class="hljs-literal">null</span>, msg.getBytes());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        threadPool.shutdown();<br>        <span class="hljs-keyword">while</span> (!threadPool.isTerminated()) &#123;<br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;所有消息发送完成&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LimitConsumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;slowQueue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 消费成功回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// 模拟业务操作</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody()));<br>            <span class="hljs-comment">//channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br>        &#125;;<br>        <span class="hljs-comment">// 消费取消回调</span><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> cancel -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;取消消费&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 参数一：单条消息大小限制，一般为0不限制</span><br><span class="hljs-comment">         * 参数二：一次性消费的消息数量</span><br><span class="hljs-comment">         * 参数三：限流设置应用于channel(true)还是consumer(false)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//channel.basicQos(0, 10, false);</span><br>        channel.basicConsume(QUEUE_NAME,<span class="hljs-literal">true</span>,deliverCallback,cancelCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到设置了<code>Qos</code>后消费10条消息就结束了，由于将应答注释了所以不会继续消费</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657788530091-d93bc039-cf19-4333-8675-0aebef171f60.png" alt="img" style="zoom:80%;" /><p>放开应答的注释，可以看到持续消费，每次<code>Unacked</code>的都是10条，速率也是每秒一条</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657788655762-690e9fe9-6818-4f97-bf62-8093423d5b2a.png" alt="img" style="zoom:80%;" /><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p>上面是通过持久化来保障在服务器崩溃时，消息不会丢失。但是生产者发布消息后，消息是否能正确到达Broker服务器呢？默认情况下消息发出后是不会有返回信息的，所以需要引入发布确认机制</p><p>消息被投递到匹配的队列后，Broker会返回一个确认信息给生产者，这个操作叫做<strong>消息确认发布，</strong>它有两种方式：</p><ol><li>通过事务机制实现：设置 channel 为 transaction 模式，这是 AMQP协议层面提供的解决方案</li><li>通过发送方确认实现：设置 channel 为 confirm 模式，这是 RabbitMQ 提供的解决方案</li></ol><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><p>RabbitMQ 客户端中与事务机制有关的方法有三个</p><ul><li><code>channel.txSelect</code>：用于将当前 channel 设置成 transaction 模式</li><li><code>channel.txCommit</code>：用于提交事务</li><li><code>channel.txRollback</code>：用于回滚事务</li></ul><p><code>channel.txSelect</code>将当前信道开启为事务模式后，生产者就可以发布消息给Broker服务器了，如果<code>channel.txCommit</code>提交成功了，则消息一定到达了broker了，如果在 <code>channel.txCommit</code>执行之前 broker 异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过<code>channel.txRollback</code>回滚事务。如图是正常提交事务的，对于使用回滚需要通过<code>try/catch</code>捕获发生的异常，Publish后也不是正常的Commit，而是异常的Rollback</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657087189068-c913b1f3-55a9-487d-bab0-0508e20f83fc.png" alt="img" style="zoom:80%;" /><p>事务确实能够解决 producer 与 broker 之间消息确认的问题，只有消息成功被 broker 接收，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作，同时进行消息重发，但是使用事务机制的话会降低RabbitMQ的性能。RabbitMQ提供了改进方案，即发送方确认（Confirm确认）</p><h3 id="confirm模式"><a href="#confirm模式" class="headerlink" title="confirm模式"></a>confirm模式</h3><h4 id="发布确认逻辑"><a href="#发布确认逻辑" class="headerlink" title="发布确认逻辑"></a>发布确认逻辑</h4><p>生产者将信道设置成 confirm 模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker回传给生产者的确认消息中的<code>delivery-tag</code>包含了确认消息的序列号，此外broker也可以设置<code>basic.ack</code>的 multiple参数，表示到这个序号之前的所有消息都已经得到了处理。</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657087502262-4d4a734b-ef1f-4b85-83b9-3cf1b0e60a33.png" alt="img" style="zoom:80%;" /><p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><p>发布确认默认是没有开启的，通过在信道上设置开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开启发布确认</span><br>channel.confirmSelect();<br></code></pre></td></tr></table></figure><h4 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h4><p>单个发布确认是一种简单的发布确认方式：生产者发布一个消息之后只有等收到确认才会发送下一个，它是一种<strong>同步确认发布</strong>的方式。<code>waitForConfirmsOrDie(long)</code>这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>这种方式最大的缺点是发布速度很慢，效率低，每秒只能不超过数百条数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">singleConfirm</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>    channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 开启发布确认</span><br>    channel.confirmSelect();<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MSG_COUNT; i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;消息_&quot;</span> + i;<br>        System.out.println(<span class="hljs-string">&quot;生产了：&quot;</span> + msg);<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes());<br>        <span class="hljs-comment">// 服务端返回 false 或超时时间内未返回，生产者可以消息重发</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> channel.waitForConfirms();<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            System.out.println(msg + <span class="hljs-string">&quot;已发送到队列中&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;发布了 &quot;</span> + MSG_COUNT + <span class="hljs-string">&quot; 个单独确认消息，耗时：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到每次都是<code>waitForConfirms</code>之后才发送下一条：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657075515953-df32b9f9-2f44-4a36-a2ab-5f4bd2959ccd.png" alt="img" style="zoom:80%;" /><h4 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h4><p>批量确认模式也是一种<strong>同步确认发布</strong>的方式，先发布一批消息再一起确认，这样可以提高吞吐量，不过如果如果出现问题不能定位到具体的消息上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">batchConfirm</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>    channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>    channel.confirmSelect();<br>    <span class="hljs-comment">// 批量确认size</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">batchSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// 待确认的消息个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">size4Confirm</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MSG_COUNT; i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;消息_&quot;</span> + i;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes());<br>        size4Confirm++;<br>        <span class="hljs-keyword">if</span> (size4Confirm == batchSize) &#123;<br>            channel.waitForConfirms();<br>            size4Confirm = <span class="hljs-number">0</span>;<br>            System.out.println(<span class="hljs-string">&quot;批量确认，最新的消息是：&quot;</span> + msg);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//为了确保还有剩余没有确认消息 再次确认</span><br>    <span class="hljs-keyword">if</span> (size4Confirm &gt; <span class="hljs-number">0</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;处理剩余的未确认消息&quot;</span>);<br>        channel.waitForConfirms();<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;发布了 &quot;</span> + MSG_COUNT + <span class="hljs-string">&quot; 个批量确认消息，耗时：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到每一百个消息进行一次确认，当前的100个确认之前不会发送下一批，所以每批消息的确认序号都是固定增加的：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657075878906-402f0f24-0303-4211-b687-f85932cbe6ef.png" alt="img" style="zoom:80%;" /><h4 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h4><p>因为异步非阻塞的特性，异步确认的可靠性和效率都很高，它是通过回调函数来实现消息的可靠传递的</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657075982958-f0c9af4a-80b5-4d00-8979-c61b6dc8ff9e.png" alt="img" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyConfirm1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>    channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>    channel.confirmSelect();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 消息确认成功的回调函数</span><br><span class="hljs-comment">         * 参数一：消息的标记</span><br><span class="hljs-comment">         * 参数二：是否批量确认</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">successCall</span> <span class="hljs-operator">=</span> (deliveryTag, multiple) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;确认的消息：&quot;</span> + deliveryTag);<br>    &#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 消息确认失败的回调函数</span><br><span class="hljs-comment">         * 参数一：消息的标记</span><br><span class="hljs-comment">         * 参数二：是否批量确认</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">failedCall</span> <span class="hljs-operator">=</span> (deliveryTag, multiple) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;未能确认的消息：&quot;</span> + deliveryTag);<br>    &#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 设置异步确认模式的消息确认监听器</span><br><span class="hljs-comment">         * 参数一：成功的回调</span><br><span class="hljs-comment">         * 参数二：失败的回调</span><br><span class="hljs-comment">         */</span><br>    channel.addConfirmListener(successCall, failedCall);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MSG_COUNT; i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;消息_&quot;</span> + i;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes());<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;发布了 &quot;</span> + MSG_COUNT + <span class="hljs-string">&quot; 个异步确认消息，耗时：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到消息的确认是异步进行的，并没有特定的串行顺序：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657093167844-de63969a-ebb5-47a2-9555-0c09c7563351.png" alt="img" style="zoom:80%;" /><h4 id="如何处理未被确认的消息？"><a href="#如何处理未被确认的消息？" class="headerlink" title="如何处理未被确认的消息？"></a>如何处理未被确认的消息？</h4><p>最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p><ol><li>通过一个并发队列，将所有要发送的消息加到队列中</li><li>在发布确认的回调函数中删除已确认的消息，剩下的就是未确认的消息了</li><li>在失败的回调函数中处理未确认的消息，比如重发或者打印出来</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyConfirm2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>    channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>    channel.confirmSelect();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 用于存储消息的线程安全队列</span><br><span class="hljs-comment">     * concurrentSkipListMap比concurrentHashMap有更好的并发支持，是一个有序map容器，原理为跳表</span><br><span class="hljs-comment">     */</span><br>    ConcurrentSkipListMap&lt;Long, Object&gt; infoMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 消息确认成功的回调函数：删除已确认的消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">successCall</span> <span class="hljs-operator">=</span> (deliveryTag, multiple) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (multiple) &#123;<br>            <span class="hljs-comment">// 从key=null到截止key，作为指定key合集</span><br>            ConcurrentNavigableMap&lt;Long, Object&gt; confirmed = infoMap.headMap(deliveryTag);<br>            confirmed.clear();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            infoMap.remove(deliveryTag);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;确认的消息：&quot;</span> + deliveryTag);<br>    &#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 消息确认失败的回调函数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">failedCall</span> <span class="hljs-operator">=</span> (deliveryTag, multiple) -&gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> String.valueOf(infoMap.get(deliveryTag));<br>        System.out.println(<span class="hljs-string">&quot;未能确认的消息：&quot;</span> + deliveryTag + <span class="hljs-string">&quot; ，消息是：&quot;</span> + info);<br>    &#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 设置异步确认模式的消息确认监听器</span><br><span class="hljs-comment">     */</span><br>    channel.addConfirmListener(successCall, failedCall);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MSG_COUNT; i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;消息_&quot;</span> + i;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes());<br>        <span class="hljs-comment">// 记录所有要打的消息，key为下一次发布信息的序号</span><br>        infoMap.putIfAbsent(channel.getNextPublishSeqNo(), msg);<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;发布了 &quot;</span> + MSG_COUNT + <span class="hljs-string">&quot; 个异步确认消息，耗时：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657093787471-61fa1944-eba6-4982-8b07-30f6fe950706.png" alt="img" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;消息分发策略&quot;&gt;&lt;a href=&quot;#消息分发策略&quot; class=&quot;headerlink&quot; title=&quot;消息分发策略&quot;&gt;&lt;/a&gt;消息分发策略&lt;/h2&gt;&lt;p&gt;默认的消息分发策略是&lt;strong&gt;轮询&lt;/strong&gt;，参照上面的消息应答可以看出会有一定问题——消息处</summary>
      
    
    
    
    <category term="消息队列" scheme="https://61hhh-github-io.vercel.app/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RabbitMQ" scheme="https://61hhh-github-io.vercel.app/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>2、RabbitMQ消息应答&amp;持久化</title>
    <link href="https://61hhh-github-io.vercel.app/20230511/62ae0b86/"/>
    <id>https://61hhh-github-io.vercel.app/20230511/62ae0b86/</id>
    <published>2023-05-11T02:20:55.000Z</published>
    <updated>2024-04-16T08:42:11.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><p>1、问题引出</p><p>假设消费者处理某个业务功能需要100条消息，现在获取了50条，还没处理完进程就终止了。</p><p>按照入门示例写的代码，未处理的消息就会被直接丢弃，而剩余未发送的50条消息，也不会再发给它了，因为它是不可接收的状态了。即此时这100条消息还未实现对应功能便被丢失了！</p><p>2、解决方案</p><p>为了保证消息能可靠的到达消费者并处理，RabbitMQ引入了消息应答机制（message acknowledgement）——<strong>消费者在接收并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></p><p>如果某个消费者处理时异常结束没有发送应答，RabbitMQ就会认为这条消息没被处理，然后交给另外一个消费者。这样就可以保证即使消费者挂掉也不会丢失消息数据</p><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><p>入门示例中消费者采用的是自动应答——即消息发送后就被认为发送成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br></code></pre></td></tr></table></figure><p>自动应答模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>，</p><ul><li>自动应答没有对传递消息的数量做限制，可以实现消费者接收过载的消息</li><li>但是有可能会使得消费者端产生消息的积压，导致内存耗尽，消费者进程被系统杀死</li><li>而且在消息接收处理完之前，消费者出现问题，那么消息就会丢失</li></ul><p>所以自动应答，应该是在<strong>消费者可以高效并以 某种速率能够处理这些消息的情况下使用</strong></p><h3 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h3><p>手动应答即关闭自动应答，在回调逻辑中进行手动处理应答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 关闭了自动应答</span><br>channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br></code></pre></td></tr></table></figure><p>手动应答有几个实现方法：</p><ul><li><code>Channel.basicAck</code>：用于消息的肯定确认，表示已接收并处理该消息了，MQ可以删除它了</li><li><code>Channel.basicNack</code> ：用于消息的否定确认</li><li><code>Channel.basicReject</code>：用于消息的否定确认，比<code>basicNack</code>少一个参数，如果队列未配置死信队列则直接丢弃，有配置则发送到对应死信队列中</li></ul><h4 id="确认应答"><a href="#确认应答" class="headerlink" title="确认应答"></a>确认应答</h4><p>1、编写代码</p><p>生产者代码保持入门DEMO不动，调整消费者的消费成功回调逻辑即可</p><p>这里是<code>AckConsumer1</code>的处理，<code>AckConsumer2</code>只需要调整延时1秒即可，模拟不同业务的处理时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AckConsumer1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ack_queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        <span class="hljs-comment">// 消费回调逻辑</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始消费&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;模拟实际业务操作，耗时20秒&quot;</span>);<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">20</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;接收到消息：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody()));<br><br>            <span class="hljs-comment">/*  手动应答</span><br><span class="hljs-comment">             *  参数一：消息标记tag</span><br><span class="hljs-comment">             *  参数二：是否批量消费消息(true：应答队列中的所有消息 | false：应答接收到的消息)</span><br><span class="hljs-comment">             */</span><br>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>        &#125;;<br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> (consumerTag) -&gt; &#123;<br>            System.out.println(consumerTag + <span class="hljs-string">&quot;---&gt;消费者取消了消费接口&quot;</span>);<br>        &#125;;<br><br>        System.out.println(<span class="hljs-string">&quot;Work02   等待消费消息........&quot;</span>);<br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">false</span>, deliverCallback, cancelCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、测试</p><ul><li>消费者发送了4条消息，按照默认的轮询逻辑，text1、text3会被<code>AckConsumer1</code>消费，text2、text4会被<code>AckConsumer2</code>消费</li><li>其中<code>AckConsumer1</code>处理并应答的时间较长，中途挂掉了后，未处理的text3消息会重新入队被<code>AckConsumer2</code>消费</li></ul><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657004590812-b7e6d6e2-f9f2-4fc5-9e45-c0ae4f77db82.png" style="zoom:80%;" /><p>通过管理面板也可以看到队列中消息的状态</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657004959127-88d3b238-9175-424d-a2dd-aa7e76762332.png" alt="img" style="zoom:80%;" /><h4 id="否定应答"><a href="#否定应答" class="headerlink" title="否定应答"></a>否定应答</h4><p>否定应答代码与确认应答类似，只是调用方法由<code>basicAck</code>变成<code>basicNack</code>或者<code>basicReject</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*消费者成功消费回调逻辑*/</span><br><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, message) -&gt; &#123;<br><br>   System.out.println(<span class="hljs-string">&quot;消费者A对消息进行消费!&quot;</span>);<br>   <span class="hljs-keyword">try</span> &#123;<br>     TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);  <span class="hljs-comment">//模拟实际业务操作</span><br>   &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>       e.printStackTrace();<br>   &#125;<br>   System.out.println(<span class="hljs-string">&quot;消费者A接收到的信息为:&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 参数一：  消息标记tag</span><br><span class="hljs-comment">    * 参数二：  是否批量消费消息（true为应答该队列中所有的消息，false为只应答接收到的消息）</span><br><span class="hljs-comment">    * 参数三：  是否重回队列</span><br><span class="hljs-comment">    * */</span><br>    channel.basicNack(message.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);  <span class="hljs-comment">//拒绝消息应答方法1</span><br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 参数一：  消息标记tag</span><br><span class="hljs-comment">    * 参数二：  是否重回队列</span><br><span class="hljs-comment">    * */</span><br>    channel.basicReject(message.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>);       <span class="hljs-comment">//拒绝消息应答方法2</span><br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>持久化分为三个部分：交换器持久化、队列持久化、消息持久化</p><p>其中如果交换器不设置持久化，mq重启后并不会丢失消息，丢失的是该交换器的元数据，只是之后不能将消息发送到该交换机了，对于常用的交换机建议将其持久化。交换器的持久化在声明方法<code>exchangeDeclare</code>中设置durable参数为true即可</p><p>上面的消息应答，作用是避免消费者出现事故时消息丢失，而如果要避免RabbitMQ出现事故导致的消息丢失，则需要<strong>将队列和消息标记为持久化的</strong></p><h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p>之前声明队列的第二个参数durable默认都是false，即非持久化的，rabbitmq如果重启就会删改该队列，将参数设置为true后可以保证队列不被删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//让队列持久化</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">durable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//声明队列</span><br>channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>在生产者声明队列时设置持久化参数后，可以在管理面板中查看</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657005848793-65f41b46-3f42-4fc8-8bf7-e900da2189c6.png" alt="img" style="zoom:80%;" /><p>【注】如果之前创建队列<code>dur_queue</code>非持久化，再创建持久化，会报错参数不等价，反之亦然</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657006026388-328c4e4c-9129-4546-8496-05a72c76fd6b.png" alt="img" style="zoom:80%;" /><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>队列持久化只能保证rabbitmq下线时不会删除队列，但是队列中的消息如果要不丢失，也需要开启持久化！通过生产者发布消息时第三个参数<code>BasicProperties</code>添加<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code>来实现</p><p>可以将所有消息都设置持久化，但是会影响RabbitMQ性能，因为磁盘的读写速度远慢于内存读写！对于可靠性不高的消息可以不采取持久化。对于消息持久化的选择需要综合可靠性和吞吐量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//basicProperties设置为PERSISTENT_TEXT_PLAIN：以text/plain形式将消息持久化到磁盘中</span><br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());<br></code></pre></td></tr></table></figure><p>将队列、消息都设置为持久化后，就能百分百保证消息不丢失了吗？当然是不行的！</p><ol><li>如果消费者设置自动应答，应答后没处理就宕机了，那应答的消息肯定就丢失了。这一部分可以通过手动应答处理</li><li>RabbitMQ并不会每次遇到一条持久化的消息都（调用内核的fsync）进行同步存盘操作，而是会先保存到操作系统的缓存中再存入磁盘，这个时间间隔很短但是存在！如果在这个间隔内发生宕机还是会丢失消息</li></ol><p>因此队列+消息持久化设置持久性保证不强，只能用于一些简单场景，可以采用的参考方案是**MQ集群+发布确认+消息缓存Redis(AOF备份)**来保证消息不丢失</p><h2 id="消息优先级"><a href="#消息优先级" class="headerlink" title="消息优先级"></a>消息优先级</h2><p>消息队列默认是先进先出的，消费顺序也是如此，如果<strong>需要使后面的某些特定消息先进行消费，需要对队列和消息设置优先级</strong></p><p>设置了优先级的队列和消息，会在队列中排序。没有设置优先级的消息依旧按照进入队列的顺序消费，消费者需要在消息进入队列排序完成后消费才能体现优先级。优先级范围为 0~255，值越高优先级越高，且消息优先级不能超过队列优先级</p><p>1、生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;FanoutExchange&quot;</span>; <span class="hljs-comment">//交换机名称</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">// 对队列设置优先级 范围在0-255之间</span><br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&quot;x-max-priority&quot;</span>, <span class="hljs-number">10</span>);<br>        channel.queueDeclare(<span class="hljs-string">&quot;PriorityQueue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, map);<br>        channel.queueBind(<span class="hljs-string">&quot;PriorityQueue&quot;</span>, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INFO_&quot;</span> + i;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">final</span> AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder().priority(<span class="hljs-number">5</span>).build();<br>                channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, properties, msg.getBytes());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>, msg.getBytes());<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----消息发送完毕-----&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityConsumer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;PriorityQueue&quot;</span>; <span class="hljs-comment">//交换机名称</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, msg) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;接收到消息：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody()));<br>            channel.basicAck(msg.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>        &#125;;<br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">false</span>, deliverCallback, consumer -&gt; &#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到对3取余为0的消息<code>0、3、6、9</code>被提前消费了</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657789513216-c636aa2d-349b-4d2b-ac3e-b89217a51ef8.png" alt="img" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;消息应答&quot;&gt;&lt;a href=&quot;#消息应答&quot; class=&quot;headerlink&quot; title=&quot;消息应答&quot;&gt;&lt;/a&gt;消息应答&lt;/h2&gt;&lt;p&gt;1、问题引出&lt;/p&gt;
&lt;p&gt;假设消费者处理某个业务功能需要100条消息，现在获取了50条，还没处理完进程就终止了。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="消息队列" scheme="https://61hhh-github-io.vercel.app/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RabbitMQ" scheme="https://61hhh-github-io.vercel.app/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>1、RabbitMQ快速入门</title>
    <link href="https://61hhh-github-io.vercel.app/20230511/34902a6/"/>
    <id>https://61hhh-github-io.vercel.app/20230511/34902a6/</id>
    <published>2023-05-11T02:11:14.000Z</published>
    <updated>2024-04-16T08:42:11.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、消息队列"><a href="#1、消息队列" class="headerlink" title="1、消息队列"></a>1、消息队列</h2><h3 id="1-1-消息队列的基本概念"><a href="#1-1-消息队列的基本概念" class="headerlink" title="1.1 消息队列的基本概念"></a>1.1 消息队列的基本概念</h3><p>消息（Message）是指在应用层之间传递的数据，比如文本字符串、JSON。现在的互联网系统中，前后端各个组件模块间传递数据信息，都可以称之为消息</p><p>而消息队列中间件（Message Queue Middleware，简称MQ）则是利用 <strong>可靠的消息传递机制</strong>进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过消息模型，它可以在<strong>分布式环境下扩展进程间的通信</strong>。</p><p>基于此，消息队列有两种模型：</p><ol><li><p><strong>点对点模式</strong>（P2P，Point to Point），也可以称作队列模型。基本组成生产者Producer、队列Queue、消费者Consumer，生产者发送消息到队列、消费者从队列中消费消息，总体是一个发-&gt;存-&gt;收的流程；其中一个队列可以存储多个生产者的消息、一个队列也可以有多个消费者，但是消费者之间对于消息的消费是竞争的，即消息只能被一个消费者消费。</p><img referrerpolicy="no-referrer" referrerpolicy="no-referrer" referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752853775-d629dca9-650b-45c6-82fc-f1ea314de706.png" alt="img" style="zoom:80%;"/></li><li><p><strong>发布订阅模型</strong>（P&#x2F;S，Pub&#x2F;Sub），发布订阅模型中基本组成为生产者Publisher、主题Topic、订阅者Subscriber</p></li></ol><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752866085-a83509a2-55ec-42f3-90a7-7dc831e8c365.png" alt="img" style="zoom:80%;" /><p>消息中间件适用于<strong>需要可靠的数据传送的分布式环境</strong>。发送者将消息发送给消息服务器，消息服务器将 消息存放在若干队列中，在合适的时候再将消息 转发给接收者。实现应用程序之间的协同，优点在于能够在客户和服务器之间提供同步和异步的链接，并且在任何时刻都可以将消息进行传送或存储转发。</p><h3 id="1-2-为什么用消息队列"><a href="#1-2-为什么用消息队列" class="headerlink" title="1.2 为什么用消息队列"></a>1.2 为什么用消息队列</h3><p>消息队列的主要应用场景有三点：<strong>解耦、异步、削峰</strong></p><ul><li><strong>解耦</strong>：在引入消息队列之前，上游业务模块A的功能FA可能需要调用到BCD的服务，还需要考虑到怎么调？变更怎么处理？等等。而引入消息队列后，功能FA执行后将消息发送到消息队列，下游的服务需要就自己消费消息即可</li><li><strong>异步</strong>：一个功能的调用链路往往涉及到多个服务，如果调用链路过长，就会导致功能的响应时间过长。引入消息队列后处理异步进行，可以极大降低响应时间</li><li><strong>削峰</strong>：在高峰期大量数据涌入，可能会超出系统能处理的极限，如果有消息队列做缓冲就不至于导致系统宕机</li></ul><p>由以上三点可以知道，在个人或小型的系统中其实是不需要消息队列的，消息队列应该主要应用于大型的分布式系统中，以实现系统功能解耦、提高响应率、保证高并发环境的稳定性。</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752892421-6a275339-4254-47bf-92f1-7b7d8d67c033.png" alt="img" style="zoom: 80%;" /><h3 id="1-3-主流消息队列的简单对比"><a href="#1-3-主流消息队列的简单对比" class="headerlink" title="1.3 主流消息队列的简单对比"></a>1.3 主流消息队列的简单对比</h3><p>市场上主流的消息队列有以下几种，他们各有优劣</p><p>1、RabbitMQ：使用Erlang语言，基于AMQP（高级消息队列协议）实现的开源消息中间件。消息延迟能做到微秒级，有较好的并发特性，能实现万级流量吞吐</p><p>2、Kafka：主要应用于大数据的消息中间件，以超高的并发吞吐量而闻名。能做到十万级的吞吐，毫秒级的延迟，在大数据实时计算和日志采集领域被大规模使用</p><p>3、ActiveMQ：作为老牌MQ，基于主从架构实现高可用，能保证较低的消息丢失率</p><p>4、RocketMQ：阿里开源的消息中间件。性能好延迟低，有对应的中文社区</p><p>如图公众号博主【三分恶】在他的：<a href="https://mp.weixin.qq.com/s/fcyDIr6Nas8fBukByI3tEg">面渣逆袭：RocketMQ二十三问</a> 中做出了详细对比：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656746312635-45d549c0-1c5d-41b0-bd2f-27e8663c8619.png" alt="img" style="zoom: 80%;" /><h2 id="2、RabbitMQ简介"><a href="#2、RabbitMQ简介" class="headerlink" title="2、RabbitMQ简介"></a>2、RabbitMQ简介</h2><h3 id="2-1-RabbitMQ概念"><a href="#2-1-RabbitMQ概念" class="headerlink" title="2.1 RabbitMQ概念"></a>2.1 RabbitMQ概念</h3><p>RabbitMQ是Erlang基于AMQP（Advanced Message Queuing Protocol）的实现，最初起源于金融系统，用于在分布式系统中存储转发消息</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654765818347-bc4a54a8-7d21-4002-8f78-9f73b1feb75d.png" alt="img" style="zoom: 80%;" /><h4 id="RabbitMQ核心组件"><a href="#RabbitMQ核心组件" class="headerlink" title="RabbitMQ核心组件"></a>RabbitMQ核心组件</h4><ul><li>Producer：消息生产者，投递消息的一方，属于Client；消息一般由两部分组成——标签（label）和消息体（payload）</li><li>Consumer：消息消费者，接收消息的一方，属于Client；消费者连接到RabbitMQ服务器，并订阅到队列上，消费消息时只消费消息体，丢弃标签</li><li>Broker：消息队列服务进程，一般可以将一个Broker看作一台服务器</li><li>Exchange：消息队列交换机，实际上消息并不是由生产者直接投递到消息队列，而是发到交换机Exchange上，<strong>由交换机采用相应策略将消息路由转发到对应队列中</strong></li></ul><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654768178092-5b24deb4-f615-4bdd-aa42-27c4dcb3af9d.png" alt="img" style="zoom: 80%;" /><ul><li>Queue：消息队列，存储消息的队列，RabbitMQ中消息只能存储在队列中。多个消费者可以订阅同一个队列，此时消息会采用轮询机制（Round-Robin），即消息被平摊给多个消费者，而不是所有消费者都收到所有消息</li></ul><p> 【注】RabbitMQ不支持队列层面的广播消息，要实现广播需要二次开发，但不建议这么做</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654767707901-6f3e059a-9ddf-4058-afed-3b343640b22b.png" alt="img" style="zoom: 80%;" /><h4 id="RabbitMQ的运行流程"><a href="#RabbitMQ的运行流程" class="headerlink" title="RabbitMQ的运行流程"></a>RabbitMQ的运行流程</h4><ol><li>生产者连接到Broker，建立连接（connection）开启信道（channel）</li><li>生产者声明一个交换机（Exchange），并设置对应属性，如交换机类型、是否持久化等</li><li>生产者声明一个队列（Queue）并设置对应属性，如是否持久化、是否排他、是否自动删除等</li><li>生产者通过路由键（RoutingKey）将交换机和队列设置绑定（Binding）</li><li>生产者发送消息到Broker中，消息包含了路由键、交换器等信息</li><li>交换机根据设置的类型规则，通过路由键匹配对应的队列</li><li>如果找到则存入相应的队列中并，可以设置是否确认</li><li>如果没有找到，则根据之前配置的属性选择丢弃或者回退</li><li>关闭信道与连接</li></ol><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654767542320-5f7bcd66-2552-4ad0-9228-4797cd539962.png" alt="img" style="zoom: 80%;" /><h4 id="RabbitMQ主要特点"><a href="#RabbitMQ主要特点" class="headerlink" title="RabbitMQ主要特点"></a>RabbitMQ主要特点</h4><ul><li>可靠性：支持持久化，传输确认，发布确认等保证了MQ的可靠性</li><li>灵活的分发消息策略：在消息进入MQ队列前由Exchange(交换机)进行路由消息，RabbitMQ提供了内置的Exchange，也可以通过插件自定义</li><li>支持集群：多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker</li><li>多种协议：RabbitMQ支持除原生AMQP外的多种消息队列协议，如 STOMP、MQTT 等</li><li>多种语言客户端：RabbitMQ几乎支持所有常用语言，如 Java、Python、Ruby 等</li><li>可视化管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker</li><li>插件机制：RabbitMQ提供了许多插件，也可以自定义插件</li></ul><h2 id="3、RabbitMQ安装"><a href="#3、RabbitMQ安装" class="headerlink" title="3、RabbitMQ安装"></a>3、RabbitMQ安装</h2><h3 id="3-1-安装-amp-运行"><a href="#3-1-安装-amp-运行" class="headerlink" title="3.1 安装&amp;运行"></a>3.1 安装&amp;运行</h3><p>Windows安装RabbitMQ需要前置erlang环境</p><ol><li>在<a href="https://www.erlang-solutions.com/downloads/">erlang官网</a>下载，</li><li>RabbitMQ的官方<a href="https://www.rabbitmq.com/download.html">下载链接</a>下载</li><li>下载按步骤安装完毕后，打开RabbitMQ安装目录下的sbin目录，通过命令行界面执行：rabbitmq-plugins enable rabbitmq_management安装管理功能插件</li><li>执行bat文件即可启动</li></ol><p>Linux安装可以参照Windows，也可以使用Docker简化安装操作</p><ol><li><p>指令dockers search rabbitmq搜索相关镜像</p></li><li><p>由于rabbitmq默认镜像是不带web管理端的，所以可以拉取management后缀的镜像，通过指令docker pull rabbitmq:3.8-management拉取</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654759324467-d5934078-1b18-43b9-9cad-d0da55934a08.png" alt="img" style="zoom:80%;" /></li><li><p>指令docker run –name rabbitmq -d -p 15672:15672 -p 5672:5672 镜像ID启动镜像<img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654759352997-5654f308-267e-44fd-907e-0fde0a679a7c.png" alt="img" style="zoom:80%;" /></p></li></ol><ul><li><ul><li>其中5672为rabbitmq的通信端口，而15672是web管理页面端口</li><li>通过docker ps查看正在运行的容器</li></ul></li></ul><ol><li><p>启动运行后，放行对应防火墙端口才可以访问。firewall-cmd –zone&#x3D;public –add-port&#x3D;5672&#x2F;tcp –permanent开放对应端口，就可以正常访问了，浏览器中键入：虚拟机IP:15672，默认账户密码都是guest，登录</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654759730631-640e63db-3d6e-415e-8169-59565a9ac176.png" alt="img" style="zoom:80%;" /></li></ol><p>【注】有时强制关闭虚拟机再重启恢复后，会还原虚拟机之前的状态，可以看到docker容器已经在运行，但是对应服务无法访问，通过<code>systemctl restart docker.service</code>就可以访问了</p><h3 id="3-2-RabbitMQ的基本使用"><a href="#3-2-RabbitMQ的基本使用" class="headerlink" title="3.2 RabbitMQ的基本使用"></a>3.2 RabbitMQ的基本使用</h3><h4 id="命令行与控制台"><a href="#命令行与控制台" class="headerlink" title="命令行与控制台"></a>命令行与控制台</h4><p>通过Docker的docker exec -it rabbitMQ容器ID bash进入bash界面，在此处可以通过rabbitMQ自己的命令行进行相关操作。基本命令都是rabbitmqctl xxx形式，详细指令可以参考官方文档：<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a></p><p><strong>1、查看基本信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl start_app # 开启服务<br>rabbitmqctl stop_app # 关闭服务<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态</span><br>rabbitmqctl status<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看binding、channel、交换机</span><br>rabbitmqctl list_bindings<br>rabbitmqctl list_channels<br>rabbitmqctl list_exchanges<br></code></pre></td></tr></table></figure><p><strong>2、rabbitmq用户操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建账号和密码</span><br>rabbitmqctl add_user admin admin123<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置用户角色</span><br>rabbitmqctl set_user_tags admin administrator<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为用户添加资源权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;<span class="hljs-built_in">read</span>&gt;</span><br>rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看用户列表</span><br>rabbitmqctl list_users<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除用户</span><br>rabbitmqctl delete_user admin<br></code></pre></td></tr></table></figure><p>由于默认的guest 账户有访问限制，默认只能通过本地网络(如 localhost) 访问，远程网络访问受限，所以在使用时我们一般另外添加用户，例如我们添加一个root用户</p><p>①执行<code>docker exec -i -t 3ae bin/bash</code>进入到rabbitMq容器内部</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654760021752-654720b7-eb24-4680-b871-25151972f9f3.png" alt="img" style="zoom:80%;" /><p>②执行 <code>rabbitmqctl add_user root 123456 </code>添加用户，用户名为root,密码为123456</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654760040728-bd353bfa-20ac-4845-a06a-decdf308c4a9.png" alt="img" style="zoom:80%;" /><p>③执行<code>abbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code>赋予root用户所有权限</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654760075446-e91a2b4e-f6dd-4271-b250-dd17a37e0de8.png" alt="img" style="zoom:80%;" /><p>④执行<code>rabbitmqctl set_user_tags root administrator</code>赋予root用户administrator角色</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654760104338-da9692f5-ab66-47a4-abac-56c3002bde3d.png" alt="img" style="zoom:80%;" /><p>⑤执行<code>rabbitmqctl list_users </code>查看所有用户即可看到root用户已经添加成功</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654760121394-dc5c8d32-f9e3-4d57-be7e-d73603d494ea.png" alt="img" style="zoom:80%;" /><p>⑥后续可以用root用户登录</p><p><strong>3、虚拟主机vhost操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加vhost</span><br>rabbitmqctl add_vhost &quot;虚拟主机名&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看vhost</span><br>rabbitmqctl list_vhosts<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看vhost权限，一般创建时不需要配置权限</span><br>rabbitmqctl list_permissions -p &quot;虚拟主机名&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除vhost</span><br>rabbitmqctl delete_vhost &quot;虚拟主机名&quot;<br></code></pre></td></tr></table></figure><p>上述操作也可以在管理界面执行，同时管理界面还支持配置文件的导入导出</p><h2 id="4、代码测试"><a href="#4、代码测试" class="headerlink" title="4、代码测试"></a>4、代码测试</h2><h3 id="4-1-Hello-World模型"><a href="#4-1-Hello-World模型" class="headerlink" title="4.1 Hello World模型"></a>4.1 Hello World模型</h3><p>一个最简单的消息队列就是<code>producer</code>、<code>message queue</code>、<code>consumer</code>，现在Docker部署了队列服务，可以简单写一下生产者消费者</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654854211560-bd2d988d-79d6-43a7-936a-f73ee2b86ced.png" alt="img" style="zoom:80%;" /><p>准备pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--rabbitmq 依赖客户端--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--操作文件流的一个依赖--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>生产者代码</strong></p><p>产生消息的步骤</p><ol><li>生产者连接到MQ的Broker，创建connection，开启channel</li><li>生命队列的相关属性：名称、是否持久化、消费模式等</li><li>发送消息，并指定持久化和routing key等属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello rabbit&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;192.168.204.127&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 生成一个队列</span><br><span class="hljs-comment">         * 1.队列名称</span><br><span class="hljs-comment">         * 2.队列里面的消息是否持久化 也就是是否用完就删除</span><br><span class="hljs-comment">         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span><br><span class="hljs-comment">         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span><br><span class="hljs-comment">         * 5.其他参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你好 Rabbit MQ！&quot;</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 发送一个消息</span><br><span class="hljs-comment">         * 1.发送到那个交换机</span><br><span class="hljs-comment">         * 2.路由的 key 是哪个</span><br><span class="hljs-comment">         * 3.其他的参数信息</span><br><span class="hljs-comment">         * 4.发送消息的消息体</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,msg.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;生产者发送了一条消息！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654854864787-ca717c44-fe79-40eb-b355-1269681db414.png" alt="img"></p><p>【注】如果先启动消费者，由于MQ里没有相应队列，连接会报错，要先启动生产者发送一条消息到队列中，此时可以看到MQ中创建了队列并有一条消息待消费</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654855241716-e190ae6d-b304-425b-a0be-90deaf21d68c.png" alt="img" style="zoom:80%;" /><p><strong>消费者代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME=<span class="hljs-string">&quot;hello rabbit&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;192.168.204.127&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br>        System.out.println(<span class="hljs-string">&quot;-----等待接收消息-----&quot;</span>);<br><br>        <span class="hljs-comment">//推送的消息如何进行消费的接口回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(message);<br>        &#125;;<br>        <span class="hljs-comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> (consumerTag) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息消费被中断&quot;</span>);<br>        &#125;;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 消费者消费消息 - 接受消息</span><br><span class="hljs-comment">         * 1.消费哪个队列</span><br><span class="hljs-comment">         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span><br><span class="hljs-comment">         * 3.消费者未成功消费的回调</span><br><span class="hljs-comment">         * 4.消息被取消时的回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, deliverCallback, cancelCallback);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654854904517-acbd1a4b-eaff-488e-a422-50505ce5f9d7.png" alt="img" style="zoom:80%;" /><h3 id="4-2-Work-queue模型"><a href="#4-2-Work-queue模型" class="headerlink" title="4.2 Work queue模型"></a>4.2 Work queue模型</h3><p>①抽取出创建连接开启通道的代码，得到工具类<code>RabbitMQUtils</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQUtils</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title function_">getChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;192.168.204.127&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-keyword">return</span> channel;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>②创建消费者类<code>Worker01</code>，模拟多个消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker01</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME=<span class="hljs-string">&quot;hello rabbit&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag,delivery)-&gt;&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">receiveMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot;接收到消息：&quot;</span>+receiveMsg);<br>        &#125;;<br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> (consumerTag)-&gt;&#123;<br>            System.out.println(consumerTag+<span class="hljs-string">&quot;---&gt;消费者取消了消费接口&quot;</span>);<br>        &#125;;<br><br>        System.out.println(<span class="hljs-string">&quot;线程1启动   等待消费消息........&quot;</span>);<br>        channel.basicConsume(QUEUE_NAME,<span class="hljs-literal">true</span>,deliverCallback,cancelCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于多个消费者逻辑代码一样，没必要再去新建类copy代码，直接在IDEA的Run Configuration勾选允许多个实例运行：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654856449966-69deba9b-b0ba-4d6f-957f-f02e2aa40365.png" alt="img" style="zoom:80%;" /><p>运行<code>Worker01</code>后，修改提示信息为<code>&quot;线程2启动   等待消费消息........&quot;</code>，再次Run，得到两个不同的线程</p><p>③修改创建者类，使得可以从控制台不断输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task01</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME=<span class="hljs-string">&quot;hello rabbit&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.next();<br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,msg.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;task01发送了消息：&quot;</span>+msg);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>④将三者都启动，输入多条数据，可以发现rabbitmq默认采取轮询策略读取消息</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654856773461-66a30dd9-e6a4-4490-bc50-564a98e08872.png" alt="img" style="zoom:80%;" /><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654856782526-216d3d82-9384-496a-813a-bd616660f528.png" alt="img" style="zoom:80%;" /><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654856792692-a8b2b2d6-e673-4a6d-ab33-fc86cd3cbf17.png" alt="img" style="zoom:80%;" /><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>学习主要看的尚硅谷网课，参考评论区两位学员的笔记，以及官方文档和《RabbitMQ实战指南》电子书</p><ul><li>官方tutorial文档：<a href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html">https://www.rabbitmq.com/tutorials/tutorial-one-java.html</a></li><li><a href="https://www.bilibili.com/video/BV1cb4y1o7zz?share_source=copy_pc">尚硅谷RabbitMQ教程丨快速掌握MQ消息中间件_哔哩哔哩_bilibili</a></li><li>《RabbitMQ实战指南》PDF</li><li><a href="https://note.oddfar.com/pages/95ce73/#hello-world">RabbitMQ - - OddFar’s Notes</a></li><li><a href="https://www.yuque.com/yuxuandmbjz/rabbitmq">RabbitMQ - - 宇轩英建</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、消息队列&quot;&gt;&lt;a href=&quot;#1、消息队列&quot; class=&quot;headerlink&quot; title=&quot;1、消息队列&quot;&gt;&lt;/a&gt;1、消息队列&lt;/h2&gt;&lt;h3 id=&quot;1-1-消息队列的基本概念&quot;&gt;&lt;a href=&quot;#1-1-消息队列的基本概念&quot; class=&quot;he</summary>
      
    
    
    
    <category term="消息队列" scheme="https://61hhh-github-io.vercel.app/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="RabbitMQ" scheme="https://61hhh-github-io.vercel.app/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-查询执行流程</title>
    <link href="https://61hhh-github-io.vercel.app/20220601/afc16bf3/"/>
    <id>https://61hhh-github-io.vercel.app/20220601/afc16bf3/</id>
    <published>2022-06-01T11:18:53.000Z</published>
    <updated>2024-05-10T06:56:45.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h2><p>以一条查询语句为例，通过查询语句在 MySQL 中的执行流程，了解 MySQL 的基础架构以及各组件模块的基本作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where ID=10；<br></code></pre></td></tr></table></figure><blockquote><p> 图片引用自：<a href="https://xiaolincoding.com/">小林coding：图解MySQL专栏</a></p></blockquote><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427212828078.png" alt="image-20230427212828078" style="zoom:80%;" /><p>如图是MySQL的基本架构示意图，MySQL 可以大致分为 Server 层和存储引擎层两大部分。</p><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p><p>正常的建表语句如果不指定默认引擎就是 InnoDB，也可以在建表语句后通过 <code> ENGINE=MyISAM</code> 指定为 MyISAM 或者其他引擎</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><blockquote><p><strong>连接器</strong>：负责跟客户端建立连接、获取权限、维持和管理连接，主要是登陆权限相关；</p></blockquote><p>使用 MySQL 首先要先连接 MySQL 服务，才能执行后续的语句操作。</p><p>1、MySQL 采用 <code>TCP</code> 作为服务器和客户端之间的网络通信协议，默认申请的端口是3306，如果服务连接会报错：<code>Can&#39;t connect to local MySQL...... </code> ，如果已启动就正常走 <code>TCP</code> 握手建立连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -h$ip -P$port -u$user -p<br></code></pre></td></tr></table></figure><p>2、连接建立后，就跟根据输入的用户名密码校验，如果账户密码有误，就会有如下报错</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427221241973.png" alt="image-20230427221241973" style="zoom:80%;" /><p>3、如果账户密码校验通过，就会查询该用户的权限信息并保存，后续的任何操作都会基于连接时读取到的该用户权限</p><blockquote><p>即一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p></blockquote><blockquote><p>每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。</p></blockquote><h4 id="连接器涉及的常见参数"><a href="#连接器涉及的常见参数" class="headerlink" title="连接器涉及的常见参数"></a>连接器涉及的常见参数</h4><p>1、如果连接完成后没有后续操作，连接就处于空闲状态，可以通过 <code>show processlist</code> 命令查看有多少个连接 </p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427221830449.png" alt="image-20230427221830449" style="zoom:80%;" /><p>2、如果客户端长时间没有操作，连接器就会断开连接，具体时间是通过 <code>wait_timeout</code> 参数设置的，默认是28880秒即8小时。对于空闲时间过长被连接器主动断开的连接，客户端并不会收到消息，只有再次发送请求时才会报错提示：<code>ERROR 2013 (HY000): Lost connection to MySQL server during query</code>，如果要继续就要重新建立连接。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427221957980.png" alt="image-20230427221957980" style="zoom:80%;" /><p>3、连接也可以手动断开，通过 <code>kill connection +id</code> 来手动关闭，如图我建立连接后手动关闭了，再次发送请求时提示报错并重连接了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427222848999.png" alt="image-20230427222848999" style="zoom:;" /><p>4、MySQL的默认连接数是有限制的，具体连接数由参数 <code>max_connections</code> 控制，可以通过 <code>show variables like &#39;max_connections&#39;</code> 查看，如果超过连接数就会拒绝新连接并提示 <code>Too many connections</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ysql&gt; show variables like &#x27;max_connections&#x27;;<br>+-----------------+-------+<br>| Variable_name   | Value |<br>+-----------------+-------+<br>| max_connections | 200   |<br>+-----------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>5、MySQL连接分为长连接和短连接。长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接；短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><blockquote><p>执行查询语句的时候，会先查询缓存，命中就直接返回（MySQL 8.0 版本后移除）</p></blockquote><p>查询缓存以 key-value 形式保存缓存数据在内存中，key 是查询的语句，value 是查询的结果</p><p>如果查询的语句和缓存中的 key 完全一致的话，就会直接返回结果给客户端</p><h5 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h5><p>在执行更新操作时，会将查询缓存全部清除。所以频繁更新的表，查询缓存的命中率很低</p><p>MySQL 8.0开始查询缓存已经从 Server 层中被移除了，8.0以后的版本查询时不会走查询缓存</p><h3 id="解析SQL"><a href="#解析SQL" class="headerlink" title="解析SQL"></a>解析SQL</h3><blockquote><p>没有命中缓存就会进入解析，分析器对查询语句进行词法语法分析，以及判断 SQL 语句是否有语法错误</p></blockquote><p>查询缓存未命中就会进入执行操作，在执行前会对 SQL 语句进行分析</p><ol><li>词法分析：根据输入的 SQL 识别系统关键字，构建语法树</li><li>语法分析：对构建的语法树分析是否符合语法规则</li></ol><p>如果输入的 SQL 中有错误语法，例如 <code>where xxx=1</code> 写成了 <code>wheere xxx=1</code> 就会报错 <code>You have an error in your SQL syntax</code></p><h3 id="优化SQL"><a href="#优化SQL" class="headerlink" title="优化SQL"></a>优化SQL</h3><blockquote><p>根据查询语句来确定最优的执行方案</p></blockquote><h4 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h4><p>预处理阶段主要工作如下：</p><ol><li>检查 SQL 中要查询的表或者字段是否存在</li><li>将 <code>SELECT *</code> 中的 <code>*</code> 扩充为全部字段</li></ol><h4 id="优化阶段"><a href="#优化阶段" class="headerlink" title="优化阶段"></a>优化阶段</h4><p>此阶段优化器会确定 SQL 语句的查询方案，它会判断不同查询方案的成本，以选择最优的方式</p><p>例如表中存在多个索引时，决定用哪个索引查询；join 连接时决定连接顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 该 SQL 就会走主键索引<br>SELECT * FROM user1 WHERE id=1<br></code></pre></td></tr></table></figure><p>要想直到具体的查询方案，可以通过 <code>explain</code> 命令对 SQL 进行解释</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230429203028812.png" alt="image-20230429203028812" style="zoom:80%;" /><p>可以看到 <code>possible_keys</code> 表示该 SQL 语句可能用到的索引，这里只有 <code>PRIMARY</code>，<code>key</code> 是实际使用的索引，用的就是 <code>PRIMARY</code></p><p>具体的索引选择方案在索引相关笔记中记录</p><h3 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h3><blockquote><p>执行查询语句，返回记录</p></blockquote><p>分析阶段解析了 SQL 语句、优化阶段指定了查询方案后，就进入正式执行阶段</p><p>执行器会根据表的存储引擎定义，调用对应的引擎接口。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> user1 <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>以 InnoDB 为例，执行的基本流程：</p><ul><li>调用 InnoDB 查询接口获取表的第一行数据，判断 id 是否小于10，是则将结果保存到结果集，不是则跳过</li><li>调用接口读取下一行数据，重复上面的判断逻辑，直到读取到表的最后一行</li><li>执行器将遍历过程中满足条件的行记录作为结果集返回给客户端</li></ul><blockquote><p>以下执行方式示例，引用自<a href="https://xiaolincoding.com/mysql/base/how_select.html#%E6%89%A7%E8%A1%8C%E5%99%A8">小林coding</a></p></blockquote><p>通过如下三种查询执行方式，介绍下执行器和存储引擎的交互过程</p><ol><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ol><h4 id="1、主键索引"><a href="#1、主键索引" class="headerlink" title="1、主键索引"></a>1、主键索引</h4><p>以这条 SQL 为例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sys_user <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>查询条件是主键，由于主键是唯一的，且这里按照等值判断，所以类型是 const 常量判断，即用主键索引查询一条记录</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>；</li><li>存储引擎通过 B+ 树定位到 id&#x3D;1 的第一条记录，不存在该记录就向执行器报错提示找不到，存在就返回该条记录；</li><li>执行器获取记录后判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过；</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了</li></ul><h4 id="2、全表扫描"><a href="#2、全表扫描" class="headerlink" title="2、全表扫描"></a>2、全表扫描</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sys_user <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx@qq.com&#x27;</span>;<br></code></pre></td></tr></table></figure><p>由于 email 字段没有索引，所以优化阶段的查询方案是全表扫描，对应 TYPE&#x3D;ALL，此时执行器和存储引擎的交互流程如下：</p><ul><li><p>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</p></li><li><p>执行器会判断读到的这条记录的 <code>email=xxx@qq.com</code> 是否成立，不是就跳过，<strong>是就返回给客户端</strong></p><blockquote><p>Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录</p></blockquote></li><li><p>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 ALL，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</p></li><li><p>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</p></li><li><p>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</p></li></ul><h4 id="3、索引下推"><a href="#3、索引下推" class="headerlink" title="3、索引下推"></a>3、索引下推</h4><p>索引下推是 MySQL5.6 之后推出的优化策略。<strong>索引下推能够减少二级索引查询时的回表操作，提高查询效率</strong></p><p><strong>回表查询</strong>：由于二级索引的 B+ 树叶子节点存储的主键值，索引在查到符合条件的记录时，会读取叶子节点中的记录的主键值，再次查询聚簇索引的 B+ 树来拿到完整的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sys_user <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> role <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>以这条 SQL 为例，假设建立了 <code>(age,role)</code> 的联合索引，由于联合索引在遇到 <code>&gt;</code>、<code>&lt;</code>、<code>%xxx</code> 时会停止匹配，即只有 age 字段参与了索引查询，后面的 role 字段没有用到索引</p><blockquote><p>联合索引不是有序的，或者说是局部有序的，因为构建 B+ 树时只能根据一个值来。<code>(a,b,c)</code> 构建排列时按照 a、b、c 的顺序来</p><p>以 <code>(age,role)</code> 的联合索引为例，从 B+ 树角度去看，在全局范围内只有 age 是有序排列的，age&#x3D;1 时可能有 role&#x3D;2、role&#x3D;5 两条记录，age&#x3D;2时可能有 role&#x3D;1、role&#x3D;2、role&#x3D;3 三条记录，<strong>即 role 的有序是针对具体的某个 age 局部存在的</strong></p><ul><li>加入查询条件是 <code>age=18 AND role=2</code>，那么 B+ 树先定位到 age&#x3D;18 的第一条记录这儿，可能有10条，再定位到 role&#x3D;2 的第一条记录这儿，此时联合索引的两个字段都参与了索引查询</li><li>当查询条件为 age&gt;18 时，必须要把联合索引的 B+ 树中从 age&gt;18 开始的第一条到最后一条记录全找出来，相当于后面的 role&#x3D;2 压根没起作用，所以它并没有用到索引</li></ul></blockquote><h5 id="无索引下推时"><a href="#无索引下推时" class="headerlink" title="无索引下推时"></a>无索引下推时</h5><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，即 <code>age&gt;18</code> 的第一条记录；</li><li>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后<strong>进行回表操作</strong>，将完整的记录返回给 Server 层；</li><li>Server 层在判断该记录 <code>role=2</code> 是否成立，成立则将其发送给客户端，否则跳过该记录；</li><li>接着继续向存储引擎索要下一条记录，重复上面的操作直到读完所有的记录；</li></ul><p>即：没有索引下推时，没查询一条二级索引记录，都需要一次回表查询，然后 Server 层再判断该记录的 <code>role=2</code> 是否成立</p><h5 id="有索引下推时"><a href="#有索引下推时" class="headerlink" title="有索引下推时"></a>有索引下推时</h5><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，即 <code>age&gt;18</code> 的第一条记录；</li><li>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，<strong>先不进行回表操作</strong>，而是<strong>先判断索引包含的列 role 值是否等于2</strong>，<strong>条件不成立则直接跳过该索引记录</strong>，<strong>成立则执行回表操作</strong>，将记录返回给 Server；</li><li>Server 层再去判断其他的查询条件（本 SQL 只有联合索引的查询条件），成立则将其发送给客户端，否则跳过该记录；</li><li>接着继续向存储引擎索要下一条记录，重复上面的操作直到读完所有的记录；</li></ul><p>即：有索引下推时，虽然 role 列还是没有用到索引，但是由于其本身在联合索引中，所以会直接在存储引擎层过滤出符合 <code>role=2</code> 的条件，再去做回表操作，相比直接每条记录都回表，节省了很多的操作</p><blockquote><p>使用 EXPLAIN 查看执行计划时，如果 Extra&#x3D;Using index condition 表示使用了索引下推</p></blockquote><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>MySQL 支持多种存储引擎，可以通过 <code>show engines</code> 指令查看支持的引擎</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230502123448721.png" alt="image-20230502123448721"></p><p>如图所示，当前版本（8.0.15）MySQL 的默认引擎是 InnoDB，并且只有 InnoDB 是支持事务的（Transactions）</p><blockquote><p>在 MySQL 5.5.5之前 MyISAM 是默认存储引擎，之后都是 InnoDB</p></blockquote><p>如果想要深入了解每个存储引擎以及它们之间的区别，可以阅读 MySQL 官方文档</p><ul><li>InnoDB 存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html</a> </li><li>其他存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html</a></li></ul><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 是基于 ISAM 的存储引擎，数据以紧密格式存储、拥有较高的插入和查询速度、不支持事务、不支持崩溃后的安全恢复、修复操作很慢、提供了全文索引、压缩表、空间数据（GIS）等特性；</p><p>使用 MyISAM 引擎创建数据库，将生产 3 个文件。文件的名字以表的名字开始，扩展名指出文件类型</p><ul><li>.frm：存储表结构定义</li><li>.MYD(MYData)：存储表数据</li><li>.MYI（MYIndex)：存储索引数据</li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 提供了具有提交回滚、崩溃的安全回复等机制。</p><p>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读；主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升；内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等；支持真正的在线热备份</p><h3 id="MyISAM-和-InnoDB"><a href="#MyISAM-和-InnoDB" class="headerlink" title="MyISAM 和 InnoDB"></a>MyISAM 和 InnoDB</h3><p>MySQL5.5 之前默认的存储引擎是 MyISAM，之后改为了 InnoDB</p><ul><li>事务：MyISAM 不支持事务；InnoDB 提供事务支持，实现了 SQL 标准定义的四个隔离级别，默认是可重复读</li><li>并发：MyISAM 只支持表级锁、InnoDB 支持行级锁（上图的 row-level locking）和表级锁，默认行级锁</li><li>索引：MyISAM 和 InnoDB 都是 B+ 树索引，但是 MyISAM 仅保存记录所在页的指针</li><li>外键：MyISAM 不支持外键、InnoDB 支持外键</li><li>备份：MyISAM 不支持在线热备份、InnoDB 支持</li><li>恢复：MyISAM 崩溃后数据损毁的概率比 InnoDB高很多，InnoDB 支持数据崩溃恢复，通过 <code>redo log</code> 操作</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>极客时间：MySQL 45讲</li><li><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">MySQL常见面试题总结</a></li><li><a href="https://xiaolincoding.com/">小林coding的图解MySQL专栏</a></li><li><a href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-engine.html">MySQL - 存储引擎</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL基础架构&quot;&gt;&lt;a href=&quot;#MySQL基础架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL基础架构&quot;&gt;&lt;/a&gt;MySQL基础架构&lt;/h2&gt;&lt;p&gt;以一条查询语句为例，通过查询语句在 MySQL 中的执行流程，了解 MySQL 的基</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://61hhh-github-io.vercel.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据库" scheme="https://61hhh-github-io.vercel.app/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://61hhh-github-io.vercel.app/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习五：主从复制</title>
    <link href="https://61hhh-github-io.vercel.app/20220528/ea10fc6a/"/>
    <id>https://61hhh-github-io.vercel.app/20220528/ea10fc6a/</id>
    <published>2022-05-28T02:30:27.000Z</published>
    <updated>2024-05-10T07:26:07.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p><p>默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><p><strong>主从复制的作用：</strong></p><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ol><h2 id="使用主从复制"><a href="#使用主从复制" class="headerlink" title="使用主从复制"></a>使用主从复制</h2><h3 id="配从不配主"><a href="#配从不配主" class="headerlink" title="配从不配主"></a>配从不配主</h3><p>主从复制只需要配置从节点，无需操作主节点</p><ol><li>配置文件：在从服务器的配置文件中加入：slaveof  <code>&lt;masterIp&gt;</code>  <code>&lt;masterport&gt;</code></li><li>启动命令：redis-server启动命令后加入 –slaveof  <code>&lt;masterIp&gt;</code>  <code>&lt;masterport&gt;</code></li><li>客户端命令：Redis服务器启动后，直接通过client执行命令：slaveof  <code>&lt;masterIp&gt;</code>  <code>&lt;masterport&gt;</code>，则该Redis实例成为从节点。</li></ol><h3 id="1-初始配置"><a href="#1-初始配置" class="headerlink" title="1 初始配置"></a>1 初始配置</h3><p>1、拷贝3份<code>redis.conf</code>文件，重命名为<code>redis6379.conf</code>、<code>redis6380.conf</code>、<code>redis6381.conf</code></p><p>2、开启<code>daemonize yes</code>；修改<code>pid</code>文件名；指定对应端口；修改log文件加上端口为后缀；修改<code>Dump.rdb</code>加端口后缀</p><p>3、启动三个redis-server，通过<code>ps -ef | grep redis</code>查看启动状态</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328101230533.png" alt="image-20220328101230533" style="zoom:80%;" /><p>4、通过<code>info replication</code>查看主从复制信息。基本的配置完成</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220325102204597.png" alt="image-20220325102204597" style="zoom:80%;" /><h3 id="2-一主二仆"><a href="#2-一主二仆" class="headerlink" title="2 一主二仆"></a>2 一主二仆</h3><p>1、在6380、6381上执行<code>SLAVEOF 127.0.0.1 6379</code>，再次打印信息，可以看到6379成为主，6380、81成为从</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328103540597.png" alt="image-20220328103540597" style="zoom:80%;" /><p>2、从机数据复制是从头开始，比如主机set k1、k2、k3，从机从k4开始配置，前面的k123都会复制</p><p>3、在主节点上写入数据，在从节点可以读取对应数据；而在从节点写入数据会报错</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328104119539.png" alt="image-20220328104119539" style="zoom:80%;" /><p>4、主机挂掉，从机信息：<code>master_link_status:down</code>原地待命，主机重启后还是主节点，从节点的信息：<code>master_link_status:up</code>；从机挂掉重启后，主从信息会丢失，需要通过命令<code>SLAVEOF 127.0.0.1 6379</code>重新指定（也可以通过配置文件修改REPLICATION部分永久生效）</p><p>5、从机可以通过<code>SLAVEOF no one</code>断开主从连接。需要注意的是，从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化</p><h3 id="3、薪火相传"><a href="#3、薪火相传" class="headerlink" title="3、薪火相传"></a>3、薪火相传</h3><p>当前主从节点中的slave可以是另一个主从节点中的master，它同样可以接收其他slave的连接和同步请求，通过此方式可以减轻当前master的读写压力</p><p>通过<code>SLAVEOF newIP newPort</code>更改主从信息，中途变更了主从复制信息后，会清除之前的数据，重新建立拷贝最新的数据，如图6381新的<code>get kkk</code>其实是通过6380获取的</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328112417755.png" alt="image-20220328112417755" style="zoom:80%;" /><h3 id="4、反客为主"><a href="#4、反客为主" class="headerlink" title="4、反客为主"></a>4、反客为主</h3><p>通过<code>SLAVEOF no one</code>将从节点变为master，使当前数据库停止与其他数据库的同步，转成主数据库</p><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>在初次成功配置主从复制后，可以查看Redis日志：</p><p>主机日志：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328141337796.png" alt="image-20220328141337796" style="zoom:80%;" /><p>从机日志：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328141422599.png" alt="image-20220328141422599" style="zoom:80%;" /><p>由日志文件可以看到：主从复制过程大体可以分为3个阶段——连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段；下面分别进行介绍。</p><h3 id="1、连接建立"><a href="#1、连接建立" class="headerlink" title="1、连接建立"></a>1、连接建立</h3><p>该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。</p><p><strong>保存主节点信息</strong></p><p>从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。</p><p>需要注意的是，<code>slaveof</code>是异步命令，从节点完成主节点ip和port的保存后，向发送<code>slaveof</code>命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。这个过程中，可以看到从节点打印日志如下：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328142210802.png" alt="image-20220328142210802"></p><p><strong>建立socket连接</strong></p><p>从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。如果连接成功，</p><ul><li>从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。</li><li>主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，<strong>并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</strong></li></ul><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328142412940.png" alt="image-20220328142412940"></p><p><strong>发送ping命令</strong></p><p>从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。</p><p>从节点发送ping命令后，可能出现3种情况：</p><p>（1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p><p>（2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p><p>（3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p><p>在主节点返回pong情况下，从节点打印日志如下：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328142502194.png" alt="image-20220328142502194"></p><p><strong>身份验证</strong></p><p>如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p><p>如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p><p><strong>发送从节点端口信息</strong></p><p>身份验证之后，从节点会向主节点发送其监听的端口号（本例为6380、6381），主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</p><h3 id="2、数据同步"><a href="#2、数据同步" class="headerlink" title="2、数据同步"></a>2、数据同步</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。</p><p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制。需要注意的是，在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p><p>在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；在Redis2.8及以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。</p><ol><li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li><li>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li></ol><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p>Redis通过psync命令进行全量复制的过程如下：</p><p>（1）从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制；具体判断过程需要在讲述了部分复制原理后再介绍。</p><p>（2）主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</p><p>（3）主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态</p><p>（4）主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态</p><p>（5）如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态</p><p>主机的同步日志：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328143313401.png" alt="image-20220328143313401"></p><p>从机的同步日志：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328143411959.png" alt="image-20220328143411959"></p><p>可以看到：从节点接收了来自主节点的175个字节的数据、接受前先flush清除旧数据、没有设置aof所以没调用<code>bgrewriteaof</code></p><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p><p>部分复制的实现，依赖于三个重要的概念：</p><ol><li>复制偏移量</li><li>复制积压缓冲区</li><li>服务器运行ID(runid)</li></ol><p><strong>复制偏移量</strong></p><p>主从节点各自维护一个复制偏移量<code>offset</code>，每次完成N个字节的数据复制后，主从节点都会修改各自的偏移量为新的<code>offset+N</code>。通过<code>offset</code>可以判断主从节点数据库状态是否保持一致：相同则一致，不同则可以根据offset找出缺少的数据。</p><p>例如主节点offset是1000，从节点是500，则部分复制会将501-1000之间的数据进行同步</p><p><strong>复制积压缓冲区</strong></p><p>主节点在初次配置主从信息开始，就会维护一个固定长度的、默认大小1MB的先进先出(FIFO)队列，用于备份主节点最近发送给从节点的数据。【无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区】</p><p>在命令传播阶段，主节点同步写命令到从节点，还会发送给复制积压缓冲区作为备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</p><p>为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p><p>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</p><ul><li>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</li><li>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</li></ul><p><strong>服务器运行ID(runid)</strong></p><p>每个Redis节点都有其运行ID，在启动时自动生成</p><p>初次主从复制时主节点会将自己的runid发送给从节点，从节点会将runid存起来。 当发生断线重连的时候，主节点根据runid判断是否能进行部分复制：</p><ul><li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li><li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li></ul><h4 id="psync命令"><a href="#psync命令" class="headerlink" title="psync命令"></a>psync命令</h4><p>PSYNC命令流程图如下：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328151656392.png" alt="image-20220328151656392" style="zoom:80%;" /><p>psync命令的大体流程如下：</p><ul><li>如果从节点没有复制过任何主节点或执行过slaveof no one命令，从节点就会向主节点发送<code>psync ? -1</code>，请求主节点进行数据的全量同步</li><li>如果前面从节点已经同步过部分数据，此时从节点就会发送<code>psync &lt;runid&gt; &lt;offset&gt;</code>命令给主节点，其中runid是上一次主节点的运行ID，offset是当前从节点的复制偏移量</li></ul><p>主节点收到psync命令后，会出现以下三种可能：</p><ul><li>如果主服务器返回<code>-err</code>，主服务器的Redis版本低于2.8，无法识别psync命令，此时从服务器会向主服务器发送sync命令，进行完整的数据全量复制</li><li>主节点返回<code>fullresync &lt;runid&gt; &lt;offset&gt;</code>，但可能runid不一致、offset差值大于复制挤压缓冲区长度等，则进行全量复制，其中runid为主节点的运行ID，offset为当前主节点的复制偏移量</li><li>如果主服务器返回<code>+continue</code>，则进行增量复制，等待主节点同步offset差值部分的数据即可</li></ul><h3 id="3、命令传播"><a href="#3、命令传播" class="headerlink" title="3、命令传播"></a>3、命令传播</h3><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。</p><p>每隔指定的时间，主节点会向从节点发送PING命令，这个PING命令的作用，主要是为了让从节点进行超时判断。PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。</p><p>从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量。REPLCONF ACK命令的作用包括：</p><p>（1）实时监测主从节点网络状态：该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1</p><p>（2）检测命令丢失：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的</p><p>（3）辅助保证从节点的数量和延迟：Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p>1、设置为一仆二主，6379带6380、6381</p><p>2、编辑一个<code>sentinel.conf</code>文件，内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">masterName:为监控对象起的服务器名称</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机</span><br>sentinel monitor masterName 127.0.0.1 6379 1<br></code></pre></td></tr></table></figure><p>3、启动redis-sentinel，指定<code>sentinel.conf</code>文件</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328155708818.png" alt="image-20220328155708818"></p><p>4、通过shutdown关闭主节点6379，等一会儿可以看到，投票选出新的6380作为主节点了</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328160255392.png" alt="image-20220328160255392"></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328160351359.png" alt="image-20220328160351359" style="zoom:80%;" /><p>5、再次重启6379后，发现现在已经变成从节点了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328160725607.png" alt="image-20220328160725607" style="zoom: 70%;" /><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html">深入学习Redis（3）：主从复制</a></li><li>尚硅谷Redis</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据</summary>
      
    
    
    
    <category term="数据库" scheme="https://61hhh-github-io.vercel.app/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://61hhh-github-io.vercel.app/tags/Redis/"/>
    
    <category term="NoSQL" scheme="https://61hhh-github-io.vercel.app/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习四：事务和发布订阅</title>
    <link href="https://61hhh-github-io.vercel.app/20220528/122afe43/"/>
    <id>https://61hhh-github-io.vercel.app/20220528/122afe43/</id>
    <published>2022-05-28T02:28:24.000Z</published>
    <updated>2024-05-10T07:26:18.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h3><p>Redis事务定义：将多个命令打包， 然后一次性、按顺序地执行，并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。</p><p>Redis通过<code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code>指令来实现事务功能。事务的主要作用就是串联多个指令，可以将Redis的事务视作一个队列，通过<code>MULTI</code>指令开始一个事务，之后我们键入的每个命令都被添加到这个队列中，当输入<code>EXEC</code>指令就开始按照先进先出顺序执行队列中的命令。</p><p>一个事务从开始到执行经历三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><p>事务相关指令含义如下：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>MULTI</td><td>标记一个事务的开始</td></tr><tr><td>EXEC</td><td>执行一个事务队列中的所有命令</td></tr><tr><td>DISCARD</td><td>取消事务，放弃执行事务队列中的命令</td></tr><tr><td>WATCH</td><td>监视一个或多个key，如果在事务执行前这个key被其他命令改动，则事务被中断</td></tr><tr><td>UNWATCH</td><td>取消监视一个或多个key</td></tr></tbody></table><span id="more"></span><h3 id="事务的执行"><a href="#事务的执行" class="headerlink" title="事务的执行"></a>事务的执行</h3><h4 id="1、正常执行"><a href="#1、正常执行" class="headerlink" title="1、正常执行"></a>1、正常执行</h4><p>通过<code>MULTI</code>指令开启事务，添加命令到队列中，通过<code>EXEC</code>执行：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220322162204162.png" alt="image-20220322162204162" style="zoom:80%;" /><h4 id="2、放弃事务"><a href="#2、放弃事务" class="headerlink" title="2、放弃事务"></a>2、放弃事务</h4><p>通过<code>MULTI</code>指令开启事务，添加命令到队列中，通过<code>DISCARD</code>取消：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323000524729.png" alt="image-20220323000524729" style="zoom:80%;" /><h4 id="3、全体连坐"><a href="#3、全体连坐" class="headerlink" title="3、全体连坐"></a>3、全体连坐</h4><p>如果事务队列中的命令存在语法错误（例如参数数量、名称等不对），或者其他更严重的错误，比如内存不足（使用 <code>maxmemory</code> 设置了最大内存限制），此时整个队列都会被取消：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323001510293.png" alt="image-20220323001510293" style="zoom:80%;" /><p>通过对入队命令的返回值做检查，如果是<code>QUEUED</code>标识正常入队，否则就是入队失败，2.6.5之后如果有入队失败的情况则<code>EXEC</code>时拒绝执行此事务。</p><h4 id="4、冤头债主"><a href="#4、冤头债主" class="headerlink" title="4、冤头债主"></a>4、冤头债主</h4><p>如果命令不是语法上的错误，而是执行阶段的错误（例如对string类型执行<code>INCR</code>等），则只有报错的命令不会被执行，而其他的正确命令都会执行，整体事务不会回滚：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323001337310.png" alt="image-20220323001337310" style="zoom:80%;" /><h3 id="WATCH监控"><a href="#WATCH监控" class="headerlink" title="WATCH监控"></a>WATCH监控</h3><h4 id="1、悲观锁"><a href="#1、悲观锁" class="headerlink" title="1、悲观锁"></a>1、悲观锁</h4><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><h4 id="2、乐观锁"><a href="#2、乐观锁" class="headerlink" title="2、乐观锁"></a>2、乐观锁</h4><p>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型</strong>，这样可以提高吞吐量，Redis就是利用这种check-and-set机制实现事务的。【乐观锁策略:提交版本必须大于记录当前版本才能执行更新】</p><h4 id="带WATCH的事务"><a href="#带WATCH的事务" class="headerlink" title="带WATCH的事务"></a>带WATCH的事务</h4><p><code>WATCH</code> 指令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务将被打断，不再执行， 直接返回失败。</p><p>并且<code>WATCH</code> 指令可以调用多次，从执行<code>WATCH</code> 开始生效直到<code>EXEC</code>，<strong>当 <code>EXEC</code> 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消</strong>。另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</p><p>设置工资开销<code>salary</code>、<code>spending</code>的初始值为10000和0，如果自己一个人正常用，洗个脚1600：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323003943605.png" alt="image-20220323003943605" style="zoom:80%;" /><p>假设工资是和女朋友一起用，第二次去洗脚时女朋友直接刷了个8400的包，这时结账就会出问题了：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323004419871.png" alt="image-20220323004419871" style="zoom:80%;" /><p>如果不加<code>WATCH</code>就会出大问题了，银行卡变成<code>-1600</code>：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323004836824.png" alt="image-20220323004836824" style="zoom:80%;" /><p><strong>watch指令，类似乐观锁</strong>，事务提交时，如果 key 的值已被别的客户端改变，比如某个 list 已被别的客户端push&#x2F;pop 过了，整个事务队列都不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败</p><p>【注】当然也可以用 Redis 实现分布式锁来保证安全性，属于悲观锁</p><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li><p>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断；</p></li><li><p>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题；</p></li><li><p>不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚；</p><blockquote><p>官方的解释：</p><p>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</p><p>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</p></blockquote></li></ul><h3 id="事务的原理"><a href="#事务的原理" class="headerlink" title="事务的原理"></a>事务的原理</h3><h4 id="1、开始事务"><a href="#1、开始事务" class="headerlink" title="1、开始事务"></a>1、开始事务</h4><p><code>MULTI</code>命令唯一做的就是， 将客户端的 <code>REDIS_MULTI</code> 选项打开， 让客户端从非事务状态切换到事务状态。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324103546438.png" alt="image-20220324103546438" style="zoom:80%;" /><h4 id="2、命令入队"><a href="#2、命令入队" class="headerlink" title="2、命令入队"></a>2、命令入队</h4><p>对于非执行指令（除EXEC、DISCARD、MULTI、WATCH）直接入队，返回结果QUEUED，如果指令有语法错误则返回错误信息</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324104045964.png" alt="image-20220324104045964" style="zoom:80%;" /><h4 id="2-、事务队列"><a href="#2-、事务队列" class="headerlink" title="2*、事务队列"></a>2*、事务队列</h4><ul><li><p>每个 Redis 客户端都有自己的事务状态， 这个事务状态保存在客户端状态的 <code>mstate</code> 属性里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisClient</span> &#123;</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 事务状态</span><br>    multiState mstate;      <span class="hljs-comment">/* MULTI/EXEC state */</span><br>    <span class="hljs-comment">// ...</span><br>&#125; redisClient;<br></code></pre></td></tr></table></figure></li><li><p>事务状态包含一个事务队列， 以及一个已入队命令的计数器 （也可以说是事务队列的长度）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">multiState</span> &#123;</span><br>    <span class="hljs-comment">// 事务队列，FIFO 顺序</span><br>    multiCmd *commands;<br>    <span class="hljs-comment">// 已入队命令计数</span><br>    <span class="hljs-type">int</span> count;<br>&#125; multiState;<br></code></pre></td></tr></table></figure></li><li><p>事务队列是一个 <code>multiCmd</code> 类型的数组， 数组中的每个 <code>multiCmd</code> 结构都保存了一个已入队命令的相关信息， 包括指向命令实现函数的指针， 命令的参数， 以及参数的数量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">multiCmd</span> &#123;</span><br>    <span class="hljs-comment">// 参数</span><br>    robj **argv;<br>    <span class="hljs-comment">// 参数数量</span><br>    <span class="hljs-type">int</span> argc;<br>    <span class="hljs-comment">// 命令指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisCommand</span> *<span class="hljs-title">cmd</span>;</span><br>&#125; multiCmd;<br></code></pre></td></tr></table></figure></li><li><p>事务队列以先进先出（FIFO）的方式保存入队的命令： 较先入队的命令会被放到数组的前面， 而较后入队的命令则会被放到数组的后面。</p></li></ul><p>由上可知事务队列是一个数组， 每个数组项是都包含三个属性：</p><ol><li>要执行的命令（cmd）</li><li>命令的参数（argv）</li><li>参数的个数（argc）</li></ol><p>执行如下指令时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Redis">redis&gt; MULTI<br>OK<br><br>redis&gt; SET book-name &quot;Mastering C++ in 21 days&quot;<br>QUEUED<br><br>redis&gt; GET book-name<br>QUEUED<br><br>redis&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;<br>QUEUED<br><br>redis&gt; SMEMBERS tag<br>QUEUED<br></code></pre></td></tr></table></figure><p>得到的指令队列：</p><table><thead><tr><th>数组索引</th><th>cmd</th><th>argv</th><th>argc</th></tr></thead><tbody><tr><td>0</td><td>SET</td><td>[“book-name”, “Mastering C++ in 21 days”]</td><td>2</td></tr><tr><td>1</td><td>GET</td><td>[“book-name”]</td><td>1</td></tr><tr><td>2</td><td>SADD</td><td>[“tag”, “C++”, “Programming”, “Mastering Series”]</td><td>4</td></tr><tr><td>3</td><td>SMEMBERS</td><td>[“tag”]</td><td>1</td></tr></tbody></table><h4 id="3、执行事务"><a href="#3、执行事务" class="headerlink" title="3、执行事务"></a>3、执行事务</h4><p>当遇到EXEC、DISCARD、MULTI、WATCH这四个指令时，事务就会被执行。服务器根据客户端所保存的事务队列， 以先进先出（FIFO）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324103946709.png" alt="image-20220324103946709" style="zoom: 80%;" /><p>当事务队列里的所有命令被执行完之后，EXEC命令会将回复队列作为自己的执行结果返回给客户端， 客户端从事务状态返回到非事务状态， 至此， 事务执行完毕。伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_transaction</span>():<br>    <span class="hljs-comment"># 创建空白的回复队列</span><br>    reply_queue = []<br>    <span class="hljs-comment"># 取出事务队列里的所有命令、参数和参数数量</span><br>    <span class="hljs-keyword">for</span> cmd, argv, argc <span class="hljs-keyword">in</span> client.transaction_queue:<br>        <span class="hljs-comment"># 执行命令，并取得命令的返回值</span><br>        reply = execute_redis_command(cmd, argv, argc)<br>        <span class="hljs-comment"># 将返回值追加到回复队列末尾</span><br>        reply_queue.append(reply)<br>    <span class="hljs-comment"># 清除客户端的事务状态</span><br>    clear_transaction_state(client)<br>    <span class="hljs-comment"># 清空事务队列</span><br>    clear_transaction_queue(client)<br>    <span class="hljs-comment"># 将事务的执行结果返回给客户端</span><br>    send_reply_to_client(client, reply_queue)<br></code></pre></td></tr></table></figure><h4 id="WATCH实现"><a href="#WATCH实现" class="headerlink" title="WATCH实现"></a>WATCH实现</h4><p>在每个代表数据库的 <code>redis.h/redisDb</code> 结构类型中， 都保存了一个 <code>watched_keys</code> 字典， 字典的键是这个数据库被监视的键， 而字典的值则是一个链表， 链表中保存了所有监视这个键的客户端。如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324143007715.png" alt="image-20220324143007715" style="zoom:80%;" /><p>其中， 键 <code>key1</code> 正在被 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 三个客户端监视， 其他一些键也分别被其他别的客户端监视着。</p><p>WATCH命令的作用， 就是将当前客户端和要监视的键在 <code>watched_keys</code> 中进行关联。</p><p>举个例子， 如果当前客户端为 <code>client10086</code> ， 那么当客户端执行 <code>WATCH key1 key2</code> 时， 前面展示的 <code>watched_keys</code> 将被修改成这个样子：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324143132923.png" alt="image-20220324143132923" style="zoom:80%;" /><p>通过 <code>watched_keys</code> 字典， 如果程序想检查某个键是否被监视， 那么它只要检查字典中是否存在这个键即可； 如果程序要获取监视某个键的所有客户端， 那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p><h4 id="WATCH触发"><a href="#WATCH触发" class="headerlink" title="WATCH触发"></a>WATCH触发</h4><p>在任何对数据库键空间（key space）进行修改的命令成功执行之后 （比如FLUSHDB、SET、DEL、LPUSH、SADD、ZREM等）， <code>multi.c/touchWatchedKey</code> 函数都会被调用——它检查数据库的 <code>watched_keys</code> 字典， 查找是否有被该命令修改的键，有的话 程序将所有监视这个&#x2F;这些被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324143653578.png" alt="image-20220324143653578" style="zoom:80%;" /><p>当客户端发送EXEC命令、触发事务执行时， 服务器会对客户端的状态进行检查：</p><ul><li>如果客户端的 <code>REDIS_DIRTY_CAS</code> 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</li><li>如果 <code>REDIS_DIRTY_CAS</code> 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</li></ul><p>可以用一段伪代码来表示这个检查：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_safety_before_execute_trasaction</span>():<br>    <span class="hljs-keyword">if</span> client.state &amp; REDIS_DIRTY_CAS:<br>        <span class="hljs-comment"># 安全性已破坏，清除事务状态</span><br>        clear_transaction_state(client)<br>        <span class="hljs-comment"># 清空事务队列</span><br>        clear_transaction_queue(client)<br>        <span class="hljs-comment"># 返回空回复给客户端</span><br>        send_empty_reply(client)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 安全性完好，执行事务</span><br>        execute_transaction()<br></code></pre></td></tr></table></figure><p>举个例子，假设数据库的 <code>watched_keys</code> 字典如下图所示：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420225953389.png" alt="image-20230420225953389" style="zoom:80%;" /><p>如果某个客户端对 <code>key1</code> 进行了修改（比如执行 <code>DEL key1</code> ）， 那么所有监视 <code>key1</code> 的客户端， 包括 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 的 <code>REDIS_DIRTY_CAS</code> 选项都会被打开， 当客户端 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 执行EXEC的时候， 它们的事务都会以失败告终。</p><p>最后，当一个客户端结束它的事务时，无论事务是成功执行，还是失败， <code>watched_keys</code> 字典中和这个客户端相关的资料都会被清除。</p><h2 id="Redis发布与订阅"><a href="#Redis发布与订阅" class="headerlink" title="Redis发布与订阅"></a>Redis发布与订阅</h2><h3 id="发布与订阅概念"><a href="#发布与订阅概念" class="headerlink" title="发布与订阅概念"></a>发布与订阅概念</h3><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。Redis 客户端可以订阅任意数量的频道。</p><p>如图是 channel1 和三个订阅了频道的Redis客户端：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324144453619.png" alt="image-20220324144453619" style="zoom: 80%;" /><p>当有消息message通过<code>PUBLISH</code>指令发送到 channel1 时，这个message会发送到订阅它的客户端：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324144910793.png" alt="image-20220324144910793" style="zoom:80%;" /><h3 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h3><p>1、打开一个客户端，订阅频道<code>channel1</code>：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324145443960.png" alt="image-20220324145443960" style="zoom:80%;" /><p>2、打开另一个客户端，通过<code>PUBLISH channel1 hello-redis0</code>发布消息，返回值1表示频道channel1有一个订阅者，可以看到订阅的客户端收到了<code>hello-redis0</code>消息：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324145758711.png" alt="image-20220324145758711" style="zoom:80%;" /><p>3、再打开一个客户端订阅channel1，发送消息<code>hello-redis1</code>，可以看到返回2，两个订阅的都收到消息，并且新订阅的是没有收到之前的消息<code>hello-redis0</code>的：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324150219041.png" alt="image-20220324150219041" style="zoom:80%;" /><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html">事务-Redis设计与实现</a></li><li>Redis——B站尚硅谷周阳</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Redis事务&quot;&gt;&lt;a href=&quot;#Redis事务&quot; class=&quot;headerlink&quot; title=&quot;Redis事务&quot;&gt;&lt;/a&gt;Redis事务&lt;/h2&gt;&lt;h3 id=&quot;事务的概念&quot;&gt;&lt;a href=&quot;#事务的概念&quot; class=&quot;headerlink&quot; title=&quot;事务的概念&quot;&gt;&lt;/a&gt;事务的概念&lt;/h3&gt;&lt;p&gt;Redis事务定义：将多个命令打包， 然后一次性、按顺序地执行，并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。&lt;/p&gt;
&lt;p&gt;Redis通过&lt;code&gt;MULTI&lt;/code&gt;、&lt;code&gt;EXEC&lt;/code&gt;、&lt;code&gt;DISCARD&lt;/code&gt;、&lt;code&gt;WATCH&lt;/code&gt;指令来实现事务功能。事务的主要作用就是串联多个指令，可以将Redis的事务视作一个队列，通过&lt;code&gt;MULTI&lt;/code&gt;指令开始一个事务，之后我们键入的每个命令都被添加到这个队列中，当输入&lt;code&gt;EXEC&lt;/code&gt;指令就开始按照先进先出顺序执行队列中的命令。&lt;/p&gt;
&lt;p&gt;一个事务从开始到执行经历三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始事务&lt;/li&gt;
&lt;li&gt;命令入队&lt;/li&gt;
&lt;li&gt;执行事务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务相关指令含义如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;MULTI&lt;/td&gt;
&lt;td&gt;标记一个事务的开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXEC&lt;/td&gt;
&lt;td&gt;执行一个事务队列中的所有命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DISCARD&lt;/td&gt;
&lt;td&gt;取消事务，放弃执行事务队列中的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WATCH&lt;/td&gt;
&lt;td&gt;监视一个或多个key，如果在事务执行前这个key被其他命令改动，则事务被中断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNWATCH&lt;/td&gt;
&lt;td&gt;取消监视一个或多个key&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://61hhh-github-io.vercel.app/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://61hhh-github-io.vercel.app/tags/Redis/"/>
    
    <category term="NoSQL" scheme="https://61hhh-github-io.vercel.app/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis-Plus 自定义批处理操作</title>
    <link href="https://61hhh-github-io.vercel.app/20220511/65ec32cd/"/>
    <id>https://61hhh-github-io.vercel.app/20220511/65ec32cd/</id>
    <published>2022-05-11T09:35:28.000Z</published>
    <updated>2024-05-10T07:51:59.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>项目中有个对接同步数据的需求，大致流程是对接其他平台后把需要的数据在代码中处理保存到本项目对应库中，ORM 框架产线统一用的 Mybatis-Plus，列表批量数据保存调用的是 <code>saveOrUpdateBatch()</code> 方法，但是在同步开始结束 <code>log.info</code> 打日志发现数据量不大但是耗时比预期的长</p><p>进入 MP 的源码中查看该方法，发现它的批量操作并不是真正的批量操作，默认的 <code>saveOrUpdateBatch()</code> 调用的是 SqlHelper 的 <code>executeBatch()</code>，遍历创建 sql 语句，然后按照一个 batchSize 开启一次事务提交，所以控制台输出的也是一条一条的 insert 语句</p><h3 id="二、改进方法"><a href="#二、改进方法" class="headerlink" title="二、改进方法"></a>二、改进方法</h3><h4 id="1、用-Mybatis-写-xml"><a href="#1、用-Mybatis-写-xml" class="headerlink" title="1、用 Mybatis 写 xml"></a>1、用 Mybatis 写 xml</h4><p>直接通过 Mybatis 写 xml，利用 <code>&lt;foreach&gt; &lt;/foreach&gt;</code> 标签遍历待操作数据</p><p>具体操作参照官方文档：<a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html#foreach">https://mybatis.org/mybatis-3/zh/dynamic-sql.html#foreach</a></p><h4 id="2、改进-MP"><a href="#2、改进-MP" class="headerlink" title="2、改进 MP"></a>2、改进 MP</h4><p>在 Mybatis-Plus 中新增有一个 sql 注入器，可以通过 sql 注入器实现批量新增删除等操作，一次注入随时可用，使用上比较方便，唯一的缺点就是在项目启动时会进行 sql 注入器注册</p><h3 id="三、步骤"><a href="#三、步骤" class="headerlink" title="三、步骤"></a>三、步骤</h3><h4 id="1、自定义-BaseMapper"><a href="#1、自定义-BaseMapper" class="headerlink" title="1、自定义 BaseMapper"></a>1、自定义 BaseMapper</h4><p>创建一个自定义的 BatchMapper（名称自定义）继承 BaseMapper，在 BatchMapper 中添加自定义的方法名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BatchMapper</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义的批量插入功能：mysqlSaveOrUpdateBatch</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list 待批量插入的数据，要自动填充 <span class="hljs-doctag">@Param</span>(xxx) xxx必须是 list/collection/array 三者之一</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 操作条数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">mysqlSaveOrUpdateBatch</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;list&quot;)</span>List&lt;T&gt; list)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、方法实现"><a href="#2、方法实现" class="headerlink" title="2、方法实现"></a>2、方法实现</h4><p>自定义方法的具体实现，逻辑上就是将待插入的数据拼接成 VALUES 多个参数形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">saveOrUpdateBatchMethod</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMethod</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> MappedStatement <span class="hljs-title function_">injectMappedStatement</span><span class="hljs-params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;script&gt;insert into %s %s values %s ON DUPLICATE KEY UPDATE %s&lt;/script&gt;&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> tableInfo.getTableName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fieldSql</span> <span class="hljs-operator">=</span> prepareFieldSql(tableInfo);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">modelValueSql</span> <span class="hljs-operator">=</span> prepareModelValueSql(tableInfo);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">duplicateKeySql</span> <span class="hljs-operator">=</span> prepareDuplicateKeySql(tableInfo);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sqlResult</span> <span class="hljs-operator">=</span> String.format(sql, tableName, fieldSql, modelValueSql, duplicateKeySql);<br>        <span class="hljs-type">SqlSource</span> <span class="hljs-variable">sqlSource</span> <span class="hljs-operator">=</span> languageDriver.createSqlSource(configuration, sqlResult, modelClass);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.addInsertMappedStatement(mapperClass, modelClass, <span class="hljs-string">&quot;mysqlSaveOrUpdateBatch&quot;</span>, sqlSource, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoKeyGenerator</span>(), <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">// 这里的名称要和Mapper中定义的一致</span><br>    &#125;<br><br>    <span class="hljs-comment">// 字段</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">prepareFieldSql</span><span class="hljs-params">(TableInfo tableInfo)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">fieldSql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&quot;(&quot;</span>);<br>        fieldSql.append(tableInfo.getKeyColumn()).append(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">columnStr</span> <span class="hljs-operator">=</span> tableInfo.getFieldList().stream().map(TableFieldInfo::getColumn).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>        fieldSql.append(columnStr).append(<span class="hljs-string">&quot;)&quot;</span>);<br>        <span class="hljs-keyword">return</span> fieldSql.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// 值</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">prepareModelValueSql</span><span class="hljs-params">(TableInfo tableInfo)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">valueSql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        valueSql.append(<span class="hljs-string">&quot;&lt;foreach collection=\&quot;list\&quot; item=\&quot;item\&quot; index=\&quot;index\&quot; open=\&quot;(\&quot; separator=\&quot;),(\&quot; close=\&quot;)\&quot;&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(tableInfo.getKeyProperty())) &#123;<br>            valueSql.append(<span class="hljs-string">&quot;#&#123;item.&quot;</span>).append(tableInfo.getKeyProperty()).append(<span class="hljs-string">&quot;&#125;,&quot;</span>);<br>        &#125;<br>        tableInfo.getFieldList().forEach(x -&gt; valueSql.append(<span class="hljs-string">&quot;#&#123;item.&quot;</span>).append(x.getProperty()).append(<span class="hljs-string">&quot;&#125;,&quot;</span>));<br>        valueSql.delete(valueSql.length() - <span class="hljs-number">1</span>, valueSql.length());<br>        valueSql.append(<span class="hljs-string">&quot;&lt;/foreach&gt;&quot;</span>);<br>        <span class="hljs-keyword">return</span> valueSql.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// 已存在数据执行更新</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">prepareDuplicateKeySql</span><span class="hljs-params">(TableInfo tableInfo)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">duplicateKeySql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(tableInfo.getKeyColumn())) &#123;<br>            duplicateKeySql.append(tableInfo.getKeyColumn()).append(<span class="hljs-string">&quot;=values(&quot;</span>).append(tableInfo.getKeyColumn()).append(<span class="hljs-string">&quot;),&quot;</span>);<br>        &#125;<br><br>        tableInfo.getFieldList().forEach(x -&gt; &#123;<br>            duplicateKeySql.append(x.getColumn())<br>                    .append(<span class="hljs-string">&quot;=values(&quot;</span>)<br>                    .append(x.getColumn())<br>                    .append(<span class="hljs-string">&quot;),&quot;</span>);<br>        &#125;);<br>        duplicateKeySql.delete(duplicateKeySql.length() - <span class="hljs-number">1</span>, duplicateKeySql.length());<br>        <span class="hljs-keyword">return</span> duplicateKeySql.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、sql-注入器"><a href="#3、sql-注入器" class="headerlink" title="3、sql 注入器"></a>3、sql 注入器</h4><p>自定义 sql 注入器继承默认的注入器，补充父类的方法，将刚刚自定义的实现方法添加到 methodList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomizedSqlInjector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultSqlInjector</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取super的methodList，添加自定义的method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;AbstractMethod&gt; <span class="hljs-title function_">getMethodList</span><span class="hljs-params">(Class&lt;?&gt; mapperClass, TableInfo tableInfo)</span> &#123;<br>        List&lt;AbstractMethod&gt; methodList = <span class="hljs-built_in">super</span>.getMethodList(mapperClass, tableInfo);<br>        methodList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">saveOrUpdateBatchMethod</span>());<br>        <span class="hljs-keyword">return</span> methodList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、补充配置"><a href="#4、补充配置" class="headerlink" title="4、补充配置"></a>4、补充配置</h4><p>一般用到 Mybatis-Plus 时都会创建一个 Config 配置类，添加分页插件等基础配置，在对应配置类中补充注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> GlobalConfig <span class="hljs-title function_">globalConfig</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">GlobalConfig</span> <span class="hljs-variable">globalConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlobalConfig</span>();<br>    <span class="hljs-keyword">return</span> globalConfig;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CustomizedSqlInjector <span class="hljs-title function_">customizedSqlInjector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizedSqlInjector</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、开启批操作"><a href="#5、开启批操作" class="headerlink" title="5、开启批操作"></a>5、开启批操作</h4><p>在项目配置的 MySQL 连接后面添加参数</p><ul><li><p><code>allowMultiQueries=true</code>：允许在 SQL 后添加分号，实现多语句在一个请求中执行，实现批处理</p></li><li><p><code>rewriteBatchedStatements=true</code>：可以理解为开启后会优化 JDBC 的解析 SQL 操作，原先单条单条执行的会合并操作。对于删除、更新会添加分号一次请求多个执行，对于插入会优化为 <code>VALUES (...),(...),(...);</code></p></li></ul><h4 id="6、修改并调用"><a href="#6、修改并调用" class="headerlink" title="6、修改并调用"></a>6、修改并调用</h4><p>修改待操作的 mapper，由原先的继承 BaseMapper 改为继承 BatchMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VehicleMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BatchMapper</span>&lt;VehicleCoordDO&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>修改调用代码，初始方法 <code>VehicleService.saveOrUpdate(list)</code> 调整为 <code>VehicleMapper.mysqlSaveOrUpdateBatch(list)</code>，通过日志查看执行的耗时是否优化了</p><p>自带的 <code>saveOrUpdateBatch()</code> 方法执行，批量提交，但是批次内还是单条执行，耗时4s</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230511163740993.png" alt="image-20230511163740993"></p><p>使用自定义的批量操作，形式和 <code>INSERT xxx VALUES (xxx),(xxx)</code> 一致，一条语句执行多个参数</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230511164158482.png" alt="image-20230511164158482"></p><h3 id="四、说明"><a href="#四、说明" class="headerlink" title="四、说明"></a>四、说明</h3><p>1、Mybatis-Plus 其实已经提供了一个拓展，里面的 <code>InsertBatchSomeColumn</code> 提供了批量插入的方法</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230511170953276.png" alt="image-20230511170953276" style="zoom:80%;" /><p>使用步骤和上面类似</p><ul><li>自定义一个注入器，在 methodList 中添加 <code>methodList.add(new InsertBatchSomeColumn());</code></li><li>在配置类中注入</li><li>修改Mapper的继承，调用</li></ul><p>2、对于自定义 saveBatch、updateBatch，操作步骤和上面一样，只是在具体实现部分有所不同，例如批量插入只需要 prepareFieldSql、prepareModelValueSql 这两部分的逻辑，sql 语句拼接也不需要 <code>ON DUPLICATE KEY UPDATE %s</code> 部分</p><blockquote><p> 其实上面的 批量插入或更新就是批量插入的特殊情况，即 MySQL 插入时指定策略为重复 key 更新</p></blockquote><p>具体的操作逻辑网上很多，可以搜索后套用一下</p><p>2、Mybatis-Plus 的 saveBatch、saveOrUpdateBatch 操作上已经进行了优化，一般情况是够用的。要注意 saveOrUpdate、saveOrUpdateBatch 方法，判断是 save 还是 update 的逻辑要用到表主键信息，表中有列名为 id 的、或者在实体类对于主键字段上添加了 @TableId 注解，才能被解析，不然会报错找不到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h3&gt;&lt;p&gt;项目中有个对接同步数据的需求，大致流程是对接其他平台后把需要的数据在代码中处理保存到本项目对应库中，ORM 框架产线统一用的</summary>
      
    
    
    
    <category term="Mybatis" scheme="https://61hhh-github-io.vercel.app/categories/Mybatis/"/>
    
    
    <category term="Mybatis" scheme="https://61hhh-github-io.vercel.app/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习三：持久化</title>
    <link href="https://61hhh-github-io.vercel.app/20211212/a4f2d1e9/"/>
    <id>https://61hhh-github-io.vercel.app/20211212/a4f2d1e9/</id>
    <published>2021-12-12T12:35:42.000Z</published>
    <updated>2024-05-10T07:25:44.157Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的是一个内存数据库，所有数据都存放在内存中，这也是它读写效率高的原因所在。不过相比于MySQL等关系型数据库将持久化，内存保存数据容易在断电宕机等情况下丢失数据，因此Redis提供了数据持久化功能，通过备份内存数据到本地、将备份文件恢复等实现持久化机制。</p><p>在学习Redis持久化之前，可以先大概学习一下配置文件，了解Redis的配置参数等。</p><h2 id="配置文件简述"><a href="#配置文件简述" class="headerlink" title="配置文件简述"></a>配置文件简述</h2><p>配置文件地址：在Redis的安装目录下，对应的<code>redis.conf</code>文件（Windows 名为 <code>redis.windows.conf</code>）</p><p><strong>Units单位</strong>：配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit。大小写不敏感</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211206215540244.png" alt="image-20211206215540244" style="zoom: 80%;" /><p><strong>INCLUDES包含</strong>：多实例的情况可以把公用的配置文件提取出来</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211206215658857.png" alt="image-20211206215658857" style="zoom: 80%;" /><p>相关配置如下表，更多详细配置可以在<code>redis.conf</code>文件中查看。</p><table><thead><tr><th align="center">配置项</th><th align="left">配置说明</th></tr></thead><tbody><tr><td align="center"><strong>网络相关</strong></td><td align="left"></td></tr><tr><td align="center"><code>port 6379</code></td><td align="left">指定redis监听端口，默认端口是6379</td></tr><tr><td align="center"><code>bind 127.0.0.1</code></td><td align="left">绑定的主机地址</td></tr><tr><td align="center"><code>timeout 300</code></td><td align="left">当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td></tr><tr><td align="center"><code>protect-mode</code></td><td align="left">将本机访问保护模式设置no</td></tr><tr><td align="center"><code>tcp-keeplive</code></td><td align="left">单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60</td></tr><tr><td align="center"><code>tcp-backlog</code></td><td align="left">设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和&#x3D;未完成三次握手队列 + 已经完成三次握手队列。<br/>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值<br/>来达到想要的效果</td></tr><tr><td align="center"><strong>通用项</strong></td><td align="left"></td></tr><tr><td align="center"><code>daemonize no</code></td><td align="left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td></tr><tr><td align="center"><code>pidfile /var/run/redis.pid</code></td><td align="left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 &#x2F;var&#x2F;run&#x2F;redis.pid 文件，可以通过 pidfile 指定</td></tr><tr><td align="center"><code>loglevel notice</code></td><td align="left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td></tr><tr><td align="center"><code>logfile stdout</code></td><td align="left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 &#x2F;dev&#x2F;null</td></tr><tr><td align="center"><code>database 16</code></td><td align="left">设定库的数量。默认16，默认数据库为0，可以使用SELECT命令在连接上指定数据库id</td></tr><tr><td align="center"><code>syslog-enabled</code></td><td align="left">是否把日志输出到syslog中</td></tr><tr><td align="center"><code>syslog-ident</code></td><td align="left">指定syslog的日志标识</td></tr><tr><td align="center"><code>syslog-facility</code></td><td align="left">指定syslog设备，值可以是User或者local</td></tr><tr><td align="center"><strong>SNAPSHOT快照</strong></td><td align="left"></td></tr><tr><td align="center"><code>save  &lt;seconds&gt;</code> <code> &lt;changes&gt;</code></td><td align="left"><code>save 900 1</code> <code>save 300 10</code> <code>save 60 10000</code>分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。<br/>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td></tr><tr><td align="center"><code>Stop-writes-on-bgsave-error</code></td><td align="left">如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制</td></tr><tr><td align="center"><code>rdbcompression yes</code></td><td align="left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td></tr><tr><td align="center"><code>rdbchecksum</code></td><td align="left">在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</td></tr><tr><td align="center"><code>dbfilename dump.rdb</code></td><td align="left">指定本地数据库文件名，默认值为 dump.rdb</td></tr><tr><td align="center"><code>dir ./</code></td><td align="left">指定本地数据库存放目录</td></tr><tr><td align="center"><strong>SECURITY安全</strong></td><td align="left"></td></tr><tr><td align="center"><code>config set/get requirepass  &quot;&lt;password&gt;&quot;</code></td><td align="left">设置&#x2F;获取密码</td></tr><tr><td align="center"><code>auth &quot;password&quot;</code></td><td align="left">密码校验</td></tr><tr><td align="center"><code>maxclients 128</code></td><td align="left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td></tr><tr><td align="center"><strong>APPEND ONLY MODE</strong></td><td align="left"></td></tr><tr><td align="center"><code>appendonly no</code></td><td align="left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td></tr><tr><td align="center"><code>appendfilename appendonly.aof</code></td><td align="left">指定更新日志文件名，默认为 appendonly.aof</td></tr><tr><td align="center"><code>appendfsync everysec</code></td><td align="left">指定更新日志条件，共有 3 个可选值：<br/>no：表示等操作系统进行数据缓存同步到磁盘（快）<br/>always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<br/>everysec：表示每秒同步一次（折中，默认值）</td></tr><tr><td align="center"><code>No-appendfsync-on-rewrite</code></td><td align="left">重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。</td></tr><tr><td align="center"><strong>VM</strong></td><td align="left"></td></tr><tr><td align="center"><code>vm-enabled no</code></td><td align="left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中</td></tr><tr><td align="center"><code>vm-swap-file /tmp/redis.swap</code></td><td align="left">虚拟内存文件路径，默认值为 &#x2F;tmp&#x2F;redis.swap，不可多个 Redis 实例共享</td></tr><tr><td align="center"><code>vm-max-memory 0</code></td><td align="left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td></tr><tr><td align="center"><code>vm-page-size 32</code></td><td align="left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td></tr><tr><td align="center"><code>vm-pages 134217728</code></td><td align="left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td></tr><tr><td align="center"><code>vm-max-threads 4</code></td><td align="left">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td></tr></tbody></table><p>Redis官网中介绍了Redis的两种持久化机制，如图所示</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208211519780.png" alt="image-20211208211519780" style="zoom:80%;" /><p>【Redis中文网的翻译如下】Redis 提供了不同级别的持久化方式</p><ul><li>RDB持久化方式能够在指定的时间间隔对你的数据进行快照存储.</li><li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</li><li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li><li>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li></ul><p>（后面的官网介绍就用Redis中文网的翻译版替代，便于理解）</p><h2 id="持久化之RDB"><a href="#持久化之RDB" class="headerlink" title="持久化之RDB"></a>持久化之RDB</h2><p>了解RDB具体内容之前，可以先看看官网的介绍</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208211537873.png" alt="image-20211208211537873" style="zoom:80%;" /><h3 id="RDB是什么"><a href="#RDB是什么" class="headerlink" title="RDB是什么"></a>RDB是什么</h3><p>RDB持久化方案是：<strong>在指定的时间间隔内将内存中的数据集快照写入磁盘(point-in-time)，即为Snapshot，恢复方式是将快照文件直接读到内存中</strong>。它以紧缩的二进制文件保存Redis数据库某一时刻所有数据对象的内存快照，可用于Redis的数据备份、转移与恢复。到目前为止，仍是官方的默认支持方案。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208234044320.png" alt="image-20211208234044320" style="zoom:80%;" /><h3 id="RDB工作原理"><a href="#RDB工作原理" class="headerlink" title="RDB工作原理"></a>RDB工作原理</h3><h4 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1.工作原理"></a>1.工作原理</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，先将数据写入到一个临时文件<code>dump.rdb</code>中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件（整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能）</p><p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h4 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">## Redis.conf：********************SNAPSHOT********************</span><br><span class="hljs-comment"># 时间策略</span><br><span class="hljs-string">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br><span class="hljs-string">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-string">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># 文件名称</span><br><span class="hljs-string">dbfilename</span> <span class="hljs-string">dump.rdb</span><br><br><span class="hljs-comment"># 文件保存路径</span><br><span class="hljs-string">dir</span> <span class="hljs-string">./</span><br><br><span class="hljs-comment"># 如果持久化出错，主进程是否停止写入</span><br><span class="hljs-string">stop-writes-on-bgsave-error</span> <span class="hljs-literal">yes</span><br><br><span class="hljs-comment"># 是否压缩</span><br><span class="hljs-string">rdbcompression</span> <span class="hljs-literal">yes</span><br><br><span class="hljs-comment"># 导入时是否检查</span><br><span class="hljs-string">rdbchecksum</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><ul><li>配置文件中持久化的策略为：<code>save &lt;seconds&gt;&lt;changes&gt;</code>，即在指定seconds内至少changs个key发生了改变，就会自动触发持久化；</li><li>RDB持久化的快照文件名称默认为<code>dump.rdb</code>；</li><li>快照文件默认存储在Redis启动时命令行所在的目录下；</li><li><code>stop-writes-on-bgsave-error</code>开启表示当Redis无法写入磁盘的话，直接关掉Redis的写操作。默认为yes；</li><li><code>rdbcompression</code>开启表示Redis会采用LZF算法对快照文件进行压缩存储；</li><li><code>rdbchecksum</code>开启表示Redis启用CRC64算法来进行数据校验</li></ul><h4 id="3-触发机制"><a href="#3-触发机制" class="headerlink" title="3.触发机制"></a>3.触发机制</h4><p>Redis的持久化触发方式有两种：指令主动触发、自动触发</p><ul><li><p>自动触发：满足配置文件中的<code>save &lt;seconds&gt;&lt;changes&gt;</code>规则时触发；主从复制时主节点发送rdb文件到从节点会触发；执行<code>debug reload</code>时会触发；shutdown时未开启aof会触发。【自动触发采用的是bgsave】</p></li><li><p>手动触发：通过手动输入指令实现。</p><ul><li><p><strong>save</strong>：执行save执行后，Redis会立刻启动持久化流程，由于Redis的请求处理是单线程模型，因此会阻塞其他所有服务。不建议线上使用。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208221452010.png" alt="image-20211208221452010" style="zoom:80%;" /></li><li><p><strong>bgsave</strong>：Redis会在后台异步进行快照操作，通过fork出子进程操作持久化，主线程同时可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间</p><p>【注】Redis的fork子进程操作会阻塞，如果频繁的执行备份或文件集较大fork耗时较长，都会影响Redis性能</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208221505183.png" alt="image-20211208221505183" style="zoom:80%;" /></li><li><p>执行flushall命令，也会产生dump.rdb文件。flushall用于清空Redis数据库所有数据，因此也会对dump.rdb等备份文件进行清空，最终得到的就是空的dump.rdb文件。</p></li></ul></li></ul><h3 id="RDB备份操作"><a href="#RDB备份操作" class="headerlink" title="RDB备份操作"></a>RDB备份操作</h3><p>1.首先设置自动备份策略<code>save 15 2</code>，15秒内有两次key的修改就自动备份。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208231357749.png" alt="image-20211208231357749" style="zoom: 80%;" /><p>2.通过<code>config get dir</code>获取rdb文件存储路径为<code>/etc/opt</code>，此时该路径下还没有dump.rdb文件</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208231546701.png" alt="image-20211208231546701" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208231525203.png" alt="image-20211208231525203" style="zoom:67%;" /><p>3.进入redis-cli，通过<code>set k v</code>指令在15秒内修改2个key，此时再看发现有文件了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208231639148.png" alt="image-20211208231639148" style="zoom:67%;" /><p>4.通过<code>shutdown</code>关闭Redis服务，将rdb文件拷贝到myconf目录并重命名dump_old.rdb，删除原来的dump.rdb文件，启动redis，此时<code>KEYS *</code>看到的时（empty array），原来的数据都没有了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208232640759.png" alt="image-20211208232640759" style="zoom:80%;" /><p>5.再次关闭Redis。将dump_old.rdb拷贝到<code>/etc/opt</code>目录下【此时会提示是否覆盖，因为shutdown未指定aof时会产生rdb文件】，启动Redis，此时就又可以看到之前的key了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208232921640.png" alt="image-20211208232921640" style="zoom:80%;" /><p>6.手动备份直接调用save或bgsave，就会在<code>/etc/opt</code>目录下生成dump.rdb文件。其他验证操作类似</p><p>7.动态停止RDB：<code>redis-cli config set save &quot;&quot;</code>#save后给空值，表示禁用保存策略</p><h3 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h3><p>RDB备份的优缺点官网文档已经给出</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>能够节省磁盘空间</li><li>恢复速度快</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改</li></ul><h2 id="持久化之AOF"><a href="#持久化之AOF" class="headerlink" title="持久化之AOF"></a>持久化之AOF</h2><p>同样可以先了解下官网文档对AOF的介绍</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208234508553.png" alt="image-20211208234508553" style="zoom:80%;" /><h3 id="AOF是什么"><a href="#AOF是什么" class="headerlink" title="AOF是什么"></a>AOF是什么</h3><p>上面的RDB是一种时间点策略的持久化，它比较适合数据备份和容灾恢复。但是它不能实时地进行数据持久化，而AOF就是对这个问题的补充。</p><p>AOF以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h3 id="AOF工作原理"><a href="#AOF工作原理" class="headerlink" title="AOF工作原理"></a>AOF工作原理</h3><h4 id="1-工作原理-1"><a href="#1-工作原理-1" class="headerlink" title="1.工作原理"></a>1.工作原理</h4><p>AOF是Redis的完全持久化策略，它通过记录所有引起Redis数据修改的指令集合，按顺序追加到文件中，然后重启时从头全部执行一遍，达到恢复关闭前的数据状态。因此将aof文件放到任何机器上，Redis都能按需执行指令恢复数据。</p><p>由于每一次的写操作都需要记录到文件中，因此AOF会对Redis的性能有一定影响</p><p>AOF的本质是利用Redis的通讯协议，将命令以纯文本形式写入到备份文件中。例如指令<code>set name leslie</code>执行，会在缓冲区追加文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">\r\n$3\r\nset\r\n$5\r\nname\r\n$5\r\nleslie\r\n<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">Redis协议</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">首先Redis是以行来划分，每行以\r\n行结束。每一行都有一个消息头，消息头共分为5种分别如下:</span><br>+#表示一个正确的状态信息，具体信息是当前行后面的字符。<br>-#表示一个错误信息，具体信息是当前行后面的字符。<br>*#表示消息体总共有多少行，不包括当前行,后面是具体的行数。<br><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-comment">#表示下一行数据长度，不包括换行符长度\r\n,后面则是对应的长度的数据。</span></span><br>:#表示返回一个数值，后面是相应的数字节符。<br></code></pre></td></tr></table></figure><p>（1）采用文本协议的原因</p><ol><li>文本协议具有很好的兼容性。</li><li>开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免二次处理开销。</li><li>文本协议具有可读性，方便直接修改和处理。</li></ol><p>（2）追加指令到缓冲区的原因</p><ol><li>Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，会带来很高的磁盘IO，影响整体性能；</li><li>Redis还可以通过提供不同的缓冲区同步策略，在性能和安全性方面做出平衡。</li></ol><h4 id="2-配置文件-1"><a href="#2-配置文件-1" class="headerlink" title="2.配置文件"></a>2.配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">是否开启aof</span><br>appendonly yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件名称</span><br>appendfilename &quot;appendonly.aof&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">同步方式</span><br>appendfsync everysec<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">aof重写期间是否同步</span><br>no-appendfsync-on-rewrite no<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重写触发配置</span><br>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载aof时如果有错如何处理</span><br>aof-load-truncated yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件重写策略</span><br>aof-rewrite-incremental-fsync yes<br></code></pre></td></tr></table></figure><ul><li>AOF默认是关闭的，通过修改配置中的<code>appendonly</code>为yes开启；</li><li>默认的备份文件名称是<code>appendonly.aof</code>；</li><li>同步方式有三种：always、everysec、no。一般采用everysec，顶多损失1s的数据；</li><li><code>no-appendfsync-on-rewrite</code>开启表示：在重写aof文件期间执行的写操作，不会写进aof文件而是写入缓存</li><li><code>auto-aof-rewrite-percentage</code>和<code>auto-aof-rewrite-min-size</code>设置了AOF文件重写的增长百分比或文件大小；</li><li><code>aof-load-truncated </code>开启表示：在加载时发现aof尾部不正确，会向客户端写入一个log，然后继续执行，如果设置为 <code>no</code> ，发现错误就会停止，必须修复后才能重新加载。</li></ul><h4 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3.工作流程"></a>3.工作流程</h4><p>AOF总体分为两个部分：将指令实时写入aof文件、读取aof文件重写数据。具体流程包括<strong>命令写入append</strong>、<strong>文件同步sysc</strong>、<strong>文件重写rewrite</strong>、<strong>重启加载load</strong>。</p><h5 id="3-1-命令写入"><a href="#3-1-命令写入" class="headerlink" title="3.1 命令写入"></a>3.1 命令写入</h5><p>Redis在启动AOF后，每执行一个写操作的指令，都会以协议格式将被执行的命令追加到Redis的AOF缓存区（aof_buf）末尾。这样的好处在于在大量写请求情况下，采用缓冲区暂存一部分命令随后根据策略一次性写入磁盘，这样可以减少磁盘的I&#x2F;O次数，提高性能。</p><p>【注】：如果命令append时正在进行重写，这些命令还会写入缓存区</p><h5 id="3-2-文件同步"><a href="#3-2-文件同步" class="headerlink" title="3.2 文件同步"></a>3.2 文件同步</h5><p>学习文件同步前，先了解Linux的<strong>系统调用write和fsync</strong></p><ul><li><p>write操作会触发<strong>延迟写（delayed write）机制</strong>——传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I&#x2F;O都通过缓冲进行。 当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者达到特定时间周期时， 再将该缓冲排到输出队列，然后待其到达队首时，才进行实际的I&#x2F;O操作。这种输出方式就被称为延迟写。</p><p>write操作通过延迟写减少了磁盘IO提高了性能。但是降低了aof文件内容更新的速度，在未达到缓冲区输出条件这段时间的数据都没有同步。如果此时系统发生故障，可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数为强制写入硬盘提供支持。</p></li><li><p>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞进程直到写入硬盘完成后返回，保证了数据持久化。</p></li></ul><p>Redis根据指定策略将缓冲区数据写入文件。Redis提供了三种同步策略，由配置参数<code>appendfsync</code>决定，下面是每个策略对应的含义：</p><ul><li>no：不使用fsync方法同步，而是交给操作系统write函数去执行同步操作，在linux操作系统中大约每30秒刷一次缓冲；</li><li>always：表示每次有写操作都调用fsync方法强制内核将数据写入到aof文件；</li><li>everysec：数据将使用调用操作系统write写入文件，并使用fsync每秒一次从内核刷新到磁盘。 这是折中的方案，最多丢失1S数据，兼顾性能和数据安全，所以Redis<strong>默认推荐使用该配置</strong>。</li></ul><h5 id="3-3-文件重写"><a href="#3-3-文件重写" class="headerlink" title="3.3 文件重写"></a>3.3 文件重写</h5><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集。</p><p>Redis会记录上次重写时的AOF大小，上面的配置文件有介绍，默认配置是当AOF文件大小是上次rewrite后大小的100%且文件大于64M时自动触发。也可以使用命令<code>bgrewriteaof</code>手动触发。</p><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size，如果Redis的AOF当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis会对AOF进行重写。 </p><p><strong>重写流程</strong></p><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename覆盖)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</p><p>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p><p>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p><p>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</p><p>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p><p>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211210002329960.png" alt="image-20211210002329960" style="zoom: 80%;" /><p><strong>重写举例</strong></p><p>Redis服务器通过AOF重写生成新的aof文件替代旧aof，新旧aof文件所对应的是相同的Redis数据状态。不过新的文件在指令上做了精简</p><p>启动Redis输入如下指令：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211210225414544.png" alt="重写实现" style="zoom:80%;" /><p>此时list中的数据状态：<code>[&quot;v0&quot;,&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;,&quot;v7&quot;,&quot;v8&quot;]</code>，旧的aof文件包括以上所有修改数据的指令。</p><p>如果要重写AOF达到和当前list相同的数据状态，最好的方法不是读取旧的aof文件，而是直接遍历当前Redis数据库中list键值，用：<code>RPUSH list v0 v1 v2 v3 v7 v8</code>一条指令实现相同的数据状态。</p><h5 id="3-4-重启加载"><a href="#3-4-重启加载" class="headerlink" title="3.4 重启加载"></a>3.4 重启加载</h5><p>当Redis服务关闭重启后，对于服务器上既有RDB又有AOF文件时，优先加载AOF文件</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211210003029035.png" alt="image-20211210003029035" style="zoom: 80%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实Redis官网的持久化介绍就是关于RDB和AOF的优缺点及使用推荐。</p><p>可以参考中文官网：<a href="http://www.redis.cn/topics/persistence.html">Redis 持久化</a>进行了解。</p><p>RDB快照、AOF重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，需要尽可能降低阻塞。比如降低fork频率、制定合理的内存分配策略、控制Redis的最大内存等</p><p>在具体实践时，可以自己制定策略，RDB和AOF结合使用，并定期检查Redis情况，然后手动备份、重写数据；单机部署多个实例时，需要注意防止福哦个机器同时持久化和重写，避免出现IO、内存的竞争，造成串行操作；也可以加入主从机器，一台备份一台响应请求等；</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844903655527677960">一文看懂Redis的持久化原理</a></li><li><a href="https://segmentfault.com/a/1190000039208726">Redis专题：万字长文详解持久化原理</a></li><li><a href="https://www.bilibili.com/video/BV1oW411u75R?p=18">尚硅谷Redis持久化</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis的是一个内存数据库，所有数据都存放在内存中，这也是它读写效率高的原因所在。不过相比于MySQL等关系型数据库将持久化，内存保存数据容易在断电宕机等情况下丢失数据，因此Redis提供了数据持久化功能，通过备份内存数据到本地、将备份文件恢复等实现持久化机制。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="数据库" scheme="https://61hhh-github-io.vercel.app/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://61hhh-github-io.vercel.app/tags/Redis/"/>
    
    <category term="NoSQL" scheme="https://61hhh-github-io.vercel.app/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习二：基本数据类型及操作</title>
    <link href="https://61hhh-github-io.vercel.app/20211206/7af3bdf0/"/>
    <id>https://61hhh-github-io.vercel.app/20211206/7af3bdf0/</id>
    <published>2021-12-06T01:37:34.000Z</published>
    <updated>2024-05-11T02:24:04.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><h3 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h3><p>Redis：Remote Dictionary Server（远程字典服务器）是一个开源免费的，用ANSI C语言编写的，遵守BSD协议的高性能（Key-Value）分布式内存数据库，基于内存运行，并支持持久化的NoSQL。</p><span id="more"></span><h3 id="Redis能干嘛"><a href="#Redis能干嘛" class="headerlink" title="Redis能干嘛"></a>Redis能干嘛</h3><p>redis是一种支持key-value等多种数据结构的存储系统，有点类似于Java的<code>Map&lt;key,Object&gt;</code>结构。可用于缓存，事件发布或订阅，高速队列等场景。</p><ol><li>缓存：Redis最主要的用法，能有效提升系统性能</li><li>排行榜：传统关系型数据库做排行很麻烦，Redis的ZSet很方便</li><li>计算器&#x2F;限速器：利用Redis中原子性的自增操作，同级用户的点赞、访问等数据，这类频繁读写的操作采用MySQL会对数据库带来很大的压力；限速器使用的典型场景为限制用户访问某个API的频率，比如出现抢购时，用户点击过多会限制访问，这样可以降低系统压力（限速器也是一种请求限流的实现方式）</li><li>好友关系：利用Redis的集合特点，通过求交集、并集、差集等获取共同爱好、共同好友等</li><li>简单消息队列：除了Redis自身的发布&#x2F;订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦</li><li>Session共享：默认Session是保存在服务器的文件中，即当前服务器，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息</li></ol><h2 id="安装测试Redis"><a href="#安装测试Redis" class="headerlink" title="安装测试Redis"></a>安装测试Redis</h2><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><p>网课给的安装包执行解压报错，因此自行安装。</p><ol><li><p>使用<code>wget http://download.redis.io/releases/redis-6.2.1.tar.gz</code>获取对应压缩包。</p></li><li><p>使用<code>tar -zxvf redis-6.2.1.tar.gz</code>解压，得到<code>redis-6.2.1</code>文件夹。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129221432662.png" alt="image-20211129221432662" style="zoom:80%;" /></li><li><p>使用<code>cd redis-6.2.1</code>进入安装目录，执行<code>make</code>指令编译。</p><ul><li><p>初次安装的虚拟机执行make会报错。是因为缺少GCC</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129221717318.png" alt="image-20211129221717318" style="zoom: 80%;" /></li><li><p>使用<code>yum install gcc-c++</code>指令安装GCC。报错：Jemalloc&#x2F;jemalloc.h：没有这个文件或目录</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129221924535.png" alt="image-20211129221924535" style="zoom: 80%;" /></li><li><p>使用<code>make distclean</code>后再次make即可。</p></li></ul></li><li><p>执行make后执行<code>make install</code>安装。</p></li><li><p>默认安装在<code>usr/local/bin</code>目录下</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129222334084.png" alt="image-20211129222334084" style="zoom: 80%;" /></li><li><p>启动测试一下</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129222550428.png" alt="image-20211129222550428" style="zoom:80%;" /></li></ol><p><strong>说明</strong></p><p>以上说明redis安装成功，不过还有一些需要修改的地方：比如刚才在<code>etc/opt/redis-6.2.1</code>目录下有个Redis.conf文件，这是Redis的配置文件，redis启动时默认按照此文件加载，后面的学习需要对此文件修改，所以可以先备份一下；现在启动Redis是前台启动的形式，启动后窗口不能执行其他操作，可以改为后台进行。</p><ol><li>在opt目录下<code>makedir myconf</code>创建myconf目录，将redis.conf复制到目录中。</li><li>修改myconf里面的配置文件，将daemonize no 改成 yes，让服务在后台启动。</li></ol><p>再次执行<code>redis-server /etc/opt/myconf/redis.conf</code>。此时服务可以启动，执行<code>redis-cli</code>启动客户端，执行ping验证连通性，得到pong即为redis启动成功。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129223723969.png" alt="image-20211129223723969" style="zoom:80%;" /><h3 id="Redis启动杂项"><a href="#Redis启动杂项" class="headerlink" title="Redis启动杂项"></a>Redis启动杂项</h3><ol><li><p>Redis默认端口是6379，可以通过配置文件修改端口。</p></li><li><p>Redis默认数据库有16个</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129224146572.png" alt="image-20211129224146572" style="zoom:80%;" /></li><li><p>select命令切换数据库，默认使用0号库</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129232543897.png" alt="image-20211129232543897" style="zoom:80%;" /></li><li><p>dbsize查看数据库的key数量</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129232703531.png" alt="image-20211129232703531" style="zoom:80%;" /></li><li><p>flushdb清空当前库、flushall清空所有库</p></li><li><p>统一密码管理：16个库都是用同样的密码</p></li><li><p><font color="red"><strong>redis高效原因：单线程＋多路复用技术</strong></font></p></li></ol><h4 id="Redis单线程"><a href="#Redis单线程" class="headerlink" title="Redis单线程"></a>Redis单线程</h4><p>Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。</p><p><strong>1.Redis不是完全单线程的</strong></p><p>Redis单线程是处理网络请求使用单个线程来处理：即一个线程处理所有网络请求，其他模块仍使用多线程。</p><p>以Redis持久化为例，RDB方式持久化即为fork一个子线程将数据写入临时文件中。</p><p><strong>2.Redis使用多路复用技术</strong></p><p>Redis对读写时间的响应是通过封装epoll<a href="Epoll%E6%98%AFLinux%E5%86%85%E6%A0%B8%E4%B8%BA%E5%A4%84%E7%90%86%E5%A4%A7%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%80%8C%E4%BD%9C%E4%BA%86%E6%94%B9%E8%BF%9B%E7%9A%84epoll%EF%BC%8C%E6%98%AFLinux%E4%B8%8B%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO%E6%8E%A5%E5%8F%A3select/poll%E7%9A%84%E5%A2%9E%E5%BC%BA%E7%89%88%E6%9C%AC%EF%BC%8C%E5%AE%83%E8%83%BD%E6%98%BE%E8%91%97%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%A4%A7%E9%87%8F%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%B0%91%E9%87%8F%E6%B4%BB%E8%B7%83%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E7%B3%BB%E7%BB%9FCPU%E5%88%A9%E7%94%A8%E7%8E%87%E3%80%82">^epoll</a>函数来实现的。Redis的实际处理速度完全依靠主进程的执行效率。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Redis-Multiplexing.gif"></p><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis的五大基本数据结构：</p><ul><li>字符串String：字符串是Redis最基本的类型，采用key-value形式。一个redis中字符串value最大为512M；</li><li>哈希Hash：hash是一个键值对集合，是一个string类型的field和value的映射表；</li><li>列表List：list是一个字符串列表，按照插入顺序排序。他的底层实现是链表；</li><li>集合Set：set是一个string类型的无序集合，通过HashTable实现；</li><li>有序集合Zset(Sorted set)：zset和set都是string类型的集合，不过zset中每个元素都会关联一个double类型的分数，redis通过这个分数危机和中的元素进行排序（zset的数据是唯一的，不过分数可以重复）</li></ul><p>有关Redis的常见数据类型操作指令，可以在<a href="http://redisdoc.com/Http://redisdoc.com/">Redis命令参考</a>中查看。</p><h3 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis Key"></a>Redis Key</h3><h4 id="1-结构"><a href="#1-结构" class="headerlink" title="1.结构"></a>1.结构</h4><p>对Redis来说，所有的Key都是字符串</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/redis-key.png" alt="redis-key" style="zoom:80%;" /><h4 id="2-常用指令"><a href="#2-常用指令" class="headerlink" title="2.常用指令"></a>2.常用指令</h4><table><thead><tr><th>命令</th><th>描述</th><th>使用</th></tr></thead><tbody><tr><td>keys</td><td>查看当前库的所有key</td><td>keys *</td></tr><tr><td>exist</td><td>判断某个key是否存在</td><td>exist key</td></tr><tr><td>type</td><td>查看key的类型</td><td>type key</td></tr><tr><td>del</td><td>删除指定key的数据</td><td>del key</td></tr><tr><td>unlink</td><td>根据value选择非阻塞删除</td><td>unlink key</td></tr><tr><td>expire</td><td>未指定key设置过期时间</td><td>expire key 10</td></tr><tr><td>ttl</td><td>查看还有多久过期</td><td>ttl key</td></tr></tbody></table><p>执行结果如下：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211202231612405.png" alt="image-20211202231612405" style="zoom:80%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">unlink</span>是非阻塞删除，即仅仅将数据从keyspace元数据中删除，真正的删除会在后续异步操作</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ttl key查看过期时间，-1表示永不过期，-2表示已过期</span><br></code></pre></td></tr></table></figure><p>注：几个查看redis库的指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">SELECT #切换数据库<br>DBSIZE #查看当前数据库key的数量<br>FLUSHDB #清空当前数据库<br>FLUSHALL #清空所有数据库<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211202232040962.png" alt="image-20211202232040962" style="zoom:80%;" /><h3 id="Redis-String"><a href="#Redis-String" class="headerlink" title="Redis String"></a>Redis String</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>String的数据结构为简单动态字符串（Simple Dynamic String，简写SDS）。是可修改的字符串，内部结构是线上类似于Java的ArrayList，采用预分配荣誉空间的方式来减少内少的频繁分配。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211204234129389.png" alt="image-20211204234129389" style="zoom:80%;" /><p>如图所示，内部为当前字符串实际分配的空间capacity，一般要高于实际字符串长度len。</p><p>当字符串长度小于1M，扩容方式是现有空间加倍；超过1M时，每次扩容只会增加1M空间。并且字符串的最大长度为512M</p><p>Redis的String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p><h4 id="2-常用指令-1"><a href="#2-常用指令-1" class="headerlink" title="2.常用指令"></a>2.常用指令</h4><table><thead><tr><th>命令</th><th>描述</th><th>使用</th></tr></thead><tbody><tr><td>SET</td><td>设置指定key的value</td><td>set key1 value1</td></tr><tr><td>GET</td><td>获取指定key的value</td><td>get key1</td></tr><tr><td>DEL</td><td>删除指定的key-value</td><td>del key1</td></tr><tr><td>INCR</td><td>将对应key的value加1</td><td>incr key1</td></tr><tr><td>DECR</td><td>将对应key的value减1</td><td>decr key1</td></tr><tr><td>INCRBY</td><td>将对应key的value加指定整数</td><td>incrby key1 count</td></tr><tr><td>DECRBY</td><td>将对应key的value减指定整数</td><td>decrby key1 count</td></tr></tbody></table><p>对string操作的指令执行结果如下（set、get、del上面已经演示）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">append key value     #在指定key的值后面追加value1，这里的追加是字符串拼接<br>strlen key  #获取指定key的长度<br>setnx  key value  #(set if not exist)只有在key不存在时才创建<br>setex  key time value #(set with expire)设置带过期时间的key-value<br>mset   K1 V1 K2 V2 ... Kn Vn#同时设置一个或多个key-value键值对<br>mget   K1 K2 .. Kn  #同时获取一个或多个给定key的值<br>msetnx K1 V1 K2 V2 ... Kn Vn#同时设置一个或多个key-value。当且仅当所有给定key都不存在时<br>getset key value #先将给定key值设置为value，返回key的旧值(old value)。即先get再set<br><br>incr、decr、incrby、decrby    <br><span class="hljs-meta prompt_">#</span><span class="language-bash">操作对象只能是数字。如果为空，新增值为1，减少值为-1；后两者自定义</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">对数值的增减操作是原子性的</span><br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211202232516451.png" alt="image-20211202232516451" style="zoom:80%;" /><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><ol><li>缓存：最经典最常用的场景。将一些常用的信息放在redis中，redis作为缓存层，MySQL作为持久层，达到降低MySQL的读写压力。</li><li>计数器：Redis的单线程模型保证了他一次只会执行一个命令的特点</li><li>session：采用Spring Session+Redis实现Session共享，一次登录多次使用。</li></ol><h3 id="Redis-List"><a href="#Redis-List" class="headerlink" title="Redis List"></a>Redis List</h3><h4 id="1-数据结构-1"><a href="#1-数据结构-1" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>List就是链表，Redis的List采用双端链表来实现，value可重复，类似于Java中的LinkedList。所以它的特性和链表相似：对两端的插入删除操作性能很好，但是通过索引定位查找的性能较差。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Redis-List.png" alt="Redis-List" style="zoom:80%;" /><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如一个列表里存储的是基本的int或string类型数据，结构上还需要两个额外的指针prev和next。</p><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><p>list的使用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">lpush/rpush  &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; .... # 从左边/右边插入一个或多个值。<br>lpop/rpop   &lt;key&gt;# 从左边/右边吐出一个值。值在键在，值光键亡。<br>rpoplpush   &lt;key1&gt;&lt;key2&gt;# 从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边。<br>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;# 按照索引下标获得元素(从左到右)<br>lrange list 0 -1   # 0左边第一个，-1右边第一个，（0-1表示获取所有）<br>lindex &lt;key&gt;&lt;index&gt;# 按照索引下标获得元素(从左到右)<br>llen   &lt;key&gt;# 获得列表长度 <br>linsert &lt;key&gt;  before &lt;value&gt;&lt;newvalue&gt;# 在&lt;value&gt;的后面插入&lt;newvalue&gt;插入值<br>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;# 从左边删除n个value(从左到右)<br>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;# 将列表key下标为index的值替换成value<br><br></code></pre></td></tr></table></figure><p>使用基础的LPUSH、RPUSH效果如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211205211524791.png" alt="image-20211205211524791" style="zoom: 80%;" /><p>可以利用list的链表本质实现一些基本数据结构。</p><ol><li>list实现队列：<strong>LPUSH+RPOP</strong>或<strong>RPUSH+LPOP</strong>；利用队列先进先出的特点，实现消息队列或异步处理等操作。</li><li>2.list实现栈：<strong>LPUSH+LPOP</strong>或<strong>RPUSH+RPOP</strong>；实现了栈先进后出的特点。</li></ol><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211205212523432.png" alt="image-20211205212523432" style="zoom: 80%;" /><h4 id="3-使用场景-1"><a href="#3-使用场景-1" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><p>list常见的场景有消息队列、时间轴、点赞评论的列表等</p><h3 id="Redis-Hash"><a href="#Redis-Hash" class="headerlink" title="Redis Hash"></a>Redis Hash</h3><p>Redis的Hash字典是一个kv键值对集合，同时v也是一个string类型的<code>field-value</code>映射表。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Redis-Hash.png" alt="Redis-Hash" style="zoom:80%;" /><h4 id="1-数据结构-2"><a href="#1-数据结构-2" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>Redis Hash类似于Java中的HashMap&lt;String,Object&gt;，内部实现上都是<strong>“数组+链表”</strong>的链地址法解决哈希冲突。</p><p>hash类型对应的数据结构是两种：ziplist(压缩链表)、hashtable(哈希表)；当<code>field-value</code>长度较短且个数较少时使用ziplist，否则使用hashtable</p><h4 id="2-常用命令-1"><a href="#2-常用命令-1" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><p>hash的常用指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">hset &lt;key&gt;&lt;field&gt;&lt;value&gt;# 给&lt;key&gt;集合中的&lt;field&gt;键赋值&lt;value&gt;<br>hget &lt;key1&gt;&lt;field&gt;# 通过&lt;key1&gt;集合的&lt;field&gt;取出对应value <br>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;... # 批量设置hash的值<br>hexists&lt;key1&gt;&lt;field&gt;# 查看哈希表key中，给定field是否存在。 <br>hkeys &lt;key&gt;# 列出该hash集合的所有field<br>hvals &lt;key&gt;# 列出该hash集合的所有value<br>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;# 为哈希表 key 中的 field 的值加上增量 1、-1<br>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;# 将哈希表 key 中的 field 的值设置为 value，当且仅当域 field 不存在 .<br><br></code></pre></td></tr></table></figure><p>使用效果如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211205215743109.png" alt="image-20211205215743109" style="zoom: 80%;" /><h4 id="3-使用场景-2"><a href="#3-使用场景-2" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><p>更丰富的缓存：相比string存储字符串，hash可以存储object，可以用来存储用户信息、订单信息等</p><h3 id="Redis-Set"><a href="#Redis-Set" class="headerlink" title="Redis Set"></a>Redis Set</h3><p>Set和List都是单key多value，不过set里面的value不允许重复；集合中的元素是无序的，不能通过下表获取元素；set可以利用集合特性实现相关操作，如取交集、并集等。Redis Set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Redis-set.png" alt="Redis-set" style="zoom:80%;" /><h4 id="1-数据结构-3"><a href="#1-数据结构-3" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>Redis的Set是string类型的无序集合(dict字典)。它底层其实是一个value为null的hash表，所以添加，删除，查找的**复杂度都是O(1)**。</p><p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><h4 id="2-常用命令-2"><a href="#2-常用命令-2" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><p>Set的常用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</span><br>smembers &lt;key&gt;# 取出该集合的所有值。<br>sismember &lt;key&gt;&lt;value&gt;# 判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0<br>scard&lt;key&gt;# 返回该集合的元素个数。<br>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .... # 删除集合中的某个元素。<br>spop &lt;key&gt;# 随机从该集合中吐出一个值。<br>srandmember &lt;key&gt;&lt;n&gt;# 随机从该集合中取出n个值。不会从集合中删除 。<br>smove &lt;source&gt;&lt;destination&gt;value# 把集合中一个值从一个集合移动到另一个集合<br>sinter &lt;key1&gt;&lt;key2&gt;# 返回两个集合的交集元素。<br>sunion &lt;key1&gt;&lt;key2&gt;# 返回两个集合的并集元素。<br>sdiff &lt;key1&gt;&lt;key2&gt;# 返回两个集合的差集元素(key1中的，不包含key2中的)<br><br></code></pre></td></tr></table></figure><p>使用效果如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211205221127567.png" alt="image-20211205221127567" style="zoom: 80%;" /><h4 id="3-使用场景-3"><a href="#3-使用场景-3" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><ol><li>标签（tag）：给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li><li>点赞，或点踩，收藏等，可以放到set中实现。</li></ol><h3 id="Redis-Zset"><a href="#Redis-Zset" class="headerlink" title="Redis Zset"></a>Redis Zset</h3><p>Zset在Set的基础上，为每个成员增加了一个评分score，通过按score由低到高给集合中的元素排序。集合中成员是唯一的，而score是可以重复的。</p><p>由于元素有序，所以可以根据评分score和次序position来快速获取一个区间的元素。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Redis-Zset.png" alt="Redis-Zset" style="zoom:80%;" /><h4 id="1-数据结构-4"><a href="#1-数据结构-4" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><p>zset底层使用了两个数据结构：</p><ol><li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li><li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li></ol><h4 id="2-常用命令-3"><a href="#2-常用命令-3" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><p>Zset常用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">zadd  &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</span><br>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;  [WITHSCORES]   <br><span class="hljs-meta prompt_"># </span><span class="language-bash">返回有序集 key 中，下标在&lt;start&gt;&lt;stop&gt;之间的元素   带WITHSCORES，可以让分数一起和值返回到结果集。</span><br>zrangebyscore key min max [withscores] [limit offset count]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">返回有序集 key 中，所有 score 值介于[min,max]的成员。有序集成员按 score 值递增(从小到大)次序排列。</span> <br>zrevrangebyscore key maxmin [withscores] [limit offset count]               <br><span class="hljs-meta prompt_"># </span><span class="language-bash">同上，改为从大到小排列。</span> <br>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;     # 为元素的score加上增量<br>zrem  &lt;key&gt;&lt;value&gt;# 删除该集合下，指定值的元素 <br>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;# 统计该集合，分数区间内的元素个数 <br>zrank &lt;key&gt;&lt;value&gt;# 返回该值在集合中的排名，从0开始。<br><br></code></pre></td></tr></table></figure><p>使用效果如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211205225104267.png" alt="image-20211205225104267" style="zoom:80%;" /><h4 id="3-使用场景-4"><a href="#3-使用场景-4" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><p>比较常用的就是排行榜。比如文章阅读量热榜、商品销量热榜等实现。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h2&gt;&lt;h3 id=&quot;Redis是什么&quot;&gt;&lt;a href=&quot;#Redis是什么&quot; class=&quot;headerlink&quot; title=&quot;Redis是什么&quot;&gt;&lt;/a&gt;Redis是什么&lt;/h3&gt;&lt;p&gt;Redis：Remote Dictionary Server（远程字典服务器）是一个开源免费的，用ANSI C语言编写的，遵守BSD协议的高性能（Key-Value）分布式内存数据库，基于内存运行，并支持持久化的NoSQL。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://61hhh-github-io.vercel.app/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://61hhh-github-io.vercel.app/tags/Redis/"/>
    
    <category term="NoSQL" scheme="https://61hhh-github-io.vercel.app/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis学习一：NoSQL学习</title>
    <link href="https://61hhh-github-io.vercel.app/20211128/57551b57/"/>
    <id>https://61hhh-github-io.vercel.app/20211128/57551b57/</id>
    <published>2021-11-27T16:04:16.000Z</published>
    <updated>2024-05-10T07:25:34.061Z</updated>
    
    <content type="html"><![CDATA[<p>作为目前最知名也是最流行的开源NoSQL数据库，Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库。因此Redis的学习很有必要。主要通过B站尚硅谷网课和配套资料免费学习。</p><ul><li>网课参考：<a href="https://www.bilibili.com/video/BV1Rv41177Af">Redis 6 入门到精通 超详细 教程</a>、<a href="https://www.bilibili.com/video/BV1oW411u75R">尚硅谷超经典Redis教程,redis实战,阳哥版从入门到精通</a></li><li>笔记参考：<a href="https://blog.csdn.net/u011863024/article/details/107476187">Redis学习笔记</a></li></ul><h2 id="NoSQL入门概述-上"><a href="#NoSQL入门概述-上" class="headerlink" title="NoSQL入门概述-上"></a>NoSQL入门概述-上</h2><h3 id="1-为什么用NoSQL"><a href="#1-为什么用NoSQL" class="headerlink" title="1 为什么用NoSQL"></a>1 为什么用NoSQL</h3><p>在介绍NoSQL之前，先介绍一下应用中的SQL发展，从单机的MySQL到分库分表+缓存到集群等等，随着移动应用发展，网站程序访问量不断激增，所以对应用的数据库要求也在不断增加。</p><p><strong>1.单机MySQL的美好年代</strong></p><p>在90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。在那个时候，更多的都是静态网页，动态交互类型的网站不多。（我们在学校做的应用基本上都是采用简单的单机MySQL）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211117221900849.png" alt="image-20211117221900849" style="zoom:80%;" /><blockquote><p>DAL dal是数据访问层的英文缩写，即为数据访问层（Data Access Layer）</p></blockquote><p>上述架构下，我们来看看数据存储的瓶颈是什么?</p><ol><li>数据量的总大小一个机器放不下时</li><li>数据的索引(B+ Tree)一个机器的内存放不下时</li><li>访问量(读写混合)一个实例不能承受</li></ol><p>如果满足了上述1or3个，进化…</p><p><strong>2.Memcached(缓存)+MySQL+垂直拆分</strong></p><p>后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web程序不再仅仅专注在功能上，同时也在追求性能。</p><p>程序员们开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211117222128588.png" alt="image-20211117222128588" style="zoom:80%;" /><p><strong>3.Mysql主从读写分离</strong></p><p>由于数据库的写入压力增加，Memcached 只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211117222205901.png" alt="image-20211117222205901" style="zoom:80%;" /><p><strong>4.分表分库+水平拆分+mysql集群</strong></p><p>在Memcached的高速缓存，MySQL的主从复制， 读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。</p><p>同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="分库：将业务相关的、频繁性的数据分在同一个数据库，将一些趋于冷的数据（如用户的名字、身份证号码等变化很少的数据）放在另外的一个库中。分表：对于复杂业务产生的大量数据，例如产生了100w条数据，放在同一个表中肯定会很慢，换个方式0-25、25-50、50-75、75-100四个分区，可以达到将数据的压力差分的目的。">[2]</span></a></sup>成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211117222231999.png" alt="image-20211117222231999" style="zoom:80%;" /><p><strong>5.MySQL的扩展性瓶颈</strong></p><p>MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小， 如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差(需要复杂的技术来实现)，大数据下IO压力大，表结构更改困难，正是当前使用MySOL的开发人员面临的问题。</p><p><strong>6.今天是什么样子? ?</strong></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211117222301900.png" alt="image-20211117222301900" style="zoom:80%;" /><p><strong>7.为什么用NoSQL</strong></p><p>传统的RDBMS使用SQL语法来存储和查询数据。相反，NoSQL数据库系统包含可存储结构化，半结构化，非结构化和多态数据的多种数据库技术。</p><img src="C:\Users\cestc\AppData\Roaming\Typora\typora-user-images\image-20211120213943790.png" alt="image-20211120213943790" style="zoom:67%;" /><p>NoSQL数据库的概念在处理大量数据的互联网巨头（例如Google，Facebook，Amazon等）中变得很流行。使用RDBMS处理海量数据时，系统响应时间变慢。</p><p>为了解决此问题，当然可以通过升级现有硬件来“横向扩展”我们的系统。但这个成本很高。这个问题的替代方案是在负载增加时将数据库负载分配到多个主机上。这种方法称为“横向扩展”。传统的SQL数据库已经不适合这些应用了，NoSQL数据库的发展也却能很好的处理这些大的数据。</p><h3 id="2-NoSQL是什么"><a href="#2-NoSQL是什么" class="headerlink" title="2 NoSQL是什么"></a>2 NoSQL是什么</h3><p>NoSQL，最初被称作Non-SQL<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="NoSQL 定义：下一代数据库主要解决一些问题：非关系、分布式、开源和水平可扩展”。">[1]</span></a></sup>；后来也称作Not Only SQL，意即“不仅仅是SQL”，泛指非关系型的数据库。是一种非关系型DMS，不需要固定的架构，可以避免joins链接，并且易于扩展。</p><p>NoSQL数据库可以用于具有庞大数据存储需求的分布式数据存储、大数据和实时SNS类型的Web应用程序。例如，像Twitter，Facebook，Google这样的大型公司，每天可能产生TB级的用户数据，这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p><h3 id="3-NoSQL特点"><a href="#3-NoSQL特点" class="headerlink" title="3 NoSQL特点"></a>3 NoSQL特点</h3><h4 id="易扩展"><a href="#易扩展" class="headerlink" title="易扩展"></a>易扩展</h4><p>例如MySQL，出于业务需求需要拓展对象的属性时，是通过alter table添加字段，但是这是有限的，且数据库的字段类型也是有限的。并且对于社会关系等比较复杂的关系，可能需要用图、树等结构来描述，采用SQL难于拓展</p><p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。（以常见的k-v键值对为例，key可以是数字、字符等等，value可以是字符串、对象、对象数组等等）</p><h4 id="大数据量高性能"><a href="#大数据量高性能" class="headerlink" title="大数据量高性能"></a>大数据量高性能</h4><p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。</p><h4 id="多样灵活的数据模型"><a href="#多样灵活的数据模型" class="headerlink" title="多样灵活的数据模型"></a>多样灵活的数据模型</h4><p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的Web 2.0时代尤其明显。</p><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>NoSQL在不太影响性能的情况，就可以方便地实现高可用的架构。比如Cassandra、HBase模型，通过复制模型也能实现高可用</p><h4 id="传统RDBMS-VS-NOSQL"><a href="#传统RDBMS-VS-NOSQL" class="headerlink" title="传统RDBMS VS NOSQL"></a>传统RDBMS VS NOSQL</h4><p><strong>RDBMS</strong></p><ul><li>高度组织化结构化数据</li><li>结构化查询语言(SQL)</li><li>数据和关系都存储在单独的表中</li><li>数据操纵语言，数据定义语言</li><li>严格的一致性</li><li>基础事务</li></ul><p><strong>NoSQL</strong></p><ul><li>代表着不仅仅是SQL</li><li>没有声明性查询语言</li><li>没有预定义的模式</li><li>键-值对存储，列存储，文档存储，图形数据库</li><li>最终一致性，而非ACID属性</li><li>非结构化和不可预知的数据</li><li>CAP定理</li><li>高性能，高可用性和可伸缩性</li></ul><h3 id="4-NoSQL的应用"><a href="#4-NoSQL的应用" class="headerlink" title="4.NoSQL的应用"></a>4.NoSQL的应用</h3><ul><li>K-V：键值对存储</li><li>Cache：缓存</li><li>Persistence：数据持久化</li></ul><h2 id="NoSQL入门概述-下"><a href="#NoSQL入门概述-下" class="headerlink" title="NoSQL入门概述-下"></a>NoSQL入门概述-下</h2><p>以腾讯微信、阿里淘宝为例：在节假日活动时会产生海量的用户数据；数据的种类肯定也是多样的，不是仅仅在数据库中表现的varchar、int等简单类型；双十一、春节车票抢购都是对数据的实时性有非常高的要求。对应于应用发展带来的数据3v，需求架构上也产生了三高。</p><table><thead><tr><th>大数据时代的3V</th><th>互联网需求的3高</th></tr></thead><tbody><tr><td>海量Volume</td><td>高并发</td></tr><tr><td>多样Variety</td><td>高可扩</td></tr><tr><td>实时Velocity</td><td>高性能</td></tr></tbody></table><h3 id="当下NoSQL应用场景简介"><a href="#当下NoSQL应用场景简介" class="headerlink" title="当下NoSQL应用场景简介"></a>当下NoSQL应用场景简介</h3><p><strong>SQL和NoSQL双剑合璧：</strong>以阿里巴巴为例，通过分析Alibaba中文站商品信息如何存放，看看阿里巴巴中文网站首页以女装&#x2F;女包包为例</p><h4 id="架构发展历程"><a href="#架构发展历程" class="headerlink" title="架构发展历程"></a>架构发展历程</h4><ol><li><p>演变过程</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420224124725.png" alt="image-20230420224124725" style="zoom: 67%;" /></li><li><p>第5代</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420224143458.png" alt="image-20230420224143458" style="zoom:67%;" /></li><li><p>第5代架构使命</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420224154563.png" alt="image-20230420224154563" style="zoom:67%;" /></li></ol><p><strong>和我们相关的，多数据源类型的存储问题</strong></p><p>例如一个购物网站的商品页面，会包含商品的基本信息、详情、销量、用户的评价（文字图片视频）、点赞点踩等等不同类型的信息，且信息的存放往往会采用不同的数据源。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420224210584.png" alt="image-20230420224210584" style="zoom:67%;" /><h4 id="阿里商品描述"><a href="#阿里商品描述" class="headerlink" title="阿里商品描述"></a>阿里商品描述</h4><p><strong>什么是IOE，为什么去IOE化</strong></p><p>I：IBM的小型机、O：Oracle的数据库、E：EMC的高端存储。这三者在金融证券电信保险等企业有着巨大的份额，许多传统企业都是采用它们的产品，导致技术上有着严重依赖，对于公司的发展提升有着很大的弊病。</p><p>去IOE化，其本意是，在阿里巴巴的IT架构中，去掉IBM的小型机、Oracle数据库、EMC存储设备，代之以自己在开源软件基础上开发的系统。借此保证企业良好的技术提升</p><table><thead><tr><th>类型</th><th>内容及存储方式</th></tr></thead><tbody><tr><td>商品基本信息</td><td>名称、价格，出厂日期，生产厂商等趋于不变的数据<br/>关系型数据库。如MySQL</td></tr><tr><td>商品描述、详情、评价信息(多文字类)</td><td>多文字信息描述类，IO读写性能变差<br/>文档数据库MongDB</td></tr><tr><td>商品的图片</td><td>商品图片展现类。<br/>分布式的文件系统，如TFS、GTF、HDFS</td></tr><tr><td>商品的关键字</td><td>淘宝自研的ISearch</td></tr><tr><td>商品的波段性的热点高频信息</td><td>内存数据库；Tair、Redis、Memcache</td></tr><tr><td>商品的交易、价格计算、积分累计</td><td>外部系统，外部第3方支付接口<br/>支付宝</td></tr></tbody></table><h2 id="NoSQL数据模型简介"><a href="#NoSQL数据模型简介" class="headerlink" title="NoSQL数据模型简介"></a>NoSQL数据模型简介</h2><p>以一个电商客户、订单、订购、地址模型来对比关系型数据库和非关系型数据库</p><p>传统关系型数据库如何设计：先画E-R图，描述模型关联，再根据E-R设计表结构。常见的关联有1:1、1:n、n:n等。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211127215531125.png" alt="image-20211127215531125" style="zoom: 67%;" /><p>NOSQL如何设计：以BSON为例，采用Json结构来表述数据的存储方式，k-v形式可以实现对象的存储。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211127215642374.png" alt="image-20211127215642374" style="zoom: 67%;" /><p><strong>为什么用聚合模型来处理</strong><br>高并发的操作是不太建议用关联查询的，互联网公司用冗余数据来避免关联查询；分布式事务是支持不了太多的并发的</p><h4 id="NoSQL数据库四大分类"><a href="#NoSQL数据库四大分类" class="headerlink" title="NoSQL数据库四大分类"></a>NoSQL数据库四大分类</h4><ol><li><p>常见的K-V键值对：【新浪：BerkeleyDB+redis】、【美团：redis+tair】、【阿里、百度：memcache+redis】</p></li><li><p>文档型数据库：Bson格式为主，【CouchDB】、【MongoDB(一个基于分布式文件存储的数据库)】</p></li><li><p>列族：顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，<br>对针对某一列或者某几列的查询有非常大的IO优势。【Cassandra】、【HBase】、【分布式文件系统】</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211127215851351.png" alt="image-20211127215851351" style="zoom:67%;" /></li><li><p>图形：图关联结构，存放的不是图片数据，而是用来表示存在复杂关系的数据，社交网络、推荐系统等应用较多。【Neo4J】、【InfoGrid】</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211127215940739.png" alt="image-20211127215940739" style="zoom:67%;" /></li></ol><h4 id="四者对比"><a href="#四者对比" class="headerlink" title="四者对比"></a>四者对比</h4><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420224302502.png" alt="image-20230420224302502" style="zoom:80%;" /><h2 id="分布式数据库CAP原理"><a href="#分布式数据库CAP原理" class="headerlink" title="分布式数据库CAP原理"></a><font color="red">分布式数据库CAP原理</font></h2><h3 id="CAP原理简介"><a href="#CAP原理简介" class="headerlink" title="CAP原理简介"></a>CAP原理简介</h3><p> 介绍分布式数据库的CAP原理之前，可以先回顾一下SQL数据库的ACID特性</p><ul><li><strong>A (Atomicity) 原子性</strong>：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成。</li><li><strong>C (Consistency) 一致性</strong>：执行事务前后，数据库的完整性没有被破坏，数据能保持一致。</li><li><strong>I (Isolation) 独立性</strong>：数据库允许多个事务进行数据操作，通过隔离性防止多个事务并发执行出现的数据不一致</li><li><strong>D (Durability) 持久性</strong>：事务对数据的修改是永久的。</li></ul><p>分布式数据库的CAP原理：<font color="red">对于分布式计算系统来说，不可能同时满足以下三点</font></p><ul><li><strong>C:Consistency（强一致性）</strong>：分布式系统中的所有数据备份，在同一时刻保持同样的值。（等同于所有节点访问同一份最新的数据副本）</li><li><strong>A:Availability（可用性）</strong>：保证每个请求都能获得非错的响应，但不保证响应的是最新的数据。</li><li><strong>P:Partition tolerance（分区容忍性）</strong>：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211127224409622.png" alt="image-20211127224409622" style="zoom: 75%;" /><h3 id="CAP的三进二"><a href="#CAP的三进二" class="headerlink" title="CAP的三进二"></a>CAP的三进二</h3><h4 id="CA（一致性-可用性）"><a href="#CA（一致性-可用性）" class="headerlink" title="CA（一致性+可用性）"></a>CA（一致性+可用性）</h4><p>即放弃系统的拓展性，传统的单点关系型数据库或类似架构的非分布式数据库，不存在网络分区问题。</p><p>比如MySQL、Oracle等传统数据库</p><h4 id="CP（一致性-容错性）"><a href="#CP（一致性-容错性）" class="headerlink" title="CP（一致性+容错性）"></a>CP（一致性+容错性）</h4><p>相当于每个请求都需要在服务器之间保持强一致性。当分区间的数据出现不一致（出现网络故障等情况），必须停止旧数据的服务，直到数据同步完成，这势必会牺牲用户的体验。</p><p>典型的比如Redis、HBase，数据的一致性是基本要求，发生特殊情况优先保证数据的强一致性</p><h4 id="AP（可用性-容错性）"><a href="#AP（可用性-容错性）" class="headerlink" title="AP（可用性+容错性）"></a>AP（可用性+容错性）</h4><p>仍然允许所有客户端读写，但是两个数据中心之间不再同步，它们的数据就会逐渐地变得不同，即牺牲一致性，保证可用性。</p><p>AP的应用场景也很多，比如12306抢票，浏览时看到还有票（可能已经没票了），点进去下单提示没票了，购买失败。这就是在数据一致性上做出牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。</p><p>但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是强一致性。退而求其次保证了最终一致性。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。</p><h3 id="BASE定理"><a href="#BASE定理" class="headerlink" title="BASE定理"></a>BASE定理</h3><p>BASE是<strong>Basically Available（基本可用）</strong>、<strong>Soft state（软状态）</strong>和<strong>Eventually consistent（最终一致性）</strong>三个短语的简写。</p><p>BASE是对CAP中一致性C和可用性A权衡的结果，来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是：<font color="red"><strong>让系统放松对某一时刻数据的强一致性要求（Strong Consistency），来换取西戎整体的伸缩性和性能上的改观，结合自身业务特点，通过适当设计保证系统达到最终一致性（Eventual Consistency）</strong></font>。</p><h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>什么是基本可用？它是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，参考例子：</p><ul><li><strong>响应时间上的损失</strong>：正常情况下一个搜索引擎0.5秒即返回给用户结果，现在出现了异常，查询的相应时间可能变成1-2秒。</li><li><strong>功能上的损失</strong>：日常购物时用户在网上买东西可以按流程顺利完成订单，但是在像双十一这种高峰期，用户访问量剧增，为了保证稳定，部分用户可能会被引导到降级页面。</li></ul><h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p><p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p><h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>软状态不能一直存在，必须有一个期限，在这段时间内可以允许数据延时，但是期限过后所有数据要达到一致状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><p>亚马逊首席技术官Werner Vogels在于2008年发表的一篇文章中对最终一致性进行了非常详细的介绍，他认为最终一致性是一种特殊的弱一致性：系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致状态，因此所有客户端对系统的数据访问都能够获取到最新的值。同时，在没有发生故障的前提下，数据达到一致状态的时间延迟，取决于网络延迟，系统负载和数据复制方案设计等因素。</p><ul><li>因果一致性（Causal consistency）</li><li>读己之所写（Read your writes）</li><li>会话一致性（Session consistency）</li><li>单调读一致性（Monotonic read consistency）</li><li>单调写一致性（Monotonic write consistency）</li></ul><p>实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p><p>总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/u011863024/article/details/107476187">Redis学习笔记</a></li><li><a href="https://mongoing.com/archives/docs/mongodb%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%99%E7%A8%8B/nosql%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BA%86%E8%A7%A3nosql%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%90%AB%E4%B9%89%EF%BC%8C%E4%BC%98%E5%8A%BF">NoSQL教程：了解NoSQL的功能，类型，含义，优势</a></li><li><a href="https://juejin.cn/post/6844903621495095304">分布式理论(二) - BASE理论</a></li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>NoSQL 定义：下一代数据库主要解决一些问题：非关系、分布式、开源和水平可扩展”。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>分库：将业务相关的、频繁性的数据分在同一个数据库，将一些趋于冷的数据（如用户的名字、身份证号码等变化很少的数据）放在另外的一个库中。分表：对于复杂业务产生的大量数据，例如产生了100w条数据，放在同一个表中肯定会很慢，换个方式0-25、25-50、50-75、75-100四个分区，可以达到将数据的压力差分的目的。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为目前最知名也是最流行的开源NoSQL数据库，Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库。因此Redis的学习很有必要。主要通过B站尚硅谷网课和配套资料免费学习。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://61hhh-github-io.vercel.app/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://61hhh-github-io.vercel.app/tags/Redis/"/>
    
    <category term="NoSQL" scheme="https://61hhh-github-io.vercel.app/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux安装(CentOS)</title>
    <link href="https://61hhh-github-io.vercel.app/20211126/e0a94a43/"/>
    <id>https://61hhh-github-io.vercel.app/20211126/e0a94a43/</id>
    <published>2021-11-26T05:56:36.000Z</published>
    <updated>2024-05-11T02:14:54.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、安装vmware"><a href="#1、安装vmware" class="headerlink" title="1、安装vmware"></a>1、安装vmware</h2><p>直接在官网下载 <code>VMware workstation 15</code> 需要登陆账号，可以在官网链接</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>download3.vmware.com<span class="hljs-regexp">/software/</span>wkst<span class="hljs-regexp">/file/</span>VMware-workstation-full-<span class="hljs-number">15.5</span>.<span class="hljs-number">7</span>-<span class="hljs-number">17171714</span>.exe<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230523862.png" alt="image-20230420230523862" style="zoom:80%;" /><p>按照图中的名称替换，下载对应的版本，然后正常安装即可，激活码直接网上搜就可以。</p><p>电脑的虚拟化技术需要开启不然启动会报错，进入对应主板的 bios 中，在 <code>ADVANCE</code> 中找到 <code>CPU Configuration</code> 修改 <code>Intel(VMX) Virtualization Technology</code> 为 <code>Enable</code> 即可。</p><h2 id="2、安装CentOS"><a href="#2、安装CentOS" class="headerlink" title="2、安装CentOS"></a>2、安装CentOS</h2><p>参考<a href="https://mp.weixin.qq.com/s/onVwwEQ1DAwbvK7qS2YNxg">人手一套Linux环境之：Windows版本教程</a> 的操作安装 CentOS 环境</p><h3 id="1-下载镜像"><a href="#1-下载镜像" class="headerlink" title="1. 下载镜像"></a>1. 下载镜像</h3><p>可以在中国的镜像网站上下载，给两个示例：<a href="http://mirrors.aliyun.com/centos/">阿里云镜像</a>、<a href="https://mirrors.huaweicloud.com/home">华为云镜像</a></p><p>先下载CentOS 7的镜像文件，建议下载7(不带后缀)，不要下载7.x【8之前的CentOS除了7其他都不再维护了】</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124223025492.png" alt="image-20211124223025492" style="zoom: 80%;" /><p>在 VMware 中新建虚拟机</p><ol><li><p>安装选择自定义(高级)</p></li><li><p>选择稍后安装操作系统（后面选择之前下载的 <code>.iso</code> 镜像文件）</p></li><li><p>命名并选择虚拟机位置，按需分配</p></li><li><p>网络选择NAT、磁盘选择分成一个</p></li><li><p>其他全部默认即可。移除USB控制器、打印机、声卡（基本用不上）</p></li></ol><h3 id="2-安装系统"><a href="#2-安装系统" class="headerlink" title="2. 安装系统"></a>2. 安装系统</h3><p>启动虚拟机后如图进行CentOS配置。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124224147583.png" alt="image-20211124224147583" style="zoom: 67%;" /><ul><li>系统时间、键盘、语言默认英文。看着比较直观</li><li>软件安装选择本地文件、最小化安装（后面再安装图形化界面）</li><li>分区自动选择、网络连接暂不开启</li><li>点击开始安装后，在上面配置 ROOT 密码、创建一个用户配置用户名密码</li></ul><h4 id="配置静态IP"><a href="#配置静态IP" class="headerlink" title="配置静态IP"></a>配置静态IP</h4><ul><li><p>在 VMWare的编辑中找到虚拟网络编辑器，选择 VMnet8，修改参数</p><p>选择 NAT 模式、不勾选本地DHCP分配IP地址、设值子网IP段 <code>192.168.61.0</code> 和子网掩码 <code>255.255.255.0</code>（记住此时的子网IP）</p><p>在NAT设值中配置网关IP <code>192.168.61.2</code>，网关IP不能和宿主机中配置的一致（记住网关IP）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230508299.png" alt="image-20230420230508299" style="zoom:80%;" /></li><li><p>点击应用-确定后保存退出，在控制面板的网络适配器中配置宿主机 VMnet8 的 IPv4 属性并保存</p><p>IP：<code>192.168.61.1</code>、子网掩码：<code>255.255.255.0</code>、 网关：<code>192.168.61.2</code></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230544298.png" alt="image-20230420230544298" style="zoom:80%;" /></li><li><p>在 <code>etc/sysconfig/netword-scripts</code> 目录下编辑 <code>ifcfg-ens32</code> 文件（有叫33的情况）</p><p>BOOTPROTO 设置为 static、ONBOOT 设置为 yes、配置 IPADDR、NETMASK、GATEWAY、DNS等</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230556909.png" alt="image-20230420230556909" style="zoom:80%;" /></li><li><p>配置完成后 wq 保存退出，<code>systemctl restart network</code>重启 network 服务，通过 <code>ping</code> 指令验证网络连通性</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230612538.png" alt="image-20230420230612538" style="zoom:80%;" /></li><li><p>至此虚拟机网络配置完毕，通过 <code>ifconfig</code> 指令查看网络信息（如果提示命令找不到，可以通过 <code>yum install net-tools</code> 安装）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230625244.png" alt="image-20230420230625244" style="zoom:80%;" /></li></ul><h4 id="配置图形化界面"><a href="#配置图形化界面" class="headerlink" title="配置图形化界面"></a>配置图形化界面</h4><p>正常安装完成后进入是命令行界面，可以参考知乎上黑马程序员发的<a href="https://zhuanlan.zhihu.com/p/126601630">回答</a>安装图形界面</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230639896.png" alt="image-20230420230639896" style="zoom:80%;" /><p>命令行模式切换为图形化桌面步骤如下：</p><ul><li><p>首次安装后，启动centOS 7系统，通过root用户登录命令行</p></li><li><p>使用指令：<code>systemctl get-default</code> 查看centOS 7的默认启动模式。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">multi-user.<span class="hljs-keyword">target</span>   <span class="hljs-comment">#命令行启动模式</span><br>graphical.<span class="hljs-keyword">target</span><span class="hljs-comment">#图形化界面启动模式</span><br></code></pre></td></tr></table></figure><p>使用<code>cat /etc/inittab</code>查看配置文件：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124230004437.png" alt="image-20211124230004437" style="zoom: 80%;" /></li><li><p>使用<code>systemctl set-default graphical.target</code>修改centOS 7的默认启动模式为图形化界面模式</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124230318153.png" alt="image-20211124230318153" style="zoom:80%;" /></li><li><p>通过<code>yum -h</code>检查yum命令是否支持；使用<code>ping www.baidu.com</code>测试网络（使用NAT模式可以ping通）</p></li><li><p>通过yum命令<code>yum groupinstall &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot;</code>获取并且安装图形界面GNOME的程序包</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124233403418.png" alt="image-20211124233403418" style="zoom: 80%;" /></li><li><p>安装成功后，重启CentOS 7系统，检验GUI界面效果</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124233738485.png" alt="image-20211124233738485" style="zoom: 50%;" /></li><li><p>后续要删除可视化桌面用 <code>yum groupremove xxx</code> 即可</p></li></ul><h4 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h4><p>要远程连接，必须开放指定端口，或者关闭防火墙，通过如下指令操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=22/tcp --permanent<br><span class="hljs-meta prompt_"># </span><span class="language-bash">zone:作用域   add-port:开放的端口,端口/协议   permanent:永久生效</span><br>systemctl stop firewalld #直接关闭防火墙<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230723728.png" alt="image-20230420230723728" style="zoom:80%;" /><h3 id="安装VMwareTools"><a href="#安装VMwareTools" class="headerlink" title="安装VMwareTools"></a>安装VMwareTools</h3><p>在虚拟机选项中看到 <code>重新安装VMware Tools</code> 是置灰的</p><p>在安装虚拟机的时候下面会有提示安装VMwareTools，不过正在安装的时候点不了，显示光盘正在使用，可以启动后点。</p><p>然后在图形化界面的文件夹可以看到有个左侧VMware Tools。执行cp命令复制文件到<code>/opt</code>目录下，该目录存放的是与系统无关的程序，即用户级的程序</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124234713082.png" alt="image-20211124234713082" style="zoom:67%;" /><p>在opt文件夹下<code>tar -zxvf</code>解压，进入解压得到的文件中，选择都回车选默认即可，安装完成即可~</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124235149228.png" alt="image-20211124235149228" style="zoom:67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、安装vmware&quot;&gt;&lt;a href=&quot;#1、安装vmware&quot; class=&quot;headerlink&quot; title=&quot;1、安装vmware&quot;&gt;&lt;/a&gt;1、安装vmware&lt;/h2&gt;&lt;p&gt;直接在官网下载 &lt;code&gt;VMware workstation 15&lt;/c</summary>
      
    
    
    
    <category term="开发工具" scheme="https://61hhh-github-io.vercel.app/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Linux" scheme="https://61hhh-github-io.vercel.app/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hexo迁移与同步</title>
    <link href="https://61hhh-github-io.vercel.app/20211115/60a54483/"/>
    <id>https://61hhh-github-io.vercel.app/20211115/60a54483/</id>
    <published>2021-11-15T01:57:14.000Z</published>
    <updated>2024-05-08T07:55:21.885Z</updated>
    
    <content type="html"><![CDATA[<p>由于现在更多使用办公电脑了，自己的笔记本彻底成了游戏本了，最近又想把记笔记捡起来，所以就将原来的<code>hexo</code>博客迁移过来。顺便再熟悉一下安装过程。</p><span id="more"></span><h2 id="1-hexo迁移"><a href="#1-hexo迁移" class="headerlink" title="1.hexo迁移"></a>1.hexo迁移</h2><p>首先安装必备的环境：<code>node</code>和<code>git</code>，配置GitHub的<code>ssh key</code>，按照<code>hexo</code>安装的基本步骤执行。<code>hexo init</code>生成基本的目录。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211115001252492.png" alt="image-20211115001252492" style="zoom:80%;" /><p>同时看看原来的目录结构，对比一下：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211115000427145.png" alt="image-20211115000427145" style="zoom:80%;" /><ul><li>首先：<code>.idea</code>和<code>.vscode</code>是使用对应编辑器产生的，可以忽略；<code>node_modules</code>是<code>npm</code>的依赖包文件，可以忽略</li><li>public：是<code>hexo</code>生成的静态文件，即博客所展示的文件</li><li>_config.yml：是全局的配置文件，<strong>【需要拷贝】</strong></li><li>package_json：框架的参数即相关依赖，有它才能安装<code>node_modules</code>，<strong>【需要拷贝】</strong></li><li>scaffolds：本意是 “脚手架” 的意思，这里引申为模板文件夹。当 <code>hexo new  </code> 的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建，<strong>【需要拷贝】</strong></li><li>source：用户创建的博客相关文件，如_post目录就是博客的md文件存放位置，<strong>【需要拷贝】</strong></li><li>themes：下载的主题，要同步的话<strong>【需要拷贝】</strong></li><li>.gitignore：用于声明不被git记录的文件，<strong>【需要拷贝】</strong></li></ul><p>即拷贝原电脑项目文件中的<code>_config.yml</code>、<code>themes</code>、<code>source</code>、<code>scaffolds</code>、<code>package.json</code>、<code>.gitignore</code>到新电脑新建的文件夹中，已有的选择覆盖即可。</p><p>执行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install #安装node_modules依赖<br>npm install hexo-deployer-git --save #安装部署git的服务<br></code></pre></td></tr></table></figure><p>本地测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g #生成静态文件<br>hexo s #起一个本地服务测试一下<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211115002949384.png" alt="image-20211115002949384" style="zoom:80%;" /><p>成功运行！</p><p>现在就可以在新电脑上开始写东西了~</p><h2 id="2-多端同步"><a href="#2-多端同步" class="headerlink" title="2.多端同步"></a>2.多端同步</h2><p>说到多端同步记笔记，自然会想到现有的有道云笔记、印象笔记、notion等等，它们也是多端协作笔记工具，不过hexo生成博客提交的是渲染之后的html文件，和这些有所不同。所以自然会想到另一个同步写作的工具——Git。</p><p>如图所示，master分支提交的是hexo渲染后的文件，而不是我们本地目录所见的</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211115003738030.png" alt="image-20211115003738030" style="zoom:80%;" /><p>网上搜到的hexo多端写作的方式，基本上都是在仓库再创建一个hexo分支，将本地的基础文件（上面所提到的那些）上传。然后不同终端需要记笔记的时候，先切换到hexo分支，拉取最新的代码，然后写了提交。比较像我们做开发项目的流程。</p><p>个人感觉这样说实话没啥必要。环境迁移好了之后，真正会修改变动的，基本上只有笔记对应的md文件，因此要同步的也就是md文件即可。目前有很多的同步工具，如OneDrive、坚果云等都很好用。以OneDrive为例，将<code>_post</code>目录下的md文件拷贝到OneDrive中，就可以实现多端的文件编辑，就算想修改主题啥的，同步一下<code>_config.yml</code>文件即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于现在更多使用办公电脑了，自己的笔记本彻底成了游戏本了，最近又想把记笔记捡起来，所以就将原来的&lt;code&gt;hexo&lt;/code&gt;博客迁移过来。顺便再熟悉一下安装过程。&lt;/p&gt;</summary>
    
    
    
    <category term="博客工具" scheme="https://61hhh-github-io.vercel.app/categories/%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="hexo" scheme="https://61hhh-github-io.vercel.app/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>SSM框架整合：SpringMVC+Spring+Mybatis</title>
    <link href="https://61hhh-github-io.vercel.app/20210305/2dd9e0d6/"/>
    <id>https://61hhh-github-io.vercel.app/20210305/2dd9e0d6/</id>
    <published>2021-03-05T04:26:14.000Z</published>
    <updated>2024-05-10T07:52:42.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>狂神的<code>SpringMVC</code>教程里，后面有SSM框架整合，跟着敲了一遍，感觉还是比较陌生，可能是看得太快了。结合着网上的博客再过一遍，捋一捋。</p><p><strong>目标：熟悉SSM框架开发的基本流程；了解框架结构</strong></p><span id="more"></span><h2 id="1、搭建项目的基础环境"><a href="#1、搭建项目的基础环境" class="headerlink" title="1、搭建项目的基础环境"></a>1、搭建项目的基础环境</h2><blockquote><p>前置–环境要求</p></blockquote><ul><li>IDEA</li><li>MySQL 5.1.6</li><li>Maven</li></ul><blockquote><p>基础环境搭建</p></blockquote><p>《1》在IDEA新建maven项目，命名为<code>SSM_Union</code>，再右键<code>Add Framework support</code>添加web框架支持。完成后如图</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305054235227.png" alt="image-20210305054235227" style="zoom:80%;" /><p>《2》在项目的<code>pom.xml</code>文件中添加依赖配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Junit--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据库驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--Servlet - JSP --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--Mybatis--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--Spring--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>《3》Maven资源过滤设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>《4》搭建目录结构如图</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305060016972.png" alt="image-20210305060016972" style="zoom:80%;" /><table><thead><tr><th>包名</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>controller</td><td>控制层</td><td>负责具体的业务模块流程的<strong>控制</strong>，controller调用service的接口实现业务控制流程。</td></tr><tr><td>dao</td><td>数据持久层</td><td>负责与底层数据打交道。常见的数据库操作、文件读写等</td></tr><tr><td>pojo</td><td>实体类(也写作entity)</td><td>与数据库的表对应，封装dao层的数据成一个对象。介于dao和service层</td></tr><tr><td>service</td><td>业务层(也叫bbl)</td><td>业务模块操作的逻辑设计。service调用dao层</td></tr></tbody></table><ul><li><p>mybatis-config.xml：mybatis的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">       <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">       <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>applicationContext.xml：spring的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>《5》准备项目所需的数据库<code>ssmbuild</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE `ssmbuild`;<br><br>USE `ssmbuild`;<br><br>DROP TABLE IF EXISTS `books`;<br><br>CREATE TABLE `books` (<br>`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;书id&#x27;,<br>`bookName` VARCHAR(100) NOT NULL COMMENT &#x27;书名&#x27;,<br>`bookCounts` INT(11) NOT NULL COMMENT &#x27;数量&#x27;,<br>`detail` VARCHAR(200) NOT NULL COMMENT &#x27;描述&#x27;,<br>KEY `bookID` (`bookID`)<br>) ENGINE=INNODB DEFAULT CHARSET=utf8<br><br>INSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES<br>(1,&#x27;Java&#x27;,1,&#x27;从入门到放弃&#x27;),<br>(2,&#x27;MySQL&#x27;,10,&#x27;从删库到跑路&#x27;),<br>(3,&#x27;Linux&#x27;,5,&#x27;从进门到进牢&#x27;);<br></code></pre></td></tr></table></figure><p>项目基本的准备工作就OK了，然后就可以开始构建模块–&gt;整合模块了。</p><h2 id="2、Mybatis框架搭建"><a href="#2、Mybatis框架搭建" class="headerlink" title="2、Mybatis框架搭建"></a>2、Mybatis框架搭建</h2><p>Mybatis层就是简化数据操作的，所以它对应的就是dao层。基本操作就是编写dao层接口、编写mapper映射文件</p><p>《1》编写数据库配置文件<code>db.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span><br><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><p>《2》IDEA连接mysql数据库</p><p>《3》编写mybatis-config.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置数据源,现在由spring实现--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;properties resource=&quot;db.properties&quot; /&gt;--&gt;</span><br><br>    <span class="hljs-comment">&lt;!--别名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.liu.pojo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--映射--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.dao.BookMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>《4》编写数据库实体类<code>com.liu.pojo.Books</code>（使用lombok插件简化）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Books</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> bookID;<br>    <span class="hljs-keyword">private</span> String bookName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> bookCounts;<br>    <span class="hljs-keyword">private</span> String detail;<br>&#125;<br></code></pre></td></tr></table></figure><p>《5》编写dao层接口<code>com.liu.dao.Books</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookMapper</span> &#123;<br>    <span class="hljs-comment">//增加一个Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(Books book)</span>;<br>    <span class="hljs-comment">//根据id删除一个Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">deleteBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>    <span class="hljs-comment">//更新Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateBook</span><span class="hljs-params">(Books books)</span>;<br>    <span class="hljs-comment">//根据id查询,返回一个Book</span><br>    Books <span class="hljs-title function_">queryBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>    <span class="hljs-comment">//查询全部Book,返回list集合</span><br>    List&lt;Books&gt; <span class="hljs-title function_">queryAllBook</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//查书</span><br>    Books <span class="hljs-title function_">queryBookName</span><span class="hljs-params">(String bookName)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>《6》编写接口对应的mapper映射文件，执行具体的SQL操作【也可以使用注解实现，mybatis学习时用过】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.liu.dao.BookMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--增加一个Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addBook&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.liu.pojo.Books&quot;</span>&gt;</span><br>        insert into ssmbuild.books(bookName,bookCounts,detail)<br>        values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--根据id删除一个Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteBookById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>        delete from ssmbuild.books where bookID=#&#123;bookID&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--更新Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBook&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.liu.pojo.Books&quot;</span>&gt;</span><br>        update ssmbuild.books<br>        set bookName = #&#123;bookName&#125;,bookCounts = #&#123;bookCounts&#125;,detail = #&#123;detail&#125;<br>        where bookID = #&#123;bookID&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--根据id查询,返回一个Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBookById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.liu.pojo.Books&quot;</span>&gt;</span><br>        select * from ssmbuild.books<br>        where bookID = #&#123;bookID&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查询全部Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryAllBook&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.liu.pojo.Books&quot;</span>&gt;</span><br>        SELECT * from ssmbuild.books;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查询全部Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBookName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.liu.pojo.Books&quot;</span>&gt;</span><br>        SELECT * from ssmbuild.books<br>        where bookName=#&#123;bookName&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-Spring整合Mybatis"><a href="#2-2-Spring整合Mybatis" class="headerlink" title="2.2 Spring整合Mybatis"></a>2.2 Spring整合Mybatis</h3><p>在学习Spring时就已经整合过，操作参照就行了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305061811079.png" alt="image-20210305061811079" style="zoom:80%;" /><p>新建<code>spring-dao.xml</code>用于整合。<font color="red"><strong>并在<code>applicationContext.xml</code>中进行注册</strong></font></p><p>《1》配置数据库连接池</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置整合mybatis --&gt;</span><br><span class="hljs-comment">&lt;!-- 1.关联数据库文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 也可以用c3p0 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置连接池属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>《2》配置SqlSessionFactory对象，照搬之前的文档</p><p>官方文档在关于Spring操作SqlSession部分有以下介绍：</p><blockquote><p>在 MyBatis 中，你可以使用 <code>SqlSessionFactory</code> 来创建 <code>SqlSession</code>。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。使用 MyBatis-Spring 之后，你不再需要直接使用 <code>SqlSessionFactory</code> 了，因为你的 bean 可以被注入一个线程安全的 <code>SqlSession</code>，它能基于 Spring 的事务配置来自动提交、回滚、关闭 session。</p></blockquote><p>有两种形式：</p><ul><li>使用<code>SqlSessionTemplate</code></li><li>使用<code>SqlSessionDaoSupport</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注入数据库连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置MyBatis全局配置文件:mybatis-config.xml --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注册完后，我们的<code>springIOC</code>容器中就有了<code>sqlSessionFactory</code>工厂，可以由此拿到<code>SqlSession</code>进而拿到代理对象，不再需要每次创建了！</p><p>《3》配置Dao层接口扫描。</p><p>有了工厂有了<code>SqlSession</code>，就要配置代理的对象了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span><br><span class="hljs-comment">&lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注入sqlSessionFactory --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.liu.dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong><font color="red">总结：总的就是spring代理mybtis，将原先的配置转移到sping中，产生代理并放置于IOC容器里</font></strong></p><h2 id="3、搭建业务逻辑框架"><a href="#3、搭建业务逻辑框架" class="headerlink" title="3、搭建业务逻辑框架"></a>3、搭建业务逻辑框架</h2><p>业务逻辑主要涉及service层和controller层。</p><p>【这一步也可以在搭建基础环境时就准备好】</p><p>接口：与<code>dao</code>层相对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 业务层service一般与数据层dao功能类似，</span><br><span class="hljs-comment"> * 区别在于dao是直接对数据库操作，service是上层调用dao</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-comment">//增加一个Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(Books book)</span>;<br>    <span class="hljs-comment">//根据id删除一个Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">deleteBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>    <span class="hljs-comment">//更新Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateBook</span><span class="hljs-params">(Books books)</span>;<br>    <span class="hljs-comment">//根据id查询,返回一个Book</span><br>    Books <span class="hljs-title function_">queryBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>    <span class="hljs-comment">//查询全部Book,返回list集合</span><br>    List&lt;Books&gt; <span class="hljs-title function_">queryAllBook</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//查书</span><br>    Books <span class="hljs-title function_">queryBookName</span><span class="hljs-params">(String bookName)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类：注解开发。<code>service层直接调用dao层的操作</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookService</span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookMapper bookMapper;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBookMapper</span><span class="hljs-params">(BookMapper bookMapper)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookMapper = bookMapper;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(Books book)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.addBook(book);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.deleteBookById(id);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateBook</span><span class="hljs-params">(Books books)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.updateBook(books);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Books <span class="hljs-title function_">queryBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.queryBookById(id);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Books&gt; <span class="hljs-title function_">queryAllBook</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.queryAllBook();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Books <span class="hljs-title function_">queryBookName</span><span class="hljs-params">(String bookName)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.queryBookName(bookName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-整合service层"><a href="#3-2-整合service层" class="headerlink" title="3.2 整合service层"></a>3.2 整合service层</h3><p>创建<code>spring-service.xml</code>文件<font color="red"><strong>并在<code>applicationContext.xml</code>中进行注册</strong></font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--1.扫描service包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.liu.service&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--2.将业务类都注入到spring，可以通过注解或配置实现--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BookServiceImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.service.BookServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookMapper&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bookMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--3.声明式事务配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--注入数据源--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4、SpringMVC框架搭建"><a href="#4、SpringMVC框架搭建" class="headerlink" title="4、SpringMVC框架搭建"></a>4、SpringMVC框架搭建</h2><p>搭建SpringMVC的基本流程：</p><ol><li>导入相关依赖</li><li>编写<code>web.xml</code> , 注册<code>DispatcherServlet</code></li><li>编写<code>springmvc</code>配置文件</li><li>接下来就是去创建对应的控制类 , controller</li><li>最后完善前端视图和controller之间的对应。测试</li></ol><p>《1》编写<code>web.xml</code>文件<font color="red"><strong>并在<code>applicationContext.xml</code>中进行注册</strong></font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--DispatchServlet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--乱码过滤--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span><br>            org.springframework.web.filter.CharacterEncodingFilter<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--Session过期时间--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>《2》创建<code>spring-mvc.xml</code>配置文件。并在<code>web/WEB-INF</code>下新建<code>jsp</code>文件夹</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context/spring-context.xsd &quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--1.注解驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--2.静态资源过滤--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--3.扫描相关的包Controller--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.liu.controller&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--4.视图解析器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!-- 前缀 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!-- 后缀 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后<code>applicationContext.xml</code>应该如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305065107243.png" alt="image-20210305065107243" style="zoom:80%;" /><h2 id="5、编写对应controller类和前端页面"><a href="#5、编写对应controller类和前端页面" class="headerlink" title="5、编写对应controller类和前端页面"></a>5、编写对应controller类和前端页面</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;BookServiceImpl&quot;)</span><br>    <span class="hljs-keyword">private</span> BookService bookService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查找所有书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> model</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/allBook&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">list</span><span class="hljs-params">(Model model)</span> &#123;<br>        List&lt;Books&gt; list = bookService.queryAllBook();<br>        model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>, list);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;allBook&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 去添加书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/toAddBook&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toAddPaper</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;addBook&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> books</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/addBook&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addPaper</span><span class="hljs-params">(Books books)</span> &#123;<br>        System.out.println(books);<br>        bookService.addBook(books);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/book/allBook&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 去更新书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> model</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/toUpdateBook&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toUpdateBook</span><span class="hljs-params">(Model model, <span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-type">Books</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> bookService.queryBookById(id);<br>        System.out.println(books);<br>        model.addAttribute(<span class="hljs-string">&quot;book&quot;</span>,books );<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;updateBook&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> model</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> book</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/updateBook&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">updateBook</span><span class="hljs-params">(Model model, Books book)</span> &#123;<br>        System.out.println(book);<br>        bookService.updateBook(book);<br>        <span class="hljs-type">Books</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> bookService.queryBookById(book.getBookID());<br>        model.addAttribute(<span class="hljs-string">&quot;books&quot;</span>, books);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/book/allBook&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/del/&#123;bookId&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">deleteBook</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bookId&quot;)</span> <span class="hljs-type">int</span> id)</span> &#123;<br>        bookService.deleteBookById(id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/book/allBook&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bookName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/queryBookName&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">queryBookName</span><span class="hljs-params">(String bookName,Model model)</span> &#123;<br>        <span class="hljs-type">Books</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> bookService.queryBookName(bookName);<br>        <span class="hljs-keyword">if</span>(books==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/book/allBook&quot;</span>;<br>        &#125;<br>        List&lt;Books&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(books);<br>        model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>, list);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;allBook&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>前端页面我直接copy的代码</strong></p><p><code>allBook.jsp</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;<br>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>书籍列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引入 Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-header&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>书籍列表 —— 显示所有书籍<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>        &lt;%--新增书籍--%&gt;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-4 column&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;</span>&gt;</span>新增书籍<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-4 column&quot;</span>&gt;</span><br>            &lt;%--查询书籍--%&gt;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-inline&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/queryBookName&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float: right&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;queryBookName&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入要查询的书籍名称&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;查询&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table table-hover table-striped&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍编号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍名字<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍数量<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍详情<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">c:forEach</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;$&#123;requestScope.get(&#x27;list&#x27;)&#125;&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.getBookID()&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.getBookName()&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.getBookCounts()&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.getDetail()&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;&quot;</span>&gt;</span>更改<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> |<br>                            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;&quot;</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">c:forEach</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>addBook.jsp</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;<br>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>新增书籍<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引入 Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-header&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>新增书籍<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/addBook&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        书籍名称：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        书籍数量：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookCounts&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        书籍详情：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;detail&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;添加&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>updateBook.jsp</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;<br>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>修改信息<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引入 Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-header&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>修改信息<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/updateBook&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookID&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;book.getBookID()&#125;&quot;</span>/&gt;</span><br>        书籍名称：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;book.getBookName()&#125;&quot;</span>/&gt;</span><br>        书籍数量：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookCounts&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;book.getBookCounts()&#125;&quot;</span>/&gt;</span><br>        书籍详情：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;detail&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;book.getDetail() &#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>项目启动的初始页<code>index.jsp</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">a</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: black;</span><br><span class="language-css">      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">h3</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">180px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">38px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;</span><br><span class="language-css">      <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">38px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background</span>: deepskyblue;</span><br><span class="language-css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;</span>&gt;</span>点击进入列表页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="6、发布"><a href="#6、发布" class="headerlink" title="6、发布"></a>6、发布</h2><p>完整的项目结构如图</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305065635143.png" alt="image-20210305065635143" style="zoom:80%;" /><p>《1》在左上角File的<code>Project Structure</code>中<code>Artifacts</code>将项目打包。采用<code>Web Application:Exploded</code>打包【因为是后面添加的web framework，所以他自动打包的会缺少lib依赖，所以我们要自己打包】</p><p>《2》配置Tomcat，启动</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305070415977.png" alt="image-20210305070415977" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305070428608.png" alt="image-20210305070428608" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305070446813.png" alt="image-20210305070446813" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305070611508.png" alt="image-20210305070611508" style="zoom:80%;" /><p>这个项目虽然很简陋，但是基本的SSM框架很明了。两天时间快速过了一遍，仅仅也只是了解了基本流程，很多细节并不清楚。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;狂神的&lt;code&gt;SpringMVC&lt;/code&gt;教程里，后面有SSM框架整合，跟着敲了一遍，感觉还是比较陌生，可能是看得太快了。结合着网上的博客再过一遍，捋一捋。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标：熟悉SSM框架开发的基本流程；了解框架结构&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://61hhh-github-io.vercel.app/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://61hhh-github-io.vercel.app/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>数据库相关核心概念</title>
    <link href="https://61hhh-github-io.vercel.app/20210218/914c342c/"/>
    <id>https://61hhh-github-io.vercel.app/20210218/914c342c/</id>
    <published>2021-02-18T11:17:27.000Z</published>
    <updated>2024-05-11T02:23:33.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位</p><p>在SQL中定义事务的语句一般有：<code>BEGIN TRANSACTION</code>; <code>COMMIT</code>; <code>ROLLBACK</code>; </p><p>一般COMMIT表示提交，即提交事务的所有操作，事务正常结束。</p><p>ROLLBACK表示回滚，即事务运行过程中发生某种故障不能继续执行，将事务对数据库中已完成的操作撤销，回滚到事务开始时的状态</p><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><p><strong>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability）</strong></p><ul><li>原子性：事务是数据库的逻辑工作单位，事务中的操作要么都做要么都不做</li><li>一致性：事务执行的结果是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性。</li><li>隔离性：一个事务的执行不能被其他事务干扰。即一个事务的内部操作及其使用的数据对其他并发事务是隔离的，并发事务之间不能相互干扰</li><li>持续性：也称永久性（Permanence），指一个事务一旦提交，他对数据库的改变应该是永久性的</li></ul><p>事务ACID特性可能遭到破坏的因素：</p><ul><li>多个事务并行执行时，不同事物的操作交叉执行；</li><li>事务在运行过程中被强制停止；</li></ul><p>事务ACID特性并不是平级的，它们的关系如下：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况</li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/a58e294a-615d-4ea0-9fbf-064a6daec4b2.png" style="zoom:80%;" /><h3 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用 <code>START TRANSACTION</code> 语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p><h2 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h3 id="1、丢失修改（W-W）"><a href="#1、丢失修改（W-W）" class="headerlink" title="1、丢失修改（W-W）"></a>1、丢失修改（W-W）</h3><p><strong>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换</strong>。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427141425200.png" alt="image-20230427141425200" style="zoom:80%;" /><h3 id="2、读脏数据（W-R）"><a href="#2、读脏数据（W-R）" class="headerlink" title="2、读脏数据（W-R）"></a>2、读脏数据（W-R）</h3><p><strong>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据</strong>。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427141408877.png" alt="image-20230427141408877" style="zoom:80%;" /><h3 id="3、不可重复读（R-W）"><a href="#3、不可重复读（R-W）" class="headerlink" title="3、不可重复读（R-W）"></a>3、不可重复读（R-W）</h3><p><strong>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致</strong>。例如：T1 读取一个数据，T2 对该数据做了修改。如果 T1 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427141450751.png" alt="image-20230427141450751" style="zoom:80%;" /><h3 id="4、幻影读"><a href="#4、幻影读" class="headerlink" title="4、幻影读"></a>4、幻影读</h3><p><strong>幻读本质上也属于不可重复读的情况</strong>。T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p>不可重复读和幻影读的区别：</p><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了</li></ul><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。</p><p>并发控制的主要技术：封锁、时间戳、乐观控制法、多版本并发控制等，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题</p><h2 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h2><p>封锁是实现并发控制一个非常重要的技术。</p><h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h3 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h3><h4 id="1、读写锁"><a href="#1、读写锁" class="headerlink" title="1、读写锁"></a>1、读写锁</h4><ul><li>排他锁（Exclusive Lock，X 锁）：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）</li><li>共享锁（Share Lock，S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）</li></ul><p>有以下两个规定：</p><ol><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ol><p>锁的兼容关系如下：</p><table><thead><tr><th align="center">-</th><th align="center">X</th><th align="center">S</th></tr></thead><tbody><tr><td align="center"><strong>X</strong></td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center"><strong>S</strong></td><td align="center">×</td><td align="center">√</td></tr></tbody></table><h4 id="2、意向锁"><a href="#2、意向锁" class="headerlink" title="2、意向锁"></a>2、意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X&#x2F;S 锁之上引入了 IX&#x2F;IS，<strong>IX&#x2F;IS 都是表锁</strong>，<strong>用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁</strong>。有以下两个规定：</p><ol><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ol><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X&#x2F;IX&#x2F;S&#x2F;IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p><table><thead><tr><th align="center">-</th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">IX</td><td align="center">×</td><td align="center">√</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">S</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">IS</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><ul><li>任意 IS&#x2F;IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li><li>S 锁只和 S&#x2F;IS 锁兼容</li><li><strong>这里兼容关系针对的是表级锁</strong>，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><h4 id="1、三级封锁协议"><a href="#1、三级封锁协议" class="headerlink" title="1、三级封锁协议"></a>1、三级封锁协议</h4><h5 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h5><p>事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。</p><p>可以解决丢失修改问题，但是仅仅读数据是不需要加锁的，因此不能保证可重复读和不读“脏”数据</p><h5 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h5><p>在一级封锁协议的基础上，增加事务 T 读取数据 R 之前必须加 S 锁，读完可释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。由于读完数据就释放S锁，因此不能保证可重复读</p><h5 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h5><p>在一级封锁协议基础上，增加事务 T 读取数据 R 之前必须对其加 S 锁，直到事务结束才可以释放。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><h4 id="2、两段锁协议"><a href="#2、两段锁协议" class="headerlink" title="2、两段锁协议"></a>2、两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p><strong>事务遵循两段锁协议是保证可串行化调度的充分条件</strong>。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">lock-x</span><span class="hljs-params">(A)</span></span>..<span class="hljs-selector-class">.lock-s</span>(B)..<span class="hljs-selector-class">.lock-s</span>(C)..<span class="hljs-selector-class">.unlock</span>(A)..<span class="hljs-selector-class">.unlock</span>(C)..<span class="hljs-selector-class">.unlock</span>(B)<br></code></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">lock-x</span><span class="hljs-params">(A)</span></span>..<span class="hljs-selector-class">.unlock</span>(A)..<span class="hljs-selector-class">.lock-s</span>(B)..<span class="hljs-selector-class">.unlock</span>(B)..<span class="hljs-selector-class">.lock-s</span>(C)..<span class="hljs-selector-class">.unlock</span>(C)<br></code></pre></td></tr></table></figure><h3 id="MySQL隐式和显示锁定"><a href="#MySQL隐式和显示锁定" class="headerlink" title="MySQL隐式和显示锁定"></a>MySQL隐式和显示锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">SELECT</span></span> ... LOCK In SHARE MODE;<br><span class="hljs-function"><span class="hljs-title">SELECT</span></span> ... <span class="hljs-keyword">FOR</span> UPDATE;<br></code></pre></td></tr></table></figure><h2 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h2><h3 id="读未提交（READ-UNCOMMITTED）"><a href="#读未提交（READ-UNCOMMITTED）" class="headerlink" title="读未提交（READ UNCOMMITTED）"></a>读未提交（READ UNCOMMITTED）</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h3 id="读已提交（READ-COMMITTED）"><a href="#读已提交（READ-COMMITTED）" class="headerlink" title="读已提交（READ COMMITTED）"></a>读已提交（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h3 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h3><p>指事务执行过程中看到的数据，和该事务启动时看到的数据是一致的。保证在同一个事务中多次读取同一数据的结果是一样的。</p><h3 id="串行化（SERIALIZABLE）"><a href="#串行化（SERIALIZABLE）" class="headerlink" title="串行化（SERIALIZABLE）"></a>串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">读已提交</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">可重复读</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">串行化</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h2 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h2><p>多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于<em>实现读已提交和可重复读这两种隔离级别</em>。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。</p><p>在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 <code>CopyOnWrite</code> 类似。</p><p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p><p><strong>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改</strong>。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><ul><li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li></ul><h3 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h3><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号:</p><ul><li>创建版本号: 指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号: 如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><h3 id="undo-日志"><a href="#undo-日志" class="headerlink" title="undo 日志"></a>undo 日志</h3><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/e41405a8-7c05-4f70-8092-e961e28d3112.jpg.jpeg" style="zoom:80%;" /><p>MySQL 在执行增删改操作时如果没有显式开始事务，由于 AUTOCOMMIT 设置会默认将每个操作语句都当作一个事务。INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>MVCC 维护了一个 ReadView 结构，主要包含了：创建 ReadView 的事务id、当前系统未提交的事务列表、最小事务id、最大事务id</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427145140377.png" alt="image-20230427145140377" style="zoom:80%;" /><p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p><ul><li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li><li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li><li>TRX_ID_MIN &lt;&#x3D; TRX_ID &lt;&#x3D; TRX_ID_MAX，需要根据隔离级别再进行判断：<ul><li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li><li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li></ul></li></ul><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><p>1、快照读</p><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> ...;<br></code></pre></td></tr></table></figure><p>2、当前读</p><p>读取的是最新的数据，需要加锁。SELECT也可以强制加锁，以下第一个语句需要加 S 锁，其它都需要加 X 锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> ? lock <span class="hljs-keyword">in</span> share mode;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> ? <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">insert</span>;<br><span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><h2 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题</p><h3 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h3><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用</p><h3 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h3><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> c <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><h3 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><p>它是 <strong>Record Locks 和 Gap Locks 的结合</strong>，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-built_in">-</span></span>∞<span class="hljs-punctuation">,</span> <span class="hljs-number">10</span>]<br>(<span class="hljs-number">10</span><span class="hljs-punctuation">,</span> <span class="hljs-number">11</span>]<br>(<span class="hljs-number">11</span><span class="hljs-punctuation">,</span> <span class="hljs-number">13</span>]<br>(<span class="hljs-number">13</span><span class="hljs-punctuation">,</span> <span class="hljs-number">20</span>]<br>(<span class="hljs-number">20</span><span class="hljs-punctuation">,</span> +∞)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.pdai.tech/md/db/sql/sql-db-theory.html">SQL DB - 数据库系统核心知识点</a></li><li><a href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理</a></li><li><a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离级别是怎么实现的？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、事务&quot;&gt;&lt;a href=&quot;#一、事务&quot; class=&quot;headerlink&quot; title=&quot;一、事务&quot;&gt;&lt;/a&gt;一、事务&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h</summary>
      
    
    
    
    <category term="计算机基础" scheme="https://61hhh-github-io.vercel.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="数据库" scheme="https://61hhh-github-io.vercel.app/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>leetbook-数组和字符串</title>
    <link href="https://61hhh-github-io.vercel.app/20201206/7970c1ba/"/>
    <id>https://61hhh-github-io.vercel.app/20201206/7970c1ba/</id>
    <published>2020-12-06T09:27:41.000Z</published>
    <updated>2024-04-16T08:42:11.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h1><span id="more"></span><h2 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h2><h3 id="寻找数组的中心索引"><a href="#寻找数组的中心索引" class="headerlink" title="寻找数组的中心索引"></a>寻找数组的中心索引</h3><p><strong>思路</strong>：前缀和——中心索引左右两边和相等，所以先sum求出总和，然后计算右边是否等于左边<code>left == sum-left-nums[i]</code>，满足就返回，不满足就右移，直到结束。时间复杂度O(N)空间复杂度O(1)</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,left=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s:nums) sum+=s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(left== sum-left-nums[i])&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            left+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h3><p><strong>思路</strong>：简单的二分查找代码。（当然由于数组已经有序了，直接遍历一遍也行）</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                left = mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                right = mid-<span class="hljs-number">1</span>;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> right+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>思路：题目是要判断重叠区间，类似算法笔记贪心</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//参考算法笔记 区间贪心，寻找不相交区间</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-comment">//按起始位置由小到大排序</span><br>        Arrays.sort(intervals,(v1,v2)-&gt; v1[<span class="hljs-number">0</span>]-v2[<span class="hljs-number">0</span>] );<br>        <span class="hljs-comment">//存放每一个内部的数组</span><br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[intervals.length][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] interval:intervals)&#123;<br>            <span class="hljs-comment">//当前数组起始位置 &gt; ans最后数组的结束位置</span><br>            <span class="hljs-comment">//将当前数组加入ans</span><br>            <span class="hljs-keyword">if</span>(index==-<span class="hljs-number">1</span> || interval[<span class="hljs-number">0</span>]&gt;ans[index][<span class="hljs-number">1</span>])<br>                ans[++index] = interval;<br>            <span class="hljs-comment">//否则将当前区间加到ans最后数组</span><br>            <span class="hljs-keyword">else</span><br>                ans[index][<span class="hljs-number">1</span>] = Math.max(ans[index][<span class="hljs-number">1</span>],interval[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.copyOf(ans, index + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维数组简介"><a href="#二维数组简介" class="headerlink" title="二维数组简介"></a>二维数组简介</h2><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p>对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。</p><p>matrix [row] [col] –&gt; matrix [col] [n-1-row]</p><p>思路一：用辅助数组存储临时旋转的结果</p><p>复杂度：时间O(N^2) 空间O(N^2)</p><p>思路二：原地旋转，前一个的列是旋转结果的行，前一个的行倒数过来是结果的列</p><p>一次旋转交换四个位置</p><p>[row,col] –&gt; [col,n-1-row] –&gt; [n-1-row,n-1-col] –&gt; [n-1-col,row] –&gt; [row,col]</p><p>n为偶数：n^2&#x2F;4 &#x3D; n&#x2F;2 * n&#x2F;2，左上角四分之一区域</p><p>n为奇数：(n^2-1)&#x2F;4 &#x3D; (n-1)&#x2F;2 * (n+1)&#x2F;2，左上角(n-1)&#x2F;2,(n+1)&#x2F;2区域</p><p>注：赋值的时候反过来</p><p>思路三：用翻转代替旋转，做两次翻转结果也是一样</p><p>水平翻转   ：matrix [row] [col] &#x3D; matrix [n-1-row] [col]</p><p>+主对角线翻转  ：matrix [row] [col] &#x3D; matrix [col] [row]</p><p>&#x3D; 联立结果    ：matirx [row] [col] &#x3D; matrix [col] [n-1-row]</p><p>注：水平+对角线–&gt;顺时针 对角线+水平–&gt;逆时针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//思路二：原地翻转</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> row=<span class="hljs-number">0</span>;row&lt;n/<span class="hljs-number">2</span>;row++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col=<span class="hljs-number">0</span>;col&lt;(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;col++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[row][col];<br>                matrix[row][col] = matrix[n-<span class="hljs-number">1</span>-col][row];<br>                matrix[n-<span class="hljs-number">1</span>-col][row] = matrix[n-<span class="hljs-number">1</span>-row][n-<span class="hljs-number">1</span>-col];<br>                matrix[n-<span class="hljs-number">1</span>-row][n-<span class="hljs-number">1</span>-col] = matrix[col][n-<span class="hljs-number">1</span>-row];<br>                matrix[col][n-<span class="hljs-number">1</span>-row] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//思路三</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">//水平翻转</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i &lt; n/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[n-<span class="hljs-number">1</span>-i][j];<br>                matrix[n-<span class="hljs-number">1</span>-i][j] = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//对角线翻转</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h3><p>思路：数组中只要某个位置<code>matrix[i][j] = 0</code>那么对应<code>i</code>行<code>j</code>列全置0，所以可以用两个数组记录行列中出现0的情况，遍历二维数组做处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[matrix.length];<br>        <span class="hljs-type">boolean</span>[] col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[matrix[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-comment">//记录0出现的行列值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">0</span>)&#123;<br>                    row[i] = <span class="hljs-literal">true</span>;<br>                    col[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//清理行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(row[i])&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].length;j++)<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//清理列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix[<span class="hljs-number">0</span>].length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(col[i])&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix.length;j++)<br>                    matrix[j][i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h2><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>思路一：横向扫描方式，一次遍历比较字符串，更新前缀prefix，遍历完后就可以得到最长前缀。</p><p>时间复杂度O(mn)，m是字符串平均长度，n是字符串数量；空间复杂度O(1)</p><p>思路二：纵向扫描，从前往后遍历所有字符串的第一列，相同列上字符相同就继续，否则就返回</p><p>还有其他方法例如分治、二分查找等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-keyword">if</span>(strs == <span class="hljs-literal">null</span> || strs.length ==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;count;i++)&#123;<br>            prefix = lcp(prefix,strs[i]);<br>            <span class="hljs-keyword">if</span>(prefix.length() == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prefix;<br>    &#125;<br><br>    <span class="hljs-comment">//获取两个字符串的lcp</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">lcp</span><span class="hljs-params">(String s1,String s2)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Math.min(s1.length(),s2.length());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(index&lt;len &amp;&amp; s1.charAt(index)==s2.charAt(index))<br>            index++;<br>        <span class="hljs-keyword">return</span> s1.substring(<span class="hljs-number">0</span>,index);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-keyword">if</span> (strs == <span class="hljs-literal">null</span> || strs.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>].length();<span class="hljs-comment">//字符串长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> strs.length;<span class="hljs-comment">//字符串数量</span><br>        <span class="hljs-comment">//每个字符串逐列进行比较</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>].charAt(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; count; j++) &#123;<br>                <span class="hljs-comment">//第j个字符串长度即为i || 对应位置字符不同</span><br>                <span class="hljs-keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;<br>                    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>思路：暴力法枚举所有子串，验证是否为回文串，可以添加剪枝<code>j-i+1&gt;maxLen</code>，只有串长比maxLen大才判断。时间复杂度O(N^3)，这个暴力法自己写的都有问题。。参考一下别人的改出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//s.charAt(i)每次都会检查数组下标越界，因此先转换成字符数组</span><br>        <span class="hljs-type">char</span>[] charArray = s.toCharArray();<br>        <span class="hljs-comment">//枚举所有长度达于1的子串charArray[i...j]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;len;j++)&#123;<br>                <span class="hljs-keyword">if</span>(j-i+<span class="hljs-number">1</span>&gt;maxLen &amp;&amp; validPalindromic(charArray,i,j))&#123;<br>                    maxLen = j-i+<span class="hljs-number">1</span>;<br>                    begin = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  s.substring(begin,begin+maxLen);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 验证子串s[left...right]是否为回文串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validPalindromic</span><span class="hljs-params">(<span class="hljs-type">char</span>[] charArray,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(charArray[left]!=charArray[right])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>别人的思路：动态规划。回文串具有天然的状态转移性质——一个回文串去掉首尾两个字符还是回文串。所以可以从两端判断：两端不等必然不是，相等再看里面</p><ol><li><p>定义状态：<code>dp[i][j]</code>表示<code>s[i...j]</code>是否为回文子串</p></li><li><p>状态转移方程:<code>dp[i][j]==(s[i]==s[j]) and dp[i+1][j-1]</code></p><p>动态规划就是填二维表，由于<code>i&lt;=j</code>所以只看对角线以上</p><p>还要考虑<code>dp[i+1][j-1]</code>可能存在边界情况。边界条件：<code>(j-1)-(i+1)+1&lt;2 --&gt; j-i&lt;3</code>即字符串长度为2或3的时候直接判断</p></li><li><p>判断结论：如果子串 <code>s[i+1..j-1]</code> 只有 1 个字符，即去掉两头，剩下中间部分只有1个字符，显然是回文；如果子串<code>s[i+1..j-1]</code>为空串，那么子串<code>s[i, j]</code>一定是回文子串。</p></li><li><p>初始化：单个字符肯定是回文串，所以对角线即<code>dp[i][i]=true</code>，不过但单个字符也不会被其他状态值参考，基本可以去除</p></li><li><p>输出：只要得到<code>dp[i][j]=true</code>就记录字串长度和起始位置</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">manLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//dp[i][j]</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len][len];<br>        <span class="hljs-type">char</span>[] charArray = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>            <span class="hljs-keyword">do</span>[i][i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;len;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;j;i++)&#123;<br>                <span class="hljs-keyword">if</span>(charArray[i]!=charArray[j])<br>                    dp[i][j] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(j-i&lt;<span class="hljs-number">3</span>)dp[i][j]=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">else</span>dp[i][j]=dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-comment">//dp[i][j]==true表示子串s[i...j]是回文串，记录长度和起始位置</span><br>                <span class="hljs-keyword">if</span>(dp[i][j]&amp;&amp;j-i+<span class="hljs-number">1</span>&gt;maxLen)&#123;<br>                    maxLen = j-i+<span class="hljs-number">1</span>;<br>                    begin = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(begin,begin+maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>别人的思路：中心扩散。除了从左右两端来判断，回文串也可以从中间往两边扩散。基本想法是遍历每一个索引，以该索引为中心利用回文串对称的特点往两边扩散  </p><h3 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h3><p>思路：一开始没想到用库函数，想着直接遍历s，开一个String数组存放单词，遇到空格就表示一个单词结束，所以只要<code>s.charAt(i)!=&#39; &#39;</code>的话就<code>word[num]+=s.charAt(i)</code>，遇到空格单词入栈和<code>num++</code>，然后将栈中元素拼接，思路没错，就是太麻烦了，效率也非常低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        s+=<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        String[] word = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10010</span>];<br>        Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10010</span>;i++)&#123;<br>            word[i]=<span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i)!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                word[num] += s.charAt(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                stack.push(word[num]);<br>                num++;<br>            &#125;<br>        &#125;<br>        String ss=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            ss+=stack.peek();<br>            <span class="hljs-keyword">if</span>(stack.size()&gt;<span class="hljs-number">1</span>&amp;&amp;stack.peek()!=<span class="hljs-string">&quot;&quot;</span>)&#123;<br>                ss+=<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            stack.pop();<br>        &#125;<br>        ss=ss.trim();<br>        <span class="hljs-keyword">return</span> ss;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题一：遇到<code>&quot; hello world!&quot;</code>会输出<code>&quot; world! hello &quot;</code>而不是预期的<code>&quot;world! hello&quot;</code>。。。在后面处理一下<code>ss=ss.trim()</code></p><p>问题二：遇到<code>&quot;a good   example&quot;</code>时，在while循环中把<code>word[num]=&quot;&quot;</code>加了一次到stack中，所以在拼接ss时多了一个空格，导致输出<code>&quot;example   good a&quot;</code>，将判断条件由<code>stack.size()!=0</code>改为<code>stack.size()&gt;1&amp;&amp;stack.peek()!=&quot; &quot; </code>就行</p><p>word数组设大一点，最后有一个输入用例非常多</p><p>别人的思路：可以直接用库函数（属实不太熟悉。。。就很致命）trim去首位空格、spilt分割、reverse翻转、join再连接。一波操作带走</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        String[] words = s.trim().split(<span class="hljs-string">&quot; +&quot;</span>);<br>        Collections.reverse(Arrays.asList(words));<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, words);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>别人的思路二：上面库函数面试可能不会让用，所以参考了一下别人的发现，可以考虑改进我的思路，从后往前遍历就不需要栈了，用一个双指针索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        s=s.trim();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">//start和end用于定位单词的首尾</span><br>        <span class="hljs-type">int</span> end=s.length()-<span class="hljs-number">1</span>,start=end;<br>        <span class="hljs-keyword">while</span>(start&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//搜索单词</span><br>            <span class="hljs-keyword">while</span>(start&gt;=<span class="hljs-number">0</span>&amp;&amp;s.charAt(start)!=<span class="hljs-string">&#x27; &#x27;</span>)start--;<br>            <span class="hljs-comment">//添加单词</span><br>            res.append(s.substring(start+<span class="hljs-number">1</span>,end+<span class="hljs-number">1</span>) +<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-comment">//跳过空格</span><br>            <span class="hljs-keyword">while</span>(start&gt;<span class="hljs-number">0</span>&amp;&amp;s.charAt(start)==<span class="hljs-string">&#x27; &#x27;</span>)start--;<br>            <span class="hljs-comment">//指向下个单词的尾字符</span><br>            end = start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim(); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h3><p>思路一：直接调用库函数indexOf</p><p>思路二：双指针暴力遍历检测</p><p>思路三：KMP算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//思路二：双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span>(needle.length()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(needle.length()&gt;haystack.length())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;haystack.length() &amp;&amp; j&lt;needle.length())&#123;<br>            <span class="hljs-keyword">if</span>(haystack.charAt(i) == needle.charAt(j))&#123;<span class="hljs-comment">//两指针值相等</span><br>                <span class="hljs-keyword">if</span>(index == -<span class="hljs-number">1</span>)<span class="hljs-comment">//index是初始值，更新index</span><br>                    index = i;<br>                <span class="hljs-keyword">if</span>(j == needle.length()-<span class="hljs-number">1</span>)<span class="hljs-comment">//如果j是needle的最后一个，即已经遍历完就返回index</span><br>                    <span class="hljs-keyword">return</span> index;<br>                j++;<span class="hljs-comment">//needle未遍历完，继续</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//指针值不相等</span><br>                <span class="hljs-keyword">if</span>(index != -<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//index不是初始值，更新i</span><br>                    i = index;<br>                    j = <span class="hljs-number">0</span>;<br>                    index = -<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            i++;<span class="hljs-comment">//i始终要后移</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针技巧"><a href="#双指针技巧" class="headerlink" title="双指针技巧"></a>双指针技巧</h2><p>常用的有：</p><ul><li>左右指针：左右两端点开始，反向运动，常用于二分查找之类问题</li><li>快慢指针：同一起点，通向运动，一快一慢，典型的判定链表中是否包含环</li></ul><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p>【题目要求原地修改输入数组、并用O(1)的额外空间解决问题】</p><p>思路：很显然放在双指针下自然想到双指针方法。。这也算是最典型的应用了，双指针left和right从两边往中间靠拢，每次交换对应的s[left]和s[right]即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">null</span> || s.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> s.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[left];<br>            s[left] = s[right];<br>            s[right] = temp;<br>            left ++;<br>            right --;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组拆分"><a href="#数组拆分" class="headerlink" title="数组拆分"></a>数组拆分</h3><p>思路：将长度为2n的数组分成n对，取每队的最小值min相加，使得最后的值sum最大。那我们就应该尽可能的保留大的值——假如最大和最小、第二大和第二小。。。这样每次取min都是小的；应该最大与第二大、第三大与第四大。。。这样才能做到保留大值。【实现上就是排序取奇数位】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">arrayPairSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i+=<span class="hljs-number">2</span>)&#123;<br>            ans+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两数之和-II-输入有序数组"><a href="#两数之和-II-输入有序数组" class="headerlink" title="两数之和 II - 输入有序数组"></a>两数之和 II - 输入有序数组</h3><p>思路：因为数组已经有序了，那这就跟二分查找差不多了，只不过它多了一步——返回是下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>,right=numbers.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers[left]+numbers[right];<br>            <span class="hljs-keyword">if</span>(sum==target)&#123;<span class="hljs-comment">//找到了</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left+<span class="hljs-number">1</span>,right+<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//数组下标从0开始,返回要补上</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>                right--;<span class="hljs-comment">//右指针左移</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left++;<span class="hljs-comment">//左指针右移</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//找不到</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>【原地移除等于目标值的元素，控制常量空间】</p><p>思路：一般思路是遇到不等于目标值的就放入新数组，这样一次遍历得到的新数组即为所需的。现在要求常数空间，那就可以用快慢指针：快指针每次都移动，慢指针只有快指针的值不为目标值val才移动，若相同则停止，等下一个不同的来覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">null</span>||nums.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>;fast&lt;nums.length;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast]!=val)&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大连续1的个数"><a href="#最大连续1的个数" class="headerlink" title="最大连续1的个数"></a>最大连续1的个数</h3><p>思路：由0、1组成的数组中连续1的最大个数。之前没用双指针，感觉差不多</p><ul><li>原来思路：变量count记录当前连续1的个数，遇到0就将count存入tmp然后count置0，下次再遇到就和tmp比较，遍历一遍得到结果</li><li>双指针：快指针判断，慢指针只有判断为1才前移</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//思路一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxConsecutiveOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>,tmp=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">1</span>)&#123;<br>                count++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tmp = Math.max(tmp,count);<br>                count=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(tmp,count);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxConsecutiveOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>,count=<span class="hljs-number">0</span>,fast;<br>        <span class="hljs-keyword">for</span>(fast=<span class="hljs-number">0</span>;fast&lt;nums.length;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast]==<span class="hljs-number">0</span>)&#123;<br>                count = Math.max(fast-slow,count);<br>                slow = fast+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(fast==nums.length-<span class="hljs-number">1</span> &amp;&amp; nums[fast]==<span class="hljs-number">1</span>)<br>                count = Math.max(fast-slow+<span class="hljs-number">1</span>,count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p>思路：题目要找出满足和&gt;&#x3D;s的长度最小的<strong>连续</strong>子数组，我第一反应就是暴力求解，不过复杂度会比较高</p><ul><li>暴力想法：枚举nums每个元素<code>nums[i]</code>，作为子数组的起始，然后从<code>i</code>开始往后，直到找到<code>j</code>使得<code>nums[i]到nums[j]</code>元素之和大于等于s，更新子数组长度。复杂度O(n<sup>2</sup>)</li><li>题解的双指针方法：双指针start和end，每轮<code>sum+=nums[end]</code>，满足大于等于s，就更新长度，然后执行<code>sum -= nums[start]</code>【start右移，类似滑动窗口，直到sum&lt;s，其中每次也更新长度】一轮完成后<code>end++</code>，开始下一轮</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">10010</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,end = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(end=<span class="hljs-number">0</span>;end&lt;nums.length;end++)&#123;<br>            sum += nums[end];<br>            <span class="hljs-keyword">while</span>(sum&gt;=s)&#123;<br>                len = Math.min(len,end-start+<span class="hljs-number">1</span>);<br>                sum -= nums[start++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len==<span class="hljs-number">10010</span>? <span class="hljs-number">0</span> : len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p>思路：打印杨辉三角嘛，两边是1直接<code>add(1)</code>，中间是正上面的左上方和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numRows;i++)&#123;<br>            ArrayList&lt;Integer&gt; sub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||j==i)&#123;<br>                    sub.add(<span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    sub.add(res.get(i-<span class="hljs-number">1</span>).get(j-<span class="hljs-number">1</span>)+res.get(i-<span class="hljs-number">1</span>).get(j));<br>                &#125;<br>            &#125;<br>            res.add(sub);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="杨辉三角-II"><a href="#杨辉三角-II" class="headerlink" title="杨辉三角 II"></a>杨辉三角 II</h3><p>思路：上一题返回整个，这个返回杨辉三角的第k行【进阶：空间O(k)】</p><ul><li><p>简单的就在k行返回；优化的思路：</p><ul><li><p>杨辉三角具有动态规划的性质，下一行依赖于上一行，且两边固定为1。</p><p>【数组写法】数组表示很直观但是rowIndex未知，那就只能将最后的数组取前rowIndex+1位放到新数组返回</p><p>【ArrayList写法】ArrayList用add会输出所有的元素，变成<code>1 11 121 1331</code>；有个set函数可以指定索引元素，但是得先有元素才行，所以最后要删除多的1</p></li><li><p>可以用组合公式<code>C(n,i) = n!/(i!*(n-i)!)</code></p></li></ul></li><li><p>或者先本地IDE跑出来，然后直接打表，标准O(1)解答！(因为题目限制k&lt;33)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getRow</span><span class="hljs-params">(<span class="hljs-type">int</span> rowIndex)</span> &#123;<br>        ArrayList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=rowIndex;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||j==i)&#123;<br>                    res.add(<span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    res.set(j,res.get(j)+res.get(j-<span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> res.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=size-<span class="hljs-number">1</span>;j&gt;=size-rowIndex;j--)&#123;<br>            res.remove(j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反转字符串中的单词-III"><a href="#反转字符串中的单词-III" class="headerlink" title="反转字符串中的单词 III"></a>反转字符串中的单词 III</h3><p>之前做过反转句子输出：<code>i love you</code>输出<code>you love i</code>这种，这题是反转每个单词，但是单词间位置不变：<code>i love you</code>输出<code>i evol uoy</code></p><p>思路：正在刷双指针，所以一下就想到双指针方法，一个slow用于定位每个单词的开始位置，<code>fast==&#39; &#39;</code>时前一个就是单词的结束位置，然后将单词的字符反转。</p><p>【写完编译不通过，才想起来Java中的String是不可变的。。。改用C++思路不变】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>,slow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>;fast&lt;s.<span class="hljs-built_in">length</span>();fast++)&#123;<br>            <span class="hljs-keyword">if</span>(s[fast]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                <span class="hljs-type">int</span> j = fast<span class="hljs-number">-1</span>;<br>                <span class="hljs-comment">//exchange</span><br>                <span class="hljs-keyword">while</span>(slow&lt;j)&#123;<br>                   <span class="hljs-built_in">swap</span>(s[slow], s[j]);<br>                   slow++;<br>                   j--;<br>                &#125;<br>                <span class="hljs-comment">//update</span><br>                slow = fast+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(fast==s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>&amp;&amp;s[fast]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                <span class="hljs-type">int</span> j = fast;<br>                <span class="hljs-keyword">while</span>(slow&lt;j)&#123;<br>                    <span class="hljs-built_in">swap</span>(s[slow], s[j]);<br>                    slow++;<br>                    j--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h3><p>看题目输入输出，好像就是找数组最小值。。。它说在某个点旋转了我也没整明白咋旋转的：<code>[0,1,2,4,5,6,7]</code>转成<code>[4,5,6,7,0,1,2]</code>。可能是说数组变成了<code>4,5,6,7</code>和<code>0,1,2</code>两个区域然后旋转了方向，所以数组不再有序了</p><p>思路：</p><ul><li>第一眼就直接遍历一遍：复杂度O(N)</li><li>改进方式：采用二分优化。但是二分需要数组有序，旋转了之后数组是乱序的，要改进一下，假设两个区域分别叫大区间和小区间<ul><li>找到中间元素mid，如果<code>nums[mid]&gt;nums[right]</code>说明mid是大区间的值，那我们就应该去小区间搜索；反之表示mid是小区间的值，那就缩小范围继续</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//数组未被旋转</span><br>        <span class="hljs-keyword">if</span>(nums[right]&gt;nums[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right&gt;left)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h3><p>思路：有序数组去重，也是双指针比较好想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">null</span>||nums.length==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums.length;<br>        &#125;<br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>,fast;<br>        <span class="hljs-keyword">for</span>(fast=<span class="hljs-number">1</span>;fast&lt;nums.length;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != nums[slow])&#123;<br>                slow++;<br>                nums[slow] = nums[fast];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><p>将数组<code>[0,1,2,0,3]</code>中0移到最后且保持原数组顺序，即<code>[1,2,3,0,0]</code>。</p><p>最简单的思路就是再开一个数组遍历，不过题目要求原地操作，所以比较容易想到双指针操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>,fast=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast&lt;nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast]!=<span class="hljs-number">0</span>)&#123;<br>                swap(nums,slow,fast);<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数组和字符串&quot;&gt;&lt;a href=&quot;#数组和字符串&quot; class=&quot;headerlink&quot; title=&quot;数组和字符串&quot;&gt;&lt;/a&gt;数组和字符串&lt;/h1&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="https://61hhh-github-io.vercel.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="leetcode" scheme="https://61hhh-github-io.vercel.app/tags/leetcode/"/>
    
    <category term="数据结构与算法" scheme="https://61hhh-github-io.vercel.app/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
