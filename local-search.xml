<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图床图片迁移</title>
    <link href="/20240511/c978efd1/"/>
    <url>/20240511/c978efd1/</url>
    
    <content type="html"><![CDATA[<p>之前注册的jihulab仓库做图床，类似于GitHub，但是偶然登录时提示试用期已经结束，需要购买专业或者旗舰版使用，为了避免保留期结束后数据被清空，所以需要迁移图片，之前买的服务器还是腾讯云的，所以这次选择用腾讯云cos。</p><span id="more"></span><h3 id="配置图床"><a href="#配置图床" class="headerlink" title="配置图床"></a>配置图床</h3><h4 id="申请COS"><a href="#申请COS" class="headerlink" title="申请COS"></a>申请COS</h4><p>先登录腾讯云，登录后搜索对象存储进入概览页面，新用户进去会送6个月的标准存储包，按照步骤领取后就可以创建存储桶了（如下图）</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20240511103900585.png" alt="image-20240511103900585"></p><p>创建一个桶，访问权限设置为<strong>公有读私有写</strong>，不然图片上传后不能访问，还得配置账号身份验证（安全问题可以通过设置防盗链）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20240511134020815.png" alt="image-20240511134020815" style="zoom:80%;" /><p>搜索进入 API 密钥管理，创建一个访问密钥</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20240511134304334.png" alt="image-20240511134304334" style="zoom:80%;" /><h4 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h4><p>准备好基本信息后进入picgo，配置腾讯云cos相关参数：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20240511134402945.png" alt="image-20240511134402945" style="zoom:80%;" /><p>此时就可以正常上传图片使用了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20240511135359520.png" alt="image-20240511135359520" style="zoom:80%;" /><h4 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h4><p>默认上传的域名（源站域名）是根据 bucket 名称、地域名称生成的，例如我的是：<code>leslie1-1309334886.cos.ap-shanghai.myqcloud.com</code>，自己有的域名话可以替换一下，存储桶列表点击进入详情，左侧域名与传输管理中添加一条自己的域名，在域名解析里添加CNAME解析即可</p><p><img src="https://cos-md.salute61.top/obsidian/image-20240511140225062.png" alt="image-20240511140225062"></p><p>在picgo出同样添加以下即可，已经上传的图片引用处正则替换一下就行</p><blockquote><p>腾讯云cos注册送的6个月标准存储容量包，但是流量使用也会产生费用，需要买流量包。</p><p>可以考虑又拍云，有免费10G存储和15G流量。操作方式和cos基本一致</p></blockquote><h3 id="图片迁移"><a href="#图片迁移" class="headerlink" title="图片迁移"></a>图片迁移</h3><p>之前在 jihulab 上的图片有几百张，手动一张张下载再重新上传太麻烦，刚好发现 PicGo 运行会启动一个本地 Server，根据他的文档是可以利用 api 上传的，写一个简单的代码去做这个工作逻辑：</p><ul><li>找到文本中 jihulab 的图片；</li><li>下载图片到指定文件夹；</li><li>把图片通过 PicGo 上传；</li><li>替换得到的新 url；</li></ul><p>我在完全没有学习过 python 的情况下，简单写一个 py 程序，工具如下：</p><ul><li>VSCode：编辑器</li><li>Codeium：GPT插件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> urllib.request<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-comment"># 正则</span><br>img_pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;https://jihulab\.com/.*\.gif&#x27;</span>, re.IGNORECASE)<br><span class="hljs-comment"># 目标文件夹</span><br>folder_path = <span class="hljs-string">&#x27;E:\\python-script\\posts&#x27;</span><br><span class="hljs-comment"># 保存文件夹</span><br>image_save_path = <span class="hljs-string">&#x27;E:\\python-script\\image_save&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(image_save_path):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(image_save_path, <span class="hljs-string">&#x27;w&#x27;</span>):<br>        <span class="hljs-keyword">pass</span><br><span class="hljs-comment"># 请求路径</span><br>upload_request = <span class="hljs-string">&#x27;http://127.0.0.1:36677/upload&#x27;</span><br><span class="hljs-comment"># 日志路径</span><br>logging.basicConfig(filename=<span class="hljs-string">&#x27;E:\\python-script\\handle.log&#x27;</span>, level=logging.INFO, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(message)s&#x27;</span>)<br><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">读取单个md文件,遍历其中所有旧url,下载上传得到新url并替换</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">match_and_save</span>(<span class="hljs-params">file_path</span>):<br>    <span class="hljs-keyword">if</span> file_path.endswith(<span class="hljs-string">&#x27;.md&#x27;</span>):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            content = f.read()<br>            matched_urls = img_pattern.findall(content)<br>            logging.info(<span class="hljs-string">&quot;开始处理: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(file_path))<br>            <span class="hljs-comment"># 旧url写入临时目录,然后上传替换url</span><br>            <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> matched_urls:<br>                <span class="hljs-comment"># 下载url到临时目录</span><br>                logging.info(<span class="hljs-string">&quot;\t&gt;&gt;&gt;&gt;原始URL: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(url))<br>                img_name = os.path.basename(url)<br>                img_abPath = os.path.join(image_save_path, img_name)<br>                urllib.request.urlretrieve(url, img_abPath)<br>                <span class="hljs-comment"># 调用上传接口</span><br>                logging.info(<span class="hljs-string">&quot;\t\t本地图片路径: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(img_abPath))<br>                data = &#123;<br>                    <span class="hljs-string">&#x27;list&#x27;</span>: [img_abPath]<br>                &#125;<br>                req = urllib.request.Request(upload_request, json.dumps(data).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json; charset=utf-8&#x27;</span>&#125;)<br>                <span class="hljs-keyword">with</span> urllib.request.urlopen(req) <span class="hljs-keyword">as</span> response:<br>                    res = json.loads(response.read().decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>                    logging.info(<span class="hljs-string">&quot;\t\t响应体:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(res))<br>                    <span class="hljs-keyword">if</span> res[<span class="hljs-string">&#x27;success&#x27;</span>]:<br>                        new_url = res[<span class="hljs-string">&#x27;result&#x27;</span>][<span class="hljs-number">0</span>]<br>                        content = content.replace(url, new_url)<br>                        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                            f.write(content)<br>            <span class="hljs-comment"># 清空临时目录</span><br>            <span class="hljs-keyword">for</span> file_name <span class="hljs-keyword">in</span> os.listdir(image_save_path):<br>                file_path = os.path.join(image_save_path, file_name)<br>                <span class="hljs-keyword">if</span> os.path.isfile(file_path):<br>                    os.remove(file_path)<br>            logging.info(<span class="hljs-string">&quot;处理完成: &#123;&#125;\n&quot;</span>.<span class="hljs-built_in">format</span>(file_path))<br>    <br>    <span class="hljs-keyword">return</span> []<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">文件则调用方法,文件夹则递归遍历</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">traverse_folder</span>(<span class="hljs-params">folder_path</span>):<br>    <span class="hljs-keyword">if</span> os.path.isdir(folder_path):<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> os.listdir(folder_path):<br>            item_path = os.path.join(folder_path, item)<br>            traverse_folder(item_path)<br>    <span class="hljs-keyword">elif</span> os.path.isfile(folder_path):<br>        match_and_save(folder_path)<br><br><span class="hljs-comment"># 调用方法</span><br>traverse_folder(folder_path)<br></code></pre></td></tr></table></figure><p>代码都是 <code>ctrl + i</code> 快捷键问 GPT 生成的，我只是每个逐个方法校验一遍，调整生成的代码即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7、RabbitMQ延时队列</title>
    <link href="/20230511/201df3ca/"/>
    <url>/20230511/201df3ca/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>延时队列也是一个消息队列，和普通队列区别之处只是它带有<strong>延时功能</strong>。例如实际开发的某些场景中，需要让消息在指定时间才会被消费</p><ol><li>订单下单后指定时间未付款就取消</li><li>用户注册后，指定时间内未登录或验证，发送消息提醒</li><li>某个业务操作失败后，间隔一段时间重试或进行其他操作</li></ol><p>类似的场景其实很多。并且上述情况好像也可以通过定时任务轮询来处理，但是性能不高，并且业务数据量大&amp;存在高并发的场景下，极易导致系统宕掉，另一方面定时任务的轮询也会有较大误差产生。</p><p>RabbitMQ本身是不支持延时队列的，但是可以通过定制方式实现</p><ul><li><strong>改造死信队列的TTL模式</strong>，使消息过期后全部进入死信队列，来达到延时的效果</li><li><strong>使用延时队列插件</strong>，让交换器管理延时消息</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>这里操作按照整合SpringBoot进行，参照整合SpringBoot，先创建SpringBoot模块，并勾选相关依赖，在yml配置文件中添加rabbitmq连接</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.204</span><span class="hljs-number">.127</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br>  <span class="hljs-attr">mvc:</span><br>    <span class="hljs-attr">pathmatch:</span><br>      <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ant_path_matcher</span><br></code></pre></td></tr></table></figure><h3 id="队列TTL延时"><a href="#队列TTL延时" class="headerlink" title="队列TTL延时"></a>队列TTL延时</h3><p>创建RabbitMQ配置类，其中队列QA、QB的过期时间分别是10s、40s，再创建交换器X和死信交换器Y，二者都是direct类型，最后创建死信队列QD存放死信消息</p><p>消费者不监听QA、QB队列，使消息进入队列后不被消费导致TTL超时进入延迟队列QD</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657795388413-69a6c47f-75f5-4da2-a15f-0258461d25a5.png" alt="img" style="zoom:80%;" /><p>【注】设计的缺点：每增加一个新的延时时间需求，就需要增加一个队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TTLQueueConfig</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">X_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ex_x&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_A</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QA&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_B</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QB&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_C</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QC&quot;</span>;<br>    <span class="hljs-comment">// 死信交换机和队列</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">Y_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ex_y&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_D</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;QD&quot;</span>;<br><br>    <span class="hljs-meta">@Bean(&quot;xExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">xExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(X_EXCHANGE);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;yExchange&quot;)</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">yExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(Y_EXCHANGE);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;queueA&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueA</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 声明死信队列</span><br>        map.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_EXCHANGE);<br>        map.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;RK_Y&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">10000</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(map).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBindingA</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="hljs-string">&quot;RK_XA&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;queueB&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueB</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 声明死信队列</span><br>        map.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_EXCHANGE);<br>        map.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;RK_Y&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">40000</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(map).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBindingB</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="hljs-string">&quot;RK_XB&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;queueC&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueC</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">// 声明死信队列</span><br>        map.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, Y_EXCHANGE);<br>        map.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="hljs-string">&quot;RK_Y&quot;</span>);<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(map).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBindingC</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="hljs-string">&quot;RK_XC&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(&quot;queueD&quot;)</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">queueD</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(QUEUE_D);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">queueBindingD</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,</span><br><span class="hljs-params">                                 <span class="hljs-meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="hljs-string">&quot;RK_Y&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RequestMapping(&quot;ttl&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendMsgController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@GetMapping(&quot;sendMsg/&#123;msg&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsg</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String msg)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;当前时间-----&gt;&#123;&#125;,发送消息给两个TTL队列-----&gt;&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), msg);<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ex_x&quot;</span>, <span class="hljs-string">&quot;RK_XA&quot;</span>, <span class="hljs-string">&quot;消息存放于ttl=10s队列QA中-----&gt;&quot;</span> + msg);<br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ex_x&quot;</span>, <span class="hljs-string">&quot;RK_XB&quot;</span>, <span class="hljs-string">&quot;消息存放于ttl=10s队列QA中-----&gt;&quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLQueueConsumer</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;QD&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveD</span><span class="hljs-params">(Message message, Channel channel)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody());<br>        log.info(<span class="hljs-string">&quot;当前时间-----&gt;&#123;&#125;,从死信队列获取到的消息-----&gt;&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动项目访问：<code>http://localhost:8080/ttl/sendMsg/发送消息TTL</code>，看到控制台对应输出</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657796562162-65178fbf-195f-4b8d-8b96-a8ef196fa270.png" alt="img" style="zoom:80%;" /><h3 id="消息TTL延时"><a href="#消息TTL延时" class="headerlink" title="消息TTL延时"></a>消息TTL延时</h3><p>上面的方法缺点很明显，不同的延时时间就需要不同的队列，可见通过队列TTL设置会比较麻烦</p><p>改造一下，在配置列中添加队列QC，不设置TTL</p><p>缺点：如果积压在队列前面的消息延时时长很长，而后面积压的消息延时时长很短，积压时间短的消息并不会被提前放入死信队列；如果QC恰好又设置了积压上限，无法被积压的消息将直接进入延时队列，达不到延时效果</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657795689587-d017a7a4-ee2b-4530-9c65-35b1fdddc47b.png" alt="img" style="zoom:80%;" /><p>生产者添加代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;sendExpirationMsg/&#123;msg&#125;/&#123;ttlTime&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsgWithTTL</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String msg, <span class="hljs-meta">@PathVariable</span> String ttlTime)</span> &#123;<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ex_x&quot;</span>, <span class="hljs-string">&quot;RK_XC&quot;</span>, msg, correlationData -&gt; &#123;<br>        correlationData.getMessageProperties().setExpiration(ttlTime);<br>        <span class="hljs-keyword">return</span> correlationData;<br>    &#125;);<br>    log.info(<span class="hljs-string">&quot;当前时间-----&gt;&#123;&#125;,发送一个TTL为&#123;&#125;的消息给队列C-----&gt;&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), ttlTime, msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>设置消息的TTL，值通过参数传入，实现不同消息具有不同TTL，可以对应到业务中的不同任务。只用了一个队列，但是实现了不同时间的延时</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657796306470-72d82375-4a6e-4a25-aa5d-571d75d5b467.png" alt="img" style="zoom:80%;" /><h3 id="插件延时"><a href="#插件延时" class="headerlink" title="插件延时"></a>插件延时</h3><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>在<a href="https://www.rabbitmq.com/community-plugins.html">RabbitMQ官网-社区插件</a>中下载<code>rabbitmq_delayed_message_exchange</code>插件，通过FileZilla等FTP工具传到虚拟机中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将插件复制到容器对应的plugins目录下</span><br>docker cp /opt/rabbitmq_delayed_message_exchange-3.10.0.ez 容器ID:/plugins<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器内部 需要容器处于运行状态</span><br>docker exec -it 容器ID /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看插件是否成功复制到指定目录</span><br>cd plugins<br>ls -l|grep delay <br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启运行插件</span><br>rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br></code></pre></td></tr></table></figure><p>注意rabbitmq的版本和插件的版本，我的RabbitMQ版本为<code>3.8.34</code>，插件在GitHub上下载<code>3.10.x</code>后运行提示报错，我看报错信息部分写了<code>supported by the plugin: [&quot;3.9.0-3.9.x&quot;, &quot;3.10.0-3.10.x&quot;]</code>所以我把<code>3.9</code>到<code>3.10</code>的版本都试了下但是都不行！</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657851569778-7edd7a28-9ff2-40f4-ad13-dcba855e72e4.png" alt="img" style="zoom:80%;" /><p>关于版本支持的说明，应该去GitHub上看插件说明，可以看到<code>3.9.x</code>的插件对应的是<code>3.9.x</code>的RabbitMQ，我的版本就应该选择<code>3.8.x</code>来适配</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657851815093-9a0eb06f-6fde-4e21-a886-2ac09b8ea220.png" alt="img" style="zoom:80%;" /><p>更换插件版本后即可成功，然后重启rabbitmq，在管理后台界面查看插件是否成功启用</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657851997103-89049ab2-e0d5-4627-b280-0e864015b69c.png" alt="img" style="zoom:80%;" /><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657852033198-97f702f0-394e-440e-9fe0-374202e10eeb.png" alt="img" style="zoom:80%;" /><h4 id="插件延时操作"><a href="#插件延时操作" class="headerlink" title="插件延时操作"></a>插件延时操作</h4><p>这里创建了一个direct交换机和队列，结构如图</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657853374382-88325615-0dc9-4d38-a5aa-9a9ecaa8b891.png" alt="img" style="zoom:80%;" /><p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中</p><p>1、配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedQueueConfig</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_QUEUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.queue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_EXCHANGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.exchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAYED_ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delayed.routingKey&quot;</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 创建插件版本的交换器，通过自定义方法创建</span><br><span class="hljs-comment">     * 插件版本非死信队列，不需要路由到不同的交换器指定过期时间，所以可以固定为direct类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CustomExchange <span class="hljs-title function_">delayedExchange</span><span class="hljs-params">()</span> &#123;<br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&quot;x-delayed-type&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>); <span class="hljs-comment">// 自定义交换机类型，固定为direct</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomExchange</span>(DELAYED_EXCHANGE, <span class="hljs-string">&quot;x-delayed-message&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, map);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">delayedQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(DELAYED_QUEUE).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">delayedBinding</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue delayedQueue,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange)<br>                .with(DELAYED_ROUTING_KEY)<br>                .noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、生产者，在对应controller中添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 延时插件</span><br><span class="hljs-meta">@RequestMapping(&quot;/plugins/sendMsg/&#123;msg&#125;/&#123;time&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMsgByPlugin</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String msg, <span class="hljs-meta">@PathVariable</span> Integer time)</span> &#123;<br>    <span class="hljs-type">MessageProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageProperties</span>();<br>    properties.setDelay(time);<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(msg.getBytes(StandardCharsets.UTF_8), properties);<br>    log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;,发送过期时间为&#123;&#125;毫秒的消息到延时插件，内容为：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), time, msg);<br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;delayed.exchange&quot;</span>, <span class="hljs-string">&quot;delayed.routingKey&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><p>3、消费者，在对应controller添加监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 延时插件消费</span><br><span class="hljs-meta">@RabbitListener(queues = &quot;delayed.queue&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveDelayQueue</span><span class="hljs-params">(Message msg, Channel channel)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody());<br>    log.info(<span class="hljs-string">&quot;当前时间：&#123;&#125;，收到延时消息：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), message);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后查看效果</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657853555914-5b835b41-9c83-4651-b7d9-69ef459cf9e3.png" alt="img" style="zoom:80%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。</p><p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6、SpringBoot整合RabbitMQ</title>
    <link href="/20230511/ef3b40a7/"/>
    <url>/20230511/ef3b40a7/</url>
    
    <content type="html"><![CDATA[<p>SpringBoot作为目前后端开发的主流框架，基本上系统都有应用，并且它对其他很多框架提供了非常优秀的集成。</p><p>新建一个springboot工程</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752277077-232a359f-9940-4be4-99a9-cd3e224dde69.png" alt="img" style="zoom: 80%;" /><p>在Messaging选项中勾选RabbitMQ，之后卡一看到mavenpom文件中依赖<code>spring-boot-starter-amqp</code>，它继承了<code>amqp-client</code>依赖实现了amqp协议</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改yaml配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.204</span><span class="hljs-number">.127</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><p>常用的RabbitMQ操作类有RabbitAdmin、RabbitTemplate，其中使用比较广泛的是RabbitTemplate，这里整合的也是以RabbitTemplate使用为主。它提供了编辑、发送、监听消息等一系列功能，通过RabbitTemplate，可以在Springboot中像操作原生API一样进行消息的发送监听操作</p><p>先按照之前的最基础模式，测试Springboot集成RabbitMQ的基础操作API</p><h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>简单模式就是最基础的消息队列，它简化了其他操作，仅模拟生产者、队列、消费者三个部分</p><ol><li>创建三个对象的对应类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 基础的生产者，通过RabbitTemplate操作消息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleSender</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SimpleSender.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.hello&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate template;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        <span class="hljs-built_in">this</span>.template.convertAndSend(queueName, message);<br>        LOGGER.info(<span class="hljs-string">&quot; [x] Sent &#x27;&#123;&#125;&#x27;&quot;</span>, message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 基础的消费者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleReceiver</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SimpleReceiver.class);<br><br>    <span class="hljs-meta">@RabbitHandler</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String in)</span> &#123;<br>        LOGGER.info(<span class="hljs-string">&quot; [x] Received &#x27;&#123;&#125;&#x27;&quot;</span>, in);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建对应配置类，在配置类中设置好队列</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRabbitConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;simple.hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SimpleSender <span class="hljs-title function_">simpleSender</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleSender</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SimpleReceiver <span class="hljs-title function_">simpleReceiver</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleReceiver</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>创建controller进行测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/rabbit&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SimpleSender simpleSender;<br><br>    <span class="hljs-meta">@GetMapping(value = &quot;/simple&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            simpleSender.send();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752435417-4cd39d9e-5f56-4ce2-8d23-cb9086870e5a.png" alt="img" style="zoom:80%;" /></h4><h4 id="Work-Queue"><a href="#Work-Queue" class="headerlink" title="Work Queue"></a>Work Queue</h4><p><strong>WorkQueue</strong>模式将多个消费者绑定到一个队列中，默认采取轮询方式分发消息</p><p>操作可以参照上面</p><ol><li>创建对应的对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 生产者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkSender</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(WorkSender.class);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;work&quot;</span>;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">limitIndex</span> <span class="hljs-operator">=</span> index % <span class="hljs-number">3</span>+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; limitIndex; i++) &#123;<br>builder.append(<span class="hljs-string">&#x27;.&#x27;</span>);<br>&#125;<br>builder.append(index+<span class="hljs-number">1</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> builder.toString();<br>rabbitTemplate.convertAndSend(QUEUE_NAME, message);<br>LOGGER.info(<span class="hljs-string">&quot; [x] Sent &#x27;&#123;&#125;&#x27;&quot;</span>, message);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 消费者</span><br><span class="hljs-meta">@RabbitListener(queues = &quot;work&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkReceiver</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(WorkReceiver.class);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> instance;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">WorkReceiver</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br><span class="hljs-built_in">this</span>.instance = i;<br>&#125;<br><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receive</span><span class="hljs-params">(String in)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">StopWatch</span> <span class="hljs-variable">watch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopWatch</span>();<br>watch.start();<br>LOGGER.info(<span class="hljs-string">&quot;instance &#123;&#125; [x] Received &#x27;&#123;&#125;&#x27;&quot;</span>, <span class="hljs-built_in">this</span>.instance, in);<br>doWork(in); <span class="hljs-comment">// 模拟业务操作</span><br>watch.stop();<br>LOGGER.info(<span class="hljs-string">&quot;instance &#123;&#125; [x] Done in &#123;&#125;s&quot;</span>, <span class="hljs-built_in">this</span>.instance, watch.getTotalTimeSeconds());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(String in)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : in.toCharArray()) &#123;<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkRabbitConfig</span> &#123;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">workQueue</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;work&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 模拟两个消费者</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> WorkReceiver <span class="hljs-title function_">workReceiver1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkReceiver</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> WorkReceiver <span class="hljs-title function_">workReceiver2</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkReceiver</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> WorkSender <span class="hljs-title function_">workSender</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkSender</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>编写controller，调用测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/work&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">workTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            workSender.send(i);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure> <img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752830230-99043ec3-05f8-4e47-b8a5-32752b7cc937.png" alt="img" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5、RabbitMQ死信队列</title>
    <link href="/20230511/9b199b28/"/>
    <url>/20230511/9b199b28/</url>
    
    <content type="html"><![CDATA[<h2 id="过期时间TTL"><a href="#过期时间TTL" class="headerlink" title="过期时间TTL"></a>过期时间TTL</h2><p>先介绍一下TTL概念</p><p>TTL即<code>Time to Live</code>的简称，表示过期时间。RabbitMQ可以对消息和队列设置对应TTL</p><h3 id="0、消息TTL设置"><a href="#0、消息TTL设置" class="headerlink" title="0、消息TTL设置"></a>0、消息TTL设置</h3><ul><li>通过队列属性设置，<strong>队列中所有消息都有相同的过期时间</strong>。</li><li>通过消息属性设置，<strong>可以实现每个消息都有自己的过期时间</strong>。</li></ul><p>二者可以同时使用，此时则以TTL数值较小的为准</p><h3 id="1、队列上设置"><a href="#1、队列上设置" class="headerlink" title="1、队列上设置"></a>1、队列上设置</h3><p>在定义队列时，添加属性<code>x-message-ttl</code>，单位是毫秒，<strong>这里设置的并不是队列的TTL，而是该队列中所有消息的TTL</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> HashMap&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>args.put(<span class="hljs-string">&quot;x-message-ttl&quot;</span>, <span class="hljs-number">6000</span>);<br>channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, args);<br></code></pre></td></tr></table></figure><p>TTL取值的区分</p><ul><li>不设置TTL：该消息不会过期</li><li>值&#x3D;0：表示除非此时可以直接将消息投递到消费者，不然就丢弃</li><li>值&gt;0：表示将在到值对应时间后过期</li></ul><h3 id="2、消息上设置"><a href="#2、消息上设置" class="headerlink" title="2、消息上设置"></a>2、消息上设置</h3><p>针对单独消息设置TTL是在<code>channel.BasicPublish</code>方法中加入<code>expiration</code>参数，单位为毫秒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> AMQP.BasicProperties.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder();<br>builder.deliveryMode(<span class="hljs-number">2</span>);<span class="hljs-comment">//设置消息持久化</span><br>builder.expiration(<span class="hljs-string">&quot;5000&quot;</span>);<span class="hljs-comment">//设置过期时间5000毫秒</span><br><span class="hljs-keyword">final</span> AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> builder.build();<br>channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, properties, msg.getBytes());<br></code></pre></td></tr></table></figure><h3 id="3、对比"><a href="#3、对比" class="headerlink" title="3、对比"></a>3、对比</h3><ol><li>队列设置：时间从消息入队开始计算，一旦超过了队列的超时时间配置，消息会自动清除。</li><li>消息设置：消息即使过期也不一定会被马上丢弃，<strong>因为每条消息是否过期是在即将投递到消费者之前判定的</strong>（ 如果当前队列有严重的消息积压情况，已过期的消息依旧会被积压在队列中，如果队列配置了消息积压上限，将导致后续应当正常消费的消息全部进入死信队列 ）</li></ol><p>队列设置中，队列已过期的消息肯定在队列头部（过期时间一致的前提下，先进先出），RabbitMQ只需要定期从队列头部开始扫描是否有已过期的消息即可。</p><p>消息设置中，每个消息的过期时间不同，如果要删除过期消息就必须扫描整个队列，所以还不如等到消息即将被消费时再判定是否过期，如果过期就删除即可</p><h2 id="死信队列DLX"><a href="#死信队列DLX" class="headerlink" title="死信队列DLX"></a>死信队列DLX</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>死信（Dead Message）：<strong>由于某些特定原因导致无法被消费的消息</strong>。</p><p>按照正常流程消息从producer到broker再到queue，consumer从queue中取出消息消费，由于特定原因queue中的消息无法被消费，这类消费异常的消息就会保存在死信队列中，来避免消息的丢失</p><p>场景：<strong>用户在商城下单后，超过半小时未付款，该订单自动取消</strong></p><p>DLX（Dead-Letter-Exchange）可以成为死信交换器，或死信邮箱。当一个消息成为死信之后，可以被重新发送到另一个交换器即DLX中，而绑定了DLX的队列即为死信队列</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>消息变成死信，一般有以下三种原因</p><ul><li>TTL过期</li><li>队列积压的消息达到最大长度，后续消息无法添加</li><li>消息被拒，消费者调用<code>basic.reject</code>或<code>basic.nack</code>并且<code>requeue=false</code></li></ul><p>DLX 是一个普通的交换器，可以在任何队列上设置，当死信消息出现时，RabbitMQ 自动将这个消息重新发布到设置的 DLX上，从而被路由到另一个队列，即 <strong>死信队列</strong></p><h2 id="死信DEMO"><a href="#死信DEMO" class="headerlink" title="死信DEMO"></a>死信DEMO</h2><p>死信队列架构图</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657438155832-0a0a8239-7d68-4412-9e9c-cf6437f2ae7e.png" alt="img" style="zoom:80%;" /><ul><li>定义一个DLX（其实就是普通交换器，用来绑定正常的交换器），为该DLX绑定队列，用于接收死信消息</li><li>定义正常的交换器，并通过属性设置它所对应的DLX和路由键</li></ul><h3 id="死信之TTL"><a href="#死信之TTL" class="headerlink" title="死信之TTL"></a>死信之TTL</h3><p>生产者代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TTLProducer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normalExchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ZhangSan&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">// 设置消息的TTL为10秒</span><br>        AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="hljs-string">&quot;10000&quot;</span>).build();<br>        <span class="hljs-comment">// 演示队列个数限制</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INFO_&quot;</span> + i;<br>            channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="hljs-literal">null</span>, msg.getBytes());<br>            System.out.println(msg + <span class="hljs-string">&quot;发送完成&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TTL消费者1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TTLConsumer1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NORMAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normalExchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DEAD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;deadExchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NORMAL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normalQueue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_DEAD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;deadQueue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ZhangSan&quot;</span>; <span class="hljs-comment">//普通队列routing-key</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LiSi&quot;</span>;     <span class="hljs-comment">//死信队列routing-key</span><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        <span class="hljs-comment">// 声明普通和死信交换机 normal-exchange在生产者处已经声明</span><br>        channel.exchangeDeclare(EXCHANGE_NORMAL, BuiltinExchangeType.DIRECT);<br>        channel.exchangeDeclare(EXCHANGE_DEAD, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 通过额外参数指定在什么条件下讲消息转发到死信队列，其中key值是rabbitmq固定的</span><br><span class="hljs-comment">         * value1：TTL时间，一般由生产者指定</span><br><span class="hljs-comment">         * value2：死信交换机名称</span><br><span class="hljs-comment">         * value3：死信交换机的routing-key</span><br><span class="hljs-comment">         * value4：指定队列能够积压消息的数量，超出该范围的消息将进入死信队列</span><br><span class="hljs-comment">         */</span><br>        HashMap&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-comment">//params.put(&quot;x-dead-letter-ttl&quot;, 10000);</span><br>        params.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, EXCHANGE_DEAD);<br>        params.put(<span class="hljs-string">&quot;x-dead-letter-routing-key&quot;</span>, ROUTING_KEY2);<br>        <span class="hljs-comment">//params.put(&quot;x-max-length&quot;, 6);</span><br><br>        channel.queueDelete(QUEUE_NORMAL); <span class="hljs-comment">//变更queueDeclare的params参数后，原队列要删除</span><br>        <span class="hljs-comment">// 声明绑定正常队列</span><br>        channel.queueDeclare(QUEUE_NORMAL, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, params);<br>        channel.queueBind(QUEUE_NORMAL, EXCHANGE_NORMAL, ROUTING_KEY1);<br>        <span class="hljs-comment">// 声明绑定死信队列</span><br>        channel.queueDeclare(QUEUE_DEAD, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.queueBind(QUEUE_DEAD, EXCHANGE_DEAD, ROUTING_KEY2);<br><br>        System.out.println(<span class="hljs-string">&quot;----------等待接收消息----------&quot;</span>);<br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot;Consumer01 接收到消息 &quot;</span> + message);<br>        &#125;;<br>        channel.basicConsume(QUEUE_NORMAL, <span class="hljs-literal">false</span>, deliverCallback, consumer -&gt; &#123;&#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>先启动消费者1再关闭，模拟消费者接收不到消息，再启动生产者</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657784417355-1fe19cd7-61ee-4e83-afa6-f29aa73671a0.png" alt="img" style="zoom:80%;" /><p>等到设置的过期时间10s到达后，消息就会送达到死信队列</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657784627848-f85d4922-d27c-46f0-abc7-d3e6ee53fb71.png" alt="img" style="zoom:80%;" /><p>以上操作完成后，启动消费者2，消费死信队列中的消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TTLConsumer2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_DEAD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;deadExchange&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_DEAD</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;deadQueue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTING_KEY2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LiSi&quot;</span>;     <span class="hljs-comment">//死信队列routing-key</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_DEAD, BuiltinExchangeType.DIRECT);<br>        channel.queueDeclare(QUEUE_DEAD, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.queueBind(QUEUE_DEAD, EXCHANGE_DEAD, ROUTING_KEY2);<br><br>        System.out.println(<span class="hljs-string">&quot;----------等待接收消息----------&quot;</span>);<br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot;TTLConsumer2接收到-----&gt;&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(QUEUE_DEAD, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657784722560-26360135-54d9-4b23-b401-3d52642e309f.png" alt="img" style="zoom:80%;" /><h3 id="死信之最大长度"><a href="#死信之最大长度" class="headerlink" title="死信之最大长度"></a>死信之最大长度</h3><p>1、将生产者代码设置TTL的部分注释</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657785108809-255e6577-7f9f-4ae3-a044-91480dd085f3.png" alt="img" style="zoom: 80%;" /><p>2、修改消费者1代码，设置队列接收消息的长度</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657785167054-e9f826b1-8b1b-457c-97b1-4e59cae1ea68.png" alt="img" style="zoom:80%;" /><p>3、和上面示例类似，先启动消费者1再关闭，模拟正常队列无法接收消息；再发送消费者，查看消息是否到达了死信队列</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657786705553-2f7fecbd-59d2-4e32-823b-4cd8f1925a8c.png" alt="img" style="zoom:80%;" /><p>4、启动消费者2消费死信队列中的消息即可</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657786766060-55d7b605-9d81-4ab1-8e65-d6b54cabc5c0.png" alt="img" style="zoom:80%;" /><h3 id="死信之消息拒绝"><a href="#死信之消息拒绝" class="headerlink" title="死信之消息拒绝"></a>死信之消息拒绝</h3><p>1、生产者不变，消费者1将队列最大长度限制注释，将<code>DeliverCallback</code>回调重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>    <span class="hljs-keyword">if</span> (msg.equals(<span class="hljs-string">&quot;INFO_5&quot;</span>)) &#123;<br>        System.out.println(<span class="hljs-string">&quot;TTLConsumer1拒收消息-----&gt;&quot;</span> + msg);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * requeue设置为false表示拒绝重新入队</span><br><span class="hljs-comment">         * 该队列如果配置了死信队列，交换机就会将消息发送到死信队列，否则会丢弃</span><br><span class="hljs-comment">         */</span><br>        channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TTLConsumer1接收到-----&gt;&quot;</span> + msg);<br>        channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;;<br>channel.basicConsume(QUEUE_NORMAL, <span class="hljs-literal">false</span>, deliverCallback, consumer -&gt; &#123;<br>&#125;);<br></code></pre></td></tr></table></figure><p>2、启动生产者后，发送10条消息。再启动消费者1和消费者2，可以查看到消费者1拒收了<code>INFO_5</code>，而消费者2消费了<code>INFO_5</code></p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657787046112-42c55314-bdc7-4649-bdb9-2c45b35da533.png" alt="img" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4、RabbitMQ交换机</title>
    <link href="/20230511/72a21c93/"/>
    <url>/20230511/72a21c93/</url>
    
    <content type="html"><![CDATA[<h2 id="交换机概念"><a href="#交换机概念" class="headerlink" title="交换机概念"></a>交换机概念</h2><p>之前的示例，都是按照<code>生产者--&gt;消息队列--&gt;消费者</code>的概念进行的</p><p>实际上RabbitMQ消息传递模型的核心思想是：<strong>生产者的消息从来不会直接发送到队列</strong>。事实上，生产者甚至不知道消息会被发到哪个队列</p><p>相反，生产者只能将消息发送到交换器。交换器工作内容非常简单：一方面它接收来自生产者的消息，另一方面它将它们推送到队列中。交换器必须确切地知道如何处理它收到的消息。是推送到特定队列还是多个队列亦或是丢弃，而这就由交换机的类型决定。</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657175708664-46a07f76-04f2-440a-96aa-a3a225aa2738.png" alt="img" style="zoom:80%;" /><p>交换器有几个基本类型：<code>fanout</code>、<code>Direct</code>、<code>topic</code>、<code>headers</code>。其中<code>headers</code>已经基本弃用了</p><p>通常情况下都是生产者发送消息后才会执行消费者操作，因此一般交换机都是由生产者创建，且声明一次即可</p><h3 id="无名exchange"><a href="#无名exchange" class="headerlink" title="无名exchange"></a>无名exchange</h3><p>之前的DEMO好没有明确用过exchange，但是仍能够将消息发到队列中，因为已经指定了默认的交换机。<code>channel.basicPublish</code>的第一个参数即为交换机，之前都用空字符串标识：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br></code></pre></td></tr></table></figure><p>默认交换机会隐式地绑定到每个队列上，RoutingKey即为队列名称。默认交换机不能显式绑定或者解绑，也不能删除</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657266583824-e3d7718d-2881-4a80-be0f-548568758561.png" alt="img" style="zoom: 67%;" /><h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><p>可以看到上面的<code>basicPublish</code>指定了队列名QUEUE_NAME，用于确定消息会发送到哪个队列。</p><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。</p><p>可以通过以下方式创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br></code></pre></td></tr></table></figure><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657269026760-961d8b83-a75e-4224-9468-3439ea26aa57.png" alt="img" style="zoom:80%;" /><h3 id="绑定Bindings"><a href="#绑定Bindings" class="headerlink" title="绑定Bindings"></a>绑定Bindings</h3><p>在最上面的图中，交换机X如何将消息发到指定队列上？对应的两个箭头实际上就是两个<code>Binding</code>：它声明了交换机和队列的绑定关系，在绑定时会有一个BindingKey，这样RabbitMQ就知道如何正确将消息路由到指定队列了。</p><p>生产者发送代码到交换机时，会提供一个RoutingKey，当RoutingKey和BindingKey相匹配时，消息就会发到对应的队列中了</p><h2 id="Fanout类型"><a href="#Fanout类型" class="headerlink" title="Fanout类型"></a>Fanout类型</h2><p><code>fanout</code>类型又称广播类型，它会将消息发送到所有队列上</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657268264623-56b3d342-177f-4d96-b300-225f581f3b82.png" alt="img" style="zoom:80%;" /><p>为了说明这种模式，我们将构建一个简单的日志DEMO，生产者生产日志，两个消费者一个将日志输出到文件，一个输出到控制台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutProducer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 声明一个exchange</span><br><span class="hljs-comment">         * 参数一：exchange的名称</span><br><span class="hljs-comment">         * 参数二：exchange的类型</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>            channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>, msg.getBytes(StandardCharsets.UTF_8));<br>            System.out.println(<span class="hljs-string">&quot;生产者EmitLogs发出消息：&quot;</span> + msg);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费者输出日志到文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutConsumer1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 随机生成一个临时队列</span><br><span class="hljs-comment">         * 当消费者与该队列断开连接时，队列自动删除</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">// 把该临时队列绑定到exchange，其中routingkey(也称之为 binding key)为空字符串</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息。。。。。。。。。。保存到文件&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:\\data\\rabbitmq.txt&quot;</span>);<br>            FileUtils.writeStringToFile(file, msg, StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;数据写入文件成功&quot;</span>);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费者输出日志到控制台</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutConsumer2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 随机生成一个临时队列</span><br><span class="hljs-comment">         * 当消费者与该队列断开连接时，队列自动删除</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> channel.queueDeclare().getQueue();<br>        <span class="hljs-comment">// 把该临时队列绑定到exchange，其中routingkey(也称之为 binding key)为空字符串</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;等待接收消息。。。。。。。。。。输出控制台&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;接收到的消息：&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到消费者1成功将日志写到了指定文件中，而消费者而打印了日志，内容相同</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657268654683-dfd8d446-3946-4994-a620-d02065885fe5.png" alt="img" style="zoom:65%;" /><h2 id="Direct类型"><a href="#Direct类型" class="headerlink" title="Direct类型"></a>Direct类型</h2><p>相比于fanout类型向所有队列广播消息，有时业务场景需要根据日志的不同级别分别输出，比如warning和error输出到文件中，info就打印到控制台，这时就不能广播消息了，此时可以使用<code>Direct</code>类型：它通过对比消息的RoutingKey和队列BindingKey，将消息发送到对应队列中。</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657270482095-66cfc377-1e2f-4483-9f88-a919e129d483.png" alt="img" style="zoom:80%;" /><p>如图的<code>direct交换机</code>绑定到了Q1、Q2，其中Q1的BindingKey是orange，Q2的BindingKey是black和green，即生产者在发送消息是的RoutingKey为orange时会发送到消息Q1、是black或green时会到Q2。加入Q1和Q2用了一样的BindingKey，那么此时的<code>direct</code>就和<code>fanout</code>效果相同了</p><p>代码DEMO如下：生产者创建多个BindingKey，每个BindingKey发送一条消息；消费者1的<code>queueBind</code>绑定error、消费者2的<code>queueBind</code>绑定info和warning，而没有绑定到任何队列的debug级别消息就丢弃</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectProducer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-comment">// 创建多个bindingKey</span><br>        HashMap&lt;String, String&gt; keyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        keyMap.put(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;info信息&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;warning&quot;</span>, <span class="hljs-string">&quot;warning警告&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;error错误&quot;</span>);<br>        <span class="hljs-comment">// debug不设置消费者接收，查看效果是全部丢失</span><br>        keyMap.put(<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-string">&quot;debug调试&quot;</span>);<br><br><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; keyEntry : keyMap.entrySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyEntry.getKey();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> keyEntry.getValue();<br>            channel.basicPublish(EXCHANGE_NAME, key, <span class="hljs-literal">null</span>, value.getBytes(StandardCharsets.UTF_8));<br>            System.out.println(<span class="hljs-string">&quot;生产者发送消息：&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectConsumer1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;disk&quot;</span>;<br>        <span class="hljs-comment">// 队列声明</span><br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 队列绑定</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;error&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;error等待接收消息。。。&quot;</span>);<br><br>        <span class="hljs-comment">// 回调函数</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;接收绑定键：&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="hljs-string">&quot;,消息：&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectConsumer2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;direct_logs&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;console&quot;</span>;<br>        <span class="hljs-comment">// 队列声明</span><br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 队列绑定</span><br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;info&quot;</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;warning&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;info&amp;&amp;warning等待接收消息。。。&quot;</span>);<br><br>        <span class="hljs-comment">// 回调函数</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;接收绑定键：&quot;</span> + delivery.getEnvelope().getRoutingKey() + <span class="hljs-string">&quot;,消息：&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如图</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657270418677-9e85644d-a472-486f-bf3a-4cec836605a3.png" alt="img" style="zoom: 67%;" /><h2 id="Topic类型"><a href="#Topic类型" class="headerlink" title="Topic类型"></a>Topic类型</h2><p>上面对广播的消息做了改造，使得可以按照不同的级别(RoutingKey)发送消息到指定队列，实现有选择的接收日志。不过direct也有一定局限性，例如info下可能是不同模块的日志，比如<code>info.common</code>、<code>info.msg</code>之类，如果都通过direct就会定义过多的BindingKey且拓展性较差，这时就可以使用<code>topic</code>类型</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657272750395-78a5e31e-ef63-4757-9a3d-858231f9ed64.png" alt="img" style="zoom:80%;" /><p><code>topic</code>类型相当于”高级版的<code>direct</code>类型“，它支持在队列绑定时对RoutingKey使用通配符，其中RoutingKey由一个或多个单词组成，单词间通过<code>.</code>连接。例如：<code>rabbit.test.hello</code>、<code>kafka.port.what</code> 不过它不能超过255个字节，并且它可以使用通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**   通配符匹配规则</span><br><span class="hljs-comment"> *      * 匹配一个单词</span><br><span class="hljs-comment"> *      # 匹配一个或多个单词</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>以上图为例：</p><ul><li>RoutingKey凡是长度为三且中间单词为orange的消息，都会发到Q1中</li><li>RoutingKey凡是长度为三且最后单词为rabbit的消息，都会发到Q2中</li><li>RoutingKey凡是以lazy开头的消息都会发到Q2中</li></ul><p>【注】消息只会被消费一次，所以如果有消息（例如<code>lazy.test.rabbit</code>）同时满足Q2的两个条件，它也只会被Q2消费一次</p><table><thead><tr><th><strong>RoutingKey类型</strong></th><th><strong>消费情况</strong></th><th></th></tr></thead><tbody><tr><td>quick.orange.rabbit</td><td>被队列 Q1、Q2 接收</td><td></td></tr><tr><td>azy.orange.elephant</td><td>被队列 Q1、Q2 接收</td><td>被队列 Q1Q2 接收到</td></tr><tr><td>quick.orange.fox</td><td>被队列 Q1 接收</td><td>被队列 Q1 接收到</td></tr><tr><td>lazy.brown.fox</td><td>被队列 Q2 接收到</td><td></td></tr><tr><td>lazy.pink.rabbit</td><td>虽然满足两个绑定但只被队列 Q2 接收一次</td><td></td></tr><tr><td>quick.brown.fox</td><td>不匹配任何绑定，不会被接收，会被丢弃</td><td></td></tr><tr><td>quick.orange.male.rabbit</td><td>是四个单词不匹配任何绑定会被丢弃</td><td></td></tr><tr><td>lazy.orange.male.rabbit</td><td>满足Q2条件，被Q2接收</td><td></td></tr></tbody></table><p>参照上面，编写demo代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopicProducer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_exchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Q1绑定：中间带orange的3个单词字符串—&gt; *.orange.*</span><br><span class="hljs-comment">         * Q2绑定：最后一个单词为rabbit的3个单词字符串—&gt; *.*.rabbit 或 首单词为lazy的多单词-&gt; lazy.#</span><br><span class="hljs-comment">         */</span><br>        HashMap&lt;String, String&gt; keyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        keyMap.put(<span class="hljs-string">&quot;quick.orange.rabbit&quot;</span>, <span class="hljs-string">&quot;被队列 Q1Q2 接收到&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;lazy.orange.elephant&quot;</span>, <span class="hljs-string">&quot;被队列 Q1Q2 接收到&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;quick.orange.fox&quot;</span>, <span class="hljs-string">&quot;被队列 Q1 接收到&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;lazy.brown.fox&quot;</span>, <span class="hljs-string">&quot;被队列 Q2 接收到&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;lazy.pink.rabbit&quot;</span>, <span class="hljs-string">&quot;虽然满足 Q2 的两个绑定,但只被队列 Q2 接收一次&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;quick.brown.fox&quot;</span>, <span class="hljs-string">&quot;不匹配任何绑定不会被任何队列接收到 会被丢弃&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;quick.orange.male.rabbit&quot;</span>, <span class="hljs-string">&quot;是四个单词不匹配任何绑定 会被丢弃&quot;</span>);<br>        keyMap.put(<span class="hljs-string">&quot;lazy.orange.male.rabbit&quot;</span>, <span class="hljs-string">&quot;是四个单词但匹配 Q2&quot;</span>);<br><br><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; keyEntry : keyMap.entrySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyEntry.getKey();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> keyEntry.getValue();<br>            channel.basicPublish(EXCHANGE_NAME, key, <span class="hljs-literal">null</span>, (key + value).getBytes(StandardCharsets.UTF_8));<br>            System.out.println(<span class="hljs-string">&quot;生产者发送消息：&quot;</span> + value);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费者1  *.orange.*</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopicConsumer1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_exchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Q1&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;*.orange.*&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Q1等待接收消息。。。&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;Q1接收到的消息：&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费者2   *.*.rabbit  lazy.#</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopicConsumer2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;topic_exchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Q2&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;*.*.rabbit&quot;</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, <span class="hljs-string">&quot;lazy.#&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Q2等待接收消息。。。&quot;</span>);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);<br>            System.out.println(<span class="hljs-string">&quot;Q2接收到的消息：&quot;</span> + msg);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">true</span>, deliverCallback, consumer -&gt; &#123;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后可以查看到名为<code>topic_exchange</code>的交换机下，有对应的三个<code>Bindings</code></p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657434093508-7a1ce8c2-bf13-43e7-97c8-a36d9573bbbf.png" alt="img" style="zoom:80%;" /><p>查看消费者1和消费者2的控制台，看到正确获取了响应的消息：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657434360638-f4cc592f-5a61-4bc1-8e7a-d56550f15441.png" alt="img" style="zoom:80%;" /><h2 id="交换机持久化"><a href="#交换机持久化" class="headerlink" title="交换机持久化"></a>交换机持久化</h2><p>交换机默认是没有持久化的，因此RabbitMQ重启后交换机就会丢失，对于常用的交换机应该设置持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *参数一:  交换机名称</span><br><span class="hljs-comment"> *参数二:  交换机类型</span><br><span class="hljs-comment"> *参数三:  是否持久化</span><br><span class="hljs-comment"> */</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;交换机名称&quot;</span>, BuiltinExchangeType.XXXX,<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h2 id="Return消息机制"><a href="#Return消息机制" class="headerlink" title="Return消息机制"></a>Return消息机制</h2><p>在消息应答一节中提到<code>发送确认</code>——确保消息从生产者到交换机。那么消息从交换机到队列的过程中要怎样保证可靠性呢？这就需要return机制</p><p>Return机制：监控交换机是否将消息发送到指定队列。对于队列不存在或者RoutingKey无法路由到的消息，都需要进行捕获，通过<code>addReturnListener</code>方法添加<code>ReturnListener</code>回调接口，该接口有一个方法<code>handleReturn</code>用于处理交换机到队列路由失败的消息</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657436096461-1ba0e68d-94ab-4319-a1c9-9f9be506b74a.png" alt="img" style="zoom:80%;" /><p>编写简单DEMO测试</p><ul><li>生产者的RoutingKey为vip消息</li><li>消费者的BindingKey为普通用户消息</li><li>观察是否会进入回调方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnProducer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;return_exchange&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NORMAL_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">VIP_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;vip&quot;</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        channel.addReturnListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnListener</span>() &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * replyCode：路由是否成功的响应码</span><br><span class="hljs-comment">             * replyText：文本说明</span><br><span class="hljs-comment">             * exchange：具体路由到的交换机</span><br><span class="hljs-comment">             * routingKey：路由键</span><br><span class="hljs-comment">             * properties：消息配置</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReturn</span><span class="hljs-params">(<span class="hljs-type">int</span> replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties basicProperties, <span class="hljs-type">byte</span>[] bytes)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                System.out.println(<span class="hljs-string">&quot;----------------------进入回调方法----------------------&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;Listener获取到无法路由的消息：\n&quot;</span> +<br>                        <span class="hljs-string">&quot;replyCode：&quot;</span> + replyCode + <span class="hljs-string">&quot;\n&quot;</span> +<br>                        <span class="hljs-string">&quot;replyText：&quot;</span> + replyText + <span class="hljs-string">&quot;\n&quot;</span> +<br>                        <span class="hljs-string">&quot;exchange：&quot;</span> + exchange + <span class="hljs-string">&quot;\n&quot;</span> +<br>                        <span class="hljs-string">&quot;routingKey：&quot;</span> + routingKey + <span class="hljs-string">&quot;\n&quot;</span> +<br>                        <span class="hljs-string">&quot;properties：&quot;</span> + basicProperties + <span class="hljs-string">&quot;\n&quot;</span> +<br>                        <span class="hljs-string">&quot;body：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 指定mandatory为true，会将不可路由的消息返回给生产者，设置为false时broker会直接丢弃不可路由的消息</span><br><span class="hljs-comment">         * 指定queue为vip而消费端为normal，无法路由就会触发回调函数</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(EXCHANGE_NAME, NORMAL_KEY, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;测试不可路由的消息文本&quot;</span>.getBytes(StandardCharsets.UTF_8));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnConsumer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;return_exchange&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">VIP_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;vip&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;queue_vip&quot;</span>;<br>        channel.queueDeclare(queueName, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.queueBind(queueName, EXCHANGE_NAME, VIP_KEY);<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;VIP接收到的消息：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8));<br>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>        &#125;;<br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> consumer -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;取消消费！&quot;</span>);<br>        &#125;;<br>        channel.basicConsume(queueName, <span class="hljs-literal">false</span>, deliverCallback, cancelCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如图可以看到成功调用回调方法</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657436841518-bc5f9d03-cff7-4a79-9537-ce77f2a84cab.png" alt="img" style="zoom:80%;" /><p>mandatory 和 immediate 他们都有当消息传递过程中不可达目的地时将消息 <strong>返回给生产者</strong> 的功能</p><p>RabbitMQ 提供的 <strong>备份交换器（Alternate Exchange）</strong> 可以将 <strong>未能被交换器路由</strong>（没有绑定队列或没有匹配的队列） 的消息存储起来，而不用返回给客户端</p><h3 id="mandatory参数"><a href="#mandatory参数" class="headerlink" title="mandatory参数"></a>mandatory参数</h3><ul><li>true：找不到匹配的队列，会将消息返回给生产者</li><li>false：找不到匹配的队列，直接丢弃</li></ul><p>交换机无法根据自身类型和路由键将消息传递到某个队列上时，会调用<code>Basic.Return</code>将消息返回给生产者，生产者通过<code>addReturnListener</code>添加返回监听，来处理未能成功路由的消息</p><h3 id="immediate参数"><a href="#immediate参数" class="headerlink" title="immediate参数"></a>immediate参数</h3><p>当设置immediate参数为 true ，如果交换器在将消息路由到队列时，发现 <strong>队列上并不存在任何消费者</strong>，那么该 <strong>消息将不会存入队列中</strong>。当与路由键匹配的所有队列都没有消费者时，会通过<code>Basic.Return</code>返回给生产者。</p><p>二者对比</p><ul><li>mandatory ：要求消息至少被路由到一个队列中，要么丢弃、要么返回给生产者</li><li>immediate：要求至少有一个订阅者，否则就返回给生产者。</li></ul><p><strong>RabbitMQ 3.+ 版本后不再对immediate支持</strong>，官方解释：该参数会影响镜像队列的性能，增加代码复杂性。建议采用 TTL 和 DLX 的方法替代</p><h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p>如果设置了<code>mandatory = false</code>，未被路由的消息会被丢弃，<code>mandatory = true</code>则需要生产者通过Return监听处理未被路由的消息。</p><p>备份交换机（<code>Alternate Exchange</code>简称AE），如果不想丢失消息，又不想自己立即接收处理这些消息，则可以使用这个备份交换器，<strong>在需要的时候再去处理</strong>这些消息</p><p>可以通过两种方式实现：</p><ol><li>可以在声明交换器时，增加<code>alternate-exchange</code>参数实现</li><li>可以通过策略（Policy）</li></ol><p>如果两种方式同时使用，前者的优先级更高，会覆盖掉 Policy 的设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义备份交换器</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;myAe&quot;</span>, <span class="hljs-string">&quot;fanout&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueDeclare(<span class="hljs-string">&quot;unroutedQueue&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind(<span class="hljs-string">&quot;unroutedQueue&quot;</span>, <span class="hljs-string">&quot;myAe&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-keyword">final</span> HashMap&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>arguments.put(<span class="hljs-string">&quot;alternate-exhcange&quot;</span>, <span class="hljs-string">&quot;myAe&quot;</span>);<br><span class="hljs-comment">// 使用备用交换器 myAe</span><br>channel.exchangeDeclare(<span class="hljs-string">&quot;normalExchange&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, arguments);<br>channel.queueDeclare(<span class="hljs-string">&quot;normalQueue&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>channel.queueBind<span class="hljs-string">&quot;normalQueue&quot;</span>, <span class="hljs-string">&quot;normalExchange&quot;</span>, ROUTING_KEY);<br></code></pre></td></tr></table></figure><p>以上代码的逻辑即为：</p><ul><li>使用部分：定义了一个normal交换机和队列，交换机的参数添加<code>alternate-exhcange</code>，用于声明normal队列的消息不可达时，将消息存放到备份交换机</li><li>定义部分：声明了备份交换机的定义，并绑定到用于存放不可路由消息的队列</li></ul>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3、RabbitMQ限流&amp;发布确认</title>
    <link href="/20230511/f2906e60/"/>
    <url>/20230511/f2906e60/</url>
    
    <content type="html"><![CDATA[<h2 id="消息分发策略"><a href="#消息分发策略" class="headerlink" title="消息分发策略"></a>消息分发策略</h2><p>默认的消息分发策略是<strong>轮询</strong>，参照上面的消息应答可以看出会有一定问题——消息处理慢的 <code>AckConsumer1</code> 和消息处理快的 <code>AckConsumer2</code> 分配了同等数量的消息，导致2早就结束空闲了，而1还有好几条消息没开始处理！因此看似公平的轮询分发其实是并不公平的</p><p>因此需要引入<strong>公平分发策略（Fair Dispatch）</strong>——在消费者中引入设置了 <code>prefetchCount=1</code> 参数的 <code>basicQos</code> 方法，它告诉了rabbitmq不要一次向该消费者传递过多消息</p><p>尚硅谷和评论区的两份笔记，都将这个叫做不公平分发，但是我在官方tutorial上看到的介绍时Fair Dispath</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657007480908-b0ed3fd5-57f1-4dfc-b21c-d93e8f3a0352.png" alt="img" style="zoom:80%;" /><p>通过<code>fair dispatch</code>和手动应答来控制消费者每次处理的消息数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// fiar dispatch</span><br><span class="hljs-type">int</span> <span class="hljs-variable">prefetchCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>channel.basicQos(prefetchCount);<br><span class="hljs-comment">// 手动应答</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>channel.basicConsume(TASK_QUEUE_NAME, autoAck, deliverCallback, cancelCallback);<br></code></pre></td></tr></table></figure><p>参数<code>prefecthCount</code>表示该消费者<strong>能积压在信道上的预处理消息数最大值</strong>：</p><ul><li>消费者通过<code>basicQos</code>方法设置了预取值后，对应的信道上最多只能积压<code>prefetchCount</code>条消息</li><li>达到对应数量后，RabbitMQ就不会向该信道传递消息</li><li>如果所有队列都达到积压上限，消息就会积压在队列中撑满队列，这个时候就只能添加新的消费者或者改变存储策略</li><li>通常增加预取值可以提高向消费者传递消息的速度，但是无限制的自动应答或者过大值会导致消费者节点内存消耗过大，因此合理的预取值需要反复试验，通常100-300之间</li></ul><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657008320923-af5cded8-cef3-42a3-8e36-7f49aabe939a.png" alt="img" style="zoom:80%;" /><h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><p>消费者宕机过程中MQ上囤积大量消息，重启消费者服务后消息瞬间涌入，造成消息消费服务压力剧增，因此大流量下消息消费端需要进行限流设置</p><p>在非自动确认消息的前提下，如果一定数量的消息（基于Consumer和Channel设置QOS的值）没有被确认，将不进行消费新的消息</p><p>1、生产者使用线程池模拟大量消息的发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LimitProducer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;slowQueue&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fastExchange&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);<br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;limit&quot;</span>);<br><br>        <span class="hljs-comment">// 使用线程池模拟短时间大量消息发送</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Thread.currentThread().getName()+<span class="hljs-string">&quot;_&quot;</span>+i;<br>            <span class="hljs-keyword">try</span> &#123;<br>                channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;limit&quot;</span>, <span class="hljs-literal">null</span>, msg.getBytes());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        threadPool.shutdown();<br>        <span class="hljs-keyword">while</span> (!threadPool.isTerminated()) &#123;<br><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;所有消息发送完成&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LimitConsumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;slowQueue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">// 消费成功回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// 模拟业务操作</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;收到的消息为：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody()));<br>            <span class="hljs-comment">//channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br>        &#125;;<br>        <span class="hljs-comment">// 消费取消回调</span><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> cancel -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;取消消费&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 参数一：单条消息大小限制，一般为0不限制</span><br><span class="hljs-comment">         * 参数二：一次性消费的消息数量</span><br><span class="hljs-comment">         * 参数三：限流设置应用于channel(true)还是consumer(false)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">//channel.basicQos(0, 10, false);</span><br>        channel.basicConsume(QUEUE_NAME,<span class="hljs-literal">true</span>,deliverCallback,cancelCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到设置了<code>Qos</code>后消费10条消息就结束了，由于将应答注释了所以不会继续消费</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657788530091-d93bc039-cf19-4333-8675-0aebef171f60.png" alt="img" style="zoom:80%;" /><p>放开应答的注释，可以看到持续消费，每次<code>Unacked</code>的都是10条，速率也是每秒一条</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657788655762-690e9fe9-6818-4f97-bf62-8093423d5b2a.png" alt="img" style="zoom:80%;" /><h2 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h2><p>上面是通过持久化来保障在服务器崩溃时，消息不会丢失。但是生产者发布消息后，消息是否能正确到达Broker服务器呢？默认情况下消息发出后是不会有返回信息的，所以需要引入发布确认机制</p><p>消息被投递到匹配的队列后，Broker会返回一个确认信息给生产者，这个操作叫做<strong>消息确认发布，</strong>它有两种方式：</p><ol><li>通过事务机制实现：设置 channel 为 transaction 模式，这是 AMQP协议层面提供的解决方案</li><li>通过发送方确认实现：设置 channel 为 confirm 模式，这是 RabbitMQ 提供的解决方案</li></ol><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><p>RabbitMQ 客户端中与事务机制有关的方法有三个</p><ul><li><code>channel.txSelect</code>：用于将当前 channel 设置成 transaction 模式</li><li><code>channel.txCommit</code>：用于提交事务</li><li><code>channel.txRollback</code>：用于回滚事务</li></ul><p><code>channel.txSelect</code>将当前信道开启为事务模式后，生产者就可以发布消息给Broker服务器了，如果<code>channel.txCommit</code>提交成功了，则消息一定到达了broker了，如果在 <code>channel.txCommit</code>执行之前 broker 异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过<code>channel.txRollback</code>回滚事务。如图是正常提交事务的，对于使用回滚需要通过<code>try/catch</code>捕获发生的异常，Publish后也不是正常的Commit，而是异常的Rollback</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657087189068-c913b1f3-55a9-487d-bab0-0508e20f83fc.png" alt="img" style="zoom:80%;" /><p>事务确实能够解决 producer 与 broker 之间消息确认的问题，只有消息成功被 broker 接收，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作，同时进行消息重发，但是使用事务机制的话会降低RabbitMQ的性能。RabbitMQ提供了改进方案，即发送方确认（Confirm确认）</p><h3 id="confirm模式"><a href="#confirm模式" class="headerlink" title="confirm模式"></a>confirm模式</h3><h4 id="发布确认逻辑"><a href="#发布确认逻辑" class="headerlink" title="发布确认逻辑"></a>发布确认逻辑</h4><p>生产者将信道设置成 confirm 模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker回传给生产者的确认消息中的<code>delivery-tag</code>包含了确认消息的序列号，此外broker也可以设置<code>basic.ack</code>的 multiple参数，表示到这个序号之前的所有消息都已经得到了处理。</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657087502262-4d4a734b-ef1f-4b85-83b9-3cf1b0e60a33.png" alt="img" style="zoom:80%;" /><p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><p>发布确认默认是没有开启的，通过在信道上设置开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开启发布确认</span><br>channel.confirmSelect();<br></code></pre></td></tr></table></figure><h4 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h4><p>单个发布确认是一种简单的发布确认方式：生产者发布一个消息之后只有等收到确认才会发送下一个，它是一种<strong>同步确认发布</strong>的方式。<code>waitForConfirmsOrDie(long)</code>这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p>这种方式最大的缺点是发布速度很慢，效率低，每秒只能不超过数百条数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">singleConfirm</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>    channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 开启发布确认</span><br>    channel.confirmSelect();<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MSG_COUNT; i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;消息_&quot;</span> + i;<br>        System.out.println(<span class="hljs-string">&quot;生产了：&quot;</span> + msg);<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes());<br>        <span class="hljs-comment">// 服务端返回 false 或超时时间内未返回，生产者可以消息重发</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> channel.waitForConfirms();<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            System.out.println(msg + <span class="hljs-string">&quot;已发送到队列中&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;发布了 &quot;</span> + MSG_COUNT + <span class="hljs-string">&quot; 个单独确认消息，耗时：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到每次都是<code>waitForConfirms</code>之后才发送下一条：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657075515953-df32b9f9-2f44-4a36-a2ab-5f4bd2959ccd.png" alt="img" style="zoom:80%;" /><h4 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h4><p>批量确认模式也是一种<strong>同步确认发布</strong>的方式，先发布一批消息再一起确认，这样可以提高吞吐量，不过如果如果出现问题不能定位到具体的消息上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">batchConfirm</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>    channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>    channel.confirmSelect();<br>    <span class="hljs-comment">// 批量确认size</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">batchSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">// 待确认的消息个数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">size4Confirm</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MSG_COUNT; i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;消息_&quot;</span> + i;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes());<br>        size4Confirm++;<br>        <span class="hljs-keyword">if</span> (size4Confirm == batchSize) &#123;<br>            channel.waitForConfirms();<br>            size4Confirm = <span class="hljs-number">0</span>;<br>            System.out.println(<span class="hljs-string">&quot;批量确认，最新的消息是：&quot;</span> + msg);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//为了确保还有剩余没有确认消息 再次确认</span><br>    <span class="hljs-keyword">if</span> (size4Confirm &gt; <span class="hljs-number">0</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;处理剩余的未确认消息&quot;</span>);<br>        channel.waitForConfirms();<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;发布了 &quot;</span> + MSG_COUNT + <span class="hljs-string">&quot; 个批量确认消息，耗时：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到每一百个消息进行一次确认，当前的100个确认之前不会发送下一批，所以每批消息的确认序号都是固定增加的：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657075878906-402f0f24-0303-4211-b687-f85932cbe6ef.png" alt="img" style="zoom:80%;" /><h4 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h4><p>因为异步非阻塞的特性，异步确认的可靠性和效率都很高，它是通过回调函数来实现消息的可靠传递的</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657075982958-f0c9af4a-80b5-4d00-8979-c61b6dc8ff9e.png" alt="img" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyConfirm1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>    channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>    channel.confirmSelect();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 消息确认成功的回调函数</span><br><span class="hljs-comment">         * 参数一：消息的标记</span><br><span class="hljs-comment">         * 参数二：是否批量确认</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">successCall</span> <span class="hljs-operator">=</span> (deliveryTag, multiple) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;确认的消息：&quot;</span> + deliveryTag);<br>    &#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 消息确认失败的回调函数</span><br><span class="hljs-comment">         * 参数一：消息的标记</span><br><span class="hljs-comment">         * 参数二：是否批量确认</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">failedCall</span> <span class="hljs-operator">=</span> (deliveryTag, multiple) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;未能确认的消息：&quot;</span> + deliveryTag);<br>    &#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 设置异步确认模式的消息确认监听器</span><br><span class="hljs-comment">         * 参数一：成功的回调</span><br><span class="hljs-comment">         * 参数二：失败的回调</span><br><span class="hljs-comment">         */</span><br>    channel.addConfirmListener(successCall, failedCall);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MSG_COUNT; i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;消息_&quot;</span> + i;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes());<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;发布了 &quot;</span> + MSG_COUNT + <span class="hljs-string">&quot; 个异步确认消息，耗时：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到消息的确认是异步进行的，并没有特定的串行顺序：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657093167844-de63969a-ebb5-47a2-9555-0c09c7563351.png" alt="img" style="zoom:80%;" /><h4 id="如何处理未被确认的消息？"><a href="#如何处理未被确认的消息？" class="headerlink" title="如何处理未被确认的消息？"></a>如何处理未被确认的消息？</h4><p>最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</p><ol><li>通过一个并发队列，将所有要发送的消息加到队列中</li><li>在发布确认的回调函数中删除已确认的消息，剩下的就是未确认的消息了</li><li>在失败的回调函数中处理未确认的消息，比如重发或者打印出来</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyConfirm2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>    channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>    channel.confirmSelect();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 用于存储消息的线程安全队列</span><br><span class="hljs-comment">     * concurrentSkipListMap比concurrentHashMap有更好的并发支持，是一个有序map容器，原理为跳表</span><br><span class="hljs-comment">     */</span><br>    ConcurrentSkipListMap&lt;Long, Object&gt; infoMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 消息确认成功的回调函数：删除已确认的消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">successCall</span> <span class="hljs-operator">=</span> (deliveryTag, multiple) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (multiple) &#123;<br>            <span class="hljs-comment">// 从key=null到截止key，作为指定key合集</span><br>            ConcurrentNavigableMap&lt;Long, Object&gt; confirmed = infoMap.headMap(deliveryTag);<br>            confirmed.clear();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            infoMap.remove(deliveryTag);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;确认的消息：&quot;</span> + deliveryTag);<br>    &#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 消息确认失败的回调函数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">ConfirmCallback</span> <span class="hljs-variable">failedCall</span> <span class="hljs-operator">=</span> (deliveryTag, multiple) -&gt; &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> String.valueOf(infoMap.get(deliveryTag));<br>        System.out.println(<span class="hljs-string">&quot;未能确认的消息：&quot;</span> + deliveryTag + <span class="hljs-string">&quot; ，消息是：&quot;</span> + info);<br>    &#125;;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 设置异步确认模式的消息确认监听器</span><br><span class="hljs-comment">     */</span><br>    channel.addConfirmListener(successCall, failedCall);<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MSG_COUNT; i++) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;消息_&quot;</span> + i;<br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes());<br>        <span class="hljs-comment">// 记录所有要打的消息，key为下一次发布信息的序号</span><br>        infoMap.putIfAbsent(channel.getNextPublishSeqNo(), msg);<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;发布了 &quot;</span> + MSG_COUNT + <span class="hljs-string">&quot; 个异步确认消息，耗时：&quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657093787471-61fa1944-eba6-4982-8b07-30f6fe950706.png" alt="img" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2、RabbitMQ消息应答&amp;持久化</title>
    <link href="/20230511/62ae0b86/"/>
    <url>/20230511/62ae0b86/</url>
    
    <content type="html"><![CDATA[<h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><p>1、问题引出</p><p>假设消费者处理某个业务功能需要100条消息，现在获取了50条，还没处理完进程就终止了。</p><p>按照入门示例写的代码，未处理的消息就会被直接丢弃，而剩余未发送的50条消息，也不会再发给它了，因为它是不可接收的状态了。即此时这100条消息还未实现对应功能便被丢失了！</p><p>2、解决方案</p><p>为了保证消息能可靠的到达消费者并处理，RabbitMQ引入了消息应答机制（message acknowledgement）——<strong>消费者在接收并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></p><p>如果某个消费者处理时异常结束没有发送应答，RabbitMQ就会认为这条消息没被处理，然后交给另外一个消费者。这样就可以保证即使消费者挂掉也不会丢失消息数据</p><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><p>入门示例中消费者采用的是自动应答——即消息发送后就被认为发送成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br></code></pre></td></tr></table></figure><p>自动应答模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>，</p><ul><li>自动应答没有对传递消息的数量做限制，可以实现消费者接收过载的消息</li><li>但是有可能会使得消费者端产生消息的积压，导致内存耗尽，消费者进程被系统杀死</li><li>而且在消息接收处理完之前，消费者出现问题，那么消息就会丢失</li></ul><p>所以自动应答，应该是在<strong>消费者可以高效并以 某种速率能够处理这些消息的情况下使用</strong></p><h3 id="手动应答"><a href="#手动应答" class="headerlink" title="手动应答"></a>手动应答</h3><p>手动应答即关闭自动应答，在回调逻辑中进行手动处理应答</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 关闭了自动应答</span><br>channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br></code></pre></td></tr></table></figure><p>手动应答有几个实现方法：</p><ul><li><code>Channel.basicAck</code>：用于消息的肯定确认，表示已接收并处理该消息了，MQ可以删除它了</li><li><code>Channel.basicNack</code> ：用于消息的否定确认</li><li><code>Channel.basicReject</code>：用于消息的否定确认，比<code>basicNack</code>少一个参数，如果队列未配置死信队列则直接丢弃，有配置则发送到对应死信队列中</li></ul><h4 id="确认应答"><a href="#确认应答" class="headerlink" title="确认应答"></a>确认应答</h4><p>1、编写代码</p><p>生产者代码保持入门DEMO不动，调整消费者的消费成功回调逻辑即可</p><p>这里是<code>AckConsumer1</code>的处理，<code>AckConsumer2</code>只需要调整延时1秒即可，模拟不同业务的处理时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AckConsumer1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ack_queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        <span class="hljs-comment">// 消费回调逻辑</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始消费&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;模拟实际业务操作，耗时20秒&quot;</span>);<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">20</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;接收到消息：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody()));<br><br>            <span class="hljs-comment">/*  手动应答</span><br><span class="hljs-comment">             *  参数一：消息标记tag</span><br><span class="hljs-comment">             *  参数二：是否批量消费消息(true：应答队列中的所有消息 | false：应答接收到的消息)</span><br><span class="hljs-comment">             */</span><br>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>        &#125;;<br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> (consumerTag) -&gt; &#123;<br>            System.out.println(consumerTag + <span class="hljs-string">&quot;---&gt;消费者取消了消费接口&quot;</span>);<br>        &#125;;<br><br>        System.out.println(<span class="hljs-string">&quot;Work02   等待消费消息........&quot;</span>);<br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">false</span>, deliverCallback, cancelCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、测试</p><ul><li>消费者发送了4条消息，按照默认的轮询逻辑，text1、text3会被<code>AckConsumer1</code>消费，text2、text4会被<code>AckConsumer2</code>消费</li><li>其中<code>AckConsumer1</code>处理并应答的时间较长，中途挂掉了后，未处理的text3消息会重新入队被<code>AckConsumer2</code>消费</li></ul><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657004590812-b7e6d6e2-f9f2-4fc5-9e45-c0ae4f77db82.png" style="zoom:80%;" /><p>通过管理面板也可以看到队列中消息的状态</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657004959127-88d3b238-9175-424d-a2dd-aa7e76762332.png" alt="img" style="zoom:80%;" /><h4 id="否定应答"><a href="#否定应答" class="headerlink" title="否定应答"></a>否定应答</h4><p>否定应答代码与确认应答类似，只是调用方法由<code>basicAck</code>变成<code>basicNack</code>或者<code>basicReject</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*消费者成功消费回调逻辑*/</span><br><span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, message) -&gt; &#123;<br><br>   System.out.println(<span class="hljs-string">&quot;消费者A对消息进行消费!&quot;</span>);<br>   <span class="hljs-keyword">try</span> &#123;<br>     TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);  <span class="hljs-comment">//模拟实际业务操作</span><br>   &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>       e.printStackTrace();<br>   &#125;<br>   System.out.println(<span class="hljs-string">&quot;消费者A接收到的信息为:&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 参数一：  消息标记tag</span><br><span class="hljs-comment">    * 参数二：  是否批量消费消息（true为应答该队列中所有的消息，false为只应答接收到的消息）</span><br><span class="hljs-comment">    * 参数三：  是否重回队列</span><br><span class="hljs-comment">    * */</span><br>    channel.basicNack(message.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);  <span class="hljs-comment">//拒绝消息应答方法1</span><br><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 参数一：  消息标记tag</span><br><span class="hljs-comment">    * 参数二：  是否重回队列</span><br><span class="hljs-comment">    * */</span><br>    channel.basicReject(message.getEnvelope().getDeliveryTag(),<span class="hljs-literal">false</span>);       <span class="hljs-comment">//拒绝消息应答方法2</span><br><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>持久化分为三个部分：交换器持久化、队列持久化、消息持久化</p><p>其中如果交换器不设置持久化，mq重启后并不会丢失消息，丢失的是该交换器的元数据，只是之后不能将消息发送到该交换机了，对于常用的交换机建议将其持久化。交换器的持久化在声明方法<code>exchangeDeclare</code>中设置durable参数为true即可</p><p>上面的消息应答，作用是避免消费者出现事故时消息丢失，而如果要避免RabbitMQ出现事故导致的消息丢失，则需要<strong>将队列和消息标记为持久化的</strong></p><h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p>之前声明队列的第二个参数durable默认都是false，即非持久化的，rabbitmq如果重启就会删改该队列，将参数设置为true后可以保证队列不被删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//让队列持久化</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">durable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//声明队列</span><br>channel.queueDeclare(TASK_QUEUE_NAME, durable, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>在生产者声明队列时设置持久化参数后，可以在管理面板中查看</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657005848793-65f41b46-3f42-4fc8-8bf7-e900da2189c6.png" alt="img" style="zoom:80%;" /><p>【注】如果之前创建队列<code>dur_queue</code>非持久化，再创建持久化，会报错参数不等价，反之亦然</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657006026388-328c4e4c-9129-4546-8496-05a72c76fd6b.png" alt="img" style="zoom:80%;" /><h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>队列持久化只能保证rabbitmq下线时不会删除队列，但是队列中的消息如果要不丢失，也需要开启持久化！通过生产者发布消息时第三个参数<code>BasicProperties</code>添加<code>MessageProperties.PERSISTENT_TEXT_PLAIN</code>来实现</p><p>可以将所有消息都设置持久化，但是会影响RabbitMQ性能，因为磁盘的读写速度远慢于内存读写！对于可靠性不高的消息可以不采取持久化。对于消息持久化的选择需要综合可靠性和吞吐量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//basicProperties设置为PERSISTENT_TEXT_PLAIN：以text/plain形式将消息持久化到磁盘中</span><br>channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());<br></code></pre></td></tr></table></figure><p>将队列、消息都设置为持久化后，就能百分百保证消息不丢失了吗？当然是不行的！</p><ol><li>如果消费者设置自动应答，应答后没处理就宕机了，那应答的消息肯定就丢失了。这一部分可以通过手动应答处理</li><li>RabbitMQ并不会每次遇到一条持久化的消息都（调用内核的fsync）进行同步存盘操作，而是会先保存到操作系统的缓存中再存入磁盘，这个时间间隔很短但是存在！如果在这个间隔内发生宕机还是会丢失消息</li></ol><p>因此队列+消息持久化设置持久性保证不强，只能用于一些简单场景，可以采用的参考方案是**MQ集群+发布确认+消息缓存Redis(AOF备份)**来保证消息不丢失</p><h2 id="消息优先级"><a href="#消息优先级" class="headerlink" title="消息优先级"></a>消息优先级</h2><p>消息队列默认是先进先出的，消费顺序也是如此，如果<strong>需要使后面的某些特定消息先进行消费，需要对队列和消息设置优先级</strong></p><p>设置了优先级的队列和消息，会在队列中排序。没有设置优先级的消息依旧按照进入队列的顺序消费，消费者需要在消息进入队列排序完成后消费才能体现优先级。优先级范围为 0~255，值越高优先级越高，且消息优先级不能超过队列优先级</p><p>1、生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;FanoutExchange&quot;</span>; <span class="hljs-comment">//交换机名称</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br>        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);<br><br>        <span class="hljs-comment">// 对队列设置优先级 范围在0-255之间</span><br>        HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>        map.put(<span class="hljs-string">&quot;x-max-priority&quot;</span>, <span class="hljs-number">10</span>);<br>        channel.queueDeclare(<span class="hljs-string">&quot;PriorityQueue&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, map);<br>        channel.queueBind(<span class="hljs-string">&quot;PriorityQueue&quot;</span>, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INFO_&quot;</span> + i;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">final</span> AMQP.<span class="hljs-type">BasicProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AMQP</span>.BasicProperties().builder().priority(<span class="hljs-number">5</span>).build();<br>                channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, properties, msg.getBytes());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>, msg.getBytes());<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;-----消息发送完毕-----&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityConsumer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;PriorityQueue&quot;</span>; <span class="hljs-comment">//交换机名称</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, msg) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;接收到消息：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(msg.getBody()));<br>            channel.basicAck(msg.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>        &#125;;<br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">false</span>, deliverCallback, consumer -&gt; &#123;&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到对3取余为0的消息<code>0、3、6、9</code>被提前消费了</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1657789513216-c636aa2d-349b-4d2b-ac3e-b89217a51ef8.png" alt="img" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1、RabbitMQ快速入门</title>
    <link href="/20230511/34902a6/"/>
    <url>/20230511/34902a6/</url>
    
    <content type="html"><![CDATA[<h2 id="1、消息队列"><a href="#1、消息队列" class="headerlink" title="1、消息队列"></a>1、消息队列</h2><h3 id="1-1-消息队列的基本概念"><a href="#1-1-消息队列的基本概念" class="headerlink" title="1.1 消息队列的基本概念"></a>1.1 消息队列的基本概念</h3><p>消息（Message）是指在应用层之间传递的数据，比如文本字符串、JSON。现在的互联网系统中，前后端各个组件模块间传递数据信息，都可以称之为消息</p><p>而消息队列中间件（Message Queue Middleware，简称MQ）则是利用 <strong>可靠的消息传递机制</strong>进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过消息模型，它可以在<strong>分布式环境下扩展进程间的通信</strong>。</p><p>基于此，消息队列有两种模型：</p><ol><li><p><strong>点对点模式</strong>（P2P，Point to Point），也可以称作队列模型。基本组成生产者Producer、队列Queue、消费者Consumer，生产者发送消息到队列、消费者从队列中消费消息，总体是一个发-&gt;存-&gt;收的流程；其中一个队列可以存储多个生产者的消息、一个队列也可以有多个消费者，但是消费者之间对于消息的消费是竞争的，即消息只能被一个消费者消费。</p><img referrerpolicy="no-referrer" referrerpolicy="no-referrer" referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752853775-d629dca9-650b-45c6-82fc-f1ea314de706.png" alt="img" style="zoom:80%;"/></li><li><p><strong>发布订阅模型</strong>（P&#x2F;S，Pub&#x2F;Sub），发布订阅模型中基本组成为生产者Publisher、主题Topic、订阅者Subscriber</p></li></ol><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752866085-a83509a2-55ec-42f3-90a7-7dc831e8c365.png" alt="img" style="zoom:80%;" /><p>消息中间件适用于<strong>需要可靠的数据传送的分布式环境</strong>。发送者将消息发送给消息服务器，消息服务器将 消息存放在若干队列中，在合适的时候再将消息 转发给接收者。实现应用程序之间的协同，优点在于能够在客户和服务器之间提供同步和异步的链接，并且在任何时刻都可以将消息进行传送或存储转发。</p><h3 id="1-2-为什么用消息队列"><a href="#1-2-为什么用消息队列" class="headerlink" title="1.2 为什么用消息队列"></a>1.2 为什么用消息队列</h3><p>消息队列的主要应用场景有三点：<strong>解耦、异步、削峰</strong></p><ul><li><strong>解耦</strong>：在引入消息队列之前，上游业务模块A的功能FA可能需要调用到BCD的服务，还需要考虑到怎么调？变更怎么处理？等等。而引入消息队列后，功能FA执行后将消息发送到消息队列，下游的服务需要就自己消费消息即可</li><li><strong>异步</strong>：一个功能的调用链路往往涉及到多个服务，如果调用链路过长，就会导致功能的响应时间过长。引入消息队列后处理异步进行，可以极大降低响应时间</li><li><strong>削峰</strong>：在高峰期大量数据涌入，可能会超出系统能处理的极限，如果有消息队列做缓冲就不至于导致系统宕机</li></ul><p>由以上三点可以知道，在个人或小型的系统中其实是不需要消息队列的，消息队列应该主要应用于大型的分布式系统中，以实现系统功能解耦、提高响应率、保证高并发环境的稳定性。</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656752892421-6a275339-4254-47bf-92f1-7b7d8d67c033.png" alt="img" style="zoom: 80%;" /><h3 id="1-3-主流消息队列的简单对比"><a href="#1-3-主流消息队列的简单对比" class="headerlink" title="1.3 主流消息队列的简单对比"></a>1.3 主流消息队列的简单对比</h3><p>市场上主流的消息队列有以下几种，他们各有优劣</p><p>1、RabbitMQ：使用Erlang语言，基于AMQP（高级消息队列协议）实现的开源消息中间件。消息延迟能做到微秒级，有较好的并发特性，能实现万级流量吞吐</p><p>2、Kafka：主要应用于大数据的消息中间件，以超高的并发吞吐量而闻名。能做到十万级的吞吐，毫秒级的延迟，在大数据实时计算和日志采集领域被大规模使用</p><p>3、ActiveMQ：作为老牌MQ，基于主从架构实现高可用，能保证较低的消息丢失率</p><p>4、RocketMQ：阿里开源的消息中间件。性能好延迟低，有对应的中文社区</p><p>如图公众号博主【三分恶】在他的：<a href="https://mp.weixin.qq.com/s/fcyDIr6Nas8fBukByI3tEg">面渣逆袭：RocketMQ二十三问</a> 中做出了详细对比：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1656746312635-45d549c0-1c5d-41b0-bd2f-27e8663c8619.png" alt="img" style="zoom: 80%;" /><h2 id="2、RabbitMQ简介"><a href="#2、RabbitMQ简介" class="headerlink" title="2、RabbitMQ简介"></a>2、RabbitMQ简介</h2><h3 id="2-1-RabbitMQ概念"><a href="#2-1-RabbitMQ概念" class="headerlink" title="2.1 RabbitMQ概念"></a>2.1 RabbitMQ概念</h3><p>RabbitMQ是Erlang基于AMQP（Advanced Message Queuing Protocol）的实现，最初起源于金融系统，用于在分布式系统中存储转发消息</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654765818347-bc4a54a8-7d21-4002-8f78-9f73b1feb75d.png" alt="img" style="zoom: 80%;" /><h4 id="RabbitMQ核心组件"><a href="#RabbitMQ核心组件" class="headerlink" title="RabbitMQ核心组件"></a>RabbitMQ核心组件</h4><ul><li>Producer：消息生产者，投递消息的一方，属于Client；消息一般由两部分组成——标签（label）和消息体（payload）</li><li>Consumer：消息消费者，接收消息的一方，属于Client；消费者连接到RabbitMQ服务器，并订阅到队列上，消费消息时只消费消息体，丢弃标签</li><li>Broker：消息队列服务进程，一般可以将一个Broker看作一台服务器</li><li>Exchange：消息队列交换机，实际上消息并不是由生产者直接投递到消息队列，而是发到交换机Exchange上，<strong>由交换机采用相应策略将消息路由转发到对应队列中</strong></li></ul><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654768178092-5b24deb4-f615-4bdd-aa42-27c4dcb3af9d.png" alt="img" style="zoom: 80%;" /><ul><li>Queue：消息队列，存储消息的队列，RabbitMQ中消息只能存储在队列中。多个消费者可以订阅同一个队列，此时消息会采用轮询机制（Round-Robin），即消息被平摊给多个消费者，而不是所有消费者都收到所有消息</li></ul><p> 【注】RabbitMQ不支持队列层面的广播消息，要实现广播需要二次开发，但不建议这么做</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654767707901-6f3e059a-9ddf-4058-afed-3b343640b22b.png" alt="img" style="zoom: 80%;" /><h4 id="RabbitMQ的运行流程"><a href="#RabbitMQ的运行流程" class="headerlink" title="RabbitMQ的运行流程"></a>RabbitMQ的运行流程</h4><ol><li>生产者连接到Broker，建立连接（connection）开启信道（channel）</li><li>生产者声明一个交换机（Exchange），并设置对应属性，如交换机类型、是否持久化等</li><li>生产者声明一个队列（Queue）并设置对应属性，如是否持久化、是否排他、是否自动删除等</li><li>生产者通过路由键（RoutingKey）将交换机和队列设置绑定（Binding）</li><li>生产者发送消息到Broker中，消息包含了路由键、交换器等信息</li><li>交换机根据设置的类型规则，通过路由键匹配对应的队列</li><li>如果找到则存入相应的队列中并，可以设置是否确认</li><li>如果没有找到，则根据之前配置的属性选择丢弃或者回退</li><li>关闭信道与连接</li></ol><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654767542320-5f7bcd66-2552-4ad0-9228-4797cd539962.png" alt="img" style="zoom: 80%;" /><h4 id="RabbitMQ主要特点"><a href="#RabbitMQ主要特点" class="headerlink" title="RabbitMQ主要特点"></a>RabbitMQ主要特点</h4><ul><li>可靠性：支持持久化，传输确认，发布确认等保证了MQ的可靠性</li><li>灵活的分发消息策略：在消息进入MQ队列前由Exchange(交换机)进行路由消息，RabbitMQ提供了内置的Exchange，也可以通过插件自定义</li><li>支持集群：多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker</li><li>多种协议：RabbitMQ支持除原生AMQP外的多种消息队列协议，如 STOMP、MQTT 等</li><li>多种语言客户端：RabbitMQ几乎支持所有常用语言，如 Java、Python、Ruby 等</li><li>可视化管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker</li><li>插件机制：RabbitMQ提供了许多插件，也可以自定义插件</li></ul><h2 id="3、RabbitMQ安装"><a href="#3、RabbitMQ安装" class="headerlink" title="3、RabbitMQ安装"></a>3、RabbitMQ安装</h2><h3 id="3-1-安装-amp-运行"><a href="#3-1-安装-amp-运行" class="headerlink" title="3.1 安装&amp;运行"></a>3.1 安装&amp;运行</h3><p>Windows安装RabbitMQ需要前置erlang环境</p><ol><li>在<a href="https://www.erlang-solutions.com/downloads/">erlang官网</a>下载，</li><li>RabbitMQ的官方<a href="https://www.rabbitmq.com/download.html">下载链接</a>下载</li><li>下载按步骤安装完毕后，打开RabbitMQ安装目录下的sbin目录，通过命令行界面执行：rabbitmq-plugins enable rabbitmq_management安装管理功能插件</li><li>执行bat文件即可启动</li></ol><p>Linux安装可以参照Windows，也可以使用Docker简化安装操作</p><ol><li><p>指令dockers search rabbitmq搜索相关镜像</p></li><li><p>由于rabbitmq默认镜像是不带web管理端的，所以可以拉取management后缀的镜像，通过指令docker pull rabbitmq:3.8-management拉取</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654759324467-d5934078-1b18-43b9-9cad-d0da55934a08.png" alt="img" style="zoom:80%;" /></li><li><p>指令docker run –name rabbitmq -d -p 15672:15672 -p 5672:5672 镜像ID启动镜像<img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654759352997-5654f308-267e-44fd-907e-0fde0a679a7c.png" alt="img" style="zoom:80%;" /></p></li></ol><ul><li><ul><li>其中5672为rabbitmq的通信端口，而15672是web管理页面端口</li><li>通过docker ps查看正在运行的容器</li></ul></li></ul><ol><li><p>启动运行后，放行对应防火墙端口才可以访问。firewall-cmd –zone&#x3D;public –add-port&#x3D;5672&#x2F;tcp –permanent开放对应端口，就可以正常访问了，浏览器中键入：虚拟机IP:15672，默认账户密码都是guest，登录</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654759730631-640e63db-3d6e-415e-8169-59565a9ac176.png" alt="img" style="zoom:80%;" /></li></ol><p>【注】有时强制关闭虚拟机再重启恢复后，会还原虚拟机之前的状态，可以看到docker容器已经在运行，但是对应服务无法访问，通过<code>systemctl restart docker.service</code>就可以访问了</p><h3 id="3-2-RabbitMQ的基本使用"><a href="#3-2-RabbitMQ的基本使用" class="headerlink" title="3.2 RabbitMQ的基本使用"></a>3.2 RabbitMQ的基本使用</h3><h4 id="命令行与控制台"><a href="#命令行与控制台" class="headerlink" title="命令行与控制台"></a>命令行与控制台</h4><p>通过Docker的docker exec -it rabbitMQ容器ID bash进入bash界面，在此处可以通过rabbitMQ自己的命令行进行相关操作。基本命令都是rabbitmqctl xxx形式，详细指令可以参考官方文档：<a href="https://www.rabbitmq.com/rabbitmqctl.8.html">https://www.rabbitmq.com/rabbitmqctl.8.html</a></p><p><strong>1、查看基本信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl start_app # 开启服务<br>rabbitmqctl stop_app # 关闭服务<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态</span><br>rabbitmqctl status<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看binding、channel、交换机</span><br>rabbitmqctl list_bindings<br>rabbitmqctl list_channels<br>rabbitmqctl list_exchanges<br></code></pre></td></tr></table></figure><p><strong>2、rabbitmq用户操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建账号和密码</span><br>rabbitmqctl add_user admin admin123<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置用户角色</span><br>rabbitmqctl set_user_tags admin administrator<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为用户添加资源权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;<span class="hljs-built_in">read</span>&gt;</span><br>rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看用户列表</span><br>rabbitmqctl list_users<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除用户</span><br>rabbitmqctl delete_user admin<br></code></pre></td></tr></table></figure><p>由于默认的guest 账户有访问限制，默认只能通过本地网络(如 localhost) 访问，远程网络访问受限，所以在使用时我们一般另外添加用户，例如我们添加一个root用户</p><p>①执行<code>docker exec -i -t 3ae bin/bash</code>进入到rabbitMq容器内部</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654760021752-654720b7-eb24-4680-b871-25151972f9f3.png" alt="img" style="zoom:80%;" /><p>②执行 <code>rabbitmqctl add_user root 123456 </code>添加用户，用户名为root,密码为123456</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654760040728-bd353bfa-20ac-4845-a06a-decdf308c4a9.png" alt="img" style="zoom:80%;" /><p>③执行<code>abbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code>赋予root用户所有权限</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654760075446-e91a2b4e-f6dd-4271-b250-dd17a37e0de8.png" alt="img" style="zoom:80%;" /><p>④执行<code>rabbitmqctl set_user_tags root administrator</code>赋予root用户administrator角色</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654760104338-da9692f5-ab66-47a4-abac-56c3002bde3d.png" alt="img" style="zoom:80%;" /><p>⑤执行<code>rabbitmqctl list_users </code>查看所有用户即可看到root用户已经添加成功</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654760121394-dc5c8d32-f9e3-4d57-be7e-d73603d494ea.png" alt="img" style="zoom:80%;" /><p>⑥后续可以用root用户登录</p><p><strong>3、虚拟主机vhost操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加vhost</span><br>rabbitmqctl add_vhost &quot;虚拟主机名&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看vhost</span><br>rabbitmqctl list_vhosts<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看vhost权限，一般创建时不需要配置权限</span><br>rabbitmqctl list_permissions -p &quot;虚拟主机名&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除vhost</span><br>rabbitmqctl delete_vhost &quot;虚拟主机名&quot;<br></code></pre></td></tr></table></figure><p>上述操作也可以在管理界面执行，同时管理界面还支持配置文件的导入导出</p><h2 id="4、代码测试"><a href="#4、代码测试" class="headerlink" title="4、代码测试"></a>4、代码测试</h2><h3 id="4-1-Hello-World模型"><a href="#4-1-Hello-World模型" class="headerlink" title="4.1 Hello World模型"></a>4.1 Hello World模型</h3><p>一个最简单的消息队列就是<code>producer</code>、<code>message queue</code>、<code>consumer</code>，现在Docker部署了队列服务，可以简单写一下生产者消费者</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654854211560-bd2d988d-79d6-43a7-936a-f73ee2b86ced.png" alt="img" style="zoom:80%;" /><p>准备pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--rabbitmq 依赖客户端--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>amqp-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--操作文件流的一个依赖--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>生产者代码</strong></p><p>产生消息的步骤</p><ol><li>生产者连接到MQ的Broker，创建connection，开启channel</li><li>生命队列的相关属性：名称、是否持久化、消费模式等</li><li>发送消息，并指定持久化和routing key等属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello rabbit&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;192.168.204.127&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 生成一个队列</span><br><span class="hljs-comment">         * 1.队列名称</span><br><span class="hljs-comment">         * 2.队列里面的消息是否持久化 也就是是否用完就删除</span><br><span class="hljs-comment">         * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span><br><span class="hljs-comment">         * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span><br><span class="hljs-comment">         * 5.其他参数</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你好 Rabbit MQ！&quot;</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 发送一个消息</span><br><span class="hljs-comment">         * 1.发送到那个交换机</span><br><span class="hljs-comment">         * 2.路由的 key 是哪个</span><br><span class="hljs-comment">         * 3.其他的参数信息</span><br><span class="hljs-comment">         * 4.发送消息的消息体</span><br><span class="hljs-comment">         */</span><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,msg.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;生产者发送了一条消息！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654854864787-ca717c44-fe79-40eb-b355-1269681db414.png" alt="img"></p><p>【注】如果先启动消费者，由于MQ里没有相应队列，连接会报错，要先启动生产者发送一条消息到队列中，此时可以看到MQ中创建了队列并有一条消息待消费</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654855241716-e190ae6d-b304-425b-a0be-90deaf21d68c.png" alt="img" style="zoom:80%;" /><p><strong>消费者代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME=<span class="hljs-string">&quot;hello rabbit&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;192.168.204.127&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br>        System.out.println(<span class="hljs-string">&quot;-----等待接收消息-----&quot;</span>);<br><br>        <span class="hljs-comment">//推送的消息如何进行消费的接口回调</span><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag, delivery) -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(message);<br>        &#125;;<br>        <span class="hljs-comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span><br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> (consumerTag) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;消息消费被中断&quot;</span>);<br>        &#125;;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 消费者消费消息 - 接受消息</span><br><span class="hljs-comment">         * 1.消费哪个队列</span><br><span class="hljs-comment">         * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span><br><span class="hljs-comment">         * 3.消费者未成功消费的回调</span><br><span class="hljs-comment">         * 4.消息被取消时的回调</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, deliverCallback, cancelCallback);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654854904517-acbd1a4b-eaff-488e-a422-50505ce5f9d7.png" alt="img" style="zoom:80%;" /><h3 id="4-2-Work-queue模型"><a href="#4-2-Work-queue模型" class="headerlink" title="4.2 Work queue模型"></a>4.2 Work queue模型</h3><p>①抽取出创建连接开启通道的代码，得到工具类<code>RabbitMQUtils</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitMQUtils</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Channel <span class="hljs-title function_">getChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br>        factory.setHost(<span class="hljs-string">&quot;192.168.204.127&quot;</span>);<br>        factory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        factory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> factory.newConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-keyword">return</span> channel;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>②创建消费者类<code>Worker01</code>，模拟多个消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker01</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME=<span class="hljs-string">&quot;hello rabbit&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        <span class="hljs-type">DeliverCallback</span> <span class="hljs-variable">deliverCallback</span> <span class="hljs-operator">=</span> (consumerTag,delivery)-&gt;&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">receiveMsg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot;接收到消息：&quot;</span>+receiveMsg);<br>        &#125;;<br>        <span class="hljs-type">CancelCallback</span> <span class="hljs-variable">cancelCallback</span> <span class="hljs-operator">=</span> (consumerTag)-&gt;&#123;<br>            System.out.println(consumerTag+<span class="hljs-string">&quot;---&gt;消费者取消了消费接口&quot;</span>);<br>        &#125;;<br><br>        System.out.println(<span class="hljs-string">&quot;线程1启动   等待消费消息........&quot;</span>);<br>        channel.basicConsume(QUEUE_NAME,<span class="hljs-literal">true</span>,deliverCallback,cancelCallback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于多个消费者逻辑代码一样，没必要再去新建类copy代码，直接在IDEA的Run Configuration勾选允许多个实例运行：</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654856449966-69deba9b-b0ba-4d6f-957f-f02e2aa40365.png" alt="img" style="zoom:80%;" /><p>运行<code>Worker01</code>后，修改提示信息为<code>&quot;线程2启动   等待消费消息........&quot;</code>，再次Run，得到两个不同的线程</p><p>③修改创建者类，使得可以从控制台不断输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task01</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME=<span class="hljs-string">&quot;hello rabbit&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> RabbitMQUtils.getChannel();<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (scanner.hasNext())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.next();<br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,QUEUE_NAME,<span class="hljs-literal">null</span>,msg.getBytes());<br>            System.out.println(<span class="hljs-string">&quot;task01发送了消息：&quot;</span>+msg);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>④将三者都启动，输入多条数据，可以发现rabbitmq默认采取轮询策略读取消息</p><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654856773461-66a30dd9-e6a4-4490-bc50-564a98e08872.png" alt="img" style="zoom:80%;" /><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654856782526-216d3d82-9384-496a-813a-bd616660f528.png" alt="img" style="zoom:80%;" /><img referrerpolicy="no-referrer" src="https://cdn.nlark.com/yuque/0/2022/png/23183050/1654856792692-a8b2b2d6-e673-4a6d-ab33-fc86cd3cbf17.png" alt="img" style="zoom:80%;" /><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>学习主要看的尚硅谷网课，参考评论区两位学员的笔记，以及官方文档和《RabbitMQ实战指南》电子书</p><ul><li>官方tutorial文档：<a href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html">https://www.rabbitmq.com/tutorials/tutorial-one-java.html</a></li><li><a href="https://www.bilibili.com/video/BV1cb4y1o7zz?share_source=copy_pc">尚硅谷RabbitMQ教程丨快速掌握MQ消息中间件_哔哩哔哩_bilibili</a></li><li>《RabbitMQ实战指南》PDF</li><li><a href="https://note.oddfar.com/pages/95ce73/#hello-world">RabbitMQ - - OddFar’s Notes</a></li><li><a href="https://www.yuque.com/yuxuandmbjz/rabbitmq">RabbitMQ - - 宇轩英建</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-查询执行流程</title>
    <link href="/20220601/afc16bf3/"/>
    <url>/20220601/afc16bf3/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h2><p>以一条查询语句为例，通过查询语句在 MySQL 中的执行流程，了解 MySQL 的基础架构以及各组件模块的基本作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where ID=10；<br></code></pre></td></tr></table></figure><blockquote><p> 图片引用自：<a href="https://xiaolincoding.com/">小林coding：图解MySQL专栏</a></p></blockquote><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427212828078.png" alt="image-20230427212828078" style="zoom:80%;" /><p>如图是MySQL的基本架构示意图，MySQL 可以大致分为 Server 层和存储引擎层两大部分。</p><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p><p>正常的建表语句如果不指定默认引擎就是 InnoDB，也可以在建表语句后通过 <code> ENGINE=MyISAM</code> 指定为 MyISAM 或者其他引擎</p><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><blockquote><p><strong>连接器</strong>：负责跟客户端建立连接、获取权限、维持和管理连接，主要是登陆权限相关；</p></blockquote><p>使用 MySQL 首先要先连接 MySQL 服务，才能执行后续的语句操作。</p><p>1、MySQL 采用 <code>TCP</code> 作为服务器和客户端之间的网络通信协议，默认申请的端口是3306，如果服务连接会报错：<code>Can&#39;t connect to local MySQL...... </code> ，如果已启动就正常走 <code>TCP</code> 握手建立连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -h$ip -P$port -u$user -p<br></code></pre></td></tr></table></figure><p>2、连接建立后，就跟根据输入的用户名密码校验，如果账户密码有误，就会有如下报错</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427221241973.png" alt="image-20230427221241973" style="zoom:80%;" /><p>3、如果账户密码校验通过，就会查询该用户的权限信息并保存，后续的任何操作都会基于连接时读取到的该用户权限</p><blockquote><p>即一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p></blockquote><blockquote><p>每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。</p></blockquote><h4 id="连接器涉及的常见参数"><a href="#连接器涉及的常见参数" class="headerlink" title="连接器涉及的常见参数"></a>连接器涉及的常见参数</h4><p>1、如果连接完成后没有后续操作，连接就处于空闲状态，可以通过 <code>show processlist</code> 命令查看有多少个连接 </p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427221830449.png" alt="image-20230427221830449" style="zoom:80%;" /><p>2、如果客户端长时间没有操作，连接器就会断开连接，具体时间是通过 <code>wait_timeout</code> 参数设置的，默认是28880秒即8小时。对于空闲时间过长被连接器主动断开的连接，客户端并不会收到消息，只有再次发送请求时才会报错提示：<code>ERROR 2013 (HY000): Lost connection to MySQL server during query</code>，如果要继续就要重新建立连接。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427221957980.png" alt="image-20230427221957980" style="zoom:80%;" /><p>3、连接也可以手动断开，通过 <code>kill connection +id</code> 来手动关闭，如图我建立连接后手动关闭了，再次发送请求时提示报错并重连接了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427222848999.png" alt="image-20230427222848999" style="zoom:;" /><p>4、MySQL的默认连接数是有限制的，具体连接数由参数 <code>max_connections</code> 控制，可以通过 <code>show variables like &#39;max_connections&#39;</code> 查看，如果超过连接数就会拒绝新连接并提示 <code>Too many connections</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ysql&gt; show variables like &#x27;max_connections&#x27;;<br>+-----------------+-------+<br>| Variable_name   | Value |<br>+-----------------+-------+<br>| max_connections | 200   |<br>+-----------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>5、MySQL连接分为长连接和短连接。长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接；短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><blockquote><p>执行查询语句的时候，会先查询缓存，命中就直接返回（MySQL 8.0 版本后移除）</p></blockquote><p>查询缓存以 key-value 形式保存缓存数据在内存中，key 是查询的语句，value 是查询的结果</p><p>如果查询的语句和缓存中的 key 完全一致的话，就会直接返回结果给客户端</p><h5 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h5><p>在执行更新操作时，会将查询缓存全部清除。所以频繁更新的表，查询缓存的命中率很低</p><p>MySQL 8.0开始查询缓存已经从 Server 层中被移除了，8.0以后的版本查询时不会走查询缓存</p><h3 id="解析SQL"><a href="#解析SQL" class="headerlink" title="解析SQL"></a>解析SQL</h3><blockquote><p>没有命中缓存就会进入解析，分析器对查询语句进行词法语法分析，以及判断 SQL 语句是否有语法错误</p></blockquote><p>查询缓存未命中就会进入执行操作，在执行前会对 SQL 语句进行分析</p><ol><li>词法分析：根据输入的 SQL 识别系统关键字，构建语法树</li><li>语法分析：对构建的语法树分析是否符合语法规则</li></ol><p>如果输入的 SQL 中有错误语法，例如 <code>where xxx=1</code> 写成了 <code>wheere xxx=1</code> 就会报错 <code>You have an error in your SQL syntax</code></p><h3 id="优化SQL"><a href="#优化SQL" class="headerlink" title="优化SQL"></a>优化SQL</h3><blockquote><p>根据查询语句来确定最优的执行方案</p></blockquote><h4 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h4><p>预处理阶段主要工作如下：</p><ol><li>检查 SQL 中要查询的表或者字段是否存在</li><li>将 <code>SELECT *</code> 中的 <code>*</code> 扩充为全部字段</li></ol><h4 id="优化阶段"><a href="#优化阶段" class="headerlink" title="优化阶段"></a>优化阶段</h4><p>此阶段优化器会确定 SQL 语句的查询方案，它会判断不同查询方案的成本，以选择最优的方式</p><p>例如表中存在多个索引时，决定用哪个索引查询；join 连接时决定连接顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 该 SQL 就会走主键索引<br>SELECT * FROM user1 WHERE id=1<br></code></pre></td></tr></table></figure><p>要想直到具体的查询方案，可以通过 <code>explain</code> 命令对 SQL 进行解释</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230429203028812.png" alt="image-20230429203028812" style="zoom:80%;" /><p>可以看到 <code>possible_keys</code> 表示该 SQL 语句可能用到的索引，这里只有 <code>PRIMARY</code>，<code>key</code> 是实际使用的索引，用的就是 <code>PRIMARY</code></p><p>具体的索引选择方案在索引相关笔记中记录</p><h3 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h3><blockquote><p>执行查询语句，返回记录</p></blockquote><p>分析阶段解析了 SQL 语句、优化阶段指定了查询方案后，就进入正式执行阶段</p><p>执行器会根据表的存储引擎定义，调用对应的引擎接口。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> user1 <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>以 InnoDB 为例，执行的基本流程：</p><ul><li>调用 InnoDB 查询接口获取表的第一行数据，判断 id 是否小于10，是则将结果保存到结果集，不是则跳过</li><li>调用接口读取下一行数据，重复上面的判断逻辑，直到读取到表的最后一行</li><li>执行器将遍历过程中满足条件的行记录作为结果集返回给客户端</li></ul><blockquote><p>以下执行方式示例，引用自<a href="https://xiaolincoding.com/mysql/base/how_select.html#%E6%89%A7%E8%A1%8C%E5%99%A8">小林coding</a></p></blockquote><p>通过如下三种查询执行方式，介绍下执行器和存储引擎的交互过程</p><ol><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ol><h4 id="1、主键索引"><a href="#1、主键索引" class="headerlink" title="1、主键索引"></a>1、主键索引</h4><p>以这条 SQL 为例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sys_user <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>查询条件是主键，由于主键是唯一的，且这里按照等值判断，所以类型是 const 常量判断，即用主键索引查询一条记录</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>；</li><li>存储引擎通过 B+ 树定位到 id&#x3D;1 的第一条记录，不存在该记录就向执行器报错提示找不到，存在就返回该条记录；</li><li>执行器获取记录后判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过；</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了</li></ul><h4 id="2、全表扫描"><a href="#2、全表扫描" class="headerlink" title="2、全表扫描"></a>2、全表扫描</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sys_user <span class="hljs-keyword">WHERE</span> email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xxx@qq.com&#x27;</span>;<br></code></pre></td></tr></table></figure><p>由于 email 字段没有索引，所以优化阶段的查询方案是全表扫描，对应 TYPE&#x3D;ALL，此时执行器和存储引擎的交互流程如下：</p><ul><li><p>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</p></li><li><p>执行器会判断读到的这条记录的 <code>email=xxx@qq.com</code> 是否成立，不是就跳过，<strong>是就返回给客户端</strong></p><blockquote><p>Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录</p></blockquote></li><li><p>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 ALL，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</p></li><li><p>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</p></li><li><p>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</p></li></ul><h4 id="3、索引下推"><a href="#3、索引下推" class="headerlink" title="3、索引下推"></a>3、索引下推</h4><p>索引下推是 MySQL5.6 之后推出的优化策略。<strong>索引下推能够减少二级索引查询时的回表操作，提高查询效率</strong></p><p><strong>回表查询</strong>：由于二级索引的 B+ 树叶子节点存储的主键值，索引在查到符合条件的记录时，会读取叶子节点中的记录的主键值，再次查询聚簇索引的 B+ 树来拿到完整的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> sys_user <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> role <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>以这条 SQL 为例，假设建立了 <code>(age,role)</code> 的联合索引，由于联合索引在遇到 <code>&gt;</code>、<code>&lt;</code>、<code>%xxx</code> 时会停止匹配，即只有 age 字段参与了索引查询，后面的 role 字段没有用到索引</p><blockquote><p>联合索引不是有序的，或者说是局部有序的，因为构建 B+ 树时只能根据一个值来。<code>(a,b,c)</code> 构建排列时按照 a、b、c 的顺序来</p><p>以 <code>(age,role)</code> 的联合索引为例，从 B+ 树角度去看，在全局范围内只有 age 是有序排列的，age&#x3D;1 时可能有 role&#x3D;2、role&#x3D;5 两条记录，age&#x3D;2时可能有 role&#x3D;1、role&#x3D;2、role&#x3D;3 三条记录，<strong>即 role 的有序是针对具体的某个 age 局部存在的</strong></p><ul><li>加入查询条件是 <code>age=18 AND role=2</code>，那么 B+ 树先定位到 age&#x3D;18 的第一条记录这儿，可能有10条，再定位到 role&#x3D;2 的第一条记录这儿，此时联合索引的两个字段都参与了索引查询</li><li>当查询条件为 age&gt;18 时，必须要把联合索引的 B+ 树中从 age&gt;18 开始的第一条到最后一条记录全找出来，相当于后面的 role&#x3D;2 压根没起作用，所以它并没有用到索引</li></ul></blockquote><h5 id="无索引下推时"><a href="#无索引下推时" class="headerlink" title="无索引下推时"></a>无索引下推时</h5><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，即 <code>age&gt;18</code> 的第一条记录；</li><li>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后<strong>进行回表操作</strong>，将完整的记录返回给 Server 层；</li><li>Server 层在判断该记录 <code>role=2</code> 是否成立，成立则将其发送给客户端，否则跳过该记录；</li><li>接着继续向存储引擎索要下一条记录，重复上面的操作直到读完所有的记录；</li></ul><p>即：没有索引下推时，没查询一条二级索引记录，都需要一次回表查询，然后 Server 层再判断该记录的 <code>role=2</code> 是否成立</p><h5 id="有索引下推时"><a href="#有索引下推时" class="headerlink" title="有索引下推时"></a>有索引下推时</h5><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，即 <code>age&gt;18</code> 的第一条记录；</li><li>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，<strong>先不进行回表操作</strong>，而是<strong>先判断索引包含的列 role 值是否等于2</strong>，<strong>条件不成立则直接跳过该索引记录</strong>，<strong>成立则执行回表操作</strong>，将记录返回给 Server；</li><li>Server 层再去判断其他的查询条件（本 SQL 只有联合索引的查询条件），成立则将其发送给客户端，否则跳过该记录；</li><li>接着继续向存储引擎索要下一条记录，重复上面的操作直到读完所有的记录；</li></ul><p>即：有索引下推时，虽然 role 列还是没有用到索引，但是由于其本身在联合索引中，所以会直接在存储引擎层过滤出符合 <code>role=2</code> 的条件，再去做回表操作，相比直接每条记录都回表，节省了很多的操作</p><blockquote><p>使用 EXPLAIN 查看执行计划时，如果 Extra&#x3D;Using index condition 表示使用了索引下推</p></blockquote><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><p>MySQL 支持多种存储引擎，可以通过 <code>show engines</code> 指令查看支持的引擎</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230502123448721.png" alt="image-20230502123448721"></p><p>如图所示，当前版本（8.0.15）MySQL 的默认引擎是 InnoDB，并且只有 InnoDB 是支持事务的（Transactions）</p><blockquote><p>在 MySQL 5.5.5之前 MyISAM 是默认存储引擎，之后都是 InnoDB</p></blockquote><p>如果想要深入了解每个存储引擎以及它们之间的区别，可以阅读 MySQL 官方文档</p><ul><li>InnoDB 存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html</a> </li><li>其他存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html</a></li></ul><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 是基于 ISAM 的存储引擎，数据以紧密格式存储、拥有较高的插入和查询速度、不支持事务、不支持崩溃后的安全恢复、修复操作很慢、提供了全文索引、压缩表、空间数据（GIS）等特性；</p><p>使用 MyISAM 引擎创建数据库，将生产 3 个文件。文件的名字以表的名字开始，扩展名指出文件类型</p><ul><li>.frm：存储表结构定义</li><li>.MYD(MYData)：存储表数据</li><li>.MYI（MYIndex)：存储索引数据</li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 提供了具有提交回滚、崩溃的安全回复等机制。</p><p>实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读；主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升；内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等；支持真正的在线热备份</p><h3 id="MyISAM-和-InnoDB"><a href="#MyISAM-和-InnoDB" class="headerlink" title="MyISAM 和 InnoDB"></a>MyISAM 和 InnoDB</h3><p>MySQL5.5 之前默认的存储引擎是 MyISAM，之后改为了 InnoDB</p><ul><li>事务：MyISAM 不支持事务；InnoDB 提供事务支持，实现了 SQL 标准定义的四个隔离级别，默认是可重复读</li><li>并发：MyISAM 只支持表级锁、InnoDB 支持行级锁（上图的 row-level locking）和表级锁，默认行级锁</li><li>索引：MyISAM 和 InnoDB 都是 B+ 树索引，但是 MyISAM 仅保存记录所在页的指针</li><li>外键：MyISAM 不支持外键、InnoDB 支持外键</li><li>备份：MyISAM 不支持在线热备份、InnoDB 支持</li><li>恢复：MyISAM 崩溃后数据损毁的概率比 InnoDB高很多，InnoDB 支持数据崩溃恢复，通过 <code>redo log</code> 操作</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>极客时间：MySQL 45讲</li><li><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">MySQL常见面试题总结</a></li><li><a href="https://xiaolincoding.com/">小林coding的图解MySQL专栏</a></li><li><a href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-engine.html">MySQL - 存储引擎</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习五：主从复制</title>
    <link href="/20220528/ea10fc6a/"/>
    <url>/20220528/ea10fc6a/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p><p>默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><p><strong>主从复制的作用：</strong></p><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ol><h2 id="使用主从复制"><a href="#使用主从复制" class="headerlink" title="使用主从复制"></a>使用主从复制</h2><h3 id="配从不配主"><a href="#配从不配主" class="headerlink" title="配从不配主"></a>配从不配主</h3><p>主从复制只需要配置从节点，无需操作主节点</p><ol><li>配置文件：在从服务器的配置文件中加入：slaveof  <code>&lt;masterIp&gt;</code>  <code>&lt;masterport&gt;</code></li><li>启动命令：redis-server启动命令后加入 –slaveof  <code>&lt;masterIp&gt;</code>  <code>&lt;masterport&gt;</code></li><li>客户端命令：Redis服务器启动后，直接通过client执行命令：slaveof  <code>&lt;masterIp&gt;</code>  <code>&lt;masterport&gt;</code>，则该Redis实例成为从节点。</li></ol><h3 id="1-初始配置"><a href="#1-初始配置" class="headerlink" title="1 初始配置"></a>1 初始配置</h3><p>1、拷贝3份<code>redis.conf</code>文件，重命名为<code>redis6379.conf</code>、<code>redis6380.conf</code>、<code>redis6381.conf</code></p><p>2、开启<code>daemonize yes</code>；修改<code>pid</code>文件名；指定对应端口；修改log文件加上端口为后缀；修改<code>Dump.rdb</code>加端口后缀</p><p>3、启动三个redis-server，通过<code>ps -ef | grep redis</code>查看启动状态</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328101230533.png" alt="image-20220328101230533" style="zoom:80%;" /><p>4、通过<code>info replication</code>查看主从复制信息。基本的配置完成</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220325102204597.png" alt="image-20220325102204597" style="zoom:80%;" /><h3 id="2-一主二仆"><a href="#2-一主二仆" class="headerlink" title="2 一主二仆"></a>2 一主二仆</h3><p>1、在6380、6381上执行<code>SLAVEOF 127.0.0.1 6379</code>，再次打印信息，可以看到6379成为主，6380、81成为从</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328103540597.png" alt="image-20220328103540597" style="zoom:80%;" /><p>2、从机数据复制是从头开始，比如主机set k1、k2、k3，从机从k4开始配置，前面的k123都会复制</p><p>3、在主节点上写入数据，在从节点可以读取对应数据；而在从节点写入数据会报错</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328104119539.png" alt="image-20220328104119539" style="zoom:80%;" /><p>4、主机挂掉，从机信息：<code>master_link_status:down</code>原地待命，主机重启后还是主节点，从节点的信息：<code>master_link_status:up</code>；从机挂掉重启后，主从信息会丢失，需要通过命令<code>SLAVEOF 127.0.0.1 6379</code>重新指定（也可以通过配置文件修改REPLICATION部分永久生效）</p><p>5、从机可以通过<code>SLAVEOF no one</code>断开主从连接。需要注意的是，从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化</p><h3 id="3、薪火相传"><a href="#3、薪火相传" class="headerlink" title="3、薪火相传"></a>3、薪火相传</h3><p>当前主从节点中的slave可以是另一个主从节点中的master，它同样可以接收其他slave的连接和同步请求，通过此方式可以减轻当前master的读写压力</p><p>通过<code>SLAVEOF newIP newPort</code>更改主从信息，中途变更了主从复制信息后，会清除之前的数据，重新建立拷贝最新的数据，如图6381新的<code>get kkk</code>其实是通过6380获取的</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328112417755.png" alt="image-20220328112417755" style="zoom:80%;" /><h3 id="4、反客为主"><a href="#4、反客为主" class="headerlink" title="4、反客为主"></a>4、反客为主</h3><p>通过<code>SLAVEOF no one</code>将从节点变为master，使当前数据库停止与其他数据库的同步，转成主数据库</p><h2 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h2><p>在初次成功配置主从复制后，可以查看Redis日志：</p><p>主机日志：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328141337796.png" alt="image-20220328141337796" style="zoom:80%;" /><p>从机日志：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328141422599.png" alt="image-20220328141422599" style="zoom:80%;" /><p>由日志文件可以看到：主从复制过程大体可以分为3个阶段——连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段；下面分别进行介绍。</p><h3 id="1、连接建立"><a href="#1、连接建立" class="headerlink" title="1、连接建立"></a>1、连接建立</h3><p>该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。</p><p><strong>保存主节点信息</strong></p><p>从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。</p><p>需要注意的是，<code>slaveof</code>是异步命令，从节点完成主节点ip和port的保存后，向发送<code>slaveof</code>命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。这个过程中，可以看到从节点打印日志如下：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328142210802.png" alt="image-20220328142210802"></p><p><strong>建立socket连接</strong></p><p>从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。如果连接成功，</p><ul><li>从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。</li><li>主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，<strong>并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</strong></li></ul><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328142412940.png" alt="image-20220328142412940"></p><p><strong>发送ping命令</strong></p><p>从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。</p><p>从节点发送ping命令后，可能出现3种情况：</p><p>（1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p><p>（2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p><p>（3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p><p>在主节点返回pong情况下，从节点打印日志如下：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328142502194.png" alt="image-20220328142502194"></p><p><strong>身份验证</strong></p><p>如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p><p>如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p><p><strong>发送从节点端口信息</strong></p><p>身份验证之后，从节点会向主节点发送其监听的端口号（本例为6380、6381），主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</p><h3 id="2、数据同步"><a href="#2、数据同步" class="headerlink" title="2、数据同步"></a>2、数据同步</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。</p><p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制。需要注意的是，在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p><p>在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；在Redis2.8及以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。</p><ol><li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li><li>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li></ol><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p>Redis通过psync命令进行全量复制的过程如下：</p><p>（1）从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制；具体判断过程需要在讲述了部分复制原理后再介绍。</p><p>（2）主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</p><p>（3）主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态</p><p>（4）主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态</p><p>（5）如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态</p><p>主机的同步日志：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328143313401.png" alt="image-20220328143313401"></p><p>从机的同步日志：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328143411959.png" alt="image-20220328143411959"></p><p>可以看到：从节点接收了来自主节点的175个字节的数据、接受前先flush清除旧数据、没有设置aof所以没调用<code>bgrewriteaof</code></p><h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p><p>部分复制的实现，依赖于三个重要的概念：</p><ol><li>复制偏移量</li><li>复制积压缓冲区</li><li>服务器运行ID(runid)</li></ol><p><strong>复制偏移量</strong></p><p>主从节点各自维护一个复制偏移量<code>offset</code>，每次完成N个字节的数据复制后，主从节点都会修改各自的偏移量为新的<code>offset+N</code>。通过<code>offset</code>可以判断主从节点数据库状态是否保持一致：相同则一致，不同则可以根据offset找出缺少的数据。</p><p>例如主节点offset是1000，从节点是500，则部分复制会将501-1000之间的数据进行同步</p><p><strong>复制积压缓冲区</strong></p><p>主节点在初次配置主从信息开始，就会维护一个固定长度的、默认大小1MB的先进先出(FIFO)队列，用于备份主节点最近发送给从节点的数据。【无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区】</p><p>在命令传播阶段，主节点同步写命令到从节点，还会发送给复制积压缓冲区作为备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</p><p>为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p><p>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</p><ul><li>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</li><li>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</li></ul><p><strong>服务器运行ID(runid)</strong></p><p>每个Redis节点都有其运行ID，在启动时自动生成</p><p>初次主从复制时主节点会将自己的runid发送给从节点，从节点会将runid存起来。 当发生断线重连的时候，主节点根据runid判断是否能进行部分复制：</p><ul><li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li><li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li></ul><h4 id="psync命令"><a href="#psync命令" class="headerlink" title="psync命令"></a>psync命令</h4><p>PSYNC命令流程图如下：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328151656392.png" alt="image-20220328151656392" style="zoom:80%;" /><p>psync命令的大体流程如下：</p><ul><li>如果从节点没有复制过任何主节点或执行过slaveof no one命令，从节点就会向主节点发送<code>psync ? -1</code>，请求主节点进行数据的全量同步</li><li>如果前面从节点已经同步过部分数据，此时从节点就会发送<code>psync &lt;runid&gt; &lt;offset&gt;</code>命令给主节点，其中runid是上一次主节点的运行ID，offset是当前从节点的复制偏移量</li></ul><p>主节点收到psync命令后，会出现以下三种可能：</p><ul><li>如果主服务器返回<code>-err</code>，主服务器的Redis版本低于2.8，无法识别psync命令，此时从服务器会向主服务器发送sync命令，进行完整的数据全量复制</li><li>主节点返回<code>fullresync &lt;runid&gt; &lt;offset&gt;</code>，但可能runid不一致、offset差值大于复制挤压缓冲区长度等，则进行全量复制，其中runid为主节点的运行ID，offset为当前主节点的复制偏移量</li><li>如果主服务器返回<code>+continue</code>，则进行增量复制，等待主节点同步offset差值部分的数据即可</li></ul><h3 id="3、命令传播"><a href="#3、命令传播" class="headerlink" title="3、命令传播"></a>3、命令传播</h3><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。</p><p>每隔指定的时间，主节点会向从节点发送PING命令，这个PING命令的作用，主要是为了让从节点进行超时判断。PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。</p><p>从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量。REPLCONF ACK命令的作用包括：</p><p>（1）实时监测主从节点网络状态：该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1</p><p>（2）检测命令丢失：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的</p><p>（3）辅助保证从节点的数量和延迟：Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</p><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p>1、设置为一仆二主，6379带6380、6381</p><p>2、编辑一个<code>sentinel.conf</code>文件，内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">masterName:为监控对象起的服务器名称</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">最后一个数字1，表示主机挂掉后slave投票看让谁接替成为主机，得票数多少后成为主机</span><br>sentinel monitor masterName 127.0.0.1 6379 1<br></code></pre></td></tr></table></figure><p>3、启动redis-sentinel，指定<code>sentinel.conf</code>文件</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328155708818.png" alt="image-20220328155708818"></p><p>4、通过shutdown关闭主节点6379，等一会儿可以看到，投票选出新的6380作为主节点了</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328160255392.png" alt="image-20220328160255392"></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328160351359.png" alt="image-20220328160351359" style="zoom:80%;" /><p>5、再次重启6379后，发现现在已经变成从节点了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220328160725607.png" alt="image-20220328160725607" style="zoom: 70%;" /><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html">深入学习Redis（3）：主从复制</a></li><li>尚硅谷Redis</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习四：事务和发布订阅</title>
    <link href="/20220528/122afe43/"/>
    <url>/20220528/122afe43/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h3><p>Redis事务定义：将多个命令打包， 然后一次性、按顺序地执行，并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。</p><p>Redis通过<code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code>指令来实现事务功能。事务的主要作用就是串联多个指令，可以将Redis的事务视作一个队列，通过<code>MULTI</code>指令开始一个事务，之后我们键入的每个命令都被添加到这个队列中，当输入<code>EXEC</code>指令就开始按照先进先出顺序执行队列中的命令。</p><p>一个事务从开始到执行经历三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><p>事务相关指令含义如下：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>MULTI</td><td>标记一个事务的开始</td></tr><tr><td>EXEC</td><td>执行一个事务队列中的所有命令</td></tr><tr><td>DISCARD</td><td>取消事务，放弃执行事务队列中的命令</td></tr><tr><td>WATCH</td><td>监视一个或多个key，如果在事务执行前这个key被其他命令改动，则事务被中断</td></tr><tr><td>UNWATCH</td><td>取消监视一个或多个key</td></tr></tbody></table><span id="more"></span><h3 id="事务的执行"><a href="#事务的执行" class="headerlink" title="事务的执行"></a>事务的执行</h3><h4 id="1、正常执行"><a href="#1、正常执行" class="headerlink" title="1、正常执行"></a>1、正常执行</h4><p>通过<code>MULTI</code>指令开启事务，添加命令到队列中，通过<code>EXEC</code>执行：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220322162204162.png" alt="image-20220322162204162" style="zoom:80%;" /><h4 id="2、放弃事务"><a href="#2、放弃事务" class="headerlink" title="2、放弃事务"></a>2、放弃事务</h4><p>通过<code>MULTI</code>指令开启事务，添加命令到队列中，通过<code>DISCARD</code>取消：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323000524729.png" alt="image-20220323000524729" style="zoom:80%;" /><h4 id="3、全体连坐"><a href="#3、全体连坐" class="headerlink" title="3、全体连坐"></a>3、全体连坐</h4><p>如果事务队列中的命令存在语法错误（例如参数数量、名称等不对），或者其他更严重的错误，比如内存不足（使用 <code>maxmemory</code> 设置了最大内存限制），此时整个队列都会被取消：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323001510293.png" alt="image-20220323001510293" style="zoom:80%;" /><p>通过对入队命令的返回值做检查，如果是<code>QUEUED</code>标识正常入队，否则就是入队失败，2.6.5之后如果有入队失败的情况则<code>EXEC</code>时拒绝执行此事务。</p><h4 id="4、冤头债主"><a href="#4、冤头债主" class="headerlink" title="4、冤头债主"></a>4、冤头债主</h4><p>如果命令不是语法上的错误，而是执行阶段的错误（例如对string类型执行<code>INCR</code>等），则只有报错的命令不会被执行，而其他的正确命令都会执行，整体事务不会回滚：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323001337310.png" alt="image-20220323001337310" style="zoom:80%;" /><h3 id="WATCH监控"><a href="#WATCH监控" class="headerlink" title="WATCH监控"></a>WATCH监控</h3><h4 id="1、悲观锁"><a href="#1、悲观锁" class="headerlink" title="1、悲观锁"></a>1、悲观锁</h4><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><h4 id="2、乐观锁"><a href="#2、乐观锁" class="headerlink" title="2、乐观锁"></a>2、乐观锁</h4><p>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型</strong>，这样可以提高吞吐量，Redis就是利用这种check-and-set机制实现事务的。【乐观锁策略:提交版本必须大于记录当前版本才能执行更新】</p><h4 id="带WATCH的事务"><a href="#带WATCH的事务" class="headerlink" title="带WATCH的事务"></a>带WATCH的事务</h4><p><code>WATCH</code> 指令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务将被打断，不再执行， 直接返回失败。</p><p>并且<code>WATCH</code> 指令可以调用多次，从执行<code>WATCH</code> 开始生效直到<code>EXEC</code>，<strong>当 <code>EXEC</code> 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消</strong>。另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</p><p>设置工资开销<code>salary</code>、<code>spending</code>的初始值为10000和0，如果自己一个人正常用，洗个脚1600：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323003943605.png" alt="image-20220323003943605" style="zoom:80%;" /><p>假设工资是和女朋友一起用，第二次去洗脚时女朋友直接刷了个8400的包，这时结账就会出问题了：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323004419871.png" alt="image-20220323004419871" style="zoom:80%;" /><p>如果不加<code>WATCH</code>就会出大问题了，银行卡变成<code>-1600</code>：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220323004836824.png" alt="image-20220323004836824" style="zoom:80%;" /><p><strong>watch指令，类似乐观锁</strong>，事务提交时，如果 key 的值已被别的客户端改变，比如某个 list 已被别的客户端push&#x2F;pop 过了，整个事务队列都不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败</p><p>【注】当然也可以用 Redis 实现分布式锁来保证安全性，属于悲观锁</p><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li><p>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断；</p></li><li><p>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题；</p></li><li><p>不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚；</p><blockquote><p>官方的解释：</p><p>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</p><p>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</p></blockquote></li></ul><h3 id="事务的原理"><a href="#事务的原理" class="headerlink" title="事务的原理"></a>事务的原理</h3><h4 id="1、开始事务"><a href="#1、开始事务" class="headerlink" title="1、开始事务"></a>1、开始事务</h4><p><code>MULTI</code>命令唯一做的就是， 将客户端的 <code>REDIS_MULTI</code> 选项打开， 让客户端从非事务状态切换到事务状态。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324103546438.png" alt="image-20220324103546438" style="zoom:80%;" /><h4 id="2、命令入队"><a href="#2、命令入队" class="headerlink" title="2、命令入队"></a>2、命令入队</h4><p>对于非执行指令（除EXEC、DISCARD、MULTI、WATCH）直接入队，返回结果QUEUED，如果指令有语法错误则返回错误信息</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324104045964.png" alt="image-20220324104045964" style="zoom:80%;" /><h4 id="2-、事务队列"><a href="#2-、事务队列" class="headerlink" title="2*、事务队列"></a>2*、事务队列</h4><ul><li><p>每个 Redis 客户端都有自己的事务状态， 这个事务状态保存在客户端状态的 <code>mstate</code> 属性里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisClient</span> &#123;</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 事务状态</span><br>    multiState mstate;      <span class="hljs-comment">/* MULTI/EXEC state */</span><br>    <span class="hljs-comment">// ...</span><br>&#125; redisClient;<br></code></pre></td></tr></table></figure></li><li><p>事务状态包含一个事务队列， 以及一个已入队命令的计数器 （也可以说是事务队列的长度）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">multiState</span> &#123;</span><br>    <span class="hljs-comment">// 事务队列，FIFO 顺序</span><br>    multiCmd *commands;<br>    <span class="hljs-comment">// 已入队命令计数</span><br>    <span class="hljs-type">int</span> count;<br>&#125; multiState;<br></code></pre></td></tr></table></figure></li><li><p>事务队列是一个 <code>multiCmd</code> 类型的数组， 数组中的每个 <code>multiCmd</code> 结构都保存了一个已入队命令的相关信息， 包括指向命令实现函数的指针， 命令的参数， 以及参数的数量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">multiCmd</span> &#123;</span><br>    <span class="hljs-comment">// 参数</span><br>    robj **argv;<br>    <span class="hljs-comment">// 参数数量</span><br>    <span class="hljs-type">int</span> argc;<br>    <span class="hljs-comment">// 命令指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisCommand</span> *<span class="hljs-title">cmd</span>;</span><br>&#125; multiCmd;<br></code></pre></td></tr></table></figure></li><li><p>事务队列以先进先出（FIFO）的方式保存入队的命令： 较先入队的命令会被放到数组的前面， 而较后入队的命令则会被放到数组的后面。</p></li></ul><p>由上可知事务队列是一个数组， 每个数组项是都包含三个属性：</p><ol><li>要执行的命令（cmd）</li><li>命令的参数（argv）</li><li>参数的个数（argc）</li></ol><p>执行如下指令时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Redis">redis&gt; MULTI<br>OK<br><br>redis&gt; SET book-name &quot;Mastering C++ in 21 days&quot;<br>QUEUED<br><br>redis&gt; GET book-name<br>QUEUED<br><br>redis&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;<br>QUEUED<br><br>redis&gt; SMEMBERS tag<br>QUEUED<br></code></pre></td></tr></table></figure><p>得到的指令队列：</p><table><thead><tr><th>数组索引</th><th>cmd</th><th>argv</th><th>argc</th></tr></thead><tbody><tr><td>0</td><td>SET</td><td>[“book-name”, “Mastering C++ in 21 days”]</td><td>2</td></tr><tr><td>1</td><td>GET</td><td>[“book-name”]</td><td>1</td></tr><tr><td>2</td><td>SADD</td><td>[“tag”, “C++”, “Programming”, “Mastering Series”]</td><td>4</td></tr><tr><td>3</td><td>SMEMBERS</td><td>[“tag”]</td><td>1</td></tr></tbody></table><h4 id="3、执行事务"><a href="#3、执行事务" class="headerlink" title="3、执行事务"></a>3、执行事务</h4><p>当遇到EXEC、DISCARD、MULTI、WATCH这四个指令时，事务就会被执行。服务器根据客户端所保存的事务队列， 以先进先出（FIFO）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324103946709.png" alt="image-20220324103946709" style="zoom: 80%;" /><p>当事务队列里的所有命令被执行完之后，EXEC命令会将回复队列作为自己的执行结果返回给客户端， 客户端从事务状态返回到非事务状态， 至此， 事务执行完毕。伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_transaction</span>():<br>    <span class="hljs-comment"># 创建空白的回复队列</span><br>    reply_queue = []<br>    <span class="hljs-comment"># 取出事务队列里的所有命令、参数和参数数量</span><br>    <span class="hljs-keyword">for</span> cmd, argv, argc <span class="hljs-keyword">in</span> client.transaction_queue:<br>        <span class="hljs-comment"># 执行命令，并取得命令的返回值</span><br>        reply = execute_redis_command(cmd, argv, argc)<br>        <span class="hljs-comment"># 将返回值追加到回复队列末尾</span><br>        reply_queue.append(reply)<br>    <span class="hljs-comment"># 清除客户端的事务状态</span><br>    clear_transaction_state(client)<br>    <span class="hljs-comment"># 清空事务队列</span><br>    clear_transaction_queue(client)<br>    <span class="hljs-comment"># 将事务的执行结果返回给客户端</span><br>    send_reply_to_client(client, reply_queue)<br></code></pre></td></tr></table></figure><h4 id="WATCH实现"><a href="#WATCH实现" class="headerlink" title="WATCH实现"></a>WATCH实现</h4><p>在每个代表数据库的 <code>redis.h/redisDb</code> 结构类型中， 都保存了一个 <code>watched_keys</code> 字典， 字典的键是这个数据库被监视的键， 而字典的值则是一个链表， 链表中保存了所有监视这个键的客户端。如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324143007715.png" alt="image-20220324143007715" style="zoom:80%;" /><p>其中， 键 <code>key1</code> 正在被 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 三个客户端监视， 其他一些键也分别被其他别的客户端监视着。</p><p>WATCH命令的作用， 就是将当前客户端和要监视的键在 <code>watched_keys</code> 中进行关联。</p><p>举个例子， 如果当前客户端为 <code>client10086</code> ， 那么当客户端执行 <code>WATCH key1 key2</code> 时， 前面展示的 <code>watched_keys</code> 将被修改成这个样子：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324143132923.png" alt="image-20220324143132923" style="zoom:80%;" /><p>通过 <code>watched_keys</code> 字典， 如果程序想检查某个键是否被监视， 那么它只要检查字典中是否存在这个键即可； 如果程序要获取监视某个键的所有客户端， 那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p><h4 id="WATCH触发"><a href="#WATCH触发" class="headerlink" title="WATCH触发"></a>WATCH触发</h4><p>在任何对数据库键空间（key space）进行修改的命令成功执行之后 （比如FLUSHDB、SET、DEL、LPUSH、SADD、ZREM等）， <code>multi.c/touchWatchedKey</code> 函数都会被调用——它检查数据库的 <code>watched_keys</code> 字典， 查找是否有被该命令修改的键，有的话 程序将所有监视这个&#x2F;这些被修改键的客户端的 <code>REDIS_DIRTY_CAS</code> 选项打开：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324143653578.png" alt="image-20220324143653578" style="zoom:80%;" /><p>当客户端发送EXEC命令、触发事务执行时， 服务器会对客户端的状态进行检查：</p><ul><li>如果客户端的 <code>REDIS_DIRTY_CAS</code> 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</li><li>如果 <code>REDIS_DIRTY_CAS</code> 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</li></ul><p>可以用一段伪代码来表示这个检查：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_safety_before_execute_trasaction</span>():<br>    <span class="hljs-keyword">if</span> client.state &amp; REDIS_DIRTY_CAS:<br>        <span class="hljs-comment"># 安全性已破坏，清除事务状态</span><br>        clear_transaction_state(client)<br>        <span class="hljs-comment"># 清空事务队列</span><br>        clear_transaction_queue(client)<br>        <span class="hljs-comment"># 返回空回复给客户端</span><br>        send_empty_reply(client)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 安全性完好，执行事务</span><br>        execute_transaction()<br></code></pre></td></tr></table></figure><p>举个例子，假设数据库的 <code>watched_keys</code> 字典如下图所示：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420225953389.png" alt="image-20230420225953389" style="zoom:80%;" /><p>如果某个客户端对 <code>key1</code> 进行了修改（比如执行 <code>DEL key1</code> ）， 那么所有监视 <code>key1</code> 的客户端， 包括 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 的 <code>REDIS_DIRTY_CAS</code> 选项都会被打开， 当客户端 <code>client2</code> 、 <code>client5</code> 和 <code>client1</code> 执行EXEC的时候， 它们的事务都会以失败告终。</p><p>最后，当一个客户端结束它的事务时，无论事务是成功执行，还是失败， <code>watched_keys</code> 字典中和这个客户端相关的资料都会被清除。</p><h2 id="Redis发布与订阅"><a href="#Redis发布与订阅" class="headerlink" title="Redis发布与订阅"></a>Redis发布与订阅</h2><h3 id="发布与订阅概念"><a href="#发布与订阅概念" class="headerlink" title="发布与订阅概念"></a>发布与订阅概念</h3><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。Redis 客户端可以订阅任意数量的频道。</p><p>如图是 channel1 和三个订阅了频道的Redis客户端：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324144453619.png" alt="image-20220324144453619" style="zoom: 80%;" /><p>当有消息message通过<code>PUBLISH</code>指令发送到 channel1 时，这个message会发送到订阅它的客户端：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324144910793.png" alt="image-20220324144910793" style="zoom:80%;" /><h3 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h3><p>1、打开一个客户端，订阅频道<code>channel1</code>：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324145443960.png" alt="image-20220324145443960" style="zoom:80%;" /><p>2、打开另一个客户端，通过<code>PUBLISH channel1 hello-redis0</code>发布消息，返回值1表示频道channel1有一个订阅者，可以看到订阅的客户端收到了<code>hello-redis0</code>消息：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324145758711.png" alt="image-20220324145758711" style="zoom:80%;" /><p>3、再打开一个客户端订阅channel1，发送消息<code>hello-redis1</code>，可以看到返回2，两个订阅的都收到消息，并且新订阅的是没有收到之前的消息<code>hello-redis0</code>的：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20220324150219041.png" alt="image-20220324150219041" style="zoom:80%;" /><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html">事务-Redis设计与实现</a></li><li>Redis——B站尚硅谷周阳</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-Plus 自定义批处理操作</title>
    <link href="/20220511/65ec32cd/"/>
    <url>/20220511/65ec32cd/</url>
    
    <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>项目中有个对接同步数据的需求，大致流程是对接其他平台后把需要的数据在代码中处理保存到本项目对应库中，ORM 框架产线统一用的 Mybatis-Plus，列表批量数据保存调用的是 <code>saveOrUpdateBatch()</code> 方法，但是在同步开始结束 <code>log.info</code> 打日志发现数据量不大但是耗时比预期的长</p><p>进入 MP 的源码中查看该方法，发现它的批量操作并不是真正的批量操作，默认的 <code>saveOrUpdateBatch()</code> 调用的是 SqlHelper 的 <code>executeBatch()</code>，遍历创建 sql 语句，然后按照一个 batchSize 开启一次事务提交，所以控制台输出的也是一条一条的 insert 语句</p><h3 id="二、改进方法"><a href="#二、改进方法" class="headerlink" title="二、改进方法"></a>二、改进方法</h3><h4 id="1、用-Mybatis-写-xml"><a href="#1、用-Mybatis-写-xml" class="headerlink" title="1、用 Mybatis 写 xml"></a>1、用 Mybatis 写 xml</h4><p>直接通过 Mybatis 写 xml，利用 <code>&lt;foreach&gt; &lt;/foreach&gt;</code> 标签遍历待操作数据</p><p>具体操作参照官方文档：<a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html#foreach">https://mybatis.org/mybatis-3/zh/dynamic-sql.html#foreach</a></p><h4 id="2、改进-MP"><a href="#2、改进-MP" class="headerlink" title="2、改进 MP"></a>2、改进 MP</h4><p>在 Mybatis-Plus 中新增有一个 sql 注入器，可以通过 sql 注入器实现批量新增删除等操作，一次注入随时可用，使用上比较方便，唯一的缺点就是在项目启动时会进行 sql 注入器注册</p><h3 id="三、步骤"><a href="#三、步骤" class="headerlink" title="三、步骤"></a>三、步骤</h3><h4 id="1、自定义-BaseMapper"><a href="#1、自定义-BaseMapper" class="headerlink" title="1、自定义 BaseMapper"></a>1、自定义 BaseMapper</h4><p>创建一个自定义的 BatchMapper（名称自定义）继承 BaseMapper，在 BatchMapper 中添加自定义的方法名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BatchMapper</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义的批量插入功能：mysqlSaveOrUpdateBatch</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list 待批量插入的数据，要自动填充 <span class="hljs-doctag">@Param</span>(xxx) xxx必须是 list/collection/array 三者之一</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 操作条数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">mysqlSaveOrUpdateBatch</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;list&quot;)</span>List&lt;T&gt; list)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、方法实现"><a href="#2、方法实现" class="headerlink" title="2、方法实现"></a>2、方法实现</h4><p>自定义方法的具体实现，逻辑上就是将待插入的数据拼接成 VALUES 多个参数形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">saveOrUpdateBatchMethod</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMethod</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> MappedStatement <span class="hljs-title function_">injectMappedStatement</span><span class="hljs-params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&lt;script&gt;insert into %s %s values %s ON DUPLICATE KEY UPDATE %s&lt;/script&gt;&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">tableName</span> <span class="hljs-operator">=</span> tableInfo.getTableName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fieldSql</span> <span class="hljs-operator">=</span> prepareFieldSql(tableInfo);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">modelValueSql</span> <span class="hljs-operator">=</span> prepareModelValueSql(tableInfo);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">duplicateKeySql</span> <span class="hljs-operator">=</span> prepareDuplicateKeySql(tableInfo);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sqlResult</span> <span class="hljs-operator">=</span> String.format(sql, tableName, fieldSql, modelValueSql, duplicateKeySql);<br>        <span class="hljs-type">SqlSource</span> <span class="hljs-variable">sqlSource</span> <span class="hljs-operator">=</span> languageDriver.createSqlSource(configuration, sqlResult, modelClass);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.addInsertMappedStatement(mapperClass, modelClass, <span class="hljs-string">&quot;mysqlSaveOrUpdateBatch&quot;</span>, sqlSource, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoKeyGenerator</span>(), <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<span class="hljs-comment">// 这里的名称要和Mapper中定义的一致</span><br>    &#125;<br><br>    <span class="hljs-comment">// 字段</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">prepareFieldSql</span><span class="hljs-params">(TableInfo tableInfo)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">fieldSql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(<span class="hljs-string">&quot;(&quot;</span>);<br>        fieldSql.append(tableInfo.getKeyColumn()).append(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">columnStr</span> <span class="hljs-operator">=</span> tableInfo.getFieldList().stream().map(TableFieldInfo::getColumn).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>        fieldSql.append(columnStr).append(<span class="hljs-string">&quot;)&quot;</span>);<br>        <span class="hljs-keyword">return</span> fieldSql.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// 值</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">prepareModelValueSql</span><span class="hljs-params">(TableInfo tableInfo)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">valueSql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        valueSql.append(<span class="hljs-string">&quot;&lt;foreach collection=\&quot;list\&quot; item=\&quot;item\&quot; index=\&quot;index\&quot; open=\&quot;(\&quot; separator=\&quot;),(\&quot; close=\&quot;)\&quot;&gt;&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(tableInfo.getKeyProperty())) &#123;<br>            valueSql.append(<span class="hljs-string">&quot;#&#123;item.&quot;</span>).append(tableInfo.getKeyProperty()).append(<span class="hljs-string">&quot;&#125;,&quot;</span>);<br>        &#125;<br>        tableInfo.getFieldList().forEach(x -&gt; valueSql.append(<span class="hljs-string">&quot;#&#123;item.&quot;</span>).append(x.getProperty()).append(<span class="hljs-string">&quot;&#125;,&quot;</span>));<br>        valueSql.delete(valueSql.length() - <span class="hljs-number">1</span>, valueSql.length());<br>        valueSql.append(<span class="hljs-string">&quot;&lt;/foreach&gt;&quot;</span>);<br>        <span class="hljs-keyword">return</span> valueSql.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// 已存在数据执行更新</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">prepareDuplicateKeySql</span><span class="hljs-params">(TableInfo tableInfo)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">duplicateKeySql</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(tableInfo.getKeyColumn())) &#123;<br>            duplicateKeySql.append(tableInfo.getKeyColumn()).append(<span class="hljs-string">&quot;=values(&quot;</span>).append(tableInfo.getKeyColumn()).append(<span class="hljs-string">&quot;),&quot;</span>);<br>        &#125;<br><br>        tableInfo.getFieldList().forEach(x -&gt; &#123;<br>            duplicateKeySql.append(x.getColumn())<br>                    .append(<span class="hljs-string">&quot;=values(&quot;</span>)<br>                    .append(x.getColumn())<br>                    .append(<span class="hljs-string">&quot;),&quot;</span>);<br>        &#125;);<br>        duplicateKeySql.delete(duplicateKeySql.length() - <span class="hljs-number">1</span>, duplicateKeySql.length());<br>        <span class="hljs-keyword">return</span> duplicateKeySql.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、sql-注入器"><a href="#3、sql-注入器" class="headerlink" title="3、sql 注入器"></a>3、sql 注入器</h4><p>自定义 sql 注入器继承默认的注入器，补充父类的方法，将刚刚自定义的实现方法添加到 methodList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomizedSqlInjector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultSqlInjector</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取super的methodList，添加自定义的method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;AbstractMethod&gt; <span class="hljs-title function_">getMethodList</span><span class="hljs-params">(Class&lt;?&gt; mapperClass, TableInfo tableInfo)</span> &#123;<br>        List&lt;AbstractMethod&gt; methodList = <span class="hljs-built_in">super</span>.getMethodList(mapperClass, tableInfo);<br>        methodList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">saveOrUpdateBatchMethod</span>());<br>        <span class="hljs-keyword">return</span> methodList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4、补充配置"><a href="#4、补充配置" class="headerlink" title="4、补充配置"></a>4、补充配置</h4><p>一般用到 Mybatis-Plus 时都会创建一个 Config 配置类，添加分页插件等基础配置，在对应配置类中补充注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> GlobalConfig <span class="hljs-title function_">globalConfig</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">GlobalConfig</span> <span class="hljs-variable">globalConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlobalConfig</span>();<br>    <span class="hljs-keyword">return</span> globalConfig;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CustomizedSqlInjector <span class="hljs-title function_">customizedSqlInjector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomizedSqlInjector</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5、开启批操作"><a href="#5、开启批操作" class="headerlink" title="5、开启批操作"></a>5、开启批操作</h4><p>在项目配置的 MySQL 连接后面添加参数</p><ul><li><p><code>allowMultiQueries=true</code>：允许在 SQL 后添加分号，实现多语句在一个请求中执行，实现批处理</p></li><li><p><code>rewriteBatchedStatements=true</code>：可以理解为开启后会优化 JDBC 的解析 SQL 操作，原先单条单条执行的会合并操作。对于删除、更新会添加分号一次请求多个执行，对于插入会优化为 <code>VALUES (...),(...),(...);</code></p></li></ul><h4 id="6、修改并调用"><a href="#6、修改并调用" class="headerlink" title="6、修改并调用"></a>6、修改并调用</h4><p>修改待操作的 mapper，由原先的继承 BaseMapper 改为继承 BatchMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VehicleMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BatchMapper</span>&lt;VehicleCoordDO&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>修改调用代码，初始方法 <code>VehicleService.saveOrUpdate(list)</code> 调整为 <code>VehicleMapper.mysqlSaveOrUpdateBatch(list)</code>，通过日志查看执行的耗时是否优化了</p><p>自带的 <code>saveOrUpdateBatch()</code> 方法执行，批量提交，但是批次内还是单条执行，耗时4s</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230511163740993.png" alt="image-20230511163740993"></p><p>使用自定义的批量操作，形式和 <code>INSERT xxx VALUES (xxx),(xxx)</code> 一致，一条语句执行多个参数</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230511164158482.png" alt="image-20230511164158482"></p><h3 id="四、说明"><a href="#四、说明" class="headerlink" title="四、说明"></a>四、说明</h3><p>1、Mybatis-Plus 其实已经提供了一个拓展，里面的 <code>InsertBatchSomeColumn</code> 提供了批量插入的方法</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230511170953276.png" alt="image-20230511170953276" style="zoom:80%;" /><p>使用步骤和上面类似</p><ul><li>自定义一个注入器，在 methodList 中添加 <code>methodList.add(new InsertBatchSomeColumn());</code></li><li>在配置类中注入</li><li>修改Mapper的继承，调用</li></ul><p>2、对于自定义 saveBatch、updateBatch，操作步骤和上面一样，只是在具体实现部分有所不同，例如批量插入只需要 prepareFieldSql、prepareModelValueSql 这两部分的逻辑，sql 语句拼接也不需要 <code>ON DUPLICATE KEY UPDATE %s</code> 部分</p><blockquote><p> 其实上面的 批量插入或更新就是批量插入的特殊情况，即 MySQL 插入时指定策略为重复 key 更新</p></blockquote><p>具体的操作逻辑网上很多，可以搜索后套用一下</p><p>2、Mybatis-Plus 的 saveBatch、saveOrUpdateBatch 操作上已经进行了优化，一般情况是够用的。要注意 saveOrUpdate、saveOrUpdateBatch 方法，判断是 save 还是 update 的逻辑要用到表主键信息，表中有列名为 id 的、或者在实体类对于主键字段上添加了 @TableId 注解，才能被解析，不然会报错找不到</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习三：持久化</title>
    <link href="/20211212/a4f2d1e9/"/>
    <url>/20211212/a4f2d1e9/</url>
    
    <content type="html"><![CDATA[<p>Redis的是一个内存数据库，所有数据都存放在内存中，这也是它读写效率高的原因所在。不过相比于MySQL等关系型数据库将持久化，内存保存数据容易在断电宕机等情况下丢失数据，因此Redis提供了数据持久化功能，通过备份内存数据到本地、将备份文件恢复等实现持久化机制。</p><p>在学习Redis持久化之前，可以先大概学习一下配置文件，了解Redis的配置参数等。</p><h2 id="配置文件简述"><a href="#配置文件简述" class="headerlink" title="配置文件简述"></a>配置文件简述</h2><p>配置文件地址：在Redis的安装目录下，对应的<code>redis.conf</code>文件（Windows 名为 <code>redis.windows.conf</code>）</p><p><strong>Units单位</strong>：配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit。大小写不敏感</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211206215540244.png" alt="image-20211206215540244" style="zoom: 80%;" /><p><strong>INCLUDES包含</strong>：多实例的情况可以把公用的配置文件提取出来</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211206215658857.png" alt="image-20211206215658857" style="zoom: 80%;" /><p>相关配置如下表，更多详细配置可以在<code>redis.conf</code>文件中查看。</p><table><thead><tr><th align="center">配置项</th><th align="left">配置说明</th></tr></thead><tbody><tr><td align="center"><strong>网络相关</strong></td><td align="left"></td></tr><tr><td align="center"><code>port 6379</code></td><td align="left">指定redis监听端口，默认端口是6379</td></tr><tr><td align="center"><code>bind 127.0.0.1</code></td><td align="left">绑定的主机地址</td></tr><tr><td align="center"><code>timeout 300</code></td><td align="left">当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td></tr><tr><td align="center"><code>protect-mode</code></td><td align="left">将本机访问保护模式设置no</td></tr><tr><td align="center"><code>tcp-keeplive</code></td><td align="left">单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60</td></tr><tr><td align="center"><code>tcp-backlog</code></td><td align="left">设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和&#x3D;未完成三次握手队列 + 已经完成三次握手队列。<br/>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值<br/>来达到想要的效果</td></tr><tr><td align="center"><strong>通用项</strong></td><td align="left"></td></tr><tr><td align="center"><code>daemonize no</code></td><td align="left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td></tr><tr><td align="center"><code>pidfile /var/run/redis.pid</code></td><td align="left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 &#x2F;var&#x2F;run&#x2F;redis.pid 文件，可以通过 pidfile 指定</td></tr><tr><td align="center"><code>loglevel notice</code></td><td align="left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td></tr><tr><td align="center"><code>logfile stdout</code></td><td align="left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 &#x2F;dev&#x2F;null</td></tr><tr><td align="center"><code>database 16</code></td><td align="left">设定库的数量。默认16，默认数据库为0，可以使用SELECT命令在连接上指定数据库id</td></tr><tr><td align="center"><code>syslog-enabled</code></td><td align="left">是否把日志输出到syslog中</td></tr><tr><td align="center"><code>syslog-ident</code></td><td align="left">指定syslog的日志标识</td></tr><tr><td align="center"><code>syslog-facility</code></td><td align="left">指定syslog设备，值可以是User或者local</td></tr><tr><td align="center"><strong>SNAPSHOT快照</strong></td><td align="left"></td></tr><tr><td align="center"><code>save  &lt;seconds&gt;</code> <code> &lt;changes&gt;</code></td><td align="left"><code>save 900 1</code> <code>save 300 10</code> <code>save 60 10000</code>分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。<br/>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td></tr><tr><td align="center"><code>Stop-writes-on-bgsave-error</code></td><td align="left">如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制</td></tr><tr><td align="center"><code>rdbcompression yes</code></td><td align="left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td></tr><tr><td align="center"><code>rdbchecksum</code></td><td align="left">在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</td></tr><tr><td align="center"><code>dbfilename dump.rdb</code></td><td align="left">指定本地数据库文件名，默认值为 dump.rdb</td></tr><tr><td align="center"><code>dir ./</code></td><td align="left">指定本地数据库存放目录</td></tr><tr><td align="center"><strong>SECURITY安全</strong></td><td align="left"></td></tr><tr><td align="center"><code>config set/get requirepass  &quot;&lt;password&gt;&quot;</code></td><td align="left">设置&#x2F;获取密码</td></tr><tr><td align="center"><code>auth &quot;password&quot;</code></td><td align="left">密码校验</td></tr><tr><td align="center"><code>maxclients 128</code></td><td align="left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td></tr><tr><td align="center"><strong>APPEND ONLY MODE</strong></td><td align="left"></td></tr><tr><td align="center"><code>appendonly no</code></td><td align="left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td></tr><tr><td align="center"><code>appendfilename appendonly.aof</code></td><td align="left">指定更新日志文件名，默认为 appendonly.aof</td></tr><tr><td align="center"><code>appendfsync everysec</code></td><td align="left">指定更新日志条件，共有 3 个可选值：<br/>no：表示等操作系统进行数据缓存同步到磁盘（快）<br/>always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<br/>everysec：表示每秒同步一次（折中，默认值）</td></tr><tr><td align="center"><code>No-appendfsync-on-rewrite</code></td><td align="left">重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。</td></tr><tr><td align="center"><strong>VM</strong></td><td align="left"></td></tr><tr><td align="center"><code>vm-enabled no</code></td><td align="left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中</td></tr><tr><td align="center"><code>vm-swap-file /tmp/redis.swap</code></td><td align="left">虚拟内存文件路径，默认值为 &#x2F;tmp&#x2F;redis.swap，不可多个 Redis 实例共享</td></tr><tr><td align="center"><code>vm-max-memory 0</code></td><td align="left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td></tr><tr><td align="center"><code>vm-page-size 32</code></td><td align="left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td></tr><tr><td align="center"><code>vm-pages 134217728</code></td><td align="left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td></tr><tr><td align="center"><code>vm-max-threads 4</code></td><td align="left">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td></tr></tbody></table><p>Redis官网中介绍了Redis的两种持久化机制，如图所示</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208211519780.png" alt="image-20211208211519780" style="zoom:80%;" /><p>【Redis中文网的翻译如下】Redis 提供了不同级别的持久化方式</p><ul><li>RDB持久化方式能够在指定的时间间隔对你的数据进行快照存储.</li><li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大.</li><li>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li><li>你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li></ul><p>（后面的官网介绍就用Redis中文网的翻译版替代，便于理解）</p><h2 id="持久化之RDB"><a href="#持久化之RDB" class="headerlink" title="持久化之RDB"></a>持久化之RDB</h2><p>了解RDB具体内容之前，可以先看看官网的介绍</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208211537873.png" alt="image-20211208211537873" style="zoom:80%;" /><h3 id="RDB是什么"><a href="#RDB是什么" class="headerlink" title="RDB是什么"></a>RDB是什么</h3><p>RDB持久化方案是：<strong>在指定的时间间隔内将内存中的数据集快照写入磁盘(point-in-time)，即为Snapshot，恢复方式是将快照文件直接读到内存中</strong>。它以紧缩的二进制文件保存Redis数据库某一时刻所有数据对象的内存快照，可用于Redis的数据备份、转移与恢复。到目前为止，仍是官方的默认支持方案。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208234044320.png" alt="image-20211208234044320" style="zoom:80%;" /><h3 id="RDB工作原理"><a href="#RDB工作原理" class="headerlink" title="RDB工作原理"></a>RDB工作原理</h3><h4 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1.工作原理"></a>1.工作原理</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，先将数据写入到一个临时文件<code>dump.rdb</code>中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件（整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能）</p><p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h4 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">## Redis.conf：********************SNAPSHOT********************</span><br><span class="hljs-comment"># 时间策略</span><br><span class="hljs-string">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span><br><span class="hljs-string">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span><br><span class="hljs-string">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span><br><br><span class="hljs-comment"># 文件名称</span><br><span class="hljs-string">dbfilename</span> <span class="hljs-string">dump.rdb</span><br><br><span class="hljs-comment"># 文件保存路径</span><br><span class="hljs-string">dir</span> <span class="hljs-string">./</span><br><br><span class="hljs-comment"># 如果持久化出错，主进程是否停止写入</span><br><span class="hljs-string">stop-writes-on-bgsave-error</span> <span class="hljs-literal">yes</span><br><br><span class="hljs-comment"># 是否压缩</span><br><span class="hljs-string">rdbcompression</span> <span class="hljs-literal">yes</span><br><br><span class="hljs-comment"># 导入时是否检查</span><br><span class="hljs-string">rdbchecksum</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><ul><li>配置文件中持久化的策略为：<code>save &lt;seconds&gt;&lt;changes&gt;</code>，即在指定seconds内至少changs个key发生了改变，就会自动触发持久化；</li><li>RDB持久化的快照文件名称默认为<code>dump.rdb</code>；</li><li>快照文件默认存储在Redis启动时命令行所在的目录下；</li><li><code>stop-writes-on-bgsave-error</code>开启表示当Redis无法写入磁盘的话，直接关掉Redis的写操作。默认为yes；</li><li><code>rdbcompression</code>开启表示Redis会采用LZF算法对快照文件进行压缩存储；</li><li><code>rdbchecksum</code>开启表示Redis启用CRC64算法来进行数据校验</li></ul><h4 id="3-触发机制"><a href="#3-触发机制" class="headerlink" title="3.触发机制"></a>3.触发机制</h4><p>Redis的持久化触发方式有两种：指令主动触发、自动触发</p><ul><li><p>自动触发：满足配置文件中的<code>save &lt;seconds&gt;&lt;changes&gt;</code>规则时触发；主从复制时主节点发送rdb文件到从节点会触发；执行<code>debug reload</code>时会触发；shutdown时未开启aof会触发。【自动触发采用的是bgsave】</p></li><li><p>手动触发：通过手动输入指令实现。</p><ul><li><p><strong>save</strong>：执行save执行后，Redis会立刻启动持久化流程，由于Redis的请求处理是单线程模型，因此会阻塞其他所有服务。不建议线上使用。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208221452010.png" alt="image-20211208221452010" style="zoom:80%;" /></li><li><p><strong>bgsave</strong>：Redis会在后台异步进行快照操作，通过fork出子进程操作持久化，主线程同时可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间</p><p>【注】Redis的fork子进程操作会阻塞，如果频繁的执行备份或文件集较大fork耗时较长，都会影响Redis性能</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208221505183.png" alt="image-20211208221505183" style="zoom:80%;" /></li><li><p>执行flushall命令，也会产生dump.rdb文件。flushall用于清空Redis数据库所有数据，因此也会对dump.rdb等备份文件进行清空，最终得到的就是空的dump.rdb文件。</p></li></ul></li></ul><h3 id="RDB备份操作"><a href="#RDB备份操作" class="headerlink" title="RDB备份操作"></a>RDB备份操作</h3><p>1.首先设置自动备份策略<code>save 15 2</code>，15秒内有两次key的修改就自动备份。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208231357749.png" alt="image-20211208231357749" style="zoom: 80%;" /><p>2.通过<code>config get dir</code>获取rdb文件存储路径为<code>/etc/opt</code>，此时该路径下还没有dump.rdb文件</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208231546701.png" alt="image-20211208231546701" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208231525203.png" alt="image-20211208231525203" style="zoom:67%;" /><p>3.进入redis-cli，通过<code>set k v</code>指令在15秒内修改2个key，此时再看发现有文件了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208231639148.png" alt="image-20211208231639148" style="zoom:67%;" /><p>4.通过<code>shutdown</code>关闭Redis服务，将rdb文件拷贝到myconf目录并重命名dump_old.rdb，删除原来的dump.rdb文件，启动redis，此时<code>KEYS *</code>看到的时（empty array），原来的数据都没有了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208232640759.png" alt="image-20211208232640759" style="zoom:80%;" /><p>5.再次关闭Redis。将dump_old.rdb拷贝到<code>/etc/opt</code>目录下【此时会提示是否覆盖，因为shutdown未指定aof时会产生rdb文件】，启动Redis，此时就又可以看到之前的key了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208232921640.png" alt="image-20211208232921640" style="zoom:80%;" /><p>6.手动备份直接调用save或bgsave，就会在<code>/etc/opt</code>目录下生成dump.rdb文件。其他验证操作类似</p><p>7.动态停止RDB：<code>redis-cli config set save &quot;&quot;</code>#save后给空值，表示禁用保存策略</p><h3 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h3><p>RDB备份的优缺点官网文档已经给出</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>能够节省磁盘空间</li><li>恢复速度快</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是如果数据庞大时还是比较消耗性能。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改</li></ul><h2 id="持久化之AOF"><a href="#持久化之AOF" class="headerlink" title="持久化之AOF"></a>持久化之AOF</h2><p>同样可以先了解下官网文档对AOF的介绍</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211208234508553.png" alt="image-20211208234508553" style="zoom:80%;" /><h3 id="AOF是什么"><a href="#AOF是什么" class="headerlink" title="AOF是什么"></a>AOF是什么</h3><p>上面的RDB是一种时间点策略的持久化，它比较适合数据备份和容灾恢复。但是它不能实时地进行数据持久化，而AOF就是对这个问题的补充。</p><p>AOF以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h3 id="AOF工作原理"><a href="#AOF工作原理" class="headerlink" title="AOF工作原理"></a>AOF工作原理</h3><h4 id="1-工作原理-1"><a href="#1-工作原理-1" class="headerlink" title="1.工作原理"></a>1.工作原理</h4><p>AOF是Redis的完全持久化策略，它通过记录所有引起Redis数据修改的指令集合，按顺序追加到文件中，然后重启时从头全部执行一遍，达到恢复关闭前的数据状态。因此将aof文件放到任何机器上，Redis都能按需执行指令恢复数据。</p><p>由于每一次的写操作都需要记录到文件中，因此AOF会对Redis的性能有一定影响</p><p>AOF的本质是利用Redis的通讯协议，将命令以纯文本形式写入到备份文件中。例如指令<code>set name leslie</code>执行，会在缓冲区追加文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">\r\n$3\r\nset\r\n$5\r\nname\r\n$5\r\nleslie\r\n<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">Redis协议</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">首先Redis是以行来划分，每行以\r\n行结束。每一行都有一个消息头，消息头共分为5种分别如下:</span><br>+#表示一个正确的状态信息，具体信息是当前行后面的字符。<br>-#表示一个错误信息，具体信息是当前行后面的字符。<br>*#表示消息体总共有多少行，不包括当前行,后面是具体的行数。<br><span class="hljs-meta prompt_">$</span><span class="language-bash"><span class="hljs-comment">#表示下一行数据长度，不包括换行符长度\r\n,后面则是对应的长度的数据。</span></span><br>:#表示返回一个数值，后面是相应的数字节符。<br></code></pre></td></tr></table></figure><p>（1）采用文本协议的原因</p><ol><li>文本协议具有很好的兼容性。</li><li>开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免二次处理开销。</li><li>文本协议具有可读性，方便直接修改和处理。</li></ol><p>（2）追加指令到缓冲区的原因</p><ol><li>Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，会带来很高的磁盘IO，影响整体性能；</li><li>Redis还可以通过提供不同的缓冲区同步策略，在性能和安全性方面做出平衡。</li></ol><h4 id="2-配置文件-1"><a href="#2-配置文件-1" class="headerlink" title="2.配置文件"></a>2.配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">是否开启aof</span><br>appendonly yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件名称</span><br>appendfilename &quot;appendonly.aof&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">同步方式</span><br>appendfsync everysec<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">aof重写期间是否同步</span><br>no-appendfsync-on-rewrite no<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重写触发配置</span><br>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载aof时如果有错如何处理</span><br>aof-load-truncated yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件重写策略</span><br>aof-rewrite-incremental-fsync yes<br></code></pre></td></tr></table></figure><ul><li>AOF默认是关闭的，通过修改配置中的<code>appendonly</code>为yes开启；</li><li>默认的备份文件名称是<code>appendonly.aof</code>；</li><li>同步方式有三种：always、everysec、no。一般采用everysec，顶多损失1s的数据；</li><li><code>no-appendfsync-on-rewrite</code>开启表示：在重写aof文件期间执行的写操作，不会写进aof文件而是写入缓存</li><li><code>auto-aof-rewrite-percentage</code>和<code>auto-aof-rewrite-min-size</code>设置了AOF文件重写的增长百分比或文件大小；</li><li><code>aof-load-truncated </code>开启表示：在加载时发现aof尾部不正确，会向客户端写入一个log，然后继续执行，如果设置为 <code>no</code> ，发现错误就会停止，必须修复后才能重新加载。</li></ul><h4 id="3-工作流程"><a href="#3-工作流程" class="headerlink" title="3.工作流程"></a>3.工作流程</h4><p>AOF总体分为两个部分：将指令实时写入aof文件、读取aof文件重写数据。具体流程包括<strong>命令写入append</strong>、<strong>文件同步sysc</strong>、<strong>文件重写rewrite</strong>、<strong>重启加载load</strong>。</p><h5 id="3-1-命令写入"><a href="#3-1-命令写入" class="headerlink" title="3.1 命令写入"></a>3.1 命令写入</h5><p>Redis在启动AOF后，每执行一个写操作的指令，都会以协议格式将被执行的命令追加到Redis的AOF缓存区（aof_buf）末尾。这样的好处在于在大量写请求情况下，采用缓冲区暂存一部分命令随后根据策略一次性写入磁盘，这样可以减少磁盘的I&#x2F;O次数，提高性能。</p><p>【注】：如果命令append时正在进行重写，这些命令还会写入缓存区</p><h5 id="3-2-文件同步"><a href="#3-2-文件同步" class="headerlink" title="3.2 文件同步"></a>3.2 文件同步</h5><p>学习文件同步前，先了解Linux的<strong>系统调用write和fsync</strong></p><ul><li><p>write操作会触发<strong>延迟写（delayed write）机制</strong>——传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I&#x2F;O都通过缓冲进行。 当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者达到特定时间周期时， 再将该缓冲排到输出队列，然后待其到达队首时，才进行实际的I&#x2F;O操作。这种输出方式就被称为延迟写。</p><p>write操作通过延迟写减少了磁盘IO提高了性能。但是降低了aof文件内容更新的速度，在未达到缓冲区输出条件这段时间的数据都没有同步。如果此时系统发生故障，可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数为强制写入硬盘提供支持。</p></li><li><p>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞进程直到写入硬盘完成后返回，保证了数据持久化。</p></li></ul><p>Redis根据指定策略将缓冲区数据写入文件。Redis提供了三种同步策略，由配置参数<code>appendfsync</code>决定，下面是每个策略对应的含义：</p><ul><li>no：不使用fsync方法同步，而是交给操作系统write函数去执行同步操作，在linux操作系统中大约每30秒刷一次缓冲；</li><li>always：表示每次有写操作都调用fsync方法强制内核将数据写入到aof文件；</li><li>everysec：数据将使用调用操作系统write写入文件，并使用fsync每秒一次从内核刷新到磁盘。 这是折中的方案，最多丢失1S数据，兼顾性能和数据安全，所以Redis<strong>默认推荐使用该配置</strong>。</li></ul><h5 id="3-3-文件重写"><a href="#3-3-文件重写" class="headerlink" title="3.3 文件重写"></a>3.3 文件重写</h5><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集。</p><p>Redis会记录上次重写时的AOF大小，上面的配置文件有介绍，默认配置是当AOF文件大小是上次rewrite后大小的100%且文件大于64M时自动触发。也可以使用命令<code>bgrewriteaof</code>手动触发。</p><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size，如果Redis的AOF当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis会对AOF进行重写。 </p><p><strong>重写流程</strong></p><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename覆盖)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</p><p>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p><p>（2）主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p><p>（3）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</p><p>（4）1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p><p>（5）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211210002329960.png" alt="image-20211210002329960" style="zoom: 80%;" /><p><strong>重写举例</strong></p><p>Redis服务器通过AOF重写生成新的aof文件替代旧aof，新旧aof文件所对应的是相同的Redis数据状态。不过新的文件在指令上做了精简</p><p>启动Redis输入如下指令：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211210225414544.png" alt="重写实现" style="zoom:80%;" /><p>此时list中的数据状态：<code>[&quot;v0&quot;,&quot;v1&quot;,&quot;v2&quot;,&quot;v3&quot;,&quot;v7&quot;,&quot;v8&quot;]</code>，旧的aof文件包括以上所有修改数据的指令。</p><p>如果要重写AOF达到和当前list相同的数据状态，最好的方法不是读取旧的aof文件，而是直接遍历当前Redis数据库中list键值，用：<code>RPUSH list v0 v1 v2 v3 v7 v8</code>一条指令实现相同的数据状态。</p><h5 id="3-4-重启加载"><a href="#3-4-重启加载" class="headerlink" title="3.4 重启加载"></a>3.4 重启加载</h5><p>当Redis服务关闭重启后，对于服务器上既有RDB又有AOF文件时，优先加载AOF文件</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211210003029035.png" alt="image-20211210003029035" style="zoom: 80%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实Redis官网的持久化介绍就是关于RDB和AOF的优缺点及使用推荐。</p><p>可以参考中文官网：<a href="http://www.redis.cn/topics/persistence.html">Redis 持久化</a>进行了解。</p><p>RDB快照、AOF重写都需要fork，这是一个重量级操作，会对Redis造成阻塞。因此为了不影响Redis主进程响应，需要尽可能降低阻塞。比如降低fork频率、制定合理的内存分配策略、控制Redis的最大内存等</p><p>在具体实践时，可以自己制定策略，RDB和AOF结合使用，并定期检查Redis情况，然后手动备份、重写数据；单机部署多个实例时，需要注意防止福哦个机器同时持久化和重写，避免出现IO、内存的竞争，造成串行操作；也可以加入主从机器，一台备份一台响应请求等；</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844903655527677960">一文看懂Redis的持久化原理</a></li><li><a href="https://segmentfault.com/a/1190000039208726">Redis专题：万字长文详解持久化原理</a></li><li><a href="https://www.bilibili.com/video/BV1oW411u75R?p=18">尚硅谷Redis持久化</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习二：基本数据类型及操作</title>
    <link href="/20211206/7af3bdf0/"/>
    <url>/20211206/7af3bdf0/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><h3 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h3><p>Redis：Remote Dictionary Server（远程字典服务器）是一个开源免费的，用ANSI C语言编写的，遵守BSD协议的高性能（Key-Value）分布式内存数据库，基于内存运行，并支持持久化的NoSQL。</p><span id="more"></span><h3 id="Redis能干嘛"><a href="#Redis能干嘛" class="headerlink" title="Redis能干嘛"></a>Redis能干嘛</h3><p>redis是一种支持key-value等多种数据结构的存储系统，有点类似于Java的<code>Map&lt;key,Object&gt;</code>结构。可用于缓存，事件发布或订阅，高速队列等场景。</p><ol><li>缓存：Redis最主要的用法，能有效提升系统性能</li><li>排行榜：传统关系型数据库做排行很麻烦，Redis的ZSet很方便</li><li>计算器&#x2F;限速器：利用Redis中原子性的自增操作，同级用户的点赞、访问等数据，这类频繁读写的操作采用MySQL会对数据库带来很大的压力；限速器使用的典型场景为限制用户访问某个API的频率，比如出现抢购时，用户点击过多会限制访问，这样可以降低系统压力（限速器也是一种请求限流的实现方式）</li><li>好友关系：利用Redis的集合特点，通过求交集、并集、差集等获取共同爱好、共同好友等</li><li>简单消息队列：除了Redis自身的发布&#x2F;订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦</li><li>Session共享：默认Session是保存在服务器的文件中，即当前服务器，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息</li></ol><h2 id="安装测试Redis"><a href="#安装测试Redis" class="headerlink" title="安装测试Redis"></a>安装测试Redis</h2><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><p>网课给的安装包执行解压报错，因此自行安装。</p><ol><li><p>使用<code>wget http://download.redis.io/releases/redis-6.2.1.tar.gz</code>获取对应压缩包。</p></li><li><p>使用<code>tar -zxvf redis-6.2.1.tar.gz</code>解压，得到<code>redis-6.2.1</code>文件夹。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129221432662.png" alt="image-20211129221432662" style="zoom:80%;" /></li><li><p>使用<code>cd redis-6.2.1</code>进入安装目录，执行<code>make</code>指令编译。</p><ul><li><p>初次安装的虚拟机执行make会报错。是因为缺少GCC</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129221717318.png" alt="image-20211129221717318" style="zoom: 80%;" /></li><li><p>使用<code>yum install gcc-c++</code>指令安装GCC。报错：Jemalloc&#x2F;jemalloc.h：没有这个文件或目录</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129221924535.png" alt="image-20211129221924535" style="zoom: 80%;" /></li><li><p>使用<code>make distclean</code>后再次make即可。</p></li></ul></li><li><p>执行make后执行<code>make install</code>安装。</p></li><li><p>默认安装在<code>usr/local/bin</code>目录下</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129222334084.png" alt="image-20211129222334084" style="zoom: 80%;" /></li><li><p>启动测试一下</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129222550428.png" alt="image-20211129222550428" style="zoom:80%;" /></li></ol><p><strong>说明</strong></p><p>以上说明redis安装成功，不过还有一些需要修改的地方：比如刚才在<code>etc/opt/redis-6.2.1</code>目录下有个Redis.conf文件，这是Redis的配置文件，redis启动时默认按照此文件加载，后面的学习需要对此文件修改，所以可以先备份一下；现在启动Redis是前台启动的形式，启动后窗口不能执行其他操作，可以改为后台进行。</p><ol><li>在opt目录下<code>makedir myconf</code>创建myconf目录，将redis.conf复制到目录中。</li><li>修改myconf里面的配置文件，将daemonize no 改成 yes，让服务在后台启动。</li></ol><p>再次执行<code>redis-server /etc/opt/myconf/redis.conf</code>。此时服务可以启动，执行<code>redis-cli</code>启动客户端，执行ping验证连通性，得到pong即为redis启动成功。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129223723969.png" alt="image-20211129223723969" style="zoom:80%;" /><h3 id="Redis启动杂项"><a href="#Redis启动杂项" class="headerlink" title="Redis启动杂项"></a>Redis启动杂项</h3><ol><li><p>Redis默认端口是6379，可以通过配置文件修改端口。</p></li><li><p>Redis默认数据库有16个</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129224146572.png" alt="image-20211129224146572" style="zoom:80%;" /></li><li><p>select命令切换数据库，默认使用0号库</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129232543897.png" alt="image-20211129232543897" style="zoom:80%;" /></li><li><p>dbsize查看数据库的key数量</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211129232703531.png" alt="image-20211129232703531" style="zoom:80%;" /></li><li><p>flushdb清空当前库、flushall清空所有库</p></li><li><p>统一密码管理：16个库都是用同样的密码</p></li><li><p><font color="red"><strong>redis高效原因：单线程＋多路复用技术</strong></font></p></li></ol><h4 id="Redis单线程"><a href="#Redis单线程" class="headerlink" title="Redis单线程"></a>Redis单线程</h4><p>Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。</p><p><strong>1.Redis不是完全单线程的</strong></p><p>Redis单线程是处理网络请求使用单个线程来处理：即一个线程处理所有网络请求，其他模块仍使用多线程。</p><p>以Redis持久化为例，RDB方式持久化即为fork一个子线程将数据写入临时文件中。</p><p><strong>2.Redis使用多路复用技术</strong></p><p>Redis对读写时间的响应是通过封装epoll<a href="Epoll%E6%98%AFLinux%E5%86%85%E6%A0%B8%E4%B8%BA%E5%A4%84%E7%90%86%E5%A4%A7%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%80%8C%E4%BD%9C%E4%BA%86%E6%94%B9%E8%BF%9B%E7%9A%84epoll%EF%BC%8C%E6%98%AFLinux%E4%B8%8B%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO%E6%8E%A5%E5%8F%A3select/poll%E7%9A%84%E5%A2%9E%E5%BC%BA%E7%89%88%E6%9C%AC%EF%BC%8C%E5%AE%83%E8%83%BD%E6%98%BE%E8%91%97%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%A4%A7%E9%87%8F%E5%B9%B6%E5%8F%91%E8%BF%9E%E6%8E%A5%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%B0%91%E9%87%8F%E6%B4%BB%E8%B7%83%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E7%B3%BB%E7%BB%9FCPU%E5%88%A9%E7%94%A8%E7%8E%87%E3%80%82">^epoll</a>函数来实现的。Redis的实际处理速度完全依靠主进程的执行效率。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Redis-Multiplexing.gif"></p><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis的五大基本数据结构：</p><ul><li>字符串String：字符串是Redis最基本的类型，采用key-value形式。一个redis中字符串value最大为512M；</li><li>哈希Hash：hash是一个键值对集合，是一个string类型的field和value的映射表；</li><li>列表List：list是一个字符串列表，按照插入顺序排序。他的底层实现是链表；</li><li>集合Set：set是一个string类型的无序集合，通过HashTable实现；</li><li>有序集合Zset(Sorted set)：zset和set都是string类型的集合，不过zset中每个元素都会关联一个double类型的分数，redis通过这个分数危机和中的元素进行排序（zset的数据是唯一的，不过分数可以重复）</li></ul><p>有关Redis的常见数据类型操作指令，可以在<a href="http://redisdoc.com/Http://redisdoc.com/">Redis命令参考</a>中查看。</p><h3 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis Key"></a>Redis Key</h3><h4 id="1-结构"><a href="#1-结构" class="headerlink" title="1.结构"></a>1.结构</h4><p>对Redis来说，所有的Key都是字符串</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/redis-key.png" alt="redis-key" style="zoom:80%;" /><h4 id="2-常用指令"><a href="#2-常用指令" class="headerlink" title="2.常用指令"></a>2.常用指令</h4><table><thead><tr><th>命令</th><th>描述</th><th>使用</th></tr></thead><tbody><tr><td>keys</td><td>查看当前库的所有key</td><td>keys *</td></tr><tr><td>exist</td><td>判断某个key是否存在</td><td>exist key</td></tr><tr><td>type</td><td>查看key的类型</td><td>type key</td></tr><tr><td>del</td><td>删除指定key的数据</td><td>del key</td></tr><tr><td>unlink</td><td>根据value选择非阻塞删除</td><td>unlink key</td></tr><tr><td>expire</td><td>未指定key设置过期时间</td><td>expire key 10</td></tr><tr><td>ttl</td><td>查看还有多久过期</td><td>ttl key</td></tr></tbody></table><p>执行结果如下：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211202231612405.png" alt="image-20211202231612405" style="zoom:80%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">unlink</span>是非阻塞删除，即仅仅将数据从keyspace元数据中删除，真正的删除会在后续异步操作</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ttl key查看过期时间，-1表示永不过期，-2表示已过期</span><br></code></pre></td></tr></table></figure><p>注：几个查看redis库的指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">SELECT #切换数据库<br>DBSIZE #查看当前数据库key的数量<br>FLUSHDB #清空当前数据库<br>FLUSHALL #清空所有数据库<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211202232040962.png" alt="image-20211202232040962" style="zoom:80%;" /><h3 id="Redis-String"><a href="#Redis-String" class="headerlink" title="Redis String"></a>Redis String</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>String的数据结构为简单动态字符串（Simple Dynamic String，简写SDS）。是可修改的字符串，内部结构是线上类似于Java的ArrayList，采用预分配荣誉空间的方式来减少内少的频繁分配。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211204234129389.png" alt="image-20211204234129389" style="zoom:80%;" /><p>如图所示，内部为当前字符串实际分配的空间capacity，一般要高于实际字符串长度len。</p><p>当字符串长度小于1M，扩容方式是现有空间加倍；超过1M时，每次扩容只会增加1M空间。并且字符串的最大长度为512M</p><p>Redis的String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p><h4 id="2-常用指令-1"><a href="#2-常用指令-1" class="headerlink" title="2.常用指令"></a>2.常用指令</h4><table><thead><tr><th>命令</th><th>描述</th><th>使用</th></tr></thead><tbody><tr><td>SET</td><td>设置指定key的value</td><td>set key1 value1</td></tr><tr><td>GET</td><td>获取指定key的value</td><td>get key1</td></tr><tr><td>DEL</td><td>删除指定的key-value</td><td>del key1</td></tr><tr><td>INCR</td><td>将对应key的value加1</td><td>incr key1</td></tr><tr><td>DECR</td><td>将对应key的value减1</td><td>decr key1</td></tr><tr><td>INCRBY</td><td>将对应key的value加指定整数</td><td>incrby key1 count</td></tr><tr><td>DECRBY</td><td>将对应key的value减指定整数</td><td>decrby key1 count</td></tr></tbody></table><p>对string操作的指令执行结果如下（set、get、del上面已经演示）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">append key value     #在指定key的值后面追加value1，这里的追加是字符串拼接<br>strlen key  #获取指定key的长度<br>setnx  key value  #(set if not exist)只有在key不存在时才创建<br>setex  key time value #(set with expire)设置带过期时间的key-value<br>mset   K1 V1 K2 V2 ... Kn Vn#同时设置一个或多个key-value键值对<br>mget   K1 K2 .. Kn  #同时获取一个或多个给定key的值<br>msetnx K1 V1 K2 V2 ... Kn Vn#同时设置一个或多个key-value。当且仅当所有给定key都不存在时<br>getset key value #先将给定key值设置为value，返回key的旧值(old value)。即先get再set<br><br>incr、decr、incrby、decrby    <br><span class="hljs-meta prompt_">#</span><span class="language-bash">操作对象只能是数字。如果为空，新增值为1，减少值为-1；后两者自定义</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">对数值的增减操作是原子性的</span><br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211202232516451.png" alt="image-20211202232516451" style="zoom:80%;" /><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><ol><li>缓存：最经典最常用的场景。将一些常用的信息放在redis中，redis作为缓存层，MySQL作为持久层，达到降低MySQL的读写压力。</li><li>计数器：Redis的单线程模型保证了他一次只会执行一个命令的特点</li><li>session：采用Spring Session+Redis实现Session共享，一次登录多次使用。</li></ol><h3 id="Redis-List"><a href="#Redis-List" class="headerlink" title="Redis List"></a>Redis List</h3><h4 id="1-数据结构-1"><a href="#1-数据结构-1" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>List就是链表，Redis的List采用双端链表来实现，value可重复，类似于Java中的LinkedList。所以它的特性和链表相似：对两端的插入删除操作性能很好，但是通过索引定位查找的性能较差。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Redis-List.png" alt="Redis-List" style="zoom:80%;" /><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如一个列表里存储的是基本的int或string类型数据，结构上还需要两个额外的指针prev和next。</p><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><p>list的使用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">lpush/rpush  &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; .... # 从左边/右边插入一个或多个值。<br>lpop/rpop   &lt;key&gt;# 从左边/右边吐出一个值。值在键在，值光键亡。<br>rpoplpush   &lt;key1&gt;&lt;key2&gt;# 从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边。<br>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;# 按照索引下标获得元素(从左到右)<br>lrange list 0 -1   # 0左边第一个，-1右边第一个，（0-1表示获取所有）<br>lindex &lt;key&gt;&lt;index&gt;# 按照索引下标获得元素(从左到右)<br>llen   &lt;key&gt;# 获得列表长度 <br>linsert &lt;key&gt;  before &lt;value&gt;&lt;newvalue&gt;# 在&lt;value&gt;的后面插入&lt;newvalue&gt;插入值<br>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;# 从左边删除n个value(从左到右)<br>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;# 将列表key下标为index的值替换成value<br><br></code></pre></td></tr></table></figure><p>使用基础的LPUSH、RPUSH效果如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211205211524791.png" alt="image-20211205211524791" style="zoom: 80%;" /><p>可以利用list的链表本质实现一些基本数据结构。</p><ol><li>list实现队列：<strong>LPUSH+RPOP</strong>或<strong>RPUSH+LPOP</strong>；利用队列先进先出的特点，实现消息队列或异步处理等操作。</li><li>2.list实现栈：<strong>LPUSH+LPOP</strong>或<strong>RPUSH+RPOP</strong>；实现了栈先进后出的特点。</li></ol><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211205212523432.png" alt="image-20211205212523432" style="zoom: 80%;" /><h4 id="3-使用场景-1"><a href="#3-使用场景-1" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><p>list常见的场景有消息队列、时间轴、点赞评论的列表等</p><h3 id="Redis-Hash"><a href="#Redis-Hash" class="headerlink" title="Redis Hash"></a>Redis Hash</h3><p>Redis的Hash字典是一个kv键值对集合，同时v也是一个string类型的<code>field-value</code>映射表。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Redis-Hash.png" alt="Redis-Hash" style="zoom:80%;" /><h4 id="1-数据结构-2"><a href="#1-数据结构-2" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>Redis Hash类似于Java中的HashMap&lt;String,Object&gt;，内部实现上都是<strong>“数组+链表”</strong>的链地址法解决哈希冲突。</p><p>hash类型对应的数据结构是两种：ziplist(压缩链表)、hashtable(哈希表)；当<code>field-value</code>长度较短且个数较少时使用ziplist，否则使用hashtable</p><h4 id="2-常用命令-1"><a href="#2-常用命令-1" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><p>hash的常用指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">hset &lt;key&gt;&lt;field&gt;&lt;value&gt;# 给&lt;key&gt;集合中的&lt;field&gt;键赋值&lt;value&gt;<br>hget &lt;key1&gt;&lt;field&gt;# 通过&lt;key1&gt;集合的&lt;field&gt;取出对应value <br>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;... # 批量设置hash的值<br>hexists&lt;key1&gt;&lt;field&gt;# 查看哈希表key中，给定field是否存在。 <br>hkeys &lt;key&gt;# 列出该hash集合的所有field<br>hvals &lt;key&gt;# 列出该hash集合的所有value<br>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;# 为哈希表 key 中的 field 的值加上增量 1、-1<br>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;# 将哈希表 key 中的 field 的值设置为 value，当且仅当域 field 不存在 .<br><br></code></pre></td></tr></table></figure><p>使用效果如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211205215743109.png" alt="image-20211205215743109" style="zoom: 80%;" /><h4 id="3-使用场景-2"><a href="#3-使用场景-2" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><p>更丰富的缓存：相比string存储字符串，hash可以存储object，可以用来存储用户信息、订单信息等</p><h3 id="Redis-Set"><a href="#Redis-Set" class="headerlink" title="Redis Set"></a>Redis Set</h3><p>Set和List都是单key多value，不过set里面的value不允许重复；集合中的元素是无序的，不能通过下表获取元素；set可以利用集合特性实现相关操作，如取交集、并集等。Redis Set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Redis-set.png" alt="Redis-set" style="zoom:80%;" /><h4 id="1-数据结构-3"><a href="#1-数据结构-3" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>Redis的Set是string类型的无序集合(dict字典)。它底层其实是一个value为null的hash表，所以添加，删除，查找的**复杂度都是O(1)**。</p><p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><h4 id="2-常用命令-2"><a href="#2-常用命令-2" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><p>Set的常用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... <br><span class="hljs-meta prompt_"># </span><span class="language-bash">将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</span><br>smembers &lt;key&gt;# 取出该集合的所有值。<br>sismember &lt;key&gt;&lt;value&gt;# 判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0<br>scard&lt;key&gt;# 返回该集合的元素个数。<br>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .... # 删除集合中的某个元素。<br>spop &lt;key&gt;# 随机从该集合中吐出一个值。<br>srandmember &lt;key&gt;&lt;n&gt;# 随机从该集合中取出n个值。不会从集合中删除 。<br>smove &lt;source&gt;&lt;destination&gt;value# 把集合中一个值从一个集合移动到另一个集合<br>sinter &lt;key1&gt;&lt;key2&gt;# 返回两个集合的交集元素。<br>sunion &lt;key1&gt;&lt;key2&gt;# 返回两个集合的并集元素。<br>sdiff &lt;key1&gt;&lt;key2&gt;# 返回两个集合的差集元素(key1中的，不包含key2中的)<br><br></code></pre></td></tr></table></figure><p>使用效果如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211205221127567.png" alt="image-20211205221127567" style="zoom: 80%;" /><h4 id="3-使用场景-3"><a href="#3-使用场景-3" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><ol><li>标签（tag）：给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li><li>点赞，或点踩，收藏等，可以放到set中实现。</li></ol><h3 id="Redis-Zset"><a href="#Redis-Zset" class="headerlink" title="Redis Zset"></a>Redis Zset</h3><p>Zset在Set的基础上，为每个成员增加了一个评分score，通过按score由低到高给集合中的元素排序。集合中成员是唯一的，而score是可以重复的。</p><p>由于元素有序，所以可以根据评分score和次序position来快速获取一个区间的元素。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Redis-Zset.png" alt="Redis-Zset" style="zoom:80%;" /><h4 id="1-数据结构-4"><a href="#1-数据结构-4" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><p>zset底层使用了两个数据结构：</p><ol><li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li><li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li></ol><h4 id="2-常用命令-3"><a href="#2-常用命令-3" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><p>Zset常用命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">zadd  &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</span><br>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;  [WITHSCORES]   <br><span class="hljs-meta prompt_"># </span><span class="language-bash">返回有序集 key 中，下标在&lt;start&gt;&lt;stop&gt;之间的元素   带WITHSCORES，可以让分数一起和值返回到结果集。</span><br>zrangebyscore key min max [withscores] [limit offset count]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">返回有序集 key 中，所有 score 值介于[min,max]的成员。有序集成员按 score 值递增(从小到大)次序排列。</span> <br>zrevrangebyscore key maxmin [withscores] [limit offset count]               <br><span class="hljs-meta prompt_"># </span><span class="language-bash">同上，改为从大到小排列。</span> <br>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;     # 为元素的score加上增量<br>zrem  &lt;key&gt;&lt;value&gt;# 删除该集合下，指定值的元素 <br>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;# 统计该集合，分数区间内的元素个数 <br>zrank &lt;key&gt;&lt;value&gt;# 返回该值在集合中的排名，从0开始。<br><br></code></pre></td></tr></table></figure><p>使用效果如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211205225104267.png" alt="image-20211205225104267" style="zoom:80%;" /><h4 id="3-使用场景-4"><a href="#3-使用场景-4" class="headerlink" title="3.使用场景"></a>3.使用场景</h4><p>比较常用的就是排行榜。比如文章阅读量热榜、商品销量热榜等实现。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习一：NoSQL学习</title>
    <link href="/20211128/57551b57/"/>
    <url>/20211128/57551b57/</url>
    
    <content type="html"><![CDATA[<p>作为目前最知名也是最流行的开源NoSQL数据库，Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库。因此Redis的学习很有必要。主要通过B站尚硅谷网课和配套资料免费学习。</p><ul><li>网课参考：<a href="https://www.bilibili.com/video/BV1Rv41177Af">Redis 6 入门到精通 超详细 教程</a>、<a href="https://www.bilibili.com/video/BV1oW411u75R">尚硅谷超经典Redis教程,redis实战,阳哥版从入门到精通</a></li><li>笔记参考：<a href="https://blog.csdn.net/u011863024/article/details/107476187">Redis学习笔记</a></li></ul><h2 id="NoSQL入门概述-上"><a href="#NoSQL入门概述-上" class="headerlink" title="NoSQL入门概述-上"></a>NoSQL入门概述-上</h2><h3 id="1-为什么用NoSQL"><a href="#1-为什么用NoSQL" class="headerlink" title="1 为什么用NoSQL"></a>1 为什么用NoSQL</h3><p>在介绍NoSQL之前，先介绍一下应用中的SQL发展，从单机的MySQL到分库分表+缓存到集群等等，随着移动应用发展，网站程序访问量不断激增，所以对应用的数据库要求也在不断增加。</p><p><strong>1.单机MySQL的美好年代</strong></p><p>在90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。在那个时候，更多的都是静态网页，动态交互类型的网站不多。（我们在学校做的应用基本上都是采用简单的单机MySQL）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211117221900849.png" alt="image-20211117221900849" style="zoom:80%;" /><blockquote><p>DAL dal是数据访问层的英文缩写，即为数据访问层（Data Access Layer）</p></blockquote><p>上述架构下，我们来看看数据存储的瓶颈是什么?</p><ol><li>数据量的总大小一个机器放不下时</li><li>数据的索引(B+ Tree)一个机器的内存放不下时</li><li>访问量(读写混合)一个实例不能承受</li></ol><p>如果满足了上述1or3个，进化…</p><p><strong>2.Memcached(缓存)+MySQL+垂直拆分</strong></p><p>后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web程序不再仅仅专注在功能上，同时也在追求性能。</p><p>程序员们开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211117222128588.png" alt="image-20211117222128588" style="zoom:80%;" /><p><strong>3.Mysql主从读写分离</strong></p><p>由于数据库的写入压力增加，Memcached 只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211117222205901.png" alt="image-20211117222205901" style="zoom:80%;" /><p><strong>4.分表分库+水平拆分+mysql集群</strong></p><p>在Memcached的高速缓存，MySQL的主从复制， 读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。</p><p>同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="分库：将业务相关的、频繁性的数据分在同一个数据库，将一些趋于冷的数据（如用户的名字、身份证号码等变化很少的数据）放在另外的一个库中。分表：对于复杂业务产生的大量数据，例如产生了100w条数据，放在同一个表中肯定会很慢，换个方式0-25、25-50、50-75、75-100四个分区，可以达到将数据的压力差分的目的。">[2]</span></a></sup>成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211117222231999.png" alt="image-20211117222231999" style="zoom:80%;" /><p><strong>5.MySQL的扩展性瓶颈</strong></p><p>MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小， 如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差(需要复杂的技术来实现)，大数据下IO压力大，表结构更改困难，正是当前使用MySOL的开发人员面临的问题。</p><p><strong>6.今天是什么样子? ?</strong></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211117222301900.png" alt="image-20211117222301900" style="zoom:80%;" /><p><strong>7.为什么用NoSQL</strong></p><p>传统的RDBMS使用SQL语法来存储和查询数据。相反，NoSQL数据库系统包含可存储结构化，半结构化，非结构化和多态数据的多种数据库技术。</p><img src="C:\Users\cestc\AppData\Roaming\Typora\typora-user-images\image-20211120213943790.png" alt="image-20211120213943790" style="zoom:67%;" /><p>NoSQL数据库的概念在处理大量数据的互联网巨头（例如Google，Facebook，Amazon等）中变得很流行。使用RDBMS处理海量数据时，系统响应时间变慢。</p><p>为了解决此问题，当然可以通过升级现有硬件来“横向扩展”我们的系统。但这个成本很高。这个问题的替代方案是在负载增加时将数据库负载分配到多个主机上。这种方法称为“横向扩展”。传统的SQL数据库已经不适合这些应用了，NoSQL数据库的发展也却能很好的处理这些大的数据。</p><h3 id="2-NoSQL是什么"><a href="#2-NoSQL是什么" class="headerlink" title="2 NoSQL是什么"></a>2 NoSQL是什么</h3><p>NoSQL，最初被称作Non-SQL<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="NoSQL 定义：下一代数据库主要解决一些问题：非关系、分布式、开源和水平可扩展”。">[1]</span></a></sup>；后来也称作Not Only SQL，意即“不仅仅是SQL”，泛指非关系型的数据库。是一种非关系型DMS，不需要固定的架构，可以避免joins链接，并且易于扩展。</p><p>NoSQL数据库可以用于具有庞大数据存储需求的分布式数据存储、大数据和实时SNS类型的Web应用程序。例如，像Twitter，Facebook，Google这样的大型公司，每天可能产生TB级的用户数据，这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p><h3 id="3-NoSQL特点"><a href="#3-NoSQL特点" class="headerlink" title="3 NoSQL特点"></a>3 NoSQL特点</h3><h4 id="易扩展"><a href="#易扩展" class="headerlink" title="易扩展"></a>易扩展</h4><p>例如MySQL，出于业务需求需要拓展对象的属性时，是通过alter table添加字段，但是这是有限的，且数据库的字段类型也是有限的。并且对于社会关系等比较复杂的关系，可能需要用图、树等结构来描述，采用SQL难于拓展</p><p>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。（以常见的k-v键值对为例，key可以是数字、字符等等，value可以是字符串、对象、对象数组等等）</p><h4 id="大数据量高性能"><a href="#大数据量高性能" class="headerlink" title="大数据量高性能"></a>大数据量高性能</h4><p>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。</p><h4 id="多样灵活的数据模型"><a href="#多样灵活的数据模型" class="headerlink" title="多样灵活的数据模型"></a>多样灵活的数据模型</h4><p>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的Web 2.0时代尤其明显。</p><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>NoSQL在不太影响性能的情况，就可以方便地实现高可用的架构。比如Cassandra、HBase模型，通过复制模型也能实现高可用</p><h4 id="传统RDBMS-VS-NOSQL"><a href="#传统RDBMS-VS-NOSQL" class="headerlink" title="传统RDBMS VS NOSQL"></a>传统RDBMS VS NOSQL</h4><p><strong>RDBMS</strong></p><ul><li>高度组织化结构化数据</li><li>结构化查询语言(SQL)</li><li>数据和关系都存储在单独的表中</li><li>数据操纵语言，数据定义语言</li><li>严格的一致性</li><li>基础事务</li></ul><p><strong>NoSQL</strong></p><ul><li>代表着不仅仅是SQL</li><li>没有声明性查询语言</li><li>没有预定义的模式</li><li>键-值对存储，列存储，文档存储，图形数据库</li><li>最终一致性，而非ACID属性</li><li>非结构化和不可预知的数据</li><li>CAP定理</li><li>高性能，高可用性和可伸缩性</li></ul><h3 id="4-NoSQL的应用"><a href="#4-NoSQL的应用" class="headerlink" title="4.NoSQL的应用"></a>4.NoSQL的应用</h3><ul><li>K-V：键值对存储</li><li>Cache：缓存</li><li>Persistence：数据持久化</li></ul><h2 id="NoSQL入门概述-下"><a href="#NoSQL入门概述-下" class="headerlink" title="NoSQL入门概述-下"></a>NoSQL入门概述-下</h2><p>以腾讯微信、阿里淘宝为例：在节假日活动时会产生海量的用户数据；数据的种类肯定也是多样的，不是仅仅在数据库中表现的varchar、int等简单类型；双十一、春节车票抢购都是对数据的实时性有非常高的要求。对应于应用发展带来的数据3v，需求架构上也产生了三高。</p><table><thead><tr><th>大数据时代的3V</th><th>互联网需求的3高</th></tr></thead><tbody><tr><td>海量Volume</td><td>高并发</td></tr><tr><td>多样Variety</td><td>高可扩</td></tr><tr><td>实时Velocity</td><td>高性能</td></tr></tbody></table><h3 id="当下NoSQL应用场景简介"><a href="#当下NoSQL应用场景简介" class="headerlink" title="当下NoSQL应用场景简介"></a>当下NoSQL应用场景简介</h3><p><strong>SQL和NoSQL双剑合璧：</strong>以阿里巴巴为例，通过分析Alibaba中文站商品信息如何存放，看看阿里巴巴中文网站首页以女装&#x2F;女包包为例</p><h4 id="架构发展历程"><a href="#架构发展历程" class="headerlink" title="架构发展历程"></a>架构发展历程</h4><ol><li><p>演变过程</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420224124725.png" alt="image-20230420224124725" style="zoom: 67%;" /></li><li><p>第5代</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420224143458.png" alt="image-20230420224143458" style="zoom:67%;" /></li><li><p>第5代架构使命</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420224154563.png" alt="image-20230420224154563" style="zoom:67%;" /></li></ol><p><strong>和我们相关的，多数据源类型的存储问题</strong></p><p>例如一个购物网站的商品页面，会包含商品的基本信息、详情、销量、用户的评价（文字图片视频）、点赞点踩等等不同类型的信息，且信息的存放往往会采用不同的数据源。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420224210584.png" alt="image-20230420224210584" style="zoom:67%;" /><h4 id="阿里商品描述"><a href="#阿里商品描述" class="headerlink" title="阿里商品描述"></a>阿里商品描述</h4><p><strong>什么是IOE，为什么去IOE化</strong></p><p>I：IBM的小型机、O：Oracle的数据库、E：EMC的高端存储。这三者在金融证券电信保险等企业有着巨大的份额，许多传统企业都是采用它们的产品，导致技术上有着严重依赖，对于公司的发展提升有着很大的弊病。</p><p>去IOE化，其本意是，在阿里巴巴的IT架构中，去掉IBM的小型机、Oracle数据库、EMC存储设备，代之以自己在开源软件基础上开发的系统。借此保证企业良好的技术提升</p><table><thead><tr><th>类型</th><th>内容及存储方式</th></tr></thead><tbody><tr><td>商品基本信息</td><td>名称、价格，出厂日期，生产厂商等趋于不变的数据<br/>关系型数据库。如MySQL</td></tr><tr><td>商品描述、详情、评价信息(多文字类)</td><td>多文字信息描述类，IO读写性能变差<br/>文档数据库MongDB</td></tr><tr><td>商品的图片</td><td>商品图片展现类。<br/>分布式的文件系统，如TFS、GTF、HDFS</td></tr><tr><td>商品的关键字</td><td>淘宝自研的ISearch</td></tr><tr><td>商品的波段性的热点高频信息</td><td>内存数据库；Tair、Redis、Memcache</td></tr><tr><td>商品的交易、价格计算、积分累计</td><td>外部系统，外部第3方支付接口<br/>支付宝</td></tr></tbody></table><h2 id="NoSQL数据模型简介"><a href="#NoSQL数据模型简介" class="headerlink" title="NoSQL数据模型简介"></a>NoSQL数据模型简介</h2><p>以一个电商客户、订单、订购、地址模型来对比关系型数据库和非关系型数据库</p><p>传统关系型数据库如何设计：先画E-R图，描述模型关联，再根据E-R设计表结构。常见的关联有1:1、1:n、n:n等。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211127215531125.png" alt="image-20211127215531125" style="zoom: 67%;" /><p>NOSQL如何设计：以BSON为例，采用Json结构来表述数据的存储方式，k-v形式可以实现对象的存储。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211127215642374.png" alt="image-20211127215642374" style="zoom: 67%;" /><p><strong>为什么用聚合模型来处理</strong><br>高并发的操作是不太建议用关联查询的，互联网公司用冗余数据来避免关联查询；分布式事务是支持不了太多的并发的</p><h4 id="NoSQL数据库四大分类"><a href="#NoSQL数据库四大分类" class="headerlink" title="NoSQL数据库四大分类"></a>NoSQL数据库四大分类</h4><ol><li><p>常见的K-V键值对：【新浪：BerkeleyDB+redis】、【美团：redis+tair】、【阿里、百度：memcache+redis】</p></li><li><p>文档型数据库：Bson格式为主，【CouchDB】、【MongoDB(一个基于分布式文件存储的数据库)】</p></li><li><p>列族：顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，<br>对针对某一列或者某几列的查询有非常大的IO优势。【Cassandra】、【HBase】、【分布式文件系统】</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211127215851351.png" alt="image-20211127215851351" style="zoom:67%;" /></li><li><p>图形：图关联结构，存放的不是图片数据，而是用来表示存在复杂关系的数据，社交网络、推荐系统等应用较多。【Neo4J】、【InfoGrid】</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211127215940739.png" alt="image-20211127215940739" style="zoom:67%;" /></li></ol><h4 id="四者对比"><a href="#四者对比" class="headerlink" title="四者对比"></a>四者对比</h4><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420224302502.png" alt="image-20230420224302502" style="zoom:80%;" /><h2 id="分布式数据库CAP原理"><a href="#分布式数据库CAP原理" class="headerlink" title="分布式数据库CAP原理"></a><font color="red">分布式数据库CAP原理</font></h2><h3 id="CAP原理简介"><a href="#CAP原理简介" class="headerlink" title="CAP原理简介"></a>CAP原理简介</h3><p> 介绍分布式数据库的CAP原理之前，可以先回顾一下SQL数据库的ACID特性</p><ul><li><strong>A (Atomicity) 原子性</strong>：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成。</li><li><strong>C (Consistency) 一致性</strong>：执行事务前后，数据库的完整性没有被破坏，数据能保持一致。</li><li><strong>I (Isolation) 独立性</strong>：数据库允许多个事务进行数据操作，通过隔离性防止多个事务并发执行出现的数据不一致</li><li><strong>D (Durability) 持久性</strong>：事务对数据的修改是永久的。</li></ul><p>分布式数据库的CAP原理：<font color="red">对于分布式计算系统来说，不可能同时满足以下三点</font></p><ul><li><strong>C:Consistency（强一致性）</strong>：分布式系统中的所有数据备份，在同一时刻保持同样的值。（等同于所有节点访问同一份最新的数据副本）</li><li><strong>A:Availability（可用性）</strong>：保证每个请求都能获得非错的响应，但不保证响应的是最新的数据。</li><li><strong>P:Partition tolerance（分区容忍性）</strong>：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211127224409622.png" alt="image-20211127224409622" style="zoom: 75%;" /><h3 id="CAP的三进二"><a href="#CAP的三进二" class="headerlink" title="CAP的三进二"></a>CAP的三进二</h3><h4 id="CA（一致性-可用性）"><a href="#CA（一致性-可用性）" class="headerlink" title="CA（一致性+可用性）"></a>CA（一致性+可用性）</h4><p>即放弃系统的拓展性，传统的单点关系型数据库或类似架构的非分布式数据库，不存在网络分区问题。</p><p>比如MySQL、Oracle等传统数据库</p><h4 id="CP（一致性-容错性）"><a href="#CP（一致性-容错性）" class="headerlink" title="CP（一致性+容错性）"></a>CP（一致性+容错性）</h4><p>相当于每个请求都需要在服务器之间保持强一致性。当分区间的数据出现不一致（出现网络故障等情况），必须停止旧数据的服务，直到数据同步完成，这势必会牺牲用户的体验。</p><p>典型的比如Redis、HBase，数据的一致性是基本要求，发生特殊情况优先保证数据的强一致性</p><h4 id="AP（可用性-容错性）"><a href="#AP（可用性-容错性）" class="headerlink" title="AP（可用性+容错性）"></a>AP（可用性+容错性）</h4><p>仍然允许所有客户端读写，但是两个数据中心之间不再同步，它们的数据就会逐渐地变得不同，即牺牲一致性，保证可用性。</p><p>AP的应用场景也很多，比如12306抢票，浏览时看到还有票（可能已经没票了），点进去下单提示没票了，购买失败。这就是在数据一致性上做出牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。</p><p>但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是强一致性。退而求其次保证了最终一致性。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。</p><h3 id="BASE定理"><a href="#BASE定理" class="headerlink" title="BASE定理"></a>BASE定理</h3><p>BASE是<strong>Basically Available（基本可用）</strong>、<strong>Soft state（软状态）</strong>和<strong>Eventually consistent（最终一致性）</strong>三个短语的简写。</p><p>BASE是对CAP中一致性C和可用性A权衡的结果，来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是：<font color="red"><strong>让系统放松对某一时刻数据的强一致性要求（Strong Consistency），来换取西戎整体的伸缩性和性能上的改观，结合自身业务特点，通过适当设计保证系统达到最终一致性（Eventual Consistency）</strong></font>。</p><h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>什么是基本可用？它是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，参考例子：</p><ul><li><strong>响应时间上的损失</strong>：正常情况下一个搜索引擎0.5秒即返回给用户结果，现在出现了异常，查询的相应时间可能变成1-2秒。</li><li><strong>功能上的损失</strong>：日常购物时用户在网上买东西可以按流程顺利完成订单，但是在像双十一这种高峰期，用户访问量剧增，为了保证稳定，部分用户可能会被引导到降级页面。</li></ul><h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p><p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p><h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>软状态不能一直存在，必须有一个期限，在这段时间内可以允许数据延时，但是期限过后所有数据要达到一致状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><p>亚马逊首席技术官Werner Vogels在于2008年发表的一篇文章中对最终一致性进行了非常详细的介绍，他认为最终一致性是一种特殊的弱一致性：系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致状态，因此所有客户端对系统的数据访问都能够获取到最新的值。同时，在没有发生故障的前提下，数据达到一致状态的时间延迟，取决于网络延迟，系统负载和数据复制方案设计等因素。</p><ul><li>因果一致性（Causal consistency）</li><li>读己之所写（Read your writes）</li><li>会话一致性（Session consistency）</li><li>单调读一致性（Monotonic read consistency）</li><li>单调写一致性（Monotonic write consistency）</li></ul><p>实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p><p>总体来说BASE理论面向的是大型高可用、可扩展的分布式系统。与传统ACID特性相反，不同于ACID的强一致性模型，BASE提出通过牺牲强一致性来获得可用性，并允许数据段时间内的不一致，但是最终达到一致状态。同时，在实际分布式场景中，不同业务对数据的一致性要求不一样。因此在设计中，ACID和BASE理论往往又会结合使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/u011863024/article/details/107476187">Redis学习笔记</a></li><li><a href="https://mongoing.com/archives/docs/mongodb%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%99%E7%A8%8B/nosql%E6%95%99%E7%A8%8B%EF%BC%9A%E4%BA%86%E8%A7%A3nosql%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%90%AB%E4%B9%89%EF%BC%8C%E4%BC%98%E5%8A%BF">NoSQL教程：了解NoSQL的功能，类型，含义，优势</a></li><li><a href="https://juejin.cn/post/6844903621495095304">分布式理论(二) - BASE理论</a></li></ul><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>NoSQL 定义：下一代数据库主要解决一些问题：非关系、分布式、开源和水平可扩展”。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>分库：将业务相关的、频繁性的数据分在同一个数据库，将一些趋于冷的数据（如用户的名字、身份证号码等变化很少的数据）放在另外的一个库中。分表：对于复杂业务产生的大量数据，例如产生了100w条数据，放在同一个表中肯定会很慢，换个方式0-25、25-50、50-75、75-100四个分区，可以达到将数据的压力差分的目的。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux安装(CentOS)</title>
    <link href="/20211126/e0a94a43/"/>
    <url>/20211126/e0a94a43/</url>
    
    <content type="html"><![CDATA[<h2 id="1、安装vmware"><a href="#1、安装vmware" class="headerlink" title="1、安装vmware"></a>1、安装vmware</h2><p>直接在官网下载 <code>VMware workstation 15</code> 需要登陆账号，可以在官网链接</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>download3.vmware.com<span class="hljs-regexp">/software/</span>wkst<span class="hljs-regexp">/file/</span>VMware-workstation-full-<span class="hljs-number">15.5</span>.<span class="hljs-number">7</span>-<span class="hljs-number">17171714</span>.exe<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230523862.png" alt="image-20230420230523862" style="zoom:80%;" /><p>按照图中的名称替换，下载对应的版本，然后正常安装即可，激活码直接网上搜就可以。</p><p>电脑的虚拟化技术需要开启不然启动会报错，进入对应主板的 bios 中，在 <code>ADVANCE</code> 中找到 <code>CPU Configuration</code> 修改 <code>Intel(VMX) Virtualization Technology</code> 为 <code>Enable</code> 即可。</p><h2 id="2、安装CentOS"><a href="#2、安装CentOS" class="headerlink" title="2、安装CentOS"></a>2、安装CentOS</h2><p>参考<a href="https://mp.weixin.qq.com/s/onVwwEQ1DAwbvK7qS2YNxg">人手一套Linux环境之：Windows版本教程</a> 的操作安装 CentOS 环境</p><h3 id="1-下载镜像"><a href="#1-下载镜像" class="headerlink" title="1. 下载镜像"></a>1. 下载镜像</h3><p>可以在中国的镜像网站上下载，给两个示例：<a href="http://mirrors.aliyun.com/centos/">阿里云镜像</a>、<a href="https://mirrors.huaweicloud.com/home">华为云镜像</a></p><p>先下载CentOS 7的镜像文件，建议下载7(不带后缀)，不要下载7.x【8之前的CentOS除了7其他都不再维护了】</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124223025492.png" alt="image-20211124223025492" style="zoom: 80%;" /><p>在 VMware 中新建虚拟机</p><ol><li><p>安装选择自定义(高级)</p></li><li><p>选择稍后安装操作系统（后面选择之前下载的 <code>.iso</code> 镜像文件）</p></li><li><p>命名并选择虚拟机位置，按需分配</p></li><li><p>网络选择NAT、磁盘选择分成一个</p></li><li><p>其他全部默认即可。移除USB控制器、打印机、声卡（基本用不上）</p></li></ol><h3 id="2-安装系统"><a href="#2-安装系统" class="headerlink" title="2. 安装系统"></a>2. 安装系统</h3><p>启动虚拟机后如图进行CentOS配置。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124224147583.png" alt="image-20211124224147583" style="zoom: 67%;" /><ul><li>系统时间、键盘、语言默认英文。看着比较直观</li><li>软件安装选择本地文件、最小化安装（后面再安装图形化界面）</li><li>分区自动选择、网络连接暂不开启</li><li>点击开始安装后，在上面配置 ROOT 密码、创建一个用户配置用户名密码</li></ul><h4 id="配置静态IP"><a href="#配置静态IP" class="headerlink" title="配置静态IP"></a>配置静态IP</h4><ul><li><p>在 VMWare的编辑中找到虚拟网络编辑器，选择 VMnet8，修改参数</p><p>选择 NAT 模式、不勾选本地DHCP分配IP地址、设值子网IP段 <code>192.168.61.0</code> 和子网掩码 <code>255.255.255.0</code>（记住此时的子网IP）</p><p>在NAT设值中配置网关IP <code>192.168.61.2</code>，网关IP不能和宿主机中配置的一致（记住网关IP）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230508299.png" alt="image-20230420230508299" style="zoom:80%;" /></li><li><p>点击应用-确定后保存退出，在控制面板的网络适配器中配置宿主机 VMnet8 的 IPv4 属性并保存</p><p>IP：<code>192.168.61.1</code>、子网掩码：<code>255.255.255.0</code>、 网关：<code>192.168.61.2</code></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230544298.png" alt="image-20230420230544298" style="zoom:80%;" /></li><li><p>在 <code>etc/sysconfig/netword-scripts</code> 目录下编辑 <code>ifcfg-ens32</code> 文件（有叫33的情况）</p><p>BOOTPROTO 设置为 static、ONBOOT 设置为 yes、配置 IPADDR、NETMASK、GATEWAY、DNS等</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230556909.png" alt="image-20230420230556909" style="zoom:80%;" /></li><li><p>配置完成后 wq 保存退出，<code>systemctl restart network</code>重启 network 服务，通过 <code>ping</code> 指令验证网络连通性</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230612538.png" alt="image-20230420230612538" style="zoom:80%;" /></li><li><p>至此虚拟机网络配置完毕，通过 <code>ifconfig</code> 指令查看网络信息（如果提示命令找不到，可以通过 <code>yum install net-tools</code> 安装）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230625244.png" alt="image-20230420230625244" style="zoom:80%;" /></li></ul><h4 id="配置图形化界面"><a href="#配置图形化界面" class="headerlink" title="配置图形化界面"></a>配置图形化界面</h4><p>正常安装完成后进入是命令行界面，可以参考知乎上黑马程序员发的<a href="https://zhuanlan.zhihu.com/p/126601630">回答</a>安装图形界面</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230639896.png" alt="image-20230420230639896" style="zoom:80%;" /><p>命令行模式切换为图形化桌面步骤如下：</p><ul><li><p>首次安装后，启动centOS 7系统，通过root用户登录命令行</p></li><li><p>使用指令：<code>systemctl get-default</code> 查看centOS 7的默认启动模式。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">multi-user.<span class="hljs-keyword">target</span>   <span class="hljs-comment">#命令行启动模式</span><br>graphical.<span class="hljs-keyword">target</span><span class="hljs-comment">#图形化界面启动模式</span><br></code></pre></td></tr></table></figure><p>使用<code>cat /etc/inittab</code>查看配置文件：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124230004437.png" alt="image-20211124230004437" style="zoom: 80%;" /></li><li><p>使用<code>systemctl set-default graphical.target</code>修改centOS 7的默认启动模式为图形化界面模式</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124230318153.png" alt="image-20211124230318153" style="zoom:80%;" /></li><li><p>通过<code>yum -h</code>检查yum命令是否支持；使用<code>ping www.baidu.com</code>测试网络（使用NAT模式可以ping通）</p></li><li><p>通过yum命令<code>yum groupinstall &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot;</code>获取并且安装图形界面GNOME的程序包</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124233403418.png" alt="image-20211124233403418" style="zoom: 80%;" /></li><li><p>安装成功后，重启CentOS 7系统，检验GUI界面效果</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124233738485.png" alt="image-20211124233738485" style="zoom: 50%;" /></li><li><p>后续要删除可视化桌面用 <code>yum groupremove xxx</code> 即可</p></li></ul><h4 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h4><p>要远程连接，必须开放指定端口，或者关闭防火墙，通过如下指令操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=22/tcp --permanent<br><span class="hljs-meta prompt_"># </span><span class="language-bash">zone:作用域   add-port:开放的端口,端口/协议   permanent:永久生效</span><br>systemctl stop firewalld #直接关闭防火墙<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420230723728.png" alt="image-20230420230723728" style="zoom:80%;" /><h3 id="安装VMwareTools"><a href="#安装VMwareTools" class="headerlink" title="安装VMwareTools"></a>安装VMwareTools</h3><p>在虚拟机选项中看到 <code>重新安装VMware Tools</code> 是置灰的</p><p>在安装虚拟机的时候下面会有提示安装VMwareTools，不过正在安装的时候点不了，显示光盘正在使用，可以启动后点。</p><p>然后在图形化界面的文件夹可以看到有个左侧VMware Tools。执行cp命令复制文件到<code>/opt</code>目录下，该目录存放的是与系统无关的程序，即用户级的程序</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124234713082.png" alt="image-20211124234713082" style="zoom:67%;" /><p>在opt文件夹下<code>tar -zxvf</code>解压，进入解压得到的文件中，选择都回车选默认即可，安装完成即可~</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211124235149228.png" alt="image-20211124235149228" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo迁移与同步</title>
    <link href="/20211115/60a54483/"/>
    <url>/20211115/60a54483/</url>
    
    <content type="html"><![CDATA[<p>由于现在更多使用办公电脑了，自己的笔记本彻底成了游戏本了，最近又想把记笔记捡起来，所以就将原来的<code>hexo</code>博客迁移过来。顺便再熟悉一下安装过程。</p><span id="more"></span><h2 id="1-hexo迁移"><a href="#1-hexo迁移" class="headerlink" title="1.hexo迁移"></a>1.hexo迁移</h2><p>首先安装必备的环境：<code>node</code>和<code>git</code>，配置GitHub的<code>ssh key</code>，按照<code>hexo</code>安装的基本步骤执行。<code>hexo init</code>生成基本的目录。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211115001252492.png" alt="image-20211115001252492" style="zoom:80%;" /><p>同时看看原来的目录结构，对比一下：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211115000427145.png" alt="image-20211115000427145" style="zoom:80%;" /><ul><li>首先：<code>.idea</code>和<code>.vscode</code>是使用对应编辑器产生的，可以忽略；<code>node_modules</code>是<code>npm</code>的依赖包文件，可以忽略</li><li>public：是<code>hexo</code>生成的静态文件，即博客所展示的文件</li><li>_config.yml：是全局的配置文件，<strong>【需要拷贝】</strong></li><li>package_json：框架的参数即相关依赖，有它才能安装<code>node_modules</code>，<strong>【需要拷贝】</strong></li><li>scaffolds：本意是 “脚手架” 的意思，这里引申为模板文件夹。当 <code>hexo new  </code> 的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建，<strong>【需要拷贝】</strong></li><li>source：用户创建的博客相关文件，如_post目录就是博客的md文件存放位置，<strong>【需要拷贝】</strong></li><li>themes：下载的主题，要同步的话<strong>【需要拷贝】</strong></li><li>.gitignore：用于声明不被git记录的文件，<strong>【需要拷贝】</strong></li></ul><p>即拷贝原电脑项目文件中的<code>_config.yml</code>、<code>themes</code>、<code>source</code>、<code>scaffolds</code>、<code>package.json</code>、<code>.gitignore</code>到新电脑新建的文件夹中，已有的选择覆盖即可。</p><p>执行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install #安装node_modules依赖<br>npm install hexo-deployer-git --save #安装部署git的服务<br></code></pre></td></tr></table></figure><p>本地测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g #生成静态文件<br>hexo s #起一个本地服务测试一下<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211115002949384.png" alt="image-20211115002949384" style="zoom:80%;" /><p>成功运行！</p><p>现在就可以在新电脑上开始写东西了~</p><h2 id="2-多端同步"><a href="#2-多端同步" class="headerlink" title="2.多端同步"></a>2.多端同步</h2><p>说到多端同步记笔记，自然会想到现有的有道云笔记、印象笔记、notion等等，它们也是多端协作笔记工具，不过hexo生成博客提交的是渲染之后的html文件，和这些有所不同。所以自然会想到另一个同步写作的工具——Git。</p><p>如图所示，master分支提交的是hexo渲染后的文件，而不是我们本地目录所见的</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20211115003738030.png" alt="image-20211115003738030" style="zoom:80%;" /><p>网上搜到的hexo多端写作的方式，基本上都是在仓库再创建一个hexo分支，将本地的基础文件（上面所提到的那些）上传。然后不同终端需要记笔记的时候，先切换到hexo分支，拉取最新的代码，然后写了提交。比较像我们做开发项目的流程。</p><p>个人感觉这样说实话没啥必要。环境迁移好了之后，真正会修改变动的，基本上只有笔记对应的md文件，因此要同步的也就是md文件即可。目前有很多的同步工具，如OneDrive、坚果云等都很好用。以OneDrive为例，将<code>_post</code>目录下的md文件拷贝到OneDrive中，就可以实现多端的文件编辑，就算想修改主题啥的，同步一下<code>_config.yml</code>文件即可。</p>]]></content>
    
    
    <categories>
      
      <category>博客工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM框架整合：SpringMVC+Spring+Mybatis</title>
    <link href="/20210305/2dd9e0d6/"/>
    <url>/20210305/2dd9e0d6/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>狂神的<code>SpringMVC</code>教程里，后面有SSM框架整合，跟着敲了一遍，感觉还是比较陌生，可能是看得太快了。结合着网上的博客再过一遍，捋一捋。</p><p><strong>目标：熟悉SSM框架开发的基本流程；了解框架结构</strong></p><span id="more"></span><h2 id="1、搭建项目的基础环境"><a href="#1、搭建项目的基础环境" class="headerlink" title="1、搭建项目的基础环境"></a>1、搭建项目的基础环境</h2><blockquote><p>前置–环境要求</p></blockquote><ul><li>IDEA</li><li>MySQL 5.1.6</li><li>Maven</li></ul><blockquote><p>基础环境搭建</p></blockquote><p>《1》在IDEA新建maven项目，命名为<code>SSM_Union</code>，再右键<code>Add Framework support</code>添加web框架支持。完成后如图</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305054235227.png" alt="image-20210305054235227" style="zoom:80%;" /><p>《2》在项目的<code>pom.xml</code>文件中添加依赖配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Junit--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据库驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--Servlet - JSP --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--Mybatis--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--Spring--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>《3》Maven资源过滤设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>《4》搭建目录结构如图</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305060016972.png" alt="image-20210305060016972" style="zoom:80%;" /><table><thead><tr><th>包名</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>controller</td><td>控制层</td><td>负责具体的业务模块流程的<strong>控制</strong>，controller调用service的接口实现业务控制流程。</td></tr><tr><td>dao</td><td>数据持久层</td><td>负责与底层数据打交道。常见的数据库操作、文件读写等</td></tr><tr><td>pojo</td><td>实体类(也写作entity)</td><td>与数据库的表对应，封装dao层的数据成一个对象。介于dao和service层</td></tr><tr><td>service</td><td>业务层(也叫bbl)</td><td>业务模块操作的逻辑设计。service调用dao层</td></tr></tbody></table><ul><li><p>mybatis-config.xml：mybatis的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">       <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">       <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>applicationContext.xml：spring的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>《5》准备项目所需的数据库<code>ssmbuild</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE `ssmbuild`;<br><br>USE `ssmbuild`;<br><br>DROP TABLE IF EXISTS `books`;<br><br>CREATE TABLE `books` (<br>`bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;书id&#x27;,<br>`bookName` VARCHAR(100) NOT NULL COMMENT &#x27;书名&#x27;,<br>`bookCounts` INT(11) NOT NULL COMMENT &#x27;数量&#x27;,<br>`detail` VARCHAR(200) NOT NULL COMMENT &#x27;描述&#x27;,<br>KEY `bookID` (`bookID`)<br>) ENGINE=INNODB DEFAULT CHARSET=utf8<br><br>INSERT  INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES<br>(1,&#x27;Java&#x27;,1,&#x27;从入门到放弃&#x27;),<br>(2,&#x27;MySQL&#x27;,10,&#x27;从删库到跑路&#x27;),<br>(3,&#x27;Linux&#x27;,5,&#x27;从进门到进牢&#x27;);<br></code></pre></td></tr></table></figure><p>项目基本的准备工作就OK了，然后就可以开始构建模块–&gt;整合模块了。</p><h2 id="2、Mybatis框架搭建"><a href="#2、Mybatis框架搭建" class="headerlink" title="2、Mybatis框架搭建"></a>2、Mybatis框架搭建</h2><p>Mybatis层就是简化数据操作的，所以它对应的就是dao层。基本操作就是编写dao层接口、编写mapper映射文件</p><p>《1》编写数据库配置文件<code>db.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span><br><span class="hljs-attr">jdbc.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure><p>《2》IDEA连接mysql数据库</p><p>《3》编写mybatis-config.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置数据源,现在由spring实现--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;properties resource=&quot;db.properties&quot; /&gt;--&gt;</span><br><br>    <span class="hljs-comment">&lt;!--别名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.liu.pojo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--映射--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.dao.BookMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>《4》编写数据库实体类<code>com.liu.pojo.Books</code>（使用lombok插件简化）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Books</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> bookID;<br>    <span class="hljs-keyword">private</span> String bookName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> bookCounts;<br>    <span class="hljs-keyword">private</span> String detail;<br>&#125;<br></code></pre></td></tr></table></figure><p>《5》编写dao层接口<code>com.liu.dao.Books</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookMapper</span> &#123;<br>    <span class="hljs-comment">//增加一个Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(Books book)</span>;<br>    <span class="hljs-comment">//根据id删除一个Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">deleteBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>    <span class="hljs-comment">//更新Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateBook</span><span class="hljs-params">(Books books)</span>;<br>    <span class="hljs-comment">//根据id查询,返回一个Book</span><br>    Books <span class="hljs-title function_">queryBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>    <span class="hljs-comment">//查询全部Book,返回list集合</span><br>    List&lt;Books&gt; <span class="hljs-title function_">queryAllBook</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//查书</span><br>    Books <span class="hljs-title function_">queryBookName</span><span class="hljs-params">(String bookName)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>《6》编写接口对应的mapper映射文件，执行具体的SQL操作【也可以使用注解实现，mybatis学习时用过】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.liu.dao.BookMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--增加一个Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addBook&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.liu.pojo.Books&quot;</span>&gt;</span><br>        insert into ssmbuild.books(bookName,bookCounts,detail)<br>        values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--根据id删除一个Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteBookById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>        delete from ssmbuild.books where bookID=#&#123;bookID&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--更新Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBook&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.liu.pojo.Books&quot;</span>&gt;</span><br>        update ssmbuild.books<br>        set bookName = #&#123;bookName&#125;,bookCounts = #&#123;bookCounts&#125;,detail = #&#123;detail&#125;<br>        where bookID = #&#123;bookID&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--根据id查询,返回一个Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBookById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.liu.pojo.Books&quot;</span>&gt;</span><br>        select * from ssmbuild.books<br>        where bookID = #&#123;bookID&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查询全部Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryAllBook&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.liu.pojo.Books&quot;</span>&gt;</span><br>        SELECT * from ssmbuild.books;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--查询全部Book--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBookName&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.liu.pojo.Books&quot;</span>&gt;</span><br>        SELECT * from ssmbuild.books<br>        where bookName=#&#123;bookName&#125;;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-Spring整合Mybatis"><a href="#2-2-Spring整合Mybatis" class="headerlink" title="2.2 Spring整合Mybatis"></a>2.2 Spring整合Mybatis</h3><p>在学习Spring时就已经整合过，操作参照就行了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305061811079.png" alt="image-20210305061811079" style="zoom:80%;" /><p>新建<code>spring-dao.xml</code>用于整合。<font color="red"><strong>并在<code>applicationContext.xml</code>中进行注册</strong></font></p><p>《1》配置数据库连接池</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置整合mybatis --&gt;</span><br><span class="hljs-comment">&lt;!-- 1.关联数据库文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 2.数据库连接池 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 也可以用c3p0 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置连接池属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>《2》配置SqlSessionFactory对象，照搬之前的文档</p><p>官方文档在关于Spring操作SqlSession部分有以下介绍：</p><blockquote><p>在 MyBatis 中，你可以使用 <code>SqlSessionFactory</code> 来创建 <code>SqlSession</code>。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。使用 MyBatis-Spring 之后，你不再需要直接使用 <code>SqlSessionFactory</code> 了，因为你的 bean 可以被注入一个线程安全的 <code>SqlSession</code>，它能基于 Spring 的事务配置来自动提交、回滚、关闭 session。</p></blockquote><p>有两种形式：</p><ul><li>使用<code>SqlSessionTemplate</code></li><li>使用<code>SqlSessionDaoSupport</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注入数据库连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置MyBatis全局配置文件:mybatis-config.xml --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注册完后，我们的<code>springIOC</code>容器中就有了<code>sqlSessionFactory</code>工厂，可以由此拿到<code>SqlSession</code>进而拿到代理对象，不再需要每次创建了！</p><p>《3》配置Dao层接口扫描。</p><p>有了工厂有了<code>SqlSession</code>，就要配置代理的对象了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span><br><span class="hljs-comment">&lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注入sqlSessionFactory --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.liu.dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong><font color="red">总结：总的就是spring代理mybtis，将原先的配置转移到sping中，产生代理并放置于IOC容器里</font></strong></p><h2 id="3、搭建业务逻辑框架"><a href="#3、搭建业务逻辑框架" class="headerlink" title="3、搭建业务逻辑框架"></a>3、搭建业务逻辑框架</h2><p>业务逻辑主要涉及service层和controller层。</p><p>【这一步也可以在搭建基础环境时就准备好】</p><p>接口：与<code>dao</code>层相对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 业务层service一般与数据层dao功能类似，</span><br><span class="hljs-comment"> * 区别在于dao是直接对数据库操作，service是上层调用dao</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BookService</span> &#123;<br>    <span class="hljs-comment">//增加一个Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(Books book)</span>;<br>    <span class="hljs-comment">//根据id删除一个Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">deleteBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>    <span class="hljs-comment">//更新Book</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateBook</span><span class="hljs-params">(Books books)</span>;<br>    <span class="hljs-comment">//根据id查询,返回一个Book</span><br>    Books <span class="hljs-title function_">queryBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br>    <span class="hljs-comment">//查询全部Book,返回list集合</span><br>    List&lt;Books&gt; <span class="hljs-title function_">queryAllBook</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//查书</span><br>    Books <span class="hljs-title function_">queryBookName</span><span class="hljs-params">(String bookName)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类：注解开发。<code>service层直接调用dao层的操作</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BookService</span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> BookMapper bookMapper;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBookMapper</span><span class="hljs-params">(BookMapper bookMapper)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookMapper = bookMapper;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(Books book)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.addBook(book);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.deleteBookById(id);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateBook</span><span class="hljs-params">(Books books)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.updateBook(books);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Books <span class="hljs-title function_">queryBookById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.queryBookById(id);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Books&gt; <span class="hljs-title function_">queryAllBook</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.queryAllBook();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Books <span class="hljs-title function_">queryBookName</span><span class="hljs-params">(String bookName)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookMapper.queryBookName(bookName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-整合service层"><a href="#3-2-整合service层" class="headerlink" title="3.2 整合service层"></a>3.2 整合service层</h3><p>创建<code>spring-service.xml</code>文件<font color="red"><strong>并在<code>applicationContext.xml</code>中进行注册</strong></font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--1.扫描service包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.liu.service&quot;</span>/&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--2.将业务类都注入到spring，可以通过注解或配置实现--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BookServiceImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.service.BookServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookMapper&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bookMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--3.声明式事务配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--注入数据源--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4、SpringMVC框架搭建"><a href="#4、SpringMVC框架搭建" class="headerlink" title="4、SpringMVC框架搭建"></a>4、SpringMVC框架搭建</h2><p>搭建SpringMVC的基本流程：</p><ol><li>导入相关依赖</li><li>编写<code>web.xml</code> , 注册<code>DispatcherServlet</code></li><li>编写<code>springmvc</code>配置文件</li><li>接下来就是去创建对应的控制类 , controller</li><li>最后完善前端视图和controller之间的对应。测试</li></ol><p>《1》编写<code>web.xml</code>文件<font color="red"><strong>并在<code>applicationContext.xml</code>中进行注册</strong></font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--DispatchServlet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--乱码过滤--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span><br>            org.springframework.web.filter.CharacterEncodingFilter<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--Session过期时间--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><p>《2》创建<code>spring-mvc.xml</code>配置文件。并在<code>web/WEB-INF</code>下新建<code>jsp</code>文件夹</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/context/spring-context.xsd &quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--1.注解驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--2.静态资源过滤--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--3.扫描相关的包Controller--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.liu.controller&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--4.视图解析器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!-- 前缀 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!-- 后缀 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后<code>applicationContext.xml</code>应该如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305065107243.png" alt="image-20210305065107243" style="zoom:80%;" /><h2 id="5、编写对应controller类和前端页面"><a href="#5、编写对应controller类和前端页面" class="headerlink" title="5、编写对应controller类和前端页面"></a>5、编写对应controller类和前端页面</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/book&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;BookServiceImpl&quot;)</span><br>    <span class="hljs-keyword">private</span> BookService bookService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查找所有书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> model</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/allBook&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">list</span><span class="hljs-params">(Model model)</span> &#123;<br>        List&lt;Books&gt; list = bookService.queryAllBook();<br>        model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>, list);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;allBook&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 去添加书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/toAddBook&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toAddPaper</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;addBook&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> books</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/addBook&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">addPaper</span><span class="hljs-params">(Books books)</span> &#123;<br>        System.out.println(books);<br>        bookService.addBook(books);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/book/allBook&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 去更新书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> model</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/toUpdateBook&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toUpdateBook</span><span class="hljs-params">(Model model, <span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-type">Books</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> bookService.queryBookById(id);<br>        System.out.println(books);<br>        model.addAttribute(<span class="hljs-string">&quot;book&quot;</span>,books );<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;updateBook&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> model</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> book</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/updateBook&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">updateBook</span><span class="hljs-params">(Model model, Books book)</span> &#123;<br>        System.out.println(book);<br>        bookService.updateBook(book);<br>        <span class="hljs-type">Books</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> bookService.queryBookById(book.getBookID());<br>        model.addAttribute(<span class="hljs-string">&quot;books&quot;</span>, books);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/book/allBook&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/del/&#123;bookId&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">deleteBook</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;bookId&quot;)</span> <span class="hljs-type">int</span> id)</span> &#123;<br>        bookService.deleteBookById(id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/book/allBook&quot;</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询书籍</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bookName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/queryBookName&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">queryBookName</span><span class="hljs-params">(String bookName,Model model)</span> &#123;<br>        <span class="hljs-type">Books</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> bookService.queryBookName(bookName);<br>        <span class="hljs-keyword">if</span>(books==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/book/allBook&quot;</span>;<br>        &#125;<br>        List&lt;Books&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(books);<br>        model.addAttribute(<span class="hljs-string">&quot;list&quot;</span>, list);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;allBook&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>前端页面我直接copy的代码</strong></p><p><code>allBook.jsp</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;<br>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>书籍列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引入 Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-header&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>书籍列表 —— 显示所有书籍<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>        &lt;%--新增书籍--%&gt;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-4 column&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;</span>&gt;</span>新增书籍<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-4 column&quot;</span>&gt;</span><br>            &lt;%--查询书籍--%&gt;<br>            <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-inline&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/queryBookName&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;float: right&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;queryBookName&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入要查询的书籍名称&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;查询&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table table-hover table-striped&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍编号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍名字<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍数量<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍详情<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">c:forEach</span> <span class="hljs-attr">var</span>=<span class="hljs-string">&quot;book&quot;</span> <span class="hljs-attr">items</span>=<span class="hljs-string">&quot;$&#123;requestScope.get(&#x27;list&#x27;)&#125;&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.getBookID()&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.getBookName()&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.getBookCounts()&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;book.getDetail()&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;&quot;</span>&gt;</span>更改<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> |<br>                            <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;&quot;</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">c:forEach</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>addBook.jsp</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;<br>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>新增书籍<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引入 Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-header&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>新增书籍<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/addBook&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        书籍名称：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        书籍数量：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookCounts&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        书籍详情：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;detail&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;添加&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>updateBook.jsp</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;<br>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>修改信息<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引入 Bootstrap --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row clearfix&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col-md-12 column&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;page-header&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>修改信息<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/updateBook&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookID&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;book.getBookID()&#125;&quot;</span>/&gt;</span><br>        书籍名称：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;book.getBookName()&#125;&quot;</span>/&gt;</span><br>        书籍数量：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookCounts&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;book.getBookCounts()&#125;&quot;</span>/&gt;</span><br>        书籍详情：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;detail&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;book.getDetail() &#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>项目启动的初始页<code>index.jsp</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">a</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: black;</span><br><span class="language-css">      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-tag">h3</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">180px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">38px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;</span><br><span class="language-css">      <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">      <span class="hljs-attribute">line-height</span>: <span class="hljs-number">38px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background</span>: deepskyblue;</span><br><span class="language-css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;</span>&gt;</span>点击进入列表页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="6、发布"><a href="#6、发布" class="headerlink" title="6、发布"></a>6、发布</h2><p>完整的项目结构如图</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305065635143.png" alt="image-20210305065635143" style="zoom:80%;" /><p>《1》在左上角File的<code>Project Structure</code>中<code>Artifacts</code>将项目打包。采用<code>Web Application:Exploded</code>打包【因为是后面添加的web framework，所以他自动打包的会缺少lib依赖，所以我们要自己打包】</p><p>《2》配置Tomcat，启动</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305070415977.png" alt="image-20210305070415977" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305070428608.png" alt="image-20210305070428608" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305070446813.png" alt="image-20210305070446813" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20210305070611508.png" alt="image-20210305070611508" style="zoom:80%;" /><p>这个项目虽然很简陋，但是基本的SSM框架很明了。两天时间快速过了一遍，仅仅也只是了解了基本流程，很多细节并不清楚。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库相关核心概念</title>
    <link href="/20210218/914c342c/"/>
    <url>/20210218/914c342c/</url>
    
    <content type="html"><![CDATA[<h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位</p><p>在SQL中定义事务的语句一般有：<code>BEGIN TRANSACTION</code>; <code>COMMIT</code>; <code>ROLLBACK</code>; </p><p>一般COMMIT表示提交，即提交事务的所有操作，事务正常结束。</p><p>ROLLBACK表示回滚，即事务运行过程中发生某种故障不能继续执行，将事务对数据库中已完成的操作撤销，回滚到事务开始时的状态</p><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><p><strong>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability）</strong></p><ul><li>原子性：事务是数据库的逻辑工作单位，事务中的操作要么都做要么都不做</li><li>一致性：事务执行的结果是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性。</li><li>隔离性：一个事务的执行不能被其他事务干扰。即一个事务的内部操作及其使用的数据对其他并发事务是隔离的，并发事务之间不能相互干扰</li><li>持续性：也称永久性（Permanence），指一个事务一旦提交，他对数据库的改变应该是永久性的</li></ul><p>事务ACID特性可能遭到破坏的因素：</p><ul><li>多个事务并行执行时，不同事物的操作交叉执行；</li><li>事务在运行过程中被强制停止；</li></ul><p>事务ACID特性并不是平级的，它们的关系如下：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况</li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/a58e294a-615d-4ea0-9fbf-064a6daec4b2.png" style="zoom:80%;" /><h3 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h3><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用 <code>START TRANSACTION</code> 语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p><h2 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h3 id="1、丢失修改（W-W）"><a href="#1、丢失修改（W-W）" class="headerlink" title="1、丢失修改（W-W）"></a>1、丢失修改（W-W）</h3><p><strong>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换</strong>。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427141425200.png" alt="image-20230427141425200" style="zoom:80%;" /><h3 id="2、读脏数据（W-R）"><a href="#2、读脏数据（W-R）" class="headerlink" title="2、读脏数据（W-R）"></a>2、读脏数据（W-R）</h3><p><strong>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据</strong>。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427141408877.png" alt="image-20230427141408877" style="zoom:80%;" /><h3 id="3、不可重复读（R-W）"><a href="#3、不可重复读（R-W）" class="headerlink" title="3、不可重复读（R-W）"></a>3、不可重复读（R-W）</h3><p><strong>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致</strong>。例如：T1 读取一个数据，T2 对该数据做了修改。如果 T1 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427141450751.png" alt="image-20230427141450751" style="zoom:80%;" /><h3 id="4、幻影读"><a href="#4、幻影读" class="headerlink" title="4、幻影读"></a>4、幻影读</h3><p><strong>幻读本质上也属于不可重复读的情况</strong>。T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p>不可重复读和幻影读的区别：</p><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了</li></ul><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。</p><p>并发控制的主要技术：封锁、时间戳、乐观控制法、多版本并发控制等，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题</p><h2 id="三、封锁"><a href="#三、封锁" class="headerlink" title="三、封锁"></a>三、封锁</h2><p>封锁是实现并发控制一个非常重要的技术。</p><h3 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h3><p>MySQL 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h3 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h3><h4 id="1、读写锁"><a href="#1、读写锁" class="headerlink" title="1、读写锁"></a>1、读写锁</h4><ul><li>排他锁（Exclusive Lock，X 锁）：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）</li><li>共享锁（Share Lock，S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）</li></ul><p>有以下两个规定：</p><ol><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ol><p>锁的兼容关系如下：</p><table><thead><tr><th align="center">-</th><th align="center">X</th><th align="center">S</th></tr></thead><tbody><tr><td align="center"><strong>X</strong></td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center"><strong>S</strong></td><td align="center">×</td><td align="center">√</td></tr></tbody></table><h4 id="2、意向锁"><a href="#2、意向锁" class="headerlink" title="2、意向锁"></a>2、意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X&#x2F;S 锁之上引入了 IX&#x2F;IS，<strong>IX&#x2F;IS 都是表锁</strong>，<strong>用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁</strong>。有以下两个规定：</p><ol><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ol><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X&#x2F;IX&#x2F;S&#x2F;IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p><table><thead><tr><th align="center">-</th><th align="center">X</th><th align="center">IX</th><th align="center">S</th><th align="center">IS</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">×</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">IX</td><td align="center">×</td><td align="center">√</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">S</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">IS</td><td align="center">×</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><ul><li>任意 IS&#x2F;IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li><li>S 锁只和 S&#x2F;IS 锁兼容</li><li><strong>这里兼容关系针对的是表级锁</strong>，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><h4 id="1、三级封锁协议"><a href="#1、三级封锁协议" class="headerlink" title="1、三级封锁协议"></a>1、三级封锁协议</h4><h5 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h5><p>事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。</p><p>可以解决丢失修改问题，但是仅仅读数据是不需要加锁的，因此不能保证可重复读和不读“脏”数据</p><h5 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h5><p>在一级封锁协议的基础上，增加事务 T 读取数据 R 之前必须加 S 锁，读完可释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。由于读完数据就释放S锁，因此不能保证可重复读</p><h5 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h5><p>在一级封锁协议基础上，增加事务 T 读取数据 R 之前必须对其加 S 锁，直到事务结束才可以释放。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><h4 id="2、两段锁协议"><a href="#2、两段锁协议" class="headerlink" title="2、两段锁协议"></a>2、两段锁协议</h4><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p><strong>事务遵循两段锁协议是保证可串行化调度的充分条件</strong>。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">lock-x</span><span class="hljs-params">(A)</span></span>..<span class="hljs-selector-class">.lock-s</span>(B)..<span class="hljs-selector-class">.lock-s</span>(C)..<span class="hljs-selector-class">.unlock</span>(A)..<span class="hljs-selector-class">.unlock</span>(C)..<span class="hljs-selector-class">.unlock</span>(B)<br></code></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">lock-x</span><span class="hljs-params">(A)</span></span>..<span class="hljs-selector-class">.unlock</span>(A)..<span class="hljs-selector-class">.lock-s</span>(B)..<span class="hljs-selector-class">.unlock</span>(B)..<span class="hljs-selector-class">.lock-s</span>(C)..<span class="hljs-selector-class">.unlock</span>(C)<br></code></pre></td></tr></table></figure><h3 id="MySQL隐式和显示锁定"><a href="#MySQL隐式和显示锁定" class="headerlink" title="MySQL隐式和显示锁定"></a>MySQL隐式和显示锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">SELECT</span></span> ... LOCK In SHARE MODE;<br><span class="hljs-function"><span class="hljs-title">SELECT</span></span> ... <span class="hljs-keyword">FOR</span> UPDATE;<br></code></pre></td></tr></table></figure><h2 id="四、隔离级别"><a href="#四、隔离级别" class="headerlink" title="四、隔离级别"></a>四、隔离级别</h2><h3 id="读未提交（READ-UNCOMMITTED）"><a href="#读未提交（READ-UNCOMMITTED）" class="headerlink" title="读未提交（READ UNCOMMITTED）"></a>读未提交（READ UNCOMMITTED）</h3><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h3 id="读已提交（READ-COMMITTED）"><a href="#读已提交（READ-COMMITTED）" class="headerlink" title="读已提交（READ COMMITTED）"></a>读已提交（READ COMMITTED）</h3><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h3 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h3><p>指事务执行过程中看到的数据，和该事务启动时看到的数据是一致的。保证在同一个事务中多次读取同一数据的结果是一样的。</p><h3 id="串行化（SERIALIZABLE）"><a href="#串行化（SERIALIZABLE）" class="headerlink" title="串行化（SERIALIZABLE）"></a>串行化（SERIALIZABLE）</h3><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p><hr><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">读已提交</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">可重复读</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">串行化</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h2 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h2><p>多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于<em>实现读已提交和可重复读这两种隔离级别</em>。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。</p><p>在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 <code>CopyOnWrite</code> 类似。</p><p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p><p><strong>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改</strong>。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><ul><li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li></ul><h3 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h3><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号:</p><ul><li>创建版本号: 指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号: 如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><h3 id="undo-日志"><a href="#undo-日志" class="headerlink" title="undo 日志"></a>undo 日志</h3><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/e41405a8-7c05-4f70-8092-e961e28d3112.jpg.jpeg" style="zoom:80%;" /><p>MySQL 在执行增删改操作时如果没有显式开始事务，由于 AUTOCOMMIT 设置会默认将每个操作语句都当作一个事务。INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>MVCC 维护了一个 ReadView 结构，主要包含了：创建 ReadView 的事务id、当前系统未提交的事务列表、最小事务id、最大事务id</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427145140377.png" alt="image-20230427145140377" style="zoom:80%;" /><p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p><ul><li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li><li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li><li>TRX_ID_MIN &lt;&#x3D; TRX_ID &lt;&#x3D; TRX_ID_MAX，需要根据隔离级别再进行判断：<ul><li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li><li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li></ul></li></ul><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><p>1、快照读</p><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> ...;<br></code></pre></td></tr></table></figure><p>2、当前读</p><p>读取的是最新的数据，需要加锁。SELECT也可以强制加锁，以下第一个语句需要加 S 锁，其它都需要加 X 锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> ? lock <span class="hljs-keyword">in</span> share mode;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> ? <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">insert</span>;<br><span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure><h2 id="六、Next-Key-Locks"><a href="#六、Next-Key-Locks" class="headerlink" title="六、Next-Key Locks"></a>六、Next-Key Locks</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题</p><h3 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h3><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用</p><h3 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h3><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">WHERE</span> c <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;<br></code></pre></td></tr></table></figure><h3 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><p>它是 <strong>Record Locks 和 Gap Locks 的结合</strong>，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name"><span class="hljs-built_in">-</span></span>∞<span class="hljs-punctuation">,</span> <span class="hljs-number">10</span>]<br>(<span class="hljs-number">10</span><span class="hljs-punctuation">,</span> <span class="hljs-number">11</span>]<br>(<span class="hljs-number">11</span><span class="hljs-punctuation">,</span> <span class="hljs-number">13</span>]<br>(<span class="hljs-number">13</span><span class="hljs-punctuation">,</span> <span class="hljs-number">20</span>]<br>(<span class="hljs-number">20</span><span class="hljs-punctuation">,</span> +∞)<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.pdai.tech/md/db/sql/sql-db-theory.html">SQL DB - 数据库系统核心知识点</a></li><li><a href="http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">数据库系统原理</a></li><li><a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离级别是怎么实现的？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetbook-数组和字符串</title>
    <link href="/20201206/7970c1ba/"/>
    <url>/20201206/7970c1ba/</url>
    
    <content type="html"><![CDATA[<h1 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h1><span id="more"></span><h2 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h2><h3 id="寻找数组的中心索引"><a href="#寻找数组的中心索引" class="headerlink" title="寻找数组的中心索引"></a>寻找数组的中心索引</h3><p><strong>思路</strong>：前缀和——中心索引左右两边和相等，所以先sum求出总和，然后计算右边是否等于左边<code>left == sum-left-nums[i]</code>，满足就返回，不满足就右移，直到结束。时间复杂度O(N)空间复杂度O(1)</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pivotIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,left=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s:nums) sum+=s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(left== sum-left-nums[i])&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            left+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h3><p><strong>思路</strong>：简单的二分查找代码。（当然由于数组已经有序了，直接遍历一遍也行）</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                left = mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                right = mid-<span class="hljs-number">1</span>;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> right+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p>思路：题目是要判断重叠区间，类似算法笔记贪心</p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//参考算法笔记 区间贪心，寻找不相交区间</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>        <span class="hljs-comment">//按起始位置由小到大排序</span><br>        Arrays.sort(intervals,(v1,v2)-&gt; v1[<span class="hljs-number">0</span>]-v2[<span class="hljs-number">0</span>] );<br>        <span class="hljs-comment">//存放每一个内部的数组</span><br>        <span class="hljs-type">int</span>[][] ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[intervals.length][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] interval:intervals)&#123;<br>            <span class="hljs-comment">//当前数组起始位置 &gt; ans最后数组的结束位置</span><br>            <span class="hljs-comment">//将当前数组加入ans</span><br>            <span class="hljs-keyword">if</span>(index==-<span class="hljs-number">1</span> || interval[<span class="hljs-number">0</span>]&gt;ans[index][<span class="hljs-number">1</span>])<br>                ans[++index] = interval;<br>            <span class="hljs-comment">//否则将当前区间加到ans最后数组</span><br>            <span class="hljs-keyword">else</span><br>                ans[index][<span class="hljs-number">1</span>] = Math.max(ans[index][<span class="hljs-number">1</span>],interval[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.copyOf(ans, index + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维数组简介"><a href="#二维数组简介" class="headerlink" title="二维数组简介"></a>二维数组简介</h2><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><p>对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。</p><p>matrix [row] [col] –&gt; matrix [col] [n-1-row]</p><p>思路一：用辅助数组存储临时旋转的结果</p><p>复杂度：时间O(N^2) 空间O(N^2)</p><p>思路二：原地旋转，前一个的列是旋转结果的行，前一个的行倒数过来是结果的列</p><p>一次旋转交换四个位置</p><p>[row,col] –&gt; [col,n-1-row] –&gt; [n-1-row,n-1-col] –&gt; [n-1-col,row] –&gt; [row,col]</p><p>n为偶数：n^2&#x2F;4 &#x3D; n&#x2F;2 * n&#x2F;2，左上角四分之一区域</p><p>n为奇数：(n^2-1)&#x2F;4 &#x3D; (n-1)&#x2F;2 * (n+1)&#x2F;2，左上角(n-1)&#x2F;2,(n+1)&#x2F;2区域</p><p>注：赋值的时候反过来</p><p>思路三：用翻转代替旋转，做两次翻转结果也是一样</p><p>水平翻转   ：matrix [row] [col] &#x3D; matrix [n-1-row] [col]</p><p>+主对角线翻转  ：matrix [row] [col] &#x3D; matrix [col] [row]</p><p>&#x3D; 联立结果    ：matirx [row] [col] &#x3D; matrix [col] [n-1-row]</p><p>注：水平+对角线–&gt;顺时针 对角线+水平–&gt;逆时针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//思路二：原地翻转</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> row=<span class="hljs-number">0</span>;row&lt;n/<span class="hljs-number">2</span>;row++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> col=<span class="hljs-number">0</span>;col&lt;(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;col++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[row][col];<br>                matrix[row][col] = matrix[n-<span class="hljs-number">1</span>-col][row];<br>                matrix[n-<span class="hljs-number">1</span>-col][row] = matrix[n-<span class="hljs-number">1</span>-row][n-<span class="hljs-number">1</span>-col];<br>                matrix[n-<span class="hljs-number">1</span>-row][n-<span class="hljs-number">1</span>-col] = matrix[col][n-<span class="hljs-number">1</span>-row];<br>                matrix[col][n-<span class="hljs-number">1</span>-row] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//思路三</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;<br>        <span class="hljs-comment">//水平翻转</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i &lt; n/<span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[n-<span class="hljs-number">1</span>-i][j];<br>                matrix[n-<span class="hljs-number">1</span>-i][j] = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//对角线翻转</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>                matrix[i][j] = matrix[j][i];<br>                matrix[j][i] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h3><p>思路：数组中只要某个位置<code>matrix[i][j] = 0</code>那么对应<code>i</code>行<code>j</code>列全置0，所以可以用两个数组记录行列中出现0的情况，遍历二维数组做处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">boolean</span>[] row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[matrix.length];<br>        <span class="hljs-type">boolean</span>[] col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[matrix[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-comment">//记录0出现的行列值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">0</span>)&#123;<br>                    row[i] = <span class="hljs-literal">true</span>;<br>                    col[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//清理行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(row[i])&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].length;j++)<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//清理列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix[<span class="hljs-number">0</span>].length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(col[i])&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix.length;j++)<br>                    matrix[j][i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h2><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>思路一：横向扫描方式，一次遍历比较字符串，更新前缀prefix，遍历完后就可以得到最长前缀。</p><p>时间复杂度O(mn)，m是字符串平均长度，n是字符串数量；空间复杂度O(1)</p><p>思路二：纵向扫描，从前往后遍历所有字符串的第一列，相同列上字符相同就继续，否则就返回</p><p>还有其他方法例如分治、二分查找等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-keyword">if</span>(strs == <span class="hljs-literal">null</span> || strs.length ==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;count;i++)&#123;<br>            prefix = lcp(prefix,strs[i]);<br>            <span class="hljs-keyword">if</span>(prefix.length() == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prefix;<br>    &#125;<br><br>    <span class="hljs-comment">//获取两个字符串的lcp</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">lcp</span><span class="hljs-params">(String s1,String s2)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Math.min(s1.length(),s2.length());<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(index&lt;len &amp;&amp; s1.charAt(index)==s2.charAt(index))<br>            index++;<br>        <span class="hljs-keyword">return</span> s1.substring(<span class="hljs-number">0</span>,index);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        <span class="hljs-keyword">if</span> (strs == <span class="hljs-literal">null</span> || strs.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>].length();<span class="hljs-comment">//字符串长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> strs.length;<span class="hljs-comment">//字符串数量</span><br>        <span class="hljs-comment">//每个字符串逐列进行比较</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> strs[<span class="hljs-number">0</span>].charAt(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; count; j++) &#123;<br>                <span class="hljs-comment">//第j个字符串长度即为i || 对应位置字符不同</span><br>                <span class="hljs-keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c) &#123;<br>                    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>, i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>思路：暴力法枚举所有子串，验证是否为回文串，可以添加剪枝<code>j-i+1&gt;maxLen</code>，只有串长比maxLen大才判断。时间复杂度O(N^3)，这个暴力法自己写的都有问题。。参考一下别人的改出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//s.charAt(i)每次都会检查数组下标越界，因此先转换成字符数组</span><br>        <span class="hljs-type">char</span>[] charArray = s.toCharArray();<br>        <span class="hljs-comment">//枚举所有长度达于1的子串charArray[i...j]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;len;j++)&#123;<br>                <span class="hljs-keyword">if</span>(j-i+<span class="hljs-number">1</span>&gt;maxLen &amp;&amp; validPalindromic(charArray,i,j))&#123;<br>                    maxLen = j-i+<span class="hljs-number">1</span>;<br>                    begin = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>  s.substring(begin,begin+maxLen);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 验证子串s[left...right]是否为回文串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validPalindromic</span><span class="hljs-params">(<span class="hljs-type">char</span>[] charArray,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(charArray[left]!=charArray[right])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>别人的思路：动态规划。回文串具有天然的状态转移性质——一个回文串去掉首尾两个字符还是回文串。所以可以从两端判断：两端不等必然不是，相等再看里面</p><ol><li><p>定义状态：<code>dp[i][j]</code>表示<code>s[i...j]</code>是否为回文子串</p></li><li><p>状态转移方程:<code>dp[i][j]==(s[i]==s[j]) and dp[i+1][j-1]</code></p><p>动态规划就是填二维表，由于<code>i&lt;=j</code>所以只看对角线以上</p><p>还要考虑<code>dp[i+1][j-1]</code>可能存在边界情况。边界条件：<code>(j-1)-(i+1)+1&lt;2 --&gt; j-i&lt;3</code>即字符串长度为2或3的时候直接判断</p></li><li><p>判断结论：如果子串 <code>s[i+1..j-1]</code> 只有 1 个字符，即去掉两头，剩下中间部分只有1个字符，显然是回文；如果子串<code>s[i+1..j-1]</code>为空串，那么子串<code>s[i, j]</code>一定是回文子串。</p></li><li><p>初始化：单个字符肯定是回文串，所以对角线即<code>dp[i][i]=true</code>，不过但单个字符也不会被其他状态值参考，基本可以去除</p></li><li><p>输出：只要得到<code>dp[i][j]=true</code>就记录字串长度和起始位置</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> s;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">manLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//dp[i][j]</span><br>        <span class="hljs-type">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len][len];<br>        <span class="hljs-type">char</span>[] charArray = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>            <span class="hljs-keyword">do</span>[i][i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;len;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;j;i++)&#123;<br>                <span class="hljs-keyword">if</span>(charArray[i]!=charArray[j])<br>                    dp[i][j] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(j-i&lt;<span class="hljs-number">3</span>)dp[i][j]=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">else</span>dp[i][j]=dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-comment">//dp[i][j]==true表示子串s[i...j]是回文串，记录长度和起始位置</span><br>                <span class="hljs-keyword">if</span>(dp[i][j]&amp;&amp;j-i+<span class="hljs-number">1</span>&gt;maxLen)&#123;<br>                    maxLen = j-i+<span class="hljs-number">1</span>;<br>                    begin = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(begin,begin+maxLen);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>别人的思路：中心扩散。除了从左右两端来判断，回文串也可以从中间往两边扩散。基本想法是遍历每一个索引，以该索引为中心利用回文串对称的特点往两边扩散  </p><h3 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h3><p>思路：一开始没想到用库函数，想着直接遍历s，开一个String数组存放单词，遇到空格就表示一个单词结束，所以只要<code>s.charAt(i)!=&#39; &#39;</code>的话就<code>word[num]+=s.charAt(i)</code>，遇到空格单词入栈和<code>num++</code>，然后将栈中元素拼接，思路没错，就是太麻烦了，效率也非常低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        s+=<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>        String[] word = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10010</span>];<br>        Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10010</span>;i++)&#123;<br>            word[i]=<span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i)!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                word[num] += s.charAt(i);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                stack.push(word[num]);<br>                num++;<br>            &#125;<br>        &#125;<br>        String ss=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>            ss+=stack.peek();<br>            <span class="hljs-keyword">if</span>(stack.size()&gt;<span class="hljs-number">1</span>&amp;&amp;stack.peek()!=<span class="hljs-string">&quot;&quot;</span>)&#123;<br>                ss+=<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            stack.pop();<br>        &#125;<br>        ss=ss.trim();<br>        <span class="hljs-keyword">return</span> ss;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题一：遇到<code>&quot; hello world!&quot;</code>会输出<code>&quot; world! hello &quot;</code>而不是预期的<code>&quot;world! hello&quot;</code>。。。在后面处理一下<code>ss=ss.trim()</code></p><p>问题二：遇到<code>&quot;a good   example&quot;</code>时，在while循环中把<code>word[num]=&quot;&quot;</code>加了一次到stack中，所以在拼接ss时多了一个空格，导致输出<code>&quot;example   good a&quot;</code>，将判断条件由<code>stack.size()!=0</code>改为<code>stack.size()&gt;1&amp;&amp;stack.peek()!=&quot; &quot; </code>就行</p><p>word数组设大一点，最后有一个输入用例非常多</p><p>别人的思路：可以直接用库函数（属实不太熟悉。。。就很致命）trim去首位空格、spilt分割、reverse翻转、join再连接。一波操作带走</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        String[] words = s.trim().split(<span class="hljs-string">&quot; +&quot;</span>);<br>        Collections.reverse(Arrays.asList(words));<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot; &quot;</span>, words);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>别人的思路二：上面库函数面试可能不会让用，所以参考了一下别人的发现，可以考虑改进我的思路，从后往前遍历就不需要栈了，用一个双指针索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;<br>        s=s.trim();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">//start和end用于定位单词的首尾</span><br>        <span class="hljs-type">int</span> end=s.length()-<span class="hljs-number">1</span>,start=end;<br>        <span class="hljs-keyword">while</span>(start&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//搜索单词</span><br>            <span class="hljs-keyword">while</span>(start&gt;=<span class="hljs-number">0</span>&amp;&amp;s.charAt(start)!=<span class="hljs-string">&#x27; &#x27;</span>)start--;<br>            <span class="hljs-comment">//添加单词</span><br>            res.append(s.substring(start+<span class="hljs-number">1</span>,end+<span class="hljs-number">1</span>) +<span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-comment">//跳过空格</span><br>            <span class="hljs-keyword">while</span>(start&gt;<span class="hljs-number">0</span>&amp;&amp;s.charAt(start)==<span class="hljs-string">&#x27; &#x27;</span>)start--;<br>            <span class="hljs-comment">//指向下个单词的尾字符</span><br>            end = start;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString().trim(); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h3><p>思路一：直接调用库函数indexOf</p><p>思路二：双指针暴力遍历检测</p><p>思路三：KMP算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//思路二：双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;<br>        <span class="hljs-keyword">if</span>(needle.length()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(needle.length()&gt;haystack.length())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;haystack.length() &amp;&amp; j&lt;needle.length())&#123;<br>            <span class="hljs-keyword">if</span>(haystack.charAt(i) == needle.charAt(j))&#123;<span class="hljs-comment">//两指针值相等</span><br>                <span class="hljs-keyword">if</span>(index == -<span class="hljs-number">1</span>)<span class="hljs-comment">//index是初始值，更新index</span><br>                    index = i;<br>                <span class="hljs-keyword">if</span>(j == needle.length()-<span class="hljs-number">1</span>)<span class="hljs-comment">//如果j是needle的最后一个，即已经遍历完就返回index</span><br>                    <span class="hljs-keyword">return</span> index;<br>                j++;<span class="hljs-comment">//needle未遍历完，继续</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//指针值不相等</span><br>                <span class="hljs-keyword">if</span>(index != -<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//index不是初始值，更新i</span><br>                    i = index;<br>                    j = <span class="hljs-number">0</span>;<br>                    index = -<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            i++;<span class="hljs-comment">//i始终要后移</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针技巧"><a href="#双指针技巧" class="headerlink" title="双指针技巧"></a>双指针技巧</h2><p>常用的有：</p><ul><li>左右指针：左右两端点开始，反向运动，常用于二分查找之类问题</li><li>快慢指针：同一起点，通向运动，一快一慢，典型的判定链表中是否包含环</li></ul><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p>【题目要求原地修改输入数组、并用O(1)的额外空间解决问题】</p><p>思路：很显然放在双指针下自然想到双指针方法。。这也算是最典型的应用了，双指针left和right从两边往中间靠拢，每次交换对应的s[left]和s[right]即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">null</span> || s.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> s.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[left];<br>            s[left] = s[right];<br>            s[right] = temp;<br>            left ++;<br>            right --;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组拆分"><a href="#数组拆分" class="headerlink" title="数组拆分"></a>数组拆分</h3><p>思路：将长度为2n的数组分成n对，取每队的最小值min相加，使得最后的值sum最大。那我们就应该尽可能的保留大的值——假如最大和最小、第二大和第二小。。。这样每次取min都是小的；应该最大与第二大、第三大与第四大。。。这样才能做到保留大值。【实现上就是排序取奇数位】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">arrayPairSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i+=<span class="hljs-number">2</span>)&#123;<br>            ans+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="两数之和-II-输入有序数组"><a href="#两数之和-II-输入有序数组" class="headerlink" title="两数之和 II - 输入有序数组"></a>两数之和 II - 输入有序数组</h3><p>思路：因为数组已经有序了，那这就跟二分查找差不多了，只不过它多了一步——返回是下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>,right=numbers.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers[left]+numbers[right];<br>            <span class="hljs-keyword">if</span>(sum==target)&#123;<span class="hljs-comment">//找到了</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;left+<span class="hljs-number">1</span>,right+<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//数组下标从0开始,返回要补上</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>                right--;<span class="hljs-comment">//右指针左移</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left++;<span class="hljs-comment">//左指针右移</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<span class="hljs-comment">//找不到</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>【原地移除等于目标值的元素，控制常量空间】</p><p>思路：一般思路是遇到不等于目标值的就放入新数组，这样一次遍历得到的新数组即为所需的。现在要求常数空间，那就可以用快慢指针：快指针每次都移动，慢指针只有快指针的值不为目标值val才移动，若相同则停止，等下一个不同的来覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">null</span>||nums.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>;fast&lt;nums.length;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast]!=val)&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大连续1的个数"><a href="#最大连续1的个数" class="headerlink" title="最大连续1的个数"></a>最大连续1的个数</h3><p>思路：由0、1组成的数组中连续1的最大个数。之前没用双指针，感觉差不多</p><ul><li>原来思路：变量count记录当前连续1的个数，遇到0就将count存入tmp然后count置0，下次再遇到就和tmp比较，遍历一遍得到结果</li><li>双指针：快指针判断，慢指针只有判断为1才前移</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//思路一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxConsecutiveOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>,tmp=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==<span class="hljs-number">1</span>)&#123;<br>                count++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                tmp = Math.max(tmp,count);<br>                count=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(tmp,count);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//双指针</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxConsecutiveOnes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>,count=<span class="hljs-number">0</span>,fast;<br>        <span class="hljs-keyword">for</span>(fast=<span class="hljs-number">0</span>;fast&lt;nums.length;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast]==<span class="hljs-number">0</span>)&#123;<br>                count = Math.max(fast-slow,count);<br>                slow = fast+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(fast==nums.length-<span class="hljs-number">1</span> &amp;&amp; nums[fast]==<span class="hljs-number">1</span>)<br>                count = Math.max(fast-slow+<span class="hljs-number">1</span>,count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p>思路：题目要找出满足和&gt;&#x3D;s的长度最小的<strong>连续</strong>子数组，我第一反应就是暴力求解，不过复杂度会比较高</p><ul><li>暴力想法：枚举nums每个元素<code>nums[i]</code>，作为子数组的起始，然后从<code>i</code>开始往后，直到找到<code>j</code>使得<code>nums[i]到nums[j]</code>元素之和大于等于s，更新子数组长度。复杂度O(n<sup>2</sup>)</li><li>题解的双指针方法：双指针start和end，每轮<code>sum+=nums[end]</code>，满足大于等于s，就更新长度，然后执行<code>sum -= nums[start]</code>【start右移，类似滑动窗口，直到sum&lt;s，其中每次也更新长度】一轮完成后<code>end++</code>，开始下一轮</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">10010</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,end = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(end=<span class="hljs-number">0</span>;end&lt;nums.length;end++)&#123;<br>            sum += nums[end];<br>            <span class="hljs-keyword">while</span>(sum&gt;=s)&#123;<br>                len = Math.min(len,end-start+<span class="hljs-number">1</span>);<br>                sum -= nums[start++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len==<span class="hljs-number">10010</span>? <span class="hljs-number">0</span> : len;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p>思路：打印杨辉三角嘛，两边是1直接<code>add(1)</code>，中间是正上面的左上方和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numRows;i++)&#123;<br>            ArrayList&lt;Integer&gt; sub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||j==i)&#123;<br>                    sub.add(<span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    sub.add(res.get(i-<span class="hljs-number">1</span>).get(j-<span class="hljs-number">1</span>)+res.get(i-<span class="hljs-number">1</span>).get(j));<br>                &#125;<br>            &#125;<br>            res.add(sub);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="杨辉三角-II"><a href="#杨辉三角-II" class="headerlink" title="杨辉三角 II"></a>杨辉三角 II</h3><p>思路：上一题返回整个，这个返回杨辉三角的第k行【进阶：空间O(k)】</p><ul><li><p>简单的就在k行返回；优化的思路：</p><ul><li><p>杨辉三角具有动态规划的性质，下一行依赖于上一行，且两边固定为1。</p><p>【数组写法】数组表示很直观但是rowIndex未知，那就只能将最后的数组取前rowIndex+1位放到新数组返回</p><p>【ArrayList写法】ArrayList用add会输出所有的元素，变成<code>1 11 121 1331</code>；有个set函数可以指定索引元素，但是得先有元素才行，所以最后要删除多的1</p></li><li><p>可以用组合公式<code>C(n,i) = n!/(i!*(n-i)!)</code></p></li></ul></li><li><p>或者先本地IDE跑出来，然后直接打表，标准O(1)解答！(因为题目限制k&lt;33)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getRow</span><span class="hljs-params">(<span class="hljs-type">int</span> rowIndex)</span> &#123;<br>        ArrayList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=rowIndex;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||j==i)&#123;<br>                    res.add(<span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    res.set(j,res.get(j)+res.get(j-<span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> res.size();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=size-<span class="hljs-number">1</span>;j&gt;=size-rowIndex;j--)&#123;<br>            res.remove(j);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反转字符串中的单词-III"><a href="#反转字符串中的单词-III" class="headerlink" title="反转字符串中的单词 III"></a>反转字符串中的单词 III</h3><p>之前做过反转句子输出：<code>i love you</code>输出<code>you love i</code>这种，这题是反转每个单词，但是单词间位置不变：<code>i love you</code>输出<code>i evol uoy</code></p><p>思路：正在刷双指针，所以一下就想到双指针方法，一个slow用于定位每个单词的开始位置，<code>fast==&#39; &#39;</code>时前一个就是单词的结束位置，然后将单词的字符反转。</p><p>【写完编译不通过，才想起来Java中的String是不可变的。。。改用C++思路不变】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>,slow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>;fast&lt;s.<span class="hljs-built_in">length</span>();fast++)&#123;<br>            <span class="hljs-keyword">if</span>(s[fast]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                <span class="hljs-type">int</span> j = fast<span class="hljs-number">-1</span>;<br>                <span class="hljs-comment">//exchange</span><br>                <span class="hljs-keyword">while</span>(slow&lt;j)&#123;<br>                   <span class="hljs-built_in">swap</span>(s[slow], s[j]);<br>                   slow++;<br>                   j--;<br>                &#125;<br>                <span class="hljs-comment">//update</span><br>                slow = fast+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(fast==s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>&amp;&amp;s[fast]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                <span class="hljs-type">int</span> j = fast;<br>                <span class="hljs-keyword">while</span>(slow&lt;j)&#123;<br>                    <span class="hljs-built_in">swap</span>(s[slow], s[j]);<br>                    slow++;<br>                    j--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="寻找旋转排序数组中的最小值"><a href="#寻找旋转排序数组中的最小值" class="headerlink" title="寻找旋转排序数组中的最小值"></a>寻找旋转排序数组中的最小值</h3><p>看题目输入输出，好像就是找数组最小值。。。它说在某个点旋转了我也没整明白咋旋转的：<code>[0,1,2,4,5,6,7]</code>转成<code>[4,5,6,7,0,1,2]</code>。可能是说数组变成了<code>4,5,6,7</code>和<code>0,1,2</code>两个区域然后旋转了方向，所以数组不再有序了</p><p>思路：</p><ul><li>第一眼就直接遍历一遍：复杂度O(N)</li><li>改进方式：采用二分优化。但是二分需要数组有序，旋转了之后数组是乱序的，要改进一下，假设两个区域分别叫大区间和小区间<ul><li>找到中间元素mid，如果<code>nums[mid]&gt;nums[right]</code>说明mid是大区间的值，那我们就应该去小区间搜索；反之表示mid是小区间的值，那就缩小范围继续</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//数组未被旋转</span><br>        <span class="hljs-keyword">if</span>(nums[right]&gt;nums[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right&gt;left)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h3><p>思路：有序数组去重，也是双指针比较好想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span>(nums==<span class="hljs-literal">null</span>||nums.length==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums.length;<br>        &#125;<br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>,fast;<br>        <span class="hljs-keyword">for</span>(fast=<span class="hljs-number">1</span>;fast&lt;nums.length;fast++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast] != nums[slow])&#123;<br>                slow++;<br>                nums[slow] = nums[fast];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><p>将数组<code>[0,1,2,0,3]</code>中0移到最后且保持原数组顺序，即<code>[1,2,3,0,0]</code>。</p><p>最简单的思路就是再开一个数组遍历，不过题目要求原地操作，所以比较容易想到双指针操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//双指针</span><br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>,fast=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast&lt;nums.length)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast]!=<span class="hljs-number">0</span>)&#123;<br>                swap(nums,slow,fast);<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = tmp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet学习四-Cookie和Session</title>
    <link href="/20201115/e0643af3/"/>
    <url>/20201115/e0643af3/</url>
    
    <content type="html"><![CDATA[<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话跟踪是Web应用中常见的技术，用来跟踪用户的整个访问。例如用户打开浏览器，在浏览器中点击了多个标签页，访问不同的资源，然后关闭浏览器，整个过程可以称为一次会话。</p><p>常见的会话跟踪技术有Cookie和Session，Cookie出现时间更早些，在《计算机网络》课程中有讲到过。Cookie是通过客户端记录来确定用户身份信息；Session是通过服务器端记录来确定用户身份信息。</p><p>通过会话跟踪技术，我们可以实现很多常见的功能：密码保存、购物车信息、商品推荐等</p><span id="more"></span><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>以购物为例，用户对商品的所有操作应该属于一次会话，用户添加商品A到购物车后返回主界面，再次添加时无法判断这是否已经在购物车内【由于Web应用程序采用的是无状态的HTTP协议进行数据传输：<strong>一旦数据交换完毕连接就会断开，再次交互时需要建立新的连接</strong>。因此服务器无法跟踪用户的会话】</p><p>为了解决这个问题，引入了Cookie机制。W3C组织提出了：为解决HTTP无状态连接的问题，<strong>服务器给每个客户端颁发一个通行证，访问时携带通行证，这样服务器就能确认用户信息</strong>，这个通行证就是Cookie。</p><p>Cookie实际上是一个记录用户信息的文本数据。客户端请求服务器，如果服务器要记录客户端状态，就使用response向客户端颁发一个Cookie，客户端将其保存，再次请求时浏览器会将请求网址连同Cookie一同提交，服务器检查Cookie确定用户信息。</p><p>【查看Cookie的操作】：在浏览器网址栏中输入<code>javascript:alert(document.cookie)</code>回车即可；或者F12在控制台输出同样指令也行。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201115141148663.png" alt="image-20201115141148663"></p><p>我们访问很多网站时，他也会在网站底部提示：是否允许保存Cookie</p><h3 id="2、Cookie举例"><a href="#2、Cookie举例" class="headerlink" title="2、Cookie举例"></a>2、Cookie举例</h3><h4 id="2-1、API及属性方法"><a href="#2-1、API及属性方法" class="headerlink" title="2.1、API及属性方法"></a>2.1、API及属性方法</h4><p>Java中将Cookie封装在<code>Javax.servlet.http.cookie</code>类中。每个Cookie都是该Cookie类的对象。服务器通过操作Cookie类对象对客户端Cookie进行操作。</p><ul><li>通过**<code>request.getCookie()</code>获取客户端提交的所有Cookie**（以Cookie[]数组形式返回）；</li><li>通过**<code>response.addCookie(Cookiecookie)</code>向客户端设置Cookie；**它用于在响应头中增加一个Set-Cookie头字段</li></ul><p>常见属性方法：【这里直接将别的博客整理的拿过来作为参考】</p><table><thead><tr><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td>String name</td><td>该Cookie的名称。Cookie一旦创建，名称便不可更改</td></tr><tr><td>Object value</td><td>该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码</td></tr><tr><td><strong>int maxAge</strong></td><td><strong>该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1</strong></td></tr><tr><td>boolean secure</td><td>该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false</td></tr><tr><td>String path</td><td>该Cookie的使用路径。如果设置为“&#x2F;sessionWeb&#x2F;”，则只有contextPath为“&#x2F;sessionWeb”的程序可以访问该Cookie。如果设置为“&#x2F;”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“&#x2F;”</td></tr><tr><td>String domain</td><td>可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.”</td></tr><tr><td>String comment</td><td>该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明</td></tr><tr><td>int version</td><td>该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范</td></tr></tbody></table><p>方法</p><ul><li>public Cookie(String name,String value)</li><li>setValue与getValue⽅法</li><li>setPath与getPath⽅法</li><li>setDomain与getDomain⽅法</li><li>getName⽅法</li></ul><p>编写代码如下：验证Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CookieTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.setContentType(<span class="hljs-string">&quot;txt/html;charset=UTF-8&quot;</span>);<br>        <span class="hljs-comment">//创建Cookie对象</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;LiuYi&quot;</span>);<br>        <span class="hljs-comment">//设置时间</span><br>        cookie.setMaxAge(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">//给浏览器颁发Cookie</span><br>        resp.addCookie(cookie);<br>        resp.getWriter().write(<span class="hljs-string">&quot;向浏览器颁发了用户名Cookie！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【记得要设置Cookie的时间】在<code>web.xml</code>中注册，打开页面会下载Cookie文件，打开即为我们的Cookie信息。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201115145147399.png" alt="image-20201115145147399"></p><h3 id="3、Cookie特性"><a href="#3、Cookie特性" class="headerlink" title="3、Cookie特性"></a>3、Cookie特性</h3><h4 id="3-1、Cookie有效期"><a href="#3-1、Cookie有效期" class="headerlink" title="3.1、Cookie有效期"></a>3.1、Cookie有效期</h4><p>Cookie中有个属性叫<code>maxAge</code>，它决定了Cookie的有效期，<strong>通过<code>setMaxAge</code>与<code>getMaxAge</code>⽅法来设置<code>maxAge</code>属性</strong>。</p><ul><li><p>如果<code>maxAge</code>属性为正数，则表示该Cookie会在<code>maxAge</code>秒之后自动失效。浏览器会将对应的Cookie持久化到硬盘中。无论客户关闭了浏览器还是电脑，只要还在<code>maxAge</code>秒之前，登录网站时该Cookie仍然有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 新建Cookie</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;LiuYi&quot;</span>);<br><span class="hljs-comment">// 设置生命周期为MAX_VALUE</span><br>cookie.setMaxAge(Integer.MAX_VALUE);<br><span class="hljs-comment">// 输出到客户端</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure></li><li><p>如果<code>maxAge</code>为负数，则表示该Cookie是临时的，仅在本浏览器窗口内有效，关闭窗口后该Cookie即失效。<code>maxAge</code>为负数的Cookie不会被持久化。Cookie信息保存在浏览器内存中，因此关闭浏览器该Cookie就消失了。Cookie默认的<code>maxAge</code>值为–1。</p><p>因此上面的代码如果没有写<code>setMaxAge</code>的话，就不会下载到本地文件。</p></li><li><p><code>maxAge</code>设置为0，表示<strong>删除Cookie</strong>。Cookie机制没有提供删除Cookie的方法，因此通过设置该Cookie即时失效实现删除Cookie的效果。失效的Cookie会被浏览器从Cookie文件或者内存中删除</p></li></ul><h4 id="3-2、Cookie不可跨域性"><a href="#3-2、Cookie不可跨域性" class="headerlink" title="3.2、Cookie不可跨域性"></a>3.2、Cookie不可跨域性</h4><p>由于很多网站都会使用Cookie，例如<code>baidu.com</code>颁发了Cookie、<code>bilibili.com</code>颁发了Cookie。那么我们在访问B站时，浏览器会不会把百度的Cookie也上传过去？或者百度会不会修改B站的Cookie？</p><p>其实是不会的。因为<strong>Cookie有一个特性：不可跨域性</strong>。即访问百度时浏览器只会携带百度的Cookie，百度能操作的也只有百度的Cookie！</p><p>由于Cookie是保存在客户端的，因此对Cookie的管理是由浏览器进行的。浏览器会根据网址域名来判断该网站能否操作另一网站的Cookie。例如根据域名<code>baidu.com</code>得知它不能操作<code>bilibili.com</code>的域名、<code>img.baidu.com</code>和<code>baidu.com</code>都是百度但是二者不能操作对方的Cookie······</p><h4 id="3-3、Cookie编码"><a href="#3-3、Cookie编码" class="headerlink" title="3.3、Cookie编码"></a>3.3、Cookie编码</h4><p>中英文的字符编码是不同的。中文采用的是4字符的Unicode字符、英文采用的是2字节的ASCII编码。因此在Cookie中设置中文时要对Unicode字符进行编码，否则会出现乱码错误</p><h4 id="3-4、Cookie修改删除"><a href="#3-4、Cookie修改删除" class="headerlink" title="3.4、Cookie修改删除"></a>3.4、Cookie修改删除</h4><p>Cookie并没有直接提供修改删除的操作。</p><ul><li>如果要修改某个Cookie，实际操作是创建同名Cookie添加到Response中覆盖原来的。</li><li>删除Cookie在上面有说过，就是设置Cookie的时间为0然后添加到浏览器。</li></ul><p>【注：新建的的Cookie除了value和maxAge，其余的属性要和原来的Cookie保持一致】</p><h4 id="3-5、Cookie的域名"><a href="#3-5、Cookie的域名" class="headerlink" title="3.5、Cookie的域名"></a>3.5、Cookie的域名</h4><p>Cookie是不可跨域的，<code>www.baidu.com</code>颁发的Cookie是不会提交到<code>www.bilibili.com</code>上的。这个特性保证了网站不能非法获取其他网站的Cookie。同一个一级域名下的子域名也不能交接Cookie。例如：<code>goole.com</code>和<code>images.goole.com</code>的Cookie也不能访问。</p><p>Cookie有domain属性，可以设置访问改Cookie的域名，例如<code>.baidu.com</code>，则所有<code>.baiu.com</code>结尾的域名都可以访问该Cookie【注意第一个字符必须为<code>&quot;.&quot;</code>】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;time&quot;</span>,<span class="hljs-string">&quot;20201111&quot;</span>);<span class="hljs-comment">//创建Cookie</span><br>cookie1.setDomain(<span class="hljs-string">&quot;.liuyirespect.com&quot;</span>);<span class="hljs-comment">//设置Cookie的有效域名</span><br>cookie1.setPath(<span class="hljs-string">&quot;/&quot;</span>);<span class="hljs-comment">//设置路径</span><br>cookie1.setMaxAge(Integer.MAX_VALUE);<span class="hljs-comment">//设置有效期</span><br>resp.addCookie(cookie1);<span class="hljs-comment">//resp输出</span><br></code></pre></td></tr></table></figure><h4 id="3-6、Cookie的路径"><a href="#3-6、Cookie的路径" class="headerlink" title="3.6、Cookie的路径"></a>3.6、Cookie的路径</h4><p>Cookie的domain属性决定了访问Cookie的域名，而path属性决定了访问Cookie的路径。</p><p>默认Cookie是当前域名都可以使用它，假设我们只允许<code>cookieServlet</code>可以使用，那就设置对应<code>cookieServlet</code>的路径即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;time&quot;</span>,<span class="hljs-string">&quot;20201111&quot;</span>);<span class="hljs-comment">//创建Cookie</span><br>cookie1.setPath(<span class="hljs-string">&quot;/cookieServlet&quot;</span>);<span class="hljs-comment">//设置路径</span><br>resp.addCookie(cookie1);<span class="hljs-comment">//resp输出</span><br></code></pre></td></tr></table></figure><h4 id="3-7、Cookie的安全性"><a href="#3-7、Cookie的安全性" class="headerlink" title="3.7、Cookie的安全性"></a>3.7、Cookie的安全性</h4><p>由于HTTP协议无状态不安全，所以如果不想Cookie在不安全的协议中传输，可以设置对应Cookie的Secure属性为true，则浏览器只会在HTTPS和SSL等安全协议中传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;time&quot;</span>,<span class="hljs-string">&quot;20201111&quot;</span>);<span class="hljs-comment">//创建Cookie</span><br>cookie1.setSecure(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置安全属性</span><br>resp.addCookie(cookie1);<span class="hljs-comment">//resp输出</span><br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201126073935429.png" alt="image-20201126073935429"></p><p>【注】secure只是保证Cookie在安全的协议中传输，但是对于Cookie本身没有做任何安全操作，因此要提高安全性，可以在程序中对Cookie进行加密操作</p><h3 id="4、Cookie举例"><a href="#4、Cookie举例" class="headerlink" title="4、Cookie举例"></a>4、Cookie举例</h3><h4 id="4-1、显示访问时间"><a href="#4-1、显示访问时间" class="headerlink" title="4.1、显示访问时间"></a>4.1、显示访问时间</h4><p>编写代码如下，并在web.xml中注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CookieDemo01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//设置编码</span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><br>        <span class="hljs-comment">//打印输出</span><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br><br>        <span class="hljs-comment">//Cookie是服务器从客户端获取的</span><br>        Cookie[] cookies = req.getCookies();<span class="hljs-comment">//cookies数组表示可能有多个cookie</span><br>        <span class="hljs-comment">//判断cookie</span><br>        <span class="hljs-keyword">if</span>(cookies!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//存在的话</span><br>            out.write(<span class="hljs-string">&quot;上一次的访问时间是：&quot;</span>);<br>            <span class="hljs-comment">//获取上一次的cookie</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cookies.length;i++)&#123;<br>                <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> cookies[i];<br>                <span class="hljs-keyword">if</span>(cookie.getName().equals(<span class="hljs-string">&quot;lastTime&quot;</span>))&#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> Long.parseLong(cookie.getValue());<br>                    <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>((l));<br>                    out.write(date.toLocaleString());<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            out.write(<span class="hljs-string">&quot;第一次访问本站！&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//服务器响应给客户端的cookie</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;lastTime&quot;</span>, System.currentTimeMillis() + <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//设置有效期</span><br>        cookie.setMaxAge(<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>);<br><br>        resp.addCookie(cookie);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如图：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201126074829511.png" alt="image-20201126074829511"></p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>看一下百度的Session定义</p><blockquote><p>Session：在计算机中，尤其是在网络应用中，称为“会话控制”。Session对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的Web页之间跳转时，存储在Session对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web页时，如果该用户还没有会话，则Web服务器将自动创建一个 Session对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。注意会话状态仅在支持cookie的浏览器中保留。</p></blockquote><p>也就是说：Session是<strong>服务器端使用的一种记录客户端状态的机制</strong>。</p><p>创建Session的同时，服务器会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session，从而再次使用之。</p><p>把访问网络应用比作参加宴会。Cookie相当于请帖，来宾【客户端】出示请帖进入宴会，而Session相当于嘉宾表，主人【服务器】拿着嘉宾表来确认是否邀请了对应的嘉宾。</p><h4 id="1-1、Cookie的优点"><a href="#1-1、Cookie的优点" class="headerlink" title="1.1、Cookie的优点"></a>1.1、Cookie的优点</h4><ul><li>Session使用上比Cookie简单；</li><li>Session存储更多样化，Cookie只能存储字符串，Session还可以存储对象</li></ul><h3 id="2、Session特性"><a href="#2、Session特性" class="headerlink" title="2、Session特性"></a>2、Session特性</h3><h4 id="2-1、Session的生命周期和有效期"><a href="#2-1、Session的生命周期和有效期" class="headerlink" title="2.1、Session的生命周期和有效期"></a>2.1、Session的生命周期和有效期</h4><p><strong>Session是在用户第一次访问服务器的时候自动创建的</strong>，对应的Session对象保存在内存中【只有访问jsp、servlet等程序时才会创建Session，而访问HTML、IMAGE等静态资源时并不会创建。也可以使用req.getSession(true)】</p><p>Session生成后，只要用户继续访问，服务器都会认为该Session活跃(active)了一次，就会更新Session的最后访问时间。</p><p>对于长期没有活跃的Session，服务器会把它从内存中删除，这样的目的就是为了避免内存溢出【Session内容相比Cookie较复杂，所以如果大量Session放在服务器中会导致内存溢出】，有一个超时时间属性<code>maxInactiveInterval</code>，默认是30分钟，过了超时时间都没有访问的就自动失效了，可以通过<code>getMaxInactiveInterval()</code>方法获取。修改方法如下：</p><ul><li><p>1、在<code>tomcat/conf/web.xml</code>中修改。对所有的web应用都有效。默认是20分钟</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>2、在对应应用的web.xml中设置。发生冲突时以自己应用中的web.xml为准。</p></li><li><p>3、通过<code>setMaxInactiveInterval()</code>方法修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置Session最⻓超时时间为60秒，这⾥的单位是秒</span><br>httpSession.setMaxInactiveInterval(<span class="hljs-number">60</span>);<br>System.out.println(httpSession.getMaxInactiveInterval());<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-2、Session的域对象特性"><a href="#2-2、Session的域对象特性" class="headerlink" title="2.2、Session的域对象特性"></a>2.2、Session的域对象特性</h4><p>Session常见的API如下：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201128074433997.png" alt="image-20201128074433997"></p><p>可以看到，Session和ServletContext有类似的方法，即Session也是一个域对象。只要Session对象没有被销毁，就可以通过它来实现通信。</p><h4 id="2-3、Session实现原理"><a href="#2-3、Session实现原理" class="headerlink" title="2.3、Session实现原理"></a>2.3、Session实现原理</h4><p>我们的一个Session对应一个用户，一个浏览器的会话会产生一个Session，那么再用另一个浏览器打开相同的会话会产生另一个Session。即服务器能为不同的用户提供不同Session</p><p>由于HTTP是无状态协议，因此Session无法根据HTTP连接来判断是否为同一客户。<strong>因此服务器向客户端发送一个名为JSESSIONID的Cookie，它的值为该Session的id【即<code>HttpSession.getId()</code>的返回值】</strong>，Session根据该Cookie来判断是否为同一用户。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201128091027056.png" alt="image-20201128091027056"></p><p>这个Cookie的MaxAge是-1，即只有在当前浏览器使用，不会存储在硬盘中</p><p>所以：</p><ul><li>访问使用Session的网页应用1时，服务器会自动创建名为JSESSIONID的Cookie并颁发给用户浏览器。</li><li>使用同一浏览器访问服务器的网页应用2时，浏览器会将Cookie值传给服务器，服务器根据此得知该用户使用的是哪一个Session。</li><li>采用新的会话浏览器时，用户浏览器是没有对应Cookie的，所以服务器无法判断用户的Session。</li></ul><h4 id="2-3、URL地址重写"><a href="#2-3、URL地址重写" class="headerlink" title="2.3、URL地址重写"></a>2.3、URL地址重写</h4><p>如果浏览器禁止了Cookie，或者它本身不支持Cookie时【比如手机浏览器很多不支持】，对应的解决方法是采用<strong>URL地址重写</strong>。它的原理是将该用户的Session的id信息重写到URL地址中，服务器解析重写后的URL获取Session的id。</p><p>它使用的方法如下：</p><ul><li><code>encodeURL(String url)</code></li><li><code>encodeRedirectURL(String url)</code></li></ul><p>这两个方法会自动判断是否支持Cookie。如果支持，重写后的URL就不会带有JSESSIONID。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000013129480">Servlet第五篇【介绍会话技术、Cookie的API、详解、应用】</a></li><li><a href="https://segmentfault.com/a/1190000013130309">Servlet第六篇【Session介绍、API、生命周期、应用、与Cookie区别】</a></li><li><a href="https://www.cnblogs.com/l199616j/p/11195667.html">cookie和session的详解与区别</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet学习三-req和resp</title>
    <link href="/20201109/57c1ff86/"/>
    <url>/20201109/57c1ff86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Request-amp-Response简介"><a href="#一、Request-amp-Response简介" class="headerlink" title="一、Request&amp;Response简介"></a>一、Request&amp;Response简介</h2><p>我们自己创建的那些类，主要就是重写<code>doGet</code>和<code>doPost</code>方法，它们里面的两个参数就是<code>(HttpServletRequest req, HttpServletResponse resp)</code></p><p>Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。</p><p><strong>服务器处理请求的流程</strong></p><ol><li>服务器收到请求，开辟一个新的线程</li><li>将客户端请求数据封装到request对象中</li><li>创建response对象，用来向客户端发送响应，服务器解析response对象后响应给浏览器</li></ol><span id="more"></span><h2 id="二、Response对象及其应用"><a href="#二、Response对象及其应用" class="headerlink" title="二、Response对象及其应用"></a>二、Response对象及其应用</h2><p>Http的响应包含状态行、实体内容、消息头、空行组成</p><h3 id="1、Response实现重定向"><a href="#1、Response实现重定向" class="headerlink" title="1、Response实现重定向"></a>1、Response实现重定向</h3><p>重定向：将网络请求重新定向发送到其他位置。它是服务器通知浏览器去访问另一个网址，让浏览器再发送一个请求</p><p>编写代码如下 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RediectServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * 方式一</span><br><span class="hljs-comment">        * resp.setHeader(&quot;Location&quot;,&quot;/r/imageShow&quot;);</span><br><span class="hljs-comment">        * resp.setStatus(302);</span><br><span class="hljs-comment">        * */</span><br>        resp.sendRedirect(<span class="hljs-string">&quot;/s1/imageShow&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、Response向浏览器输出数据"><a href="#2、Response向浏览器输出数据" class="headerlink" title="2、Response向浏览器输出数据"></a>2、Response向浏览器输出数据</h3><p><strong>2.1、GetWriter()输出字符数据</strong></p><p>基本步骤：获取字符输出流；写出数据</p><p>GetWriter()是Writer的子类，它只能向浏览器输出字符数据，不能输出二进制数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br>out.write(<span class="hljs-string">&quot;向浏览器输出数据&quot;</span>);<br><span class="hljs-comment">//resp.getWriter().print(&quot;向浏览器输出数据&quot;);</span><br></code></pre></td></tr></table></figure><p>在输出过程中可能会出现乱码现象，因为默认的流编码时ISO-8859-1，我们要改成utf-8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><span class="hljs-comment">//或者写成：setContentType(&quot;text/html;charset=utf-8&quot;);</span><br></code></pre></td></tr></table></figure><p><strong>2.2、GetOutputStream输出字节数据</strong></p><p>基本步骤：获取字节输出流；写出数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>out.write(<span class="hljs-string">&quot;输出数据&quot;</span>.getBytes(<span class="hljs-string">&quot;utf-8&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="3、Response下载文件"><a href="#3、Response下载文件" class="headerlink" title="3、Response下载文件"></a>3、Response下载文件</h3><p>前面已经提到过了，利用response下载文件。</p><p>这里可以尝试一下Response下载文件，在resource目录下加入一张图片，然后编写FileServlet类，获取工程目录下的资源文件。一开始我们不知道对应的目录在哪儿，可以用<code>getContextPath()</code>拿到当前的上下文context路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//1、获取下载文件的路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">realPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;G:\\Kuang_JavaWeb\\servlet-01\\src\\main\\webapp\\resources\\leslie.jpg&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;下载路径：&quot;</span>+realPath);<br>        <span class="hljs-comment">//2、下载的文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> realPath.substring(realPath.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>)+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//3、设置浏览器支持下载（）</span><br>        resp.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>,<span class="hljs-string">&quot;attachment; &quot;</span>+<span class="hljs-string">&quot;filename: &quot;</span>+fileName);<br>        <span class="hljs-comment">//4、获取下载文件的输入流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(realPath);<br>        <span class="hljs-comment">//5、创建缓冲区</span><br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//6、获取OutputStream对象</span><br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>        <span class="hljs-comment">//7、将FileOutputStream写入Buffer缓冲区</span><br>        <span class="hljs-keyword">while</span> ((len=in.read(buffer))&gt;<span class="hljs-number">0</span>)&#123;<br>            out.write(buffer,<span class="hljs-number">0</span>,len);<br>        &#125;<br><br>        <span class="hljs-comment">//关闭流</span><br>        in.close();<br>        out.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201108192023201.png" alt="image-20201108192023201"></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/fileD.jpg.jpeg" style="zoom:50%;" /><p>可以看到成功下载了</p><h3 id="4、Response实现验证码"><a href="#4、Response实现验证码" class="headerlink" title="4、Response实现验证码"></a>4、Response实现验证码</h3><p>我们在登录的时候经常会输入验证码，通过response可以实现类似的功能。</p><ul><li>自动定时刷新；通过设置<code>setHeader(&quot;refresh&quot;,&quot;3&quot;)</code>实现3秒定时刷新</li><li>采用BufferedImage生成图片；</li><li>graphics2D写入我们生成的随机数到之前的图片上；</li><li>设置缓存，浏览器本身具有缓存机制，会导致每次图片都一样，所以要禁止掉；</li></ul><p>编写代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//浏览器自动刷新</span><br>        resp.setHeader(<span class="hljs-string">&quot;refresh&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>);<br><br>        <span class="hljs-comment">//在内存中创建图片</span><br>        <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedImage</span>(<span class="hljs-number">80</span>,<span class="hljs-number">20</span>,BufferedImage.TYPE_INT_RGB);<br>        <span class="hljs-comment">//取得图片</span><br>        <span class="hljs-type">Graphics2D</span> <span class="hljs-variable">graphics</span> <span class="hljs-operator">=</span> (Graphics2D) image.getGraphics();<span class="hljs-comment">//画笔</span><br>        <span class="hljs-comment">//设置图片背景色</span><br>        graphics.setColor(Color.white);<br>        graphics.fillRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">80</span>,<span class="hljs-number">20</span>);<br>        <span class="hljs-comment">//给图片画东西(写入数据)</span><br>        graphics.setColor(Color.BLUE);<br>        graphics.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-literal">null</span>,Font.BOLD,<span class="hljs-number">20</span>));<br>        graphics.drawString(getNum(),<span class="hljs-number">0</span>,<span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">//通知浏览器  对应的打开方式</span><br>        resp.setContentType(<span class="hljs-string">&quot;image/jpeg&quot;</span>);<br>        <span class="hljs-comment">//取消网站的缓存</span><br>        resp.setDateHeader(<span class="hljs-string">&quot;expires&quot;</span>,-<span class="hljs-number">1</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br>        resp.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>,<span class="hljs-string">&quot;no-cache&quot;</span>);<br><br>        <span class="hljs-comment">//图片传给浏览器</span><br>        ImageIO.write(image,<span class="hljs-string">&quot;jpg&quot;</span>,resp.getOutputStream());<br>    &#125;<br>    <span class="hljs-comment">//取得随机数</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getNum</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">9999999</span>)+<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">7</span>-num.length();i++)&#123;<br>            sb.append(<span class="hljs-string">&quot;0&quot;</span>);<br>        &#125;<br>        num = sb.toString()+num;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、Request对象及其应用"><a href="#三、Request对象及其应用" class="headerlink" title="三、Request对象及其应用"></a>三、Request对象及其应用</h2><p>request是service()方法中的一个参数，在客户端发出请求时，服务器创建一个request对象并将请求数据封装到request中，然后调用service()方法传递。浏览器的信息都会封装在request中</p><p>request作用：获取请求头、请求参数；域对象功能；请求转发和包含</p><h3 id="1、作为域对象使用"><a href="#1、作为域对象使用" class="headerlink" title="1、作为域对象使用"></a>1、作为域对象使用</h3><p>相比较于ServletContext这种对应整个应用的域对象，request则是指一个请求对应的域对象。它是一个map结构，实现存值取值操作。常用的方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">req.getAttribute(String name);<br>req.setAttribute(String name);<br>req.removeAttribute(String name);<br>req.getAttributeName();<br></code></pre></td></tr></table></figure><p>编写代码如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;body&gt;<br>&lt;h2&gt;Hello World!&lt;/h2&gt;<br><br>&lt;%--这里提交的路径，应该是后面跳转的项目的目标路径--%&gt;<br>&lt;%--$&#123;pageContext.request.contextPath&#125;代表当前项目--%&gt;<br>&lt;form action=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/requestServlet&quot;</span> method=<span class="hljs-string">&quot;get&quot;</span>&gt;<br>    用户名：&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;user&quot;</span>&gt;&lt;br&gt;<br>    密码：&lt;input type=<span class="hljs-string">&quot;password&quot;</span> name=<span class="hljs-string">&quot;pwd&quot;</span>&gt;&lt;br&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span>&gt;<br>&lt;/form&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>通过get方式提交数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">requestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pwd</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;pwd&quot;</span>);<br><br>        System.out.println(user+<span class="hljs-string">&quot;: &quot;</span>+pwd);<br><br>        resp.sendRedirect(<span class="hljs-string">&quot;/s1/redirectSuccess.jsp&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到提交之后实现跳转数据提交成功</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201110163603437.png" alt="image-20201110163603437"></p><p><img src="http://img2.salute61.top/PicGo/image-20201110163619759.png" alt="image-20201110163619759"></p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201110163651619.png" alt="image-20201110163651619"></p><h3 id="2、实现转发"><a href="#2、实现转发" class="headerlink" title="2、实现转发"></a>2、实现转发</h3><p>response的sendRedirect可以实现重定向，在request中也有实现页面跳转的功能，在之前的ServletContext部分就说明过，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">reqDisp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//获取跳转对象</span><br>        <span class="hljs-type">RequestDispatcher</span> <span class="hljs-variable">dispatcher</span> <span class="hljs-operator">=</span> req.getRequestDispatcher(<span class="hljs-string">&quot;/reqDispFile.jsp&quot;</span>);<br>        <span class="hljs-comment">//调用跳转对象的forward功能</span><br>        dispatcher.forward(req,resp);<br>        System.out.println(<span class="hljs-string">&quot;request测试Dispatch!!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPut</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问<code>http://localhost:8080/s1/reqDisp</code>进入到了<code>reqDispFile.jsp</code>页面中，说明跳转成功了！</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201110164625504.png" alt="image-20201110164625504"></p><p>由于request也是域对象，因此它也可以实现数据的传递，只不过request的域只代表当前一次请求</p><p>分别编写两个类用于数据传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">reqDispData</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        req.setAttribute(<span class="hljs-string">&quot;usrname&quot;</span>,<span class="hljs-string">&quot;zhangSan&quot;</span>);<br><br><br>        <span class="hljs-comment">//获取跳转对象</span><br>        <span class="hljs-type">RequestDispatcher</span> <span class="hljs-variable">dispatcher</span> <span class="hljs-operator">=</span> req.getRequestDispatcher(<span class="hljs-string">&quot;/reqDispData2&quot;</span>);<br>        <span class="hljs-comment">//调用跳转对象的forward功能</span><br>        dispatcher.forward(req,resp);<br>        System.out.println(<span class="hljs-string">&quot;request测试Dispatch!!!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">reqDispData2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">usrname</span> <span class="hljs-operator">=</span> (String) req.getAttribute(<span class="hljs-string">&quot;usrname&quot;</span>);<br>        resp.getWriter().write(<span class="hljs-string">&quot;通过request获取的name是：&quot;</span>+usrname);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先直接访问Data2是显示为null的，表示没有数据传过去；然后进入Data，他会设置属性值并且页面跳转到Data2的页面中，显示出名字zhangsan</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201110165553251.png" alt="image-20201110165553251"></p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201110165612755.png" alt="image-20201110165612755"></p><h3 id="3、request实现防盗链"><a href="#3、request实现防盗链" class="headerlink" title="3、request实现防盗链"></a>3、request实现防盗链</h3><p>编写代码如下：利用Referer标头实现防盗链功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">reqFDL</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><br>        <span class="hljs-comment">//获取请求是从哪儿来的</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">referer</span> <span class="hljs-operator">=</span> req.getHeader(<span class="hljs-string">&quot;Referer&quot;</span>);<br>        <span class="hljs-comment">//直接输入的网址 || 不是本网站的重定向</span><br>        <span class="hljs-keyword">if</span> (referer==<span class="hljs-literal">null</span>|| !referer.startsWith(<span class="hljs-string">&quot;http://localhost&quot;</span>))&#123;<br>            <span class="hljs-comment">//回到首页</span><br>            resp.sendRedirect(<span class="hljs-string">&quot;/FDL.jsp&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//首页点击进入的，正常显示</span><br>        resp.getWriter().write(<span class="hljs-string">&quot;从我的网站中进入到此页面的！可以访问！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改首页提交按钮的跳转，在首页点击提交后可以跳转到目标页面reqFDL中，但是直接访问<code>http://localhost:8080/s1/reqFDL</code>就会跳转到FDL.jsp页面中，不能看到目标页面。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201110171516766.png" alt="image-20201110171516766"></p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201110171530650.png" alt="image-20201110171530650"></p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201110172022252.png" alt="image-20201110172022252"></p><p>Referer的作用一个是防盗链，只允许自己的网站访问我的资源服务器。Referer作用是指示它从哪儿链接过来，如果为空表示它是直接输入地址访问的</p><h2 id="请求转发和重定向的区别"><a href="#请求转发和重定向的区别" class="headerlink" title="请求转发和重定向的区别"></a>请求转发和重定向的区别</h2><p><strong>重定向：</strong>客户端发送一次请求后，服务器给予响应，这个响应是下一次客户端要访问的地址，于是客户端再次发起请求，然后得到响应，获取想要的数据。即客户端最少要发起两次请求</p><p><strong>请求转发：</strong>客户端发送一次请求后，请求在服务器端进行传递，客户端仅仅发送了一次请求</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201110180947603.png" alt="image-20201110180947603"></p><p>他们的区别：</p><ol><li>转发是在服务器端发生的；重定向是在浏览器端发生的</li><li>请求次数不同：重定向最少要发送两次、转发只会发送一次</li><li>转发时浏览器的地址栏不会变化【即这个操作对浏览器是透明的】；重定向时地址栏会发生改变</li><li>重定向时，我们写的资源地址是：<code>resp.sendRedirect(URL地址)</code>；转发时我们写的地址是：<code>req.getRequestDispatcher(URL地址).forward(request, response)</code>。</li><li>重定向是跳转，可以到任何资源地址下，即实现跨域访问；转发要求还是在当前web应用下的资源</li></ol><p>使用场景：</p><p>重定向没有转发快，因为它要再次经过客户端</p><ul><li>对于跨域的访问，要跳转到外部网站，可以使用重定向</li><li>转发的request可以传递不同类型数据，因此在有数据传输的任务下可以考虑转发</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java自动装拆箱</title>
    <link href="/20201109/d443007a/"/>
    <url>/20201109/d443007a/</url>
    
    <content type="html"><![CDATA[<h2 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h2><p>Java有四种八类基本数据类型，除此之外其他的都是对象即引用类型。JDK1.5后为基本数据类型引入了对应的包装类</p><p><strong>1.1 基本数据类型可以分为：</strong></p><ul><li>整数类型：byte、short、int、long</li><li>浮点数型：float、double</li><li>字符类型：char</li><li>布尔类型：boolean</li></ul><p>【注】Java中数据类型不存在无符号的，即他们的取值范围是固定的</p><span id="more"></span><p><strong>1.2 为什么int的范围是[-2,147,483,648 , 2,147,483,647]？</strong></p><p>先说一个字节<code>byte</code>的范围：一个字节8位，最高位表示正负号，所以实际是**[10000000，01111111]<strong>。即</strong>[-2<sup>^</sup>7，2<sup>^</sup>7-1]**</p><p><code>int</code>：是4字节32位，然后最高位0、1表示正负号，所以实际是31位数据，即**[-2<sup>^31</sup>，2<sup>^31</sup>-1]<strong>。所以得到的结果是</strong>[-2,147,483,648 , 2,147,483,647]**。同理其他的数据类型也是</p><p><strong>1.3 基本数据类型的作用</strong>：</p><p>在Java中new的对象是存储在堆中的，我们使用都是通过栈中的引用来操作，对于这种常用的数据类型还要每个都去new就很麻烦且浪费资源，所以Java和C++一样提供这些基本数据类型，它们的变量不会在堆上创建，而是直接在栈内存中存储，因此更加高效。</p><h2 id="2、包装类型"><a href="#2、包装类型" class="headerlink" title="2、包装类型"></a>2、包装类型</h2><table><thead><tr><th>数据类型</th><th>默认值</th><th>存储格式</th><th>数据范围</th><th>包装类型</th></tr></thead><tbody><tr><td>short</td><td>0</td><td>2 个字节</td><td>-32,768 到 32,767</td><td>Short</td></tr><tr><td>int</td><td>0</td><td>4 个字节</td><td>-2,147,483,648 到 2,147,483,647</td><td>Integer</td></tr><tr><td>byte</td><td>0</td><td>1 个字节</td><td>-128 到 127</td><td>Byte</td></tr><tr><td>char</td><td>空</td><td>2 个字节</td><td>Unicode 的字符范围：<code>\u0000</code>（即为 0）到 <code>\uffff</code>（即为 65,535）</td><td>Character</td></tr><tr><td>long</td><td>0L 或 0l</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td>Long</td></tr><tr><td>float</td><td>0.0F 或 0.0f</td><td>4 个字节</td><td>32 位 IEEEE-754 单精度范围</td><td>Float</td></tr><tr><td>double</td><td>0.0 或 0.0D(d)</td><td>8 个字节</td><td>64 位 IEEE-754 双精度范围</td><td>Double</td></tr><tr><td>boolean</td><td>false</td><td>1 位</td><td>true 或 false</td><td>Boolean</td></tr></tbody></table><p><strong>2.1 自动拆箱与装箱</strong></p><p>简单说，装箱就是自动将基本数据类型转化为对应的包装类，拆箱就是自动将包装类转化为基本数据类型。</p><p><strong>2.2为什么要这样做</strong></p><ul><li>因为Java是面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是Object类型。</li><li>为泛型提供支持。因为泛型默认是Object类型</li><li>更多的属性和方法。让基本类型有了对象的特性，为其添加属性和方法，丰富了基本类型的操作</li></ul><p><strong>2.3 实现原理</strong></p><p>编写代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">autoboxing</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">totalPac</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalNum</span> <span class="hljs-operator">=</span> totalPac;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译之后，用指令<code>javap -c autoboxing</code>反编译字节码文件得到如下代码：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201109174638916.png" alt="image-20201109174638916"></p><p>在执行上面的代码时，系统实际执行的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">totalPac</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-comment">//对应👇</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">totalPac</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">totalNum</span> <span class="hljs-operator">=</span> totalPac;<br><span class="hljs-comment">//对应👇</span><br><span class="hljs-type">int</span> <span class="hljs-variable">totalNum</span> <span class="hljs-operator">=</span> totalPac.intValue();<br></code></pre></td></tr></table></figure><blockquote><p>自动装箱采用的都是valueOf()方法实现，拆箱都是通过包装类对象的对应xxValue()方法实现</p><p>当然不同包装类的方法会有所不同，其中Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的；Double、Float的valueOf方法的实现是直接返回新建对象。</p></blockquote><ul><li><p>查看<code>valueOf</code>源码</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>可以把low和high理解为Integer的边界：如果<code>i</code>大于127或小于-128就创建一个Integer对象返回；否则就执行<code>cache[i+ (-IntegerCache.low)]</code>；<code>cache</code>是<code>IntegerCache</code>类的一个Integer类型final数组对象，即<code>valueOf()</code>返回的都是Integer对象。所以装箱会创建对应的对象，消耗内存。cache用于缓存。</p></li><li><p>再看<code>intValue</code>源码</p><p>就是返回Integer对象的value属性值。【<code>Integer</code>对象有属性：<code>private final int value;</code>】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">intValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>cache缓存</strong></p><p>当需要进行自动装箱时，创建对象之前先从<code>IntegerCache.cache</code>中寻找，如果数字在-128至127之间时，会直接使用缓存中的对象，而不是重新创建一个对象。如果没找到才使用new新建对象。</p><p>所以如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>System.out.println(num1==num2);<span class="hljs-comment">//true</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">num3</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">num4</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>System.out.println(num3==num4);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>具体代码实现可以看源码<code>IntegerCache</code>部分</p></li></ul><h2 id="3、拆装箱的应用场景"><a href="#3、拆装箱的应用场景" class="headerlink" title="3、拆装箱的应用场景"></a>3、拆装箱的应用场景</h2><ul><li><p><strong>&lt;1&gt;数据类型的比较</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>System.out.println(num==<span class="hljs-number">100</span>? <span class="hljs-string">&quot;yes!&quot;</span>:<span class="hljs-string">&quot;no!&quot;</span>);<br></code></pre></td></tr></table></figure><p>实际上比较的是<code>num.valueOf()</code></p></li><li><p><strong>&lt;2&gt;集合类保存基本数据类型</strong></p><p>在Java中集合类只能接收对象类型，但是我们总是直接往ArrayList中直接add整数，因为系统已经自动为我们转换了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">autoboxing</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;++i)&#123;<br>            list.add(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201109180630089.png" alt="image-20201109180630089"></p></li><li><p><strong>&lt;3&gt;包装类的运算</strong></p><p>对于包装类，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">num1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>System.out.println(num1+num2);<br></code></pre></td></tr></table></figure><p>Integer对象是不能直接运算的，但是这样运行也可以，因为默认会变成<code>num1.intValue() + num2.intValue()</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet学习二-ServletContext及应用、ServletConfig</title>
    <link href="/20201105/a72fbeb3/"/>
    <url>/20201105/a72fbeb3/</url>
    
    <content type="html"><![CDATA[<h2 id="Servlet映射"><a href="#Servlet映射" class="headerlink" title="Servlet映射"></a>Servlet映射</h2><h3 id="Servlet中的Mapping"><a href="#Servlet中的Mapping" class="headerlink" title="Servlet中的Mapping"></a>Servlet中的Mapping</h3><p>1、一个servlet可以映射到多个URL上</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--servlet注册--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.liu.servlet.helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-comment">&lt;!--servlet请求路径--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/helloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201108182924215.png" alt="image-20201108182924215" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201108183004543.png" alt="image-20201108183004543" style="zoom:80%;" /><p>通过<code>http://localhost:8080/s1/helloServlet2</code>和<code>http://localhost:8080/s1/helloServlet</code>访问到的实际上是同一个Servlte对象</p><span id="more"></span><h3 id="Servlet的通配符"><a href="#Servlet的通配符" class="headerlink" title="Servlet的通配符"></a>Servlet的通配符</h3><p>通配符有两种</p><ul><li><p><code>*.xxx</code>  –&gt;匹配所有以xxx为拓展名的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.liu.servlet.helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>/</code>开头并以<code>/*</code>结尾  –&gt;匹配已注册的Servlet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.liu.servlet.helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/helloServlet2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>优先级问题</strong></p><p>对于不同情况同时出现，看谁的匹配度高就选择谁；<code>*.xxx</code>的优先级是最低的</p><h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><p>ServletContext对象叫做Servlet上下文，是在Tomcat启动时创建的，也叫域对象，我们的一个web对象对应一个ServletContext，它的作用范围是整个应用。它包含了所有Servlet共享的资源信息，通过一组方法来给servlet使用、用来和servlet容器通讯</p><p>常用作用：</p><ol><li>获取当前工程目录的资源；</li><li>读取全局配置参数；</li><li>servlet通过servletContext实现通讯；</li><li>实现servlet的请求转发</li></ol><h3 id="servlet之间的通讯实现"><a href="#servlet之间的通讯实现" class="headerlink" title="servlet之间的通讯实现"></a>servlet之间的通讯实现</h3><p>创建两个类putName和getName，编写对应的方法，通过ServletContext传递要通讯的数据，使用<code>setAttribute</code>放入数据、<code>getAttribute</code>获取，然后注册对应的servlet，验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">putName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;刘义&quot;</span>;<br>        servletContext.setAttribute(<span class="hljs-string">&quot;username&quot;</span>,name);<br><br>        resp.getWriter().print(<span class="hljs-string">&quot;已传数据至ServletContext&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">getName</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) servletContext.getAttribute(<span class="hljs-string">&quot;username&quot;</span>);<br><br>        resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        resp.getWriter().print(<span class="hljs-string">&quot;名字：&quot;</span>+name);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本模型如下：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201108185340531.png" alt="image-20201108185340531" style="zoom:80%;" /><p>可以看到，先访问<code>http://localhost:8080/s1/get</code>名字是null，然后访问&#x2F;put后再回到&#x2F;get就可以看到我们的数据了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201108185725891.png" alt="image-20201108185725891" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201108190653423.png" alt="image-20201108190653423" style="zoom:80%;" /><p><img src="http://img2.salute61.top/PicGo/image-20201108185848198.png" alt="image-20201108185848198"></p><p>servletContext存储数据特点：<strong>全局共享</strong>，里面的数据所有动态资源都可以写入和获取；服务器启动的时候创建，服务器关闭的时候销毁，因为这是全局应用程序对象，全局共享对象。</p><h3 id="获取全局配置参数"><a href="#获取全局配置参数" class="headerlink" title="获取全局配置参数"></a>获取全局配置参数</h3><p>要想让所有的servlet都获取数据库的信息，不可能一个个的在web.xml中配置，可以直接使用<code>&lt;context-param&gt;</code>配置使得整个web应用的servlet都可以读取到</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><code>getInitParameter(name);</code>–&gt;根据指定的参数名获取参数值</li><li><code>getInitParameterNames();</code>&#x2F;&#x2F;获取所有参数名称列表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">contextDemo2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br><br>        resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>        resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> context.getInitParameter(<span class="hljs-string">&quot;url&quot;</span>);<br>        resp.getWriter().print(<span class="hljs-string">&quot;获取web.xml中的URL：&quot;</span>+url);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201108194424768.png" alt="image-20201108194424768" style="zoom:80%;" /><h3 id="读取资源文件"><a href="#读取资源文件" class="headerlink" title="读取资源文件"></a>读取资源文件</h3><p>这里可以尝试一下Response下载文件，在resource目录下加入一张图片，然后编写FileServlet类，获取工程目录下的资源文件。一开始我们不知道对应的目录在哪儿，可以用<code>getContextPath()</code>拿到当前的上下文context路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//1、获取下载文件的路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">realPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;G:\\Kuang_JavaWeb\\servlet-01\\src\\main\\webapp\\resources\\leslie.jpg&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;下载路径：&quot;</span>+realPath);<br>        <span class="hljs-comment">//2、下载的文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> realPath.substring(realPath.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>)+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//3、设置浏览器支持下载（）</span><br>        resp.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>,<span class="hljs-string">&quot;attachment; &quot;</span>+<span class="hljs-string">&quot;filename: &quot;</span>+fileName);<br>        <span class="hljs-comment">//4、获取下载文件的输入流</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(realPath);<br>        <span class="hljs-comment">//5、创建缓冲区</span><br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">//6、获取OutputStream对象</span><br>        <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br>        <span class="hljs-comment">//7、将FileOutputStream写入Buffer缓冲区</span><br>        <span class="hljs-keyword">while</span> ((len=in.read(buffer))&gt;<span class="hljs-number">0</span>)&#123;<br>            out.write(buffer,<span class="hljs-number">0</span>,len);<br>        &#125;<br><br>        <span class="hljs-comment">//关闭流</span><br>        in.close();<br>        out.close();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201108192023201.png" alt="image-20201108192023201"></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/fileD.jpg.jpeg" style="zoom:50%;" /><p>可以看到成功下载了！</p><p>上面的路径写死了为绝对路径，如果资源改变了目录那我们又要去改代码，这种情况下就可以用servletContext来做，因为servlet编译后文件应该是放在WEB-INF&#x2F;classes目录下的，所以可以用servletContext下的getResourceAsStream()方法传递上述目录为参数实现</p><h3 id="实现servlet的请求转发"><a href="#实现servlet的请求转发" class="headerlink" title="实现servlet的请求转发"></a>实现servlet的请求转发</h3><p>先建一个类，编写对应的代码如下：这里用到的就是servletContext的getRequestDispatcher方法，参数就是要转发的页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">contextDemo03</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br><br>        <span class="hljs-comment">//请求转发  </span><br>        <span class="hljs-type">RequestDispatcher</span> <span class="hljs-variable">dispatcher</span> <span class="hljs-operator">=</span> context.getRequestDispatcher(<span class="hljs-string">&quot;/get&quot;</span>);<br>        dispatcher.forward(req,resp);<br><br>        System.out.println(<span class="hljs-string">&quot;进入了Servlet测试Dispatch中&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">super</span>.doPost(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201108192914059.png" alt="image-20201108192914059" style="zoom:80%;" /><p>可以看到：网址访问的是<code>http://localhost:8080/s1/disp</code>但是我们进入的是之前的&#x2F;get的页面！按下F12在控制台中可以看到状态码变化。也可以通过程序输出语句检测它是否确实进入了contextDemo03中，可以在控制台中看到对应的语句输出！</p><h2 id="ServletConfig对象"><a href="#ServletConfig对象" class="headerlink" title="ServletConfig对象"></a>ServletConfig对象</h2><p>通过ServletConfig对象我们可以读取到web.xml中配置的初始化参数；也可以在一开始配置初始化参数，通过<code>&lt;init-param&gt;</code>去实现</p><p>通过配置web.xml对servlet统一管理，实现简化开发的目的</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet学习一-Servlet入门</title>
    <link href="/20201104/e7515609/"/>
    <url>/20201104/e7515609/</url>
    
    <content type="html"><![CDATA[<h2 id="Servlet简介"><a href="#Servlet简介" class="headerlink" title="Servlet简介"></a>Servlet简介</h2><p>Java Servlet 是运行在 <strong>Web 服务器或应用服务器上</strong>的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201104160436506.png" alt="Servlet架构"></p><p>作用：处理浏览器带来的HTTP请求，并返回一个响应给浏览器，从而实现浏览器和服务器的交互</p><p>开发步骤：</p><ol><li>编写一个Servlet程序</li><li>部署到Web服务器</li></ol><p>【注】：我们一般将Servlet部署在如Tomcat之类的服务器上，关于Tomcat的介绍，可以看之前的博客：<a href="http://salute61.top/2020/07/05/Tomcat%E5%AD%A6%E4%B9%A0/">Tomcat学习</a></p><span id="more"></span><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>1、新建一个maven项目，然后删除原来的项目结构（即原来的src目录），在主项目的pom.xml中导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、创建modules，勾选Create from archetype，选择webapp创建</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201104162246668.png" alt="image-20201104162246668" style="zoom:80%;" /><h2 id="Servlet程序编写"><a href="#Servlet程序编写" class="headerlink" title="Servlet程序编写"></a>Servlet程序编写</h2><p>1、在上面创建的Servlet modules的webapp目录下新建Java和resources目录并标记，编写helloServlet类继承httpServlet并重写doGet和doPost方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">helloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-comment">//由于get和post只是请求的不同方式，因此可以互相调用，对应逻辑相同</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;进入doGet！&quot;</span>);<br>        <br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> resp.getWriter();<br>        writer.print(<span class="hljs-string">&quot;helloServlet&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;进入post！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在web.xml中配置，使得浏览器发出的请求能到达对应的Servlet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">                         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span></span><br><span class="hljs-tag">         &gt;</span><br><br>    <span class="hljs-comment">&lt;!--servlet注册--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.liu.servlet.helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--servlet请求路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/helloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>3、IDEA中配置Tomcat</p><ul><li><p>在右上角Run–Edit Configuration</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201104164343123.png" alt="image-20201104164343123" style="zoom:80%;" /></li><li><p>在Server右侧的Configure…找到本地的Tomcat服务器，查看JRE版本和项目要保持一致、在上面的Deployment中点击+号找到我们的Servlet项目，添加Application context路径，启动访问</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201104165240454.png" alt="image-20201104165240454"></p></li></ul><p>【注】：启动的时候报错<code>Error:java: Compilation failed: internal java compiler error</code>，应该是项目的JDK版本设置不一致，在Project Structure–&gt;Project和Setting–Java Complier中将JDK版本都设为一致的即可！</p><h3 id="浏览器通过配置定位到对应Servlet的步骤"><a href="#浏览器通过配置定位到对应Servlet的步骤" class="headerlink" title="浏览器通过配置定位到对应Servlet的步骤"></a><strong>浏览器通过配置定位到对应Servlet的步骤</strong></h3><ul><li>首先浏览器通过<a href="http://localhost:8080/s1%E6%89%BE%E5%88%B0web.xml%E4%B8%AD%E7%9A%84%60">http://localhost:8080/s1找到web.xml中的`</a><url-pattern>&#96;；</li><li>匹配到url-pattern后找到Servlet的名字helloServlet</li><li>helloServlet对应的路径为<code>com.liu.servlet.helloServlet</code>，获取到对应的doGet和doPost方法</li></ul><h2 id="Servlet创建方式"><a href="#Servlet创建方式" class="headerlink" title="Servlet创建方式"></a>Servlet创建方式</h2><p>Servlet常见的创建方式有三种，我们用的继承HTTPServlet就属于其中一种，查看HttpServlet类图如下：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/HttpServlet.png" alt="HttpServlet" style="zoom:80%;" /><p>上面已经展示了继承HttpServlet类实现，还有另外两种继承GenericServlet和实现Servlet方式。</p><p>GenericServlet类继承了Servlet接口，主要作用就是实现了Servlet接口中的方法，简化了编写Servlet步骤</p><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>1、创建一个类，实现Servlet接口</p><ul><li>ctrl+o可以看到有5个方法需要重写：init【初始化】、getServletConfig【获取Servlet配置】、service【服务】、getServletInfo【获取Servlet服务信息】、destroy【销毁服务】</li><li>可以猜到service中应该是对应的服务代码，在service中编写代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testServlet</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Servlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title function_">getServletConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        res.getWriter().write(<span class="hljs-string">&quot;helloWorld!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServletInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、配置web.xml文件，部署到Tomcat中，键入<a href="http://localhost:8080/s1/testServlet%E8%AE%BF%E9%97%AE">http://localhost:8080/s1/testServlet访问</a></p><ul><li><p>可以发现，第一次访问时init方法和service方法被执行，后续再进入&#x2F;testServlet只会执行service方法</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201104172052959.png" alt="image-20201104172052959" style="zoom:80%;" /></li><li><p>关闭tomcat服务器，destroy方法被调用了</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201104172155166.png" alt="image-20201104172155166" style="zoom:80%;" /></li></ul><p><strong>Servlet生命周期：</strong></p><ol><li>加载Servlet。Tomcat第一次访问Servlet时，<strong>会由Tomcat负责创建Servlet的实例</strong></li><li>初始化。Servlet实例被初始化后，在访问时，Tomcat会调用init()方法初始化对象（仅执行一次）</li><li>处理服务。浏览器每次访问Servlet时都会调用service()方法处理请求服务</li><li>销毁。Tomcat关闭时要删除相关的Servlet，会自动调用destroy()方法，释放所占的资源</li></ol><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201104174537836.png" alt="image-20201104174537836" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习六-整合Mybatis</title>
    <link href="/20201019/349c2981/"/>
    <url>/20201019/349c2981/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Mybatis属实良心，对于在spring中整合mybatis，同样有官方文档可以参考。</p><p>【参】<a href="https://mybatis.org/spring/zh/index.html">Mybatis-Spring文档</a></p><blockquote><p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 <code>SqlSession</code> 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 <code>DataAccessException</code>。最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring。</p></blockquote><p>当然，整合的前提是要先熟悉Mybatis和Spring了。对应版本也要注意：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223646936.png" alt="image-20230420223646936" style="zoom:80%;" /><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1、首先要导入相关依赖，参照之前的Spring module来导入，再加上特有的包</p><p><code>mysql-connector-java</code>、<code>mybatis</code>、<code>spring-webmvc</code>、<code>spring-jdbc</code>、<code>aspectjweaver</code>、**<code>mybatis-spring</code>**、<code>lombok</code> 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Spring操作数据库还需要SpringJDBC--&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、编写配置文件</p><p>（1）编写pojo实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String pwd;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）Mybatis的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.liu10.pojo.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;User&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--有了Spring整合后，其实完全可以不用MybatisConfig.xml文件，它已经被Spring的数据源替代了--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;leslie61&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/liu10/mapper/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）User接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    List&lt;User&gt; <span class="hljs-title function_">selectUser</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）接口对应的mapper映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.liu10.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>        select * from mybatis.user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试类</p><p>3、编写测试代码</p><h2 id="回顾Mybatis"><a href="#回顾Mybatis" class="headerlink" title="回顾Mybatis"></a>回顾Mybatis</h2><p>先回顾Mybatis，参照Mybatis的方式去实现一遍，然后再用Spring去重构代码</p><p>（1）编写pojo实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String pwd;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）Mybatis的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.liu10.pojo.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;User&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br><br>    有了Spring整合后，其实完全可以不用MybatisConfig.xml文件，它已经被Spring的数据源替代了<br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;leslie61&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/liu10/mapper/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（3）User接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    List&lt;User&gt; <span class="hljs-title function_">selectUser</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（4）接口对应的mapper映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.liu10.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>        select * from mybatis.user;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（5）测试类</p><p>【注】这里同样使用了之前Mybatis的工具类MybatisUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> ***;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/10/3 14:31</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        List&lt;User&gt; userList = mapper.selectUser();<br>        <span class="hljs-keyword">for</span> (User user : userList) &#123;<br>            System.out.println(user);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Spring整合"><a href="#Spring整合" class="headerlink" title="Spring整合"></a>Spring整合</h2><p>以官方文档的入门为讲解，应该没有比它更权威更官方的了😂，而且示例代码+文字讲解还是很容易理解的。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>要使用 MyBatis-Spring 模块，只需要在类路径下包含 <code>mybatis-spring-2.0.5.jar</code> 文件和相关依赖即可。</p><p>如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 <code>SqlSessionFactory</code> 和至少一个数据映射器类。</p><p>在 MyBatis-Spring 中，可使用 <code>SqlSessionFactoryBean</code>来创建 <code>SqlSessionFactory</code>。 要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">sqlSessionFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-type">SqlSessionFactoryBean</span> <span class="hljs-variable">factoryBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBean</span>();<br>  factoryBean.setDataSource(dataSource());<br>  <span class="hljs-keyword">return</span> factoryBean.getObject();<br>&#125;<br></code></pre></td></tr></table></figure><p>【注意】：<code>SqlSessionFactory</code> 需要一个 <code>DataSource</code>（数据源）。 这可以是任意的 <code>DataSource</code>，只需要和配置其它 Spring 数据库连接一样配置它就可以了。</p><p>假设你定义了一个如下的 mapper 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>  <span class="hljs-meta">@Select(&quot;SELECT * FROM users WHERE id = #&#123;userId&#125;&quot;)</span><br>  User <span class="hljs-title function_">getUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userId&quot;)</span> String userId)</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>那么可以通过 <code>MapperFactoryBean</code> 将接口加入到 Spring 中:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperInterface&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.mybatis.spring.sample.mapper.UserMapper&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意的是：所指定的映射器类<strong>必须</strong>是一个接口，而不是具体的实现类。在这个示例中，通过注解来指定 SQL 语句，但是也可以使用 MyBatis 映射器的 XML 配置文件。</p><p>配置好之后，你就可以像 Spring 中普通的 bean 注入方法那样，将映射器注入到你的业务或服务对象中。<code>MapperFactoryBean</code> 将会负责 <code>SqlSession</code> 的创建和关闭。如果使用了 Spring 的事务功能，那么当事务完成时，session 将会被提交或回滚。最终任何异常都会被转换成 Spring 的 <code>DataAccessException</code> 异常。</p><p>使用 Java 代码来配置的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> UserMapper <span class="hljs-title function_">userMapper</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-type">SqlSessionTemplate</span> <span class="hljs-variable">sqlSessionTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionTemplate</span>(sqlSessionFactory());<br>  <span class="hljs-keyword">return</span> sqlSessionTemplate.getMapper(UserMapper.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>要调用 MyBatis 的数据方法，只需一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FooServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FooService</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserMapper userMapper;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FooServiceImpl</span><span class="hljs-params">(UserMapper userMapper)</span> &#123;<br>    <span class="hljs-built_in">this</span>.userMapper = userMapper;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> User <span class="hljs-title function_">doSomeBusinessStuff</span><span class="hljs-params">(String userId)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.userMapper.getUser(userId);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="整合操作"><a href="#整合操作" class="headerlink" title="整合操作"></a>整合操作</h3><p>官方文档在关于Spring操作SqlSession部分有以下介绍：</p><blockquote><p>在 MyBatis 中，你可以使用 <code>SqlSessionFactory</code> 来创建 <code>SqlSession</code>。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。使用 MyBatis-Spring 之后，你不再需要直接使用 <code>SqlSessionFactory</code> 了，因为你的 bean 可以被注入一个线程安全的 <code>SqlSession</code>，它能基于 Spring 的事务配置来自动提交、回滚、关闭 session。</p></blockquote><p>有两种形式：</p><ul><li>使用<code>SqlSessionTemplate</code></li><li>使用<code>SqlSessionDaoSupport</code></li></ul><p>1、引入Spring配置文件beans.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、将数据源替换成我们的Mybatis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;</span><br><span class="hljs-comment">&lt;!--下面创建 SqlSessionFactory所需的dataSource</span><br><span class="hljs-comment">        Datasource：使用Spring的数据源替换Mybatis的配置，我们使用的就是基础的JDBC</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;leslie61&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、配置SqlSessionFactory并关联Mybatis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置SqlSessionFactory--&gt;</span><br><span class="hljs-comment">&lt;!--SqlSessionFactory不需要再像之前Mybatis中那样创建</span><br><span class="hljs-comment">        官网文档指出————使用 SqlSessionFactoryBean 来创建 SqlSessionFactory</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--绑定Mybatis配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:MybatisConfig.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:com/liu10/mapper/UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4、注册sqlSessionTemplate，关联sqlSessionFactory</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--SqlSessionTemplate就是我们Mybatis中的SqlSession--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--因为他没有SqlSession的set方法，所以只能通过构造器注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>5、增加Dao接口实现类，并私有化SqlSessionTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserMapper</span> &#123;<br><br>    <span class="hljs-comment">//之前：我们的所有操作，都要使用SqlSession执行</span><br>    <span class="hljs-comment">//现在：都用SqlSessionTemplate实现</span><br>    <span class="hljs-keyword">private</span> SqlSessionTemplate sqlSession;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSqlSession</span><span class="hljs-params">(SqlSessionTemplate sqlSession)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sqlSession = sqlSession;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">selectUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-keyword">return</span> mapper.selectUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6、注册bean对象实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--将接口的实现类注册到Spring中--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu10.mapper.UserMapperImpl&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapperImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSession&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>7、测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSpring</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;userMapperImpl&quot;</span>, UserMapper.class);<br>    List&lt;User&gt; userList = mapper.selectUser();<br>    <span class="hljs-keyword">for</span> (User user : userList) &#123;<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看看官方文档关于<code>SqlSessionDaoSupport</code>的介绍</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223713319.png" alt="image-20230420223713319" style="zoom:80%;" /><p>具体操作与上面其实类似，可以自己尝试一下</p><p>相比之前Mybatis操作，现在最大的区别就是对于SqlSession我们不再需要自己去通过SqlSessionFactory创建了，而是交由bean管理，Mybatis的配置文件也完全可以不用了，通过整合在Spring配置中即可</p><p>【优化一下】：将上面的Spring配置文件分成两个</p><ul><li><code>SpringDao.xml</code>专注于数据库的操作，可以将数据库的配置专门放在SpringDao.xml中，将其写死即可</li><li><code>applicationContext</code>专注于实现类的注册等，数据库的部分放在SpringDao即可</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--SpringDao专注于数据库操作即可，可以将数据库的配置专门放在SpringDao.xml中，将其写死即可--&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--下面创建 SqlSessionFactory所需的dataSource</span><br><span class="hljs-comment">        Datasource：使用Spring的数据源替换Mybatis的配置，我们使用的就是基础的JDBC</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;leslie61&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--SqlSessionFactory不需要再像之前Mybatis中那样创建</span><br><span class="hljs-comment">        官网文档指出————使用 SqlSessionFactoryBean 来创建 SqlSessionFactory</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!--绑定Mybatis配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:MybatisConfig.xml&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:com/liu10/mapper/UserMapper.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--SqlSessionTemplate就是我们Mybatis中的SqlSession--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--因为他没有SqlSession的set方法，所以只能通过构造器注入--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/aop</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--applicationContext专注于实现类的注册等，数据库的部分放在SpringDao即可--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;springDao.xml&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--将接口的实现类注册到Spring中--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu10.mapper.UserMapperImpl&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapperImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSession&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSession&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu10.mapper.UserMapperImpl2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapperImpl2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习五-AOP学习</title>
    <link href="/20201015/c4fd4ace/"/>
    <url>/20201015/c4fd4ace/</url>
    
    <content type="html"><![CDATA[<h2 id="AOP介绍"><a href="#AOP介绍" class="headerlink" title="AOP介绍"></a>AOP介绍</h2><p>AOP（Aspect Oriented Programming）面向切面编程，是针对面向对象编程的一种补充，同时也是spring中第二个最核心的功能，例如可以进行权限认证，日志输出等，可以无侵入的对原来的功能进行切面加入自定义的非业务功能。</p><p><strong>实现AOP的技术：</strong></p><ul><li>一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；</li><li>二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</li></ul><p><strong>AOP用于SpringFramwork中：</strong></p><ul><li>提供声明式企业服务。 最重要的服务是声明式事务管理。</li><li>让用户实现自定义方面，以AOP补充其对OOP的使用。</li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223518391.png" alt="image-20230420223518391" style="zoom:80%;" /><span id="more"></span><h2 id="AOP概念名词"><a href="#AOP概念名词" class="headerlink" title="AOP概念名词"></a>AOP概念名词</h2><blockquote><p>以下名词概念都是来自官方文档，按个人理解进行翻译</p></blockquote><p><strong>concepts and terminology</strong></p><ul><li>【Aspect切面】：涉及多个类别的关注点的模块化。在Spring AOP中，方面是通过使用常规类（基于模式的方法）或使用包含@Aspect注解（@AspectJ样式）的常规类来实现的。</li><li>【Join point连接点】：程序执行过程中某一个特定的点。例如方法的执行或异常的处理。Spring AOP中连接点始终代表方法的执行  </li><li>【Advice通知】：切面在特定连接点处采取的操作，即对原代码的增强功能，它分为前置、后置、异常、最终、环绕五类</li><li>【Pointcut切入点】：与连接点匹配的谓词，本质上是用于捕获连接点的结构。通知与切入点表达式关联，并在与该切入点匹配的任何连接点处运行</li><li>【Introduction引入】：在不修改类代码的前提下，为类添加新的属性和方法。例如可以试用Introduction使Bean实现IsModified接口，以简化缓存</li><li>【Target object目标对象】：被AOP框架代理增强的对象。</li><li>【AOP代理】：AOP框架创建的对象，用于对目标对象的增强。在Spring Framework中，AOP代理可以是JDK动态代理或CGLIB代理。</li><li>【Weaving织入】：将切面连接到其他应用程序类型或对象上，以创建一个被通知的对象。像其他纯Java AOP框架一样，Spring AOP在运行时执行编织。</li></ul><p>Spring中通过Advice实现横切的逻辑插入，提供了五种Advice：</p><table><thead><tr><th>类型</th><th>连接点</th><th>实现接口</th></tr></thead><tbody><tr><td>前置通知</td><td>方法前</td><td>org.springframework.aop.MethodBeforeAdvice</td></tr><tr><td>后置通知</td><td>方法后</td><td>org.springframework.aop.AfterReturningAdvice</td></tr><tr><td>环绕通知</td><td>方法前后</td><td>org.aopalliance.intercept.MethodInterceptor</td></tr><tr><td>异常抛出通知</td><td>方法抛出异常</td><td>org.springframework.aop.ThrowsAdvice</td></tr><tr><td>引介通知</td><td>类中新增方法属性</td><td></td></tr></tbody></table><h2 id="代码实现AOP"><a href="#代码实现AOP" class="headerlink" title="代码实现AOP"></a>代码实现AOP</h2><p>【注】使用AOP实现织入，要先导入<code>aspectJ</code>依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="通过Spring-API实现"><a href="#通过Spring-API实现" class="headerlink" title="通过Spring API实现"></a>通过Spring API实现</h3><p>1、编写业务类即接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;增加用户&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;删除用户&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;更新用户&quot;</span>);<br>  &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">search</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;查询用户&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、编写对应的增强类，在这儿我们写两个：一个前置一个后置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodBeforeAdvice</span> &#123;<br>    <span class="hljs-comment">//method:要执行的目标对象的方法</span><br>    <span class="hljs-comment">//objects:参数</span><br>    <span class="hljs-comment">//object o:目标对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">(Method method, Object[] objects, Object o)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(o.getClass().getName()+<span class="hljs-string">&quot;--的--&quot;</span>+method.getName()+<span class="hljs-string">&quot;--方法被执行了&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AfterLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AfterReturningAdvice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">(Object o, Method method, Object[] objects, Object o1)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了--&quot;</span>+method.getName()+<span class="hljs-string">&quot;--方法，返回结果为--&quot;</span>+o);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、最后去Spring中注册，并实现AOP切入【要导入约束】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu9.service.UserServiceImpl&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu9.log.Log&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu9.log.AfterLog&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--切入点: expression:表达式 execution:执行的位置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointCut&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.liu9.service.UserServiceImpl.*(..) )&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--执行环绕增加--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCut&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;afterLog&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointCut&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4、编写测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.liu9.service.UserService;<br><span class="hljs-keyword">import</span> com.liu9.service.UserServiceImpl;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/10/3 10:29</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;ApplicationContext.xml&quot;</span>);<br>        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> (UserService)context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>        userService.add();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223542496.png" alt="image-20230420223542496" style="zoom:80%;" /><h3 id="自定义类实现"><a href="#自定义类实现" class="headerlink" title="自定义类实现"></a>自定义类实现</h3><p>1、在上述的service和serviceImpl不变的前提下，自定义一个切入类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">diyPoint</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;&lt;-------方法执行前-------&gt;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;&lt;-------方法执行后-------&gt;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在Spring中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--方法二：自定义类--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;diy&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu9.diy.diyPoint&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--自定义切面 ref:要引用的类--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;diy&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--切入点--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;point&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.liu9.service.UserServiceImpl.*(..) )&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!--通知--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;before&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;point&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;after&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;point&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码不变，测试执行：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223557595.png" alt="image-20230420223557595" style="zoom:80%;" /><h3 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h3><p>1、编写一个由注解是实现的增强类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liu9.diy;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/10/3 11:06</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//方式三：使用注解实现AOP</span><br>    <span class="hljs-meta">@Aspect</span> <span class="hljs-comment">//标注这个类是切面</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationPoint</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(* com.liu9.service.UserServiceImpl.*(..) )&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;&lt;-------3-方法执行前-------&gt;&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@After(&quot;execution(* com.liu9.service.UserServiceImpl.*(..) )&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;&lt;-------3-方法执行后-------&gt;&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//在环绕增强中，可以给一个参数，代表我们要获取处理切入的点</span><br>    <span class="hljs-meta">@Around(&quot;execution(* com.liu9.service.UserServiceImpl.*(..) )&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;&lt;-------3-环绕前-------&gt;&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> pjp.proceed();<br>        System.out.println(<span class="hljs-string">&quot;&lt;-------3-环绕后-------&gt;&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>2、在配置文件中声明，并添加注解支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--方式三--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu9.diy.AnnotationPoint&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--开启注解支持--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>【说明】：通过aop命名空间的<code>&lt;aop:aspectj-autoproxy /&gt;</code>声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用<code>AnnotationAwareAspectJAutoProxyCreator</code>进行自动代理的创建工作，但具体实现的细节已经被<code>aop:aspectj-autoproxy /&gt;</code>隐藏起来了</p><p><code>&lt;aop:aspectj-autoproxy /&gt;</code>有一个<code>proxy-target-class</code>属性，默认为<code>false</code>，表示使用jdk动态代理织入增强，当配为<code>&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;</code>时，表示使用CGLib动态代理技术织入增强。不过即使<code>proxy-target-class</code>设置为<code>false</code>，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</p><p>3、测试</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223614454.png" alt="image-20230420223614454" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring学习四-静态/动态代理</title>
    <link href="/20201014/f994cdda/"/>
    <url>/20201014/f994cdda/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在对象中可能会有一些公共的行为，例如日志记录、权限验证等，如果每个对象都写上这些就会造成冗余。对此AOP【Aspect Oriented Programming面向切面编程】提供了一种方式：将通用的方法抽离出来并封装，定义为独立的切面，在合适的时机将其横向切入业务流程指定的位置中</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223345217.png" alt="image-20230420223345217" style="zoom:80%;" /><p>因为Spring的AOP主要作用就是通过不修改源代码的方式，将非核心的功能代码织入，来实现对方法的增强，而它实现的原理，关键就在于使用代理模式</p><p>代理模式的分类：静态代理；动态代理</p><span id="more"></span><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>静态代理角色分析</strong></p><ul><li>抽象角色 : 一般使用接口或者抽象类来实现</li><li>真实角色 : 被代理的角色</li><li>代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .</li><li>客户  :  使用代理角色来进行一些操作 .</li></ul><p>1、创建一个抽象角色，比如一些基础的增删改查业务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、一个完成这些业务操作的真实对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;增加用户！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;删除用户！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;修改用户！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;查询用户！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、对于需求的变更，比如要新增一个日志功能，实现调用每个函数都有对应的日志输出：</p><ul><li>实现1：在原来的接口和实现类上去加。这样太过麻烦</li><li>实现2：使用代理实现，在不改变原来业务的情况下增加</li></ul><p>4、设置代理类处理日志，即代理角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceProxy</span> &#123;<br>    <span class="hljs-keyword">private</span> UserServiceImpl userService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserService</span><span class="hljs-params">(UserServiceImpl userService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userService = userService;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        log(<span class="hljs-string">&quot;add&quot;</span>);<br>        userService.add();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>&#123;<br>        log(<span class="hljs-string">&quot;delete&quot;</span>);<br>        userService.delete();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>&#123;<br>        log(<span class="hljs-string">&quot;update&quot;</span>);<br>        userService.update();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">()</span>&#123;<br>        log(<span class="hljs-string">&quot;select&quot;</span>);<br>        userService.select();<br>    &#125;<br><br>    <span class="hljs-comment">//增加日志功能不再需要去每个原有方法里添加代码</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String msg)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;[debug] 使用了&quot;</span>+msg+<span class="hljs-string">&quot;方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5、编写测试代码，即客户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        <span class="hljs-type">UserServiceProxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceProxy</span>();<br>        proxy.setUserService(userService);<br><br>        proxy.add();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//[debug] 使用了add方法</span><br><span class="hljs-comment">//增加用户！</span><br></code></pre></td></tr></table></figure><p>通过代理类处理日志，<font color="red"> 我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想</font></p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理和静态代理的角色都是用到了代理，区别就在于：动态代理是动态生成的，而静态代理是提前把代理类写好了。动态代理分类：一种是基于接口动态代理；一种是基于类动态代理</p><ul><li>基于接口：JDK动态代理</li><li>基于类：cglib</li></ul><p>以JDK的代理为例，<strong>JDK的动态代理需要了解两个类</strong> :<code> InvocationHandler</code> 和<code>Proxy</code>， 打开JDK帮助文档</p><p>【InvocationHandler：调用处理程序】</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223405917.png" alt="image-20230420223405917" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, 方法 method, Object[] args)</span>；<br><span class="hljs-comment">//参数</span><br><span class="hljs-comment">//proxy - 调用该方法的代理实例</span><br><span class="hljs-comment">//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。</span><br><span class="hljs-comment">//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或</span><br></code></pre></td></tr></table></figure><p>【Proxy  : 代理】</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223430282.png" alt="image-20230420223430282" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223453857.png" alt="image-20230420223453857" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成代理类</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-built_in">this</span>.getClass().getClassLoader(),<br>                                 rent.getClass().getInterfaces(),<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以租房子为例，现在我们租房买房都是通过第三方中介来实现，中介就相当于代理角色，我们和房东就相当于真实角色，而租房这一操作就是客户</p><p>1、抽象角色，定义一个租房接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//租房的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Rent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rent</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>2、真实角色，要出租房子的房东</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//房东</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Host</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Rent</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rent</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;房东要出租房子！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、代理角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用这个类自动生成代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><span class="hljs-comment">//方法类型：</span><br><span class="hljs-comment">//    Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),</span><br><span class="hljs-comment">//            new Class&lt;?&gt;[] &#123; Foo.class &#125;,</span><br><span class="hljs-comment">//            handler);</span><br><br>    <span class="hljs-comment">//被代理的接口 作为newProxyInstanced的参数二</span><br>    <span class="hljs-keyword">private</span> Rent rent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRent</span><span class="hljs-params">(Rent rent)</span> &#123;<br>        <span class="hljs-built_in">this</span>.rent = rent;<br>    &#125;<br><br>    <span class="hljs-comment">//生成得到代理类</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-built_in">this</span>.getClass().getClassLoader(),rent.getClass().getInterfaces(),<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//处理代理实例，并返回结果</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//动态代理的本质——就是使用反射机制实现！</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(rent, args);<br>        seeHouse();<br>        fare();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">//附加操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">seeHouse</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;中介带你看房子!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fare</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;中介费!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//真实角色</span><br>        <span class="hljs-type">Host</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Host</span>();<br>        <span class="hljs-comment">//代理角色 现在只有代理角色处理程序，并没有真实的代理角色</span><br>        <span class="hljs-type">ProxyInvocationHandler</span> <span class="hljs-variable">pih</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyInvocationHandler</span>();<br>        <span class="hljs-comment">//通过调用处理程序 处理我们要调用的接口对象</span><br>        pih.setRent(host);<br><br>        <span class="hljs-comment">//代理角色没有对应的类 而是由处理类实现！</span><br>        <span class="hljs-type">Rent</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Rent) pih.getProxy();<br>        proxy.rent();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//房东要出租房子！</span><br><span class="hljs-comment">//中介带你看房子!</span><br><span class="hljs-comment">//中介费!</span><br></code></pre></td></tr></table></figure><p><strong>【总结】：</strong>一个动态代理往往代理一类业务，他代理的是业务接口</p><p>使用动态代理可以抽离公共的代码，降低冗余、简化我们的开发，使真实角色更加存粹</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring学习三-自动装配</title>
    <link href="/20201014/1fc32a2/"/>
    <url>/20201014/1fc32a2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习Spring自动装配和注解开发时，看狂神的视频，弹幕又刷刷刷的。。搞得人压根没看明白【看这种视频真就不能开弹幕……】只是知道了这几个标签，所以看一下《Spring实战 第四版》的装配bean章节学习一下。结合狂神的视频和书本知识，互相补充吧</p><blockquote><p>Spring容器负责创建应用程序中的Bean并通过DI来协调这些对象之间的关系，在描述Bean装配操作时，Spring有很大的灵活性，它提供了三种主要的装配机制：</p><ul><li>在XML中显式装配</li><li>在Java中显式装配</li><li>隐式的bean发现机制和自动装配</li></ul></blockquote><p>作者推荐：尽可能使用自动装配机制，在必须要显式配置时，推荐使用类型安全且比XML更强大的JavaConfig。最后只有是想使用便利的XML命名空间并且在JavaConfig中没有同样的实现时才应用XML。<code>推荐：自动装配&gt;JavaConfig&gt;XML</code>。</p><p>书上的顺序是自动装配-&gt;JavaConfig-&gt;XML，狂神视频是先讲XML再自动装配再JavaConfig，我以视频顺序为主，具体的知识点两者结合着做</p><span id="more"></span><p>官方文档中给出的关于XML和configuration的问题看法：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223247040.png" alt="image-20230420223247040" style="zoom:80%;" /><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>书上关于自动装配的说法：</p><blockquote><p>Spring的自动装配需要从两个角度来实现，或者说是两个操作：</p><ol><li>组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；</li><li>自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC&#x2F;DI；</li></ol><p>组件扫描和自动装配组合就能发挥巨大威力，使得显示的配置降低到最少。</p></blockquote><p>下面就用实例来说明一下。</p><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>新建一个module叫做<code>spring05-AutoWired</code>，创建<code>pojo</code>实体类，<code>Cat  Dog </code>  都有一个<code>embark</code>的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">embark</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;汪汪汪！！！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">embark</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;喵~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建用户类<code>Man</code>，包含属性<code>Dog、cat、name</code>，然后生成对应的<strong>toString、set和get方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> &#123;<br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-keyword">private</span> Dog dog;<br>    <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写配置文件beans.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Dog&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Cat&quot;</span>/&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Man&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;cat&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dog&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;刘义&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写测试类MyTest，测试上面的代码，输出的正常，表示环境搭建无误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethodAutowire</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>       <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) context.getBean(<span class="hljs-string">&quot;user&quot;</span>);<br>       user.getCat().shout();<br>       user.getDog().shout();<br>  &#125;<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//汪汪汪！！！</span><br><span class="hljs-comment">//喵~~</span><br></code></pre></td></tr></table></figure><h3 id="自动装配xml配置"><a href="#自动装配xml配置" class="headerlink" title="自动装配xml配置"></a>自动装配xml配置</h3><h4 id="byName标签"><a href="#byName标签" class="headerlink" title="byName标签"></a>byName标签</h4><p><em>autowire byName (按名称自动装配)</em></p><p>由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p><p>采用自动装配将避免这些错误，并且使配置简单化。</p><p>修改bean配置，增加一个属性<code>autowire=&quot;byName&quot;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;man&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Man&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;刘义&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--再次在MyTest中测试，依旧可以成功--&gt;</span><br></code></pre></td></tr></table></figure><p>将<code>cat</code>的bean id修改为cat123，再次测试，发现报空指针<code>java.lang.NullPointerException</code>错误，这是因为采用byName规则无法找到对应的set方法，真正的set方法没有执行，对象未初始化，所以会报空指针错误！</p><p><strong>总结：</strong></p><p>当一个bean节点带有 autowire byName的属性时。</p><ol><li>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</li><li>去spring容器中寻找是否有此字符串名称id的对象。</li><li>如果有，就取出注入；如果没有，就报空指针异常。</li></ol><h4 id="byType标签"><a href="#byType标签" class="headerlink" title="byType标签"></a>byType标签</h4><p><em>autowire byType (按类型自动装配)</em></p><p>使用byType就跟byName方式类似了，不过byType看名字就知道它是按照类型去装配。</p><p>照例修改属性<code>autowire=&quot;byType&quot;</code>，然后进行测试，测试依然成功</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;man&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Man&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;刘义&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这时，我们如果再注册一个cat的bean对象：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Cat&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Cat&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;man&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Man&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;刘义&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>再次测试报错<code>NoUniqueBeanDefinitionException</code>，即bean对象不唯一，所以要注意同一类型的对象，在spring容器中必须唯一。如果不唯一，会报不唯一的异常。</p><p>再次修改，删除重复的cat2，再将cat的名字改掉，重新测试，依旧能允许，说明了按类型装配队id属性的值没有要求，即id属性不会影响结果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;catWrongId&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Cat&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;man&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Man&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;刘义&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--依旧运行成功了--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="使用注解装配"><a href="#使用注解装配" class="headerlink" title="使用注解装配"></a><font color="red">使用注解装配</font></h3><p>书上关于自动装配主要是注解实现，视频也是<strong>推荐不去使用自动装配xml配置 , 而使用注解 .</strong></p><p>这里参考书，讲狂神的<code>spring03 自动装配</code>、<code>spring04 注解开发</code>整合在一起，便于直观理解</p><p>使用注解前要先引入<code>context</code>约束，官方文档描述：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">    //引入<span class="hljs-attr">context</span>文件头</span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">        http://www.springframework.org/schema/context</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--开启属性注解支持--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Component 等价于 &lt;bean id=&quot;name&quot; class=&quot;com.liu.pojo.User&quot;/&gt;</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>   <span class="hljs-meta">@Value(&quot;刘义&quot;)</span><br>   <span class="hljs-comment">// 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;刘义&quot;/&gt;</span><br>    <span class="hljs-keyword">public</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>书中出现的第一个注解标签，使用@Component注解表明该类会作为组件类，并告知Spring为该类创建bean。</p><p>不过组件扫描默认是不启用的，所以还要显示配置一下Spring，从而命令它去寻找带有@Component注解的类并创建bean：</p><ul><li>书上采用的是创建一个对应的UserConfig类，打上@Configuration和@ComponentScan注解：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liu.pojo;<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserConfig</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>@ComponentScan默认扫描与配置类相同的包，即<code>com.liu.pojo</code>包下的所有子包，并查找带有@Component注解的类</p><ul><li>如果更倾向于使用XML启动组件扫描，也可以在xml文件中添加以下代码：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.liu.pojo&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>IDEA左侧出现一个绿色小叶子，点击就会跳转到对应的<code>ApplicationContext.xml</code>上：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223310765.png" alt="image-20230420223310765" style="zoom:80%;" /><p>在MyTest中测试上述代码是否正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;ApplicationContext.xml&quot;</span>);<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;user&quot;</span>, User.class);<br>        System.out.println(user.name);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出：刘义</span><br></code></pre></td></tr></table></figure><p>验证OK，即@Component注解确实创建了bean！</p><h5 id="为组件扫描的bean命名"><a href="#为组件扫描的bean命名" class="headerlink" title="为组件扫描的bean命名"></a>为组件扫描的bean命名</h5><p>可以看到上述代码中其实没有显式创建bean，对应的bean id也是没显式声明的，而我在测试代码中<code>getBean(&quot;user&quot;)</code>拿到了对应的bean。书上有解释：因为Spring会根据类名指定一个ID，具体来讲就是类名的第一个字母小写。</p><p>那么怎样设置自己想要的id呢？查看@Component注解的源码，发现它有个value的属性，所以我们可以设置对应value，即为显式的id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Component &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><span class="hljs-comment">//设置为   @Component(&quot;MyUser&quot;)</span><br><span class="hljs-comment">//对应测试的getBean中  id就为MyUser</span><br></code></pre></td></tr></table></figure><p>书上还介绍了另一种规范：<code>@Named(&quot;MyUser&quot;)</code>……推荐还是上一个</p><h5 id="设置扫描的包"><a href="#设置扫描的包" class="headerlink" title="设置扫描的包"></a>设置扫描的包</h5><p>默认情况下，使用@ComponentScan会以当前类所在的包为基础包，如果想扫描不同的包，或者多个基础包，又该怎样操作呢？书上给出了解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liu.pojo;<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">//可以设置@ComponentScan的value：</span><br><span class="hljs-meta">@ComponentScan(&quot;com.liu.pojo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserConfig</span>&#123;&#125;<br><span class="hljs-comment">//@ComponentScan(basePackages=&#123;&quot;com.liu.pojo&quot;,&quot;com.liu.dao&quot;......&#125;)</span><br><br><span class="hljs-comment">//还可以指定接口</span><br><span class="hljs-comment">//@ComponentScan(basePackageClasses=&#123;User.Class,UserDao.Class......&#125;)</span><br></code></pre></td></tr></table></figure><p>至于之前的另一个方式xml，基本上不用改啥，它的属性<code>&lt;context:component-scan base-package=&quot;com.liu&quot; /&gt;</code>就有设置扫描包位置。</p><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>上面的是自动扫描的操作，另一个就是进行自动装配，可以用@Autowired注解实现！</p><ul><li>@Autowired是按类型自动转配的，不支持id匹配。</li><li>需要导入 <code>spring-aop</code>的包！</li></ul><p>将一开始的User类中的setter方法去掉，在属性上添加@Autowired注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Cat cat;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Dog dog;<br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-comment">//get方法、toSting方法......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对应的配置文件也可以简化：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Dog&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Cat&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Man&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Man&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>测试，输出成功！</p><ul><li>@Autowired不仅能用在setter方法上，也可以用在构造器上，加在构造器上时，表示会通过该构造器来进行实例化并传入一个可以设置给对应参数类型的bean</li><li>@Autowired还可以用在其他方法上，本质上都是Spring尝试去满足方法参数上所声明的依赖</li></ul><p>如果没有匹配的bean时，会抛出异常！</p><p>解决方法：<code>@Autowired(required=false)</code> ——表示注入时容器对象bean可以为null，默认值是true。</p><p>【注】在容器的启动过程中，会初始化很多bean，这也是spring的核心之一（IOC）。但是在注入的过程中，扫描到公共方法中要注入的bean，并未找到，强行注入就会注入失败。我们又不能单独的去除改方法，所以我们采取的思想就是有bean就注入，没有就不注入。解决办法就是@Autowired(required&#x3D;false)。</p><blockquote><p>使用required属性，需要谨慎对待，如果代码中没有null检查的话，可能会报空指针异常；如果多个bean都满足依赖，Spring会报异常<code>NoUniqueBeanDefinitionException</code>，出现书后面章节所说的歧义性</p></blockquote><h5 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h5><ul><li>@Autowired是根据类型自动装配<code>(byType)</code>的，加上@Qualifier则可以根据<code>byName</code>的方式自动装配</li><li>@Qualifier不能单独使用。</li></ul><p>修改配置文件内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>如果没加@Qualifier代码就会直接报红，因为@Autowired按类型装配，此时同一类型对象不唯一，无法装配；加上@Qualifier后，类型装配不行的话就会再查找name，就能通过了~</p><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><ul><li>@Resource如有指定的name属性，先按该属性进行byName方式查找装配；</li><li>其次再进行默认的byName方式进行装配；</li><li>如果以上都不成功，则按byType的方式自动装配。</li><li>都不成功，则报异常。</li></ul><p>1 测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>   <span class="hljs-comment">//如果允许对象为null，设置required = false,默认为true</span><br>   <span class="hljs-meta">@Resource(name = &quot;cat2&quot;)</span><br>   <span class="hljs-keyword">private</span> Cat cat;<br>   <span class="hljs-meta">@Resource</span><br>   <span class="hljs-keyword">private</span> Dog dog;<br>   <span class="hljs-keyword">private</span> String str;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dog&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cat2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.kuang.pojo.User&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>测试结果正常！</p><p>将@Resource的name属性去掉，cat2去掉，再次测试，依然正常，说明上述的方法正确</p><h2 id="JavaConifg装配bean"><a href="#JavaConifg装配bean" class="headerlink" title="JavaConifg装配bean"></a>JavaConifg装配bean</h2><p>有时我们不得不使用显式装配，比如想将第三方类库装配到自己的应用中时，肯定不能在它的类上添加注解，所以就只能显式装配了。</p><p>JavaConfig的实现是通过注解完成的，因此先介绍一下注解开发</p><h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><p>Spring4之后使用spring注解要引入aop包，在配置文件当中，还得要引入一个context约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;<br>xsi:schemaLocation=&quot;<br>https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="Bean的实现"><a href="#Bean的实现" class="headerlink" title="Bean的实现"></a>Bean的实现</h4><p>之前都是在xml中使用 bean 的标签进行bean注入，但是实际开发中完全可以使用注解</p><p>1、配置要扫描的包（会包含bean对象的）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.liu&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>2、在指定包下编写类，添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Component 等价于 &lt;bean id=&quot;name&quot; class=&quot;com.liu.pojo.User&quot;/&gt;</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">//等价于&lt;property name=&quot;name&quot; value=&quot;刘义&quot;/&gt;</span><br>    <span class="hljs-meta">@Value(&quot;刘义&quot;)</span><br>    <span class="hljs-keyword">public</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】：这里在<code>String name</code>上添加了注解<code>@Value</code>相当于通过注解注入了属性值，如果有提供set方法，可以在set方法生添加<code>@Value(&quot;值&quot;)</code>；</p><p>3、编写测试类测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;ApplicationContext.xml&quot;</span>);<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;user&quot;</span>, User.class);<br>        System.out.println(user.name);<br>    &#125;<br><span class="hljs-comment">//输出：刘义</span><br></code></pre></td></tr></table></figure><h4 id="衍生注解"><a href="#衍生注解" class="headerlink" title="衍生注解"></a>衍生注解</h4><p>使用注解的目的就是为了简化配置文件，进一步简化开发、提高效率</p><p><strong>@Component的三个衍生注解</strong></p><p>为了更好的分层，Spring可以使用其他的三个注解</p><ul><li>@Controller：web层</li><li>@Service：service层</li><li>@Repository：dao层</li></ul><p>Spring会扫描这些注释，自动识别为对应的层去管理</p><p><strong>作用域@Scope</strong></p><ul><li>singleton：默认的，表示Spring会采用单例模式创建对象。关闭工厂后所有对象也随之销毁</li><li>prototype：多例模式。关闭工厂后所有对象不会全销毁，内部垃圾回收机制会回收</li></ul><h3 id="JavaConfig装配"><a href="#JavaConfig装配" class="headerlink" title="JavaConfig装配"></a>JavaConfig装配</h3><p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p><p>1、首先还是定义一个pojo实体类User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/10/2 16:10</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Value(&quot;刘义616161&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、新建一个Config包，创建一个liuConfig文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">liuConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】<code>@Configuration</code>标签表示这是一个配置类，在类中添加<code>@Bean</code>标签，通过方法去注册一个bean，返回值就是bean的类型，方法名就是bean的id</p><p>3、编写测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(liuConfig.class);<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) context.getBean(<span class="hljs-string">&quot;getUser&quot;</span>);<br>        System.out.println(user.getName());<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出：刘义616161</span><br></code></pre></td></tr></table></figure><p>也可以继续再编写另外的Config代码，通过<code>@Import(xxx.class)</code>方式导入合并其他的配置类</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora+PicGo简化图床操作</title>
    <link href="/20201009/f39da986/"/>
    <url>/20201009/f39da986/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每次写博客最费劲的问题就是图片。。。直接截图的是本地图片，上传到博客无法显示，必须要用图床工具，之前我用的是七牛云的图床，但是每次还是很麻烦：<strong>截图–&gt;保存–&gt;上传–&gt;复制外联外链–&gt;粘贴外链</strong></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/PicGo1.png" style="zoom:50%;" /><span id="more"></span><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>markdown编辑器Typora，可以点击<a href="https://www.typora.io/">官网</a>下载</p></li><li><p>图床工具PicGo，在它的<a href="https://github.com/Molunerfinn/PicGo/releases">GitHub</a>上可以下载</p></li><li><p>自己的图床，这个就随意了，选PicGo支持的就行</p><blockquote><p>PicGo支持的7种图床：七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，SM.MS，imgur</p></blockquote></li></ul><h2 id="PicGo设置"><a href="#PicGo设置" class="headerlink" title="PicGo设置"></a>PicGo设置</h2><h3 id="1、配置图床信息"><a href="#1、配置图床信息" class="headerlink" title="1、配置图床信息"></a>1、配置图床信息</h3><p>以我的七牛云图床为例，配置一下对应信息，找到图床设置–&gt;七牛图床</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/PicGo3.png"></p><ul><li><p>前两个AccessKey和SecretKey在个人中心的密钥管理中配置（如上图）</p></li><li><p>设定存储空间名：即为你设置的图床bucket的名字</p></li><li><p>设定访问网址：就是你的存储空间的域名，从图床bucket的“空间概览”里找到（要加上http:&#x2F;&#x2F;）</p></li><li><p>存储区域：你的存储区域。华东<code>z0</code>华北<code>z1</code>华南<code>z2</code>北美<code>na0</code>东南亚<code>as0</code></p></li><li><p>存储路径：存储后的形式，要加&#x2F;</p><p>如图就是以<code>PicGo/</code>为路径上传的图片：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/PicGo4.png"></p></li></ul><h3 id="2、打开PicGo的server服务"><a href="#2、打开PicGo的server服务" class="headerlink" title="2、打开PicGo的server服务"></a>2、打开PicGo的server服务</h3><p>在PicGo设置&#x2F;设置Server中找到对应设置，默认设置如图，基本上与不需要改，只要确定开了就行：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/PicGo2.png" style="zoom:67%;" /><h2 id="Typora设置"><a href="#Typora设置" class="headerlink" title="Typora设置"></a>Typora设置</h2><p>找到：文件–&gt;偏好设置–&gt;图像，进行设置</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/PicGo5.png" alt="PicGo5"></p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/PicGo6.png" alt="PicGo6"></p><h2 id="开始使用！"><a href="#开始使用！" class="headerlink" title="开始使用！"></a>开始使用！</h2><p>使用的方式很多：</p><ol><li><p>将本地图片拖到Typora上，它会自动上传</p></li><li><p>任意截图，然后粘贴，然后出现上传图片，点击即可，效果如图：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201009171350737.png" alt="image-20201009171350737"></p></li><li><p>采用快捷键插入图片：<strong>Ctrl + Shift + I</strong>    或者   <code>![]() </code>都可以，效果如图：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20201009171609612.png" alt="image-20201009171609612"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>博客工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习二-配置及依赖注入DI</title>
    <link href="/20201009/f008a534/"/>
    <url>/20201009/f008a534/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring应用"><a href="#Spring应用" class="headerlink" title="Spring应用"></a>Spring应用</h2><p>IoC的基本思想了解了，就可以尝试应用Spring了。以项目hello为例，学习一下使用Spring的基本流程。</p><p>这是第一部分：演示一遍Spring；后面还有Spring依赖注入方式说明；bean作用域说明。</p><h3 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h3><p>在maven仓库中搜Spring，可以看到很多依赖，我们选择<code>spring-webmvc</code>来导入，它能导入其他需要的文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>1、编写一个Hello实体类，并编写对应的setget方法和toString方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liu.pojo;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/10/1 10:58</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">private</span> String str;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStr</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStr</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-built_in">this</span>.str = str;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;str=&#x27;&quot;</span> + str + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、编写我们的spring文件 , 这里我们命名为beans.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--使用spring创建对象,在spring中这些都称为bean</span><br><span class="hljs-comment">        bean相当于对象!</span><br><span class="hljs-comment">        类型  变量名 = new 类型(); ——&gt; Hello hello = new Hello();</span><br><span class="hljs-comment">        id = 变量名  class = new 的对象  property相对于设置对象属性&amp;值</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Hello&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;str&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、我们可以去进行测试了 .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.liu.pojo.Hello;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/10/1 11:06</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//获取spring的上下文对象</span><br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>        <span class="hljs-comment">//对象现在都在spring中管理,要使用直接去spring中取出</span><br>        <span class="hljs-type">Hello</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> (Hello) context.getBean(<span class="hljs-string">&quot;hello&quot;</span>);<br>        System.out.println(hello.toString());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="回顾控制反转"><a href="#回顾控制反转" class="headerlink" title="回顾控制反转"></a>回顾控制反转</h3><ul><li><p>此处hello对象由谁创建？</p><p>【答】由Spring创建</p></li><li><p>hello对象的属性怎样设置？</p><p>【答】：代码中可以看到——属性由Spring容器设置（在beas.xml中）</p></li><li><p>上述就是控制反转思想的应用实例</p><ul><li>由原本程序本身控制创建对象，到Spring创建对象</li><li>程序本身不再创建对象，而是接收对象</li></ul></li></ul><h3 id="修改Spring学习一"><a href="#修改Spring学习一" class="headerlink" title="修改Spring学习一"></a>修改Spring学习一</h3><p>既然Spring提供了这么便捷的方法，我们完全可以将之前的代码重构，之前由构造函数到setter方法，现在再体验一下使用Spring方式简化操作！</p><p>在项目一中增加beans.xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mysql&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.dao.UserDaoMysqlImpl&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;oracle&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.dao.UserDaoOracleImpl&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;service&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.service.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--ref:引用spring中创建好的对象 value:具体的值 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对应的测试代码也要修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//采用spring的获取ApplicationContext方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//拿到spring容器</span><br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br><br>    <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> (UserServiceImpl)context.getBean(<span class="hljs-string">&quot;service&quot;</span>);<br>    service.getUser();<br>&#125;<br><span class="hljs-comment">//输出：Mysql获取用户数据</span><br></code></pre></td></tr></table></figure><p>测试通过！如果要修改调用，不用再那么麻烦了，可以直接在xml文件中修改配置即可，例如改为<code>UserDaoCustomImpl</code>，只需要：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Custom&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.dao.UserDaoCustomImpl&quot;</span>/&gt;</span><br><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;service&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.service.UserServiceImpl&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Custom&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="IOC创建对象方式"><a href="#IOC创建对象方式" class="headerlink" title="IOC创建对象方式"></a>IOC创建对象方式</h3><p>介绍一下常见的创建对象方式</p><p>新建项目ioc2，编写User类，及其对应的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liu.pojo;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/10/1 11:25</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User的无参构造！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        System.out.println(<span class="hljs-string">&quot;User的带参构造！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;name= &quot;</span>+name);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编写beans.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--无参的实现--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.User&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;u1,u2,u3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;刘义&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        id: bean的唯一标识，相当于我们的对象名</span><br><span class="hljs-comment">        class: bean对象所对应的全限定名——包名+类型</span><br><span class="hljs-comment">        name: 别名，且name可以取多个 还可以用alias实现别名</span><br><span class="hljs-comment">    --&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--带参的实现: 1.下标赋值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;arg1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;带参刘义&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--带参的实现: 2.通过类型创建--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;arg2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.User&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--不建议使用--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;带参刘义2&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--带参的实现: 3.直接通过参数名设置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;arg3&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;带参刘义3&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.liu.pojo.User;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/10/1 11:27</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> (User) context.getBean(<span class="hljs-string">&quot;u1&quot;</span>);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) context.getBean(<span class="hljs-string">&quot;arg1&quot;</span>);<br>        user.show();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> (User) context.getBean(<span class="hljs-string">&quot;arg2&quot;</span>);<br>        System.out.println(user==user2);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>查看结果：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420222910704.png" alt="image-20230420222910704" style="zoom:80%;" /><p>可以看到结果中：一个无参三个带参的构造函数都显示了，跟xml文件中的一致，并且是在show方法之前就显示了，**<font color="blue">说明spring中的bean在注册context容器时就将其实例化了，因为spring默认单例模式实现!</font>**</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring的学习其实和Mybatis类似，感觉通过配置文件来简化操作。<strong>最重要的是理解Spring的核心思想——IoC控制反转！</strong></p><p>基本步骤：创建pojo–&gt;编写配置文件–&gt;测试</p><h2 id="Spring依赖注入DI"><a href="#Spring依赖注入DI" class="headerlink" title="Spring依赖注入DI"></a>Spring依赖注入DI</h2><p>依赖注入DI（Dependency Injection）这个概念很重要，就是指应用程序本身不再负责对象的创建和维护，应用程序所需要的类在应用加载启动的时候创建完成，并通过set方法将类直接加载到应用程序中(DI)。</p><p>SPring中依赖注入的方式也很多，可以参考<a href="https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/spring-framework-reference/core.html#beans-dependencies">文档 1.4 Dependencies</a>了解详细信息</p><h3 id="1、构造器注入"><a href="#1、构造器注入" class="headerlink" title="1、构造器注入"></a>1、构造器注入</h3><p>在之前的代码中已经说过，它只能叫注入，不属于Spring的注入，这个其实也不推荐</p><h3 id="2、Set注入"><a href="#2、Set注入" class="headerlink" title="2、Set注入"></a>2、<font color="red">Set注入</font></h3><p>要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是 is 。</p><p>编写pojo实体类Address</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(String address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Address&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-keyword">private</span> String[] books;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; hobbies;<br>    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; card;<br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; games;<br>    <span class="hljs-keyword">private</span> String girlFriends;<br>    <span class="hljs-keyword">private</span> Properties info;<br><br>    <span class="hljs-comment">//编写对应的get、set方法和toString方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>准备对应的xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Address&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;徐州&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.Student&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--对应的注入方式--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下是几种常见类型数据的注入方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 第一种: 普通值注入：直接使用value --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;刘义&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 第二种: bean注入,使用ref --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;address&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--数组注入,ref--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;books&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>《西游记》<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>《水浒传》<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>《三国演义》<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>《红楼梦》<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--list--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>踢足球<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>看小说<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>写代码<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>打游戏<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--map--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xxxyyy199908042417&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;校园卡&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;CUMT08173000&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;银行卡&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;RichMan99999999&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--set--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;games&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>Counter-Striker: GO<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>The-Witcher3: Wild Hunt<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>FIFA 20<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--null值注入  空值和空字符串不一样 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;girlFriends&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--properties--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;学号&quot;</span>&gt;</span>08173000<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;性别&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;邮箱&quot;</span>&gt;</span>salute61@163.com<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans.xml&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) context.getBean(<span class="hljs-string">&quot;student&quot;</span>);<br>    System.out.println(student.toString());<br>&#125;<br><br><span class="hljs-comment">/*输出如下：</span><br><span class="hljs-comment">    * Student&#123;name=&#x27;刘义&#x27;,</span><br><span class="hljs-comment">    * address=Address&#123;address=&#x27;徐州&#x27;&#125;,</span><br><span class="hljs-comment">    * books=[《西游记》, 《水浒传》, 《三国演义》, 《红楼梦》],</span><br><span class="hljs-comment">    * hobbies=[踢足球, 看小说, 写代码, 打游戏],</span><br><span class="hljs-comment">    * card=&#123;身份证=xxxyyy199908042417, 校园卡=CUMT08173000, 银行卡=RichMan99999999&#125;,</span><br><span class="hljs-comment">    * games=[Counter-Striker: GO, The-Witcher3: Wild Hunt, FIFA 20],</span><br><span class="hljs-comment">    * girlFriends=&#x27;null&#x27;,</span><br><span class="hljs-comment">    * info=&#123;学号=08173000, 性别=男, 邮箱=salute61@163.com&#125;&#125;</span><br><span class="hljs-comment">     * */</span><br></code></pre></td></tr></table></figure><p>官方文档在介绍完这两种注入方式后，有以下的内容：翻译一下：</p><blockquote><div align="center">基于构造函数的注入还是基于Setter方法的注入？</div><p>​由于可以混合使用基于构造函数的DI和基于setter的DI，因此将构造函数用于强制性依赖项并将setter方法或配置方法用于可选依赖性是一个很好的经验法则【注意，可以在setter方法上使用@Required批注，以使该属性成为必需的依赖项。但是，最好使用带有参数的程序验证的构造函数注入】</p><p>​Spring团队通常提倡构造函数注入，因为它可以让您将应用程序组件实现为不可变对象，并确保不存在必需的依赖项。此外，注入构造函数的组件始终以完全初始化的状态返回到客户端（调用）代码。【附带说明一下，大量的构造函数参数会产生坏味代码，这意味着该类可能承担了太多的职责，应该对其进行重构以更好地解决关注点之间的分离】</p><p>​Setter注入主要应仅用于可以在类中分配合理的默认值的可选依赖项。否则，必须在代码使用依赖项的任何地方执行非空检查。 setter注入的一个好处是，setter方法使该类的对象在以后可以重新配置或重新注入。因此，通过JMX MBean进行管理是用于setter注入的引人注目的用例。</p><p>​使用最适合特定类的DI风格。有时，在处理您没有源代码的第三方类时，如果第三方类未公开任何setter方法，则构造函数注入可能是DI的唯一可用形式。</p></blockquote><h3 id="3、其他注入方式"><a href="#3、其他注入方式" class="headerlink" title="3、其他注入方式"></a>3、其他注入方式</h3><p>Spring支持的注入方式很多，文档中还介绍了p命名空间和c命名空间，对于这两种方式，使用前要先导入约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:p</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:c</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/c&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- p、c命名使用前要导入xml约束 --&gt;</span><br></code></pre></td></tr></table></figure><p>P命名空间注入 : 相当于properties简写模式，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- p:property简写 命名空间注入，可以直接注入属性的值 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.User&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;p-刘义&quot;</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>c 命名空间注入 : c即constructor实现，因此要加上对应的构造器，不然就会报错</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- c:constructor简写 通过构造器注入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.liu.pojo.User&quot;</span> <span class="hljs-attr">c:name</span>=<span class="hljs-string">&quot;c-刘义&quot;</span> <span class="hljs-attr">c:age</span>=<span class="hljs-string">&quot;18&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>再编写相关的测试代码验证即可。</p><h2 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h2><p>这是<a href="https://docs.spring.io/spring-framework/docs/5.2.0.RELEASE/spring-framework-reference/core.html#beans-factory-scopes">官方文档1.5Bean Scopes</a>中对bean定义的描述</p><blockquote><p>创建一个bean定义，其实质是用该bean定义对应的类来创建真正实例的“配方(recipe)”。把bean定义看成一个配方很重要，它与class很类似，只根据一张“配方”就可以创建多个实例。不仅可以控制注入到对象中的各种依赖和配置值，还可以控制该对象的作用域。这样可以灵活选择所建对象的作用域，而不必在Java Class级定义作用域。Spring Framework支持五种作用域</p></blockquote><p>以下是常见的四种作用域的定义内容：</p><h3 id="1、SingleTon"><a href="#1、SingleTon" class="headerlink" title="1、SingleTon"></a>1、SingleTon</h3><p>当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</p><p>Singleton是单例类型，就是在创建容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象（上面演示代码中就有出现）。注意，Singleton作用域是Spring中的缺省作用域。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420222938333.png" alt="image-20230420222938333" style="zoom:80%;" /><p>文档中提到：Spring的单例模式和四人帮(GoF)的单例模式不同。GoF单例对对象的范围进行硬编码，以使每个ClassLoader只能创建一个特定类的一个实例。 而Spring单例的作用域最好描述为每个容器和每个bean。 这意味着：如果在单个Spring容器中为一个特定类定义一个bean，则Spring容器将创建由该<code>bean定义</code>所定义的类的一个且只有一个实例。 Singleton范围是Spring中的默认范围。 要将bean定义为XML中的单例，可以定义bean，如以下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.DefaultAccountService&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.something.DefaultAccountService&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2、Prototype"><a href="#2、Prototype" class="headerlink" title="2、Prototype"></a>2、Prototype</h3><p>当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例。Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;account&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.foo.DefaultAccount&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;</span>  <br> 或者<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;account&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.foo.DefaultAccount&quot;</span> <span class="hljs-attr">singleton</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420223043075.png" alt="image-20230420223043075" style="zoom:80%;" /><h3 id="3、Request"><a href="#3、Request" class="headerlink" title="3、Request"></a>3、Request</h3><p>当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loginAction&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">cn.csdn.LoginAction</span>&quot; <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;request&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。</p><h3 id="4、Session"><a href="#4、Session" class="headerlink" title="4、Session"></a>4、Session</h3><p>当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userPreferences&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.foo.UserPreferences&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;session&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效。与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习一-初识Spring</title>
    <link href="/20201005/78bf396f/"/>
    <url>/20201005/78bf396f/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Spring作为Java开发应用最为广泛的一个框架（甚至可以说它是默认的JavaEE框架）能做很多事，它为企业级开发提供了丰富的功能，它们的底层都依赖于两个核心特性：依赖注入【DI：Dependency injection】和面向切面编程【AOP：Aspect Oriented Programming】。可以说它的<strong>成功来源于理念，而不是技术本身</strong>！</p><p><strong>什么是 Spring：</strong></p><ol><li>Spring 是一个<strong>轻量级的 DI &#x2F; IoC 和 AOP 容器的开源框架</strong>，最早由 Rod Johnson创建，并在其著作<strong>《Expert one on one J2EE design and development》</strong>中进行介绍。</li><li>Spring 提倡以<strong>“最小侵入性”</strong>的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring</li></ol><ul><li><strong>适用范围：任何 Java 应用</strong></li><li><strong>Spring 的根本使命：简化 Java 开发</strong></li></ul><span id="more"></span><h2 id="Spring组成模块"><a href="#Spring组成模块" class="headerlink" title="Spring组成模块"></a>Spring组成模块</h2><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 .</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420222740313.png" alt="image-20230420222740313" style="zoom:80%;" /><p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：</p><ul><li>**核心容器(Spring Core)*<em>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用</em>控制反转*（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li><li><strong>Spring 上下文</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li><li><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li><li><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li><li><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li><li><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li><li><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li></ul><h2 id="IoC基础"><a href="#IoC基础" class="headerlink" title="IoC基础"></a>IoC基础</h2><p><strong>IoC：Inverse of Control（控制反转）</strong>并不是什么技术，而是一种<strong>设计思想</strong>，就是<font color="blue"><strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong></font>DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p><p>新建一个项目，参照我们原来的写法：创建Dao接口–&gt;写Dao实现类–&gt;写Service接口–&gt;写service接口实现类–&gt;测试代码。【通过service接口实现获取Dao接口，具体的实现通过接口的实现类完成】</p><p>1、先写一个UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、再去写Dao的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;获取用户数据&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、然后去写UserService的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、最后写Service的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> &#123;<br>       userDao.getUser();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5、测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-type">UserService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>   service.getUser();<br>&#125;<br></code></pre></td></tr></table></figure><p>得到输出：<code>获取用户数据</code>，验证代码无误。</p><p>此时如果要新增一个数据库操作用户数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoMySqlImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDao</span> &#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;MySql获取用户数据&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoMySqlImpl</span>();<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> &#123;<br>       userDao.getUser();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果以后增加了Oracle实现、增加了MongDB实现······每次增加不同的实现都要去service实现类中修改对应实现，这就意味着每次需求变更都要修改代码，对于需求量很大的情况下工作量会爆增——原因就是代码设计的耦合性太高了！</p><h3 id="设计修改的思路"><a href="#设计修改的思路" class="headerlink" title="设计修改的思路"></a>设计修改的思路</h3><ul><li>其实上述的代码思路就是我们人类思考的正常思路——需要什么就去实现什么。可以理解为依赖正置；</li><li>我们要做的就是反过来思考——先对现实世界进行抽象，抽象的结果就是有了抽象类和接口，然后我们根据需求进行设计。这就是《面向对象设计与分析》中的<strong>依赖倒转原则DIP</strong></li></ul><p>回顾依赖倒转原则：了解依赖的三种写法</p><ol><li>通过构造函数实现依赖</li><li>Setter方法传递依赖对象 </li><li>接口声明依赖对象</li></ol><p>上面的代码就是通过构造函数实现，结构如下：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420222801338.png" alt="image-20230420222801338" style="zoom:80%;" /><p>我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用setter方法将其作为参数传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><span class="hljs-comment">//    private UserDao userDao = new UserDaoImpl();</span><br><span class="hljs-comment">//    要修改业务就必须修改原有代码,使得操作很复杂</span><br><span class="hljs-comment">//    private UserDao userDao = new UserDaoMysqlImpl();</span><br><span class="hljs-comment">//    private UserDao userDao = new UserDaoOracleImpl();</span><br><br>    <span class="hljs-comment">//简化方法：利用set方法,将userDao作为参数传入,保证主动权在调用者手中</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span>&#123;<br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> &#123;<br>        userDao.getUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时代码已经发生了很大的变化——由之前的程序控制创建，到现在自行传参，将控制的主动权交给了调用者手中，我们不需要再去一个个的创建对应的实现了，程序只负责提供一个接口即可，我们完全可以把关注点放在业务实现、算法思路上了！这就是IoC的基本思想。</p><p>再看我们的代码结构：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420222813851.png" alt="image-20230420222813851" style="zoom: 70%;" /><p><strong>IoC是Spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p><p>Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。</p><p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p><p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis学习六-缓存</title>
    <link href="/20201005/61e534eb/"/>
    <url>/20201005/61e534eb/</url>
    
    <content type="html"><![CDATA[<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存的概念：存在内存中的临时数据。将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</p><p>好处：减少和数据库的交互次数，减少系统开销，提高系统效率。</p><p>常用对象：需要频繁查询且较少改变的对象</p><span id="more"></span><h3 id="Mybatis缓存特性"><a href="#Mybatis缓存特性" class="headerlink" title="Mybatis缓存特性"></a>Mybatis缓存特性</h3><p>mybatis 也提供了对缓存的支持， 分为<strong>一级缓存</strong>和<strong>二级缓存</strong>。</p><ul><li>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）</li><li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li><li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</li></ul><blockquote><p>【注】狂神的视频只是简单介绍了一级二级缓存以及开启方法，我将其整理，在网上找了一些<strong>Mybatis缓存机制</strong>相关博客进行补充！</p></blockquote><p>在Mybatis的jar包中，找到<code>org.apache.ibatis</code>可以看到<code>cache</code>目录下的文件</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420180957876.png" alt="image-20230420180957876" style="zoom:80%;" /><p>其中有一个Cache 接口，只有一个默认的实现类 PerpetualCache，它是用HashMap 实现的。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p><strong>概念原理：</strong></p><p>之前学习过：每当我们使用MyBatis开启一次和数据库的会话，Mybatis会创建出<strong>一个SqlSession对象表示一次数据库会话</strong>。一次会话中会有多次查询，其中可能就会有很多重复的，Mybatis处理的方法是什么呢？</p><p>答：MyBatis会在表示会话的SqlSession对象中建立一个缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。</p><p>SqlSession只是一个Mybatis对外的接口，SqlSession将它的工作交给了Executor执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个SqlSession对象时，Mybatis会为这个对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中，Mybatis将缓存和对缓存相关的操作封装成了Cache接口中。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Mybatis-localCache.png" alt="Mybatis-localCache" style="zoom:67%;" /><p>由于Session级别的一级缓存实际上就是使用<strong>PerpetualCache</strong>维护的，那么<strong>PerpetualCache</strong>是怎样实现的呢？</p><p><strong>PerpetualCache</strong>实现原理其实很简单，其内部就是通过一个简单的<strong>HashMap</strong>来实现的，没有其他的任何限制。</p><blockquote><p>这里作为Mybatis的入门，只是了解一下。</p><p>更多底层的执行步骤细节、源码实现，以后再专门去学习记录！</p></blockquote><h3 id="一级缓存的测试"><a href="#一级缓存的测试" class="headerlink" title="一级缓存的测试"></a>一级缓存的测试</h3><p>编写接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-comment">//根据ID查询用户</span><br>    User <span class="hljs-title function_">queryUserById</span><span class="hljs-params">( <span class="hljs-type">int</span> id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口对应的Mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.liu9.pojo.User&quot;</span>&gt;</span><br>    select * from mybatis.user<br>    where  id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUserById</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>   <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><br>   <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.queryUserById(<span class="hljs-number">1</span>);<br>   System.out.println(user);<br>   <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper.queryUserById(<span class="hljs-number">1</span>);<br>   System.out.println(user2);<br>   System.out.println(user==user2);<br><br>   session.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：查询语句只执行了一次！并且判断<code>user1==user2</code>结果为true</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420181057541.png" alt="image-20230420181057541" style="zoom:80%;" /><h3 id="一级缓存生命周期"><a href="#一级缓存生命周期" class="headerlink" title="一级缓存生命周期"></a>一级缓存生命周期</h3><ul><li>一级缓存是SqlSession级别的缓存，所以在SqlSession会话结束后，SqlSession对象及其内部的Executor和PerpetualCache对象都会一并释放掉</li><li>SqlSession调用了close()方法时，会释放PerpetualCache对象</li><li>SqlSession调用了clearCache()方法时，清空缓存，对象仍可用</li><li>SqlSession调用了增删改等方法时，清空缓存，对象仍可用</li></ul><p>以下是四种常见的SqlSession失效情况：</p><h4 id="1、不同的SqlSession"><a href="#1、不同的SqlSession" class="headerlink" title="1、不同的SqlSession"></a>1、不同的SqlSession</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryUserByIdTest</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession2</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.queryUserById(<span class="hljs-number">1</span>);<br>    System.out.println(user1);<br>    System.out.println(<span class="hljs-string">&quot;&lt;------------------------------------&gt;&quot;</span>);<br>    sqlSession.close();<br><br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> sqlSession2.getMapper(UserMapper.class);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper2.queryUserById(<span class="hljs-number">1</span>);<br>    System.out.println(user2);<br>    System.out.println(<span class="hljs-string">&quot;&lt;------------------------------------&gt;&quot;</span>);<br><br>    System.out.println(user1==user2);<br>    sqlSession2.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码开启了两个SqlSession，分别执行相同的查询，输出如下：可以看到它执行了两次SQL，表明user1的缓存并没有作用到user2上！结论：<strong>每个sqlSession中的缓存相互独立</strong></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420181132780.png" alt="image-20230420181132780" style="zoom:80%;" /><h4 id="2、sqlSession相同，查询条件不同"><a href="#2、sqlSession相同，查询条件不同" class="headerlink" title="2、sqlSession相同，查询条件不同"></a>2、sqlSession相同，查询条件不同</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUserById</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>   <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>   <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><br>   <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.queryUserById(<span class="hljs-number">1</span>);<br>   System.out.println(user);<br>   <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper2.queryUserById(<span class="hljs-number">2</span>);<br>   System.out.println(user2);<br>   System.out.println(user==user2);<br><br>   session.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个很明显，user1和user2查询的对象并不相同，user1缓存的是queryUserById(1)内容，不能复用到user2上。同样观察结果发现两次查询，判断为false</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420181159362.png" alt="image-20230420181159362" style="zoom:80%;" /><h4 id="3、sqlSession相同，两次查询之间执行了增删改操作"><a href="#3、sqlSession相同，两次查询之间执行了增删改操作" class="headerlink" title="3、sqlSession相同，两次查询之间执行了增删改操作"></a>3、sqlSession相同，两次查询之间执行了增删改操作</h4><p>增加方法updateUser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//修改用户</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(Map map)</span>;<br></code></pre></td></tr></table></figure><p>配置对应的SQL语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>  update user set name = #&#123;name&#125; where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUserById3</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.queryUserById(<span class="hljs-number">1</span>);<br>    System.out.println(user);<br><br>    <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;liuyi&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-number">4</span>);<br>    mapper.updateUser(map);<br><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper.queryUserById(<span class="hljs-number">1</span>);<br>    System.out.println(user2);<br><br>    System.out.println(user==user2);<br><br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>在两次查询中间加入了一个update操作</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420181216600.png" alt="image-20230420181216600" style="zoom:80%;" /><h4 id="4、sqlSession相同，手动清除一级缓存"><a href="#4、sqlSession相同，手动清除一级缓存" class="headerlink" title="4、sqlSession相同，手动清除一级缓存"></a>4、sqlSession相同，手动清除一级缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUserById</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>   <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br><br>   <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.queryUserById(<span class="hljs-number">1</span>);<br>   System.out.println(user);<br><br>   session.clearCache();<span class="hljs-comment">//手动清除缓存</span><br><br>   <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper.queryUserById(<span class="hljs-number">1</span>);<br>   System.out.println(user2);<br><br>   System.out.println(user==user2);<br><br>   session.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出与上面一致，因为cache被手动清除了。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p><strong>概念原理：</strong></p><p>​二级缓存是用来解决一级缓存不能跨会话共享的问题的，范围是namespace 级别的，可以被多个SqlSession 共享（只要是同一个接口里面的相同方法，都可以共享），生命周期和应用同步。如果你的MyBatis使用了二级缓存，并且你的Mapper和select语句也配置使用了二级缓存，那么在执行select查询的时候，MyBatis会先从二级缓存中取输入，其次才是一级缓存，即MyBatis查询数据的顺序是：二级缓存  —&gt; 一级缓存 —&gt; 数据库。</p><p>MyBatis 用了一个装饰器的类来维护，就是CachingExecutor。如果启用了二级缓存，MyBatis 在创建Executor 对象的时候会对Executor 进行装饰。CachingExecutor 对于查询请求，会判断二级缓存是否有缓存结果，如果有就直接返回，如果没有委派交给真正的查询器Executor 实现类，比如SimpleExecutor 来执行查询，再走到一级缓存的流程。最后会把结果缓存起来，并且返回给用户。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420181235208.png" alt="image-20230420181235208" style="zoom:80%;" /><h3 id="开启二级缓存"><a href="#开启二级缓存" class="headerlink" title="开启二级缓存"></a>开启二级缓存</h3><p>开启二级缓存可以参考官方文档，里面有介绍。</p><p>1、开启全局缓存 【mybatis-config.xml】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--显式地开启全局缓存--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>2、去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br>官方示例=====&gt;查看官方文档<br><span class="hljs-tag">&lt;<span class="hljs-name">cache</span></span><br><span class="hljs-tag"> <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。<br></code></pre></td></tr></table></figure><p>3、代码测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryUserById</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>   <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session2</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><br>   <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>   <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> session2.getMapper(UserMapper.class);<br><br>   <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.queryUserById(<span class="hljs-number">1</span>);<br>   System.out.println(user);<br>   session.close();<br><br>   <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> mapper2.queryUserById(<span class="hljs-number">1</span>);<br>   System.out.println(user2);<br>   System.out.println(user==user2);<br><br>   session2.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>结果成功，类似上面。</p><p>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据；查出的数据都会被默认先放在一级缓存中；只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</p><p><strong>缓存原理图</strong></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420181252335.png" alt="image-20230420181252335" style="zoom:80%;" /><p><strong>第三方缓存EhCache</strong></p><p>MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存。以比较知名的EhCache为例：Ehcache是一种广泛使用的java分布式缓存，用于通用缓存；</p><p>要在应用程序中使用Ehcache，需要引入依赖的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.caches<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在mapper文件中写入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在当前的mapper中开启自定义二级缓存--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cache</span></span><br><span class="hljs-tag">        <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>编写ehcache.xml文件，如果在加载时未找到&#x2F;ehcache.xml资源或出现问题，则将使用默认配置。</p><p>【注】：详细的配置可以自行百度了解</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/wuzhenzhao/p/11103043.html">mybatis缓存机制</a></li><li><a href="https://blog.csdn.net/luanlouis/article/details/41280959">《深入理解mybatis原理》MyBatis的一级缓存实现详解 及使用注意事项</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis学习五-动态SQL</title>
    <link href="/20201003/3e64f5c6/"/>
    <url>/20201003/3e64f5c6/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>官方文档专门将动态SQL拿出来作为一个小节，可见其还是非常重要的，先看一下文档的描述：</p><blockquote><p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p><p>使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。</p><p>如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</p><hr><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><hr></blockquote><p>看了官方文档介绍，感觉就是：对于一些复杂SQL语句需要拼接，可能自己写的时候往往会漏个逗号多个标签之类的，而动态SQL通过上面的那些标签，可以自动的帮我们拼接</p><span id="more"></span><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>准备一个博客数据库，字段有id、作者、标题、时间、浏览量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `blog` (<br>`id` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;博客id&#x27;</span>,<br>`title` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;博客标题&#x27;</span>,<br>`author` <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;博客作者&#x27;</span>,<br>`create_time` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>`views` <span class="hljs-type">int</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;浏览量&#x27;</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></td></tr></table></figure><p>使用IDUtil工具类生成随机id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IDUtil</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">genId</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span> UUID.randomUUID().toString().replaceAll(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> String author;<br>    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-comment">//属性名和字段名不一致,(因为数据库的大小写转换)可以设置mapUnderscoreToCamelCase为true实现驼峰命名转换</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> views;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写接口和配置mapper文件，并在核心配置中注册mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BlogMapper</span> &#123;<br>    <span class="hljs-comment">//插入数据</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">addBlog</span><span class="hljs-params">(Blog blog)</span>;<br><br>    <span class="hljs-comment">//查询博客</span><br>    List&lt;Blog&gt; <span class="hljs-title function_">queryBlog</span><span class="hljs-params">(Map map)</span>;<br><br>    <span class="hljs-comment">//查询博客</span><br>    List&lt;Blog&gt; <span class="hljs-title function_">queryBlogChoose</span><span class="hljs-params">(Map map)</span>;<br><br>    <span class="hljs-comment">//更新博客</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateBlog</span><span class="hljs-params">(Map map)</span>;<br><br>    <span class="hljs-comment">//使用forEach遍历查询</span><br>    List&lt;Blog&gt; <span class="hljs-title function_">queryBlogForeach</span><span class="hljs-params">(Map map)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p><strong>需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</strong>。对应上面接口的<code>queryBlog</code>方法‘</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--需求1：</span><br><span class="hljs-comment">根据作者名字和博客名字来查询博客！</span><br><span class="hljs-comment">如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</span><br><span class="hljs-comment">select * from blog where title = #&#123;title&#125; and author = #&#123;author&#125;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogIf&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span><br>  select * from blog where<br>   <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>      title = #&#123;title&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>      and author = #&#123;author&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryBlog</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>        <span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BlogMapper.class);<br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-comment">//        map.put(&quot;title&quot;,&quot;Java如此简单&quot;);</span><br>        map.put(<span class="hljs-string">&quot;author&quot;</span>,<span class="hljs-string">&quot;狂神说&quot;</span>);<br>        List&lt;Blog&gt; blogList = mapper.queryBlog(map);<br>        <span class="hljs-keyword">for</span>(Blog blog:blogList)&#123;<br>            System.out.println(blog);<br>        &#125;<br><br>        sqlSession.close();<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title&#x3D;#{title},但是如果title为空呢？那么查询语句为 select * from user where<font color="red"> and </font>author&#x3D;#{author}，这是错误的 SQL 语句！如何解决呢？请看下面的 where 语句！</p><h3 id="where语句"><a href="#where语句" class="headerlink" title="where语句"></a>where语句</h3><p>修改上面的SQL语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogIf&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span><br>  select * from blog<br>   <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>          title = #&#123;title&#125;<br>       <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>          and author = #&#123;author&#125;<br>       <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。</p><p>测试类参照之前的代码</p><h3 id="set语句"><a href="#set语句" class="headerlink" title="set语句"></a>set语句</h3><p>同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行<strong>更新操作</strong>的时候，含有 set 关键词，我们怎么处理呢？对应接口中的<code>updateBlog</code>方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注意set是用的逗号隔开--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBlog&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>  update blog<br>     <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>            title = #&#123;title&#125;,<br>         <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>            author = #&#123;author&#125;<br>         <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>  where id = #&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">UpdateBlogTest</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>    <span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BlogMapper.class);<br><br>    <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    <span class="hljs-comment">//采用choose标签 默认匹配第一个就结束了</span><br>    map.put(<span class="hljs-string">&quot;title&quot;</span>,<span class="hljs-string">&quot;Mybatis如此简单2222&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;author&quot;</span>,<span class="hljs-string">&quot;狂神说2333&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>    mapper.updateBlog(map);<br><br>    sqlSession.commit();<br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="choose语句"><a href="#choose语句" class="headerlink" title="choose语句"></a>choose语句</h3><p>有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句，遇到一个满足条件的就返回了，对应接口的<code>queryBlogChoose</code>方法。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogChoose&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span><br>  select * from blog<br>   <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>                title = #&#123;title&#125;<br>           <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>              and author = #&#123;author&#125;<br>           <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>              and views = #&#123;views&#125;<br>           <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试类参照之前的代码</p><h3 id="提取SQL片段"><a href="#提取SQL片段" class="headerlink" title="提取SQL片段"></a>提取SQL片段</h3><p>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</p><p><strong>提取SQL片段：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;if-title-author&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>      title = #&#123;title&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>      and author = #&#123;author&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>引用SQL片段：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogIf&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span><br>  select * from blog<br>   <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;if-title-author&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Foreach语句"><a href="#Foreach语句" class="headerlink" title="Foreach语句"></a>Foreach语句</h3><p>将数据库中前三个数据的id修改为1,2,3；需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息，即遍历前三个数据项，对应接口<code>queryBlogForeach</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogForeach&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span><br>  select * from blog<br>   <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">       collection:指定输入对象中的集合属性</span><br><span class="hljs-comment">       item:每次遍历生成的对象</span><br><span class="hljs-comment">       open:开始遍历时的拼接字符串</span><br><span class="hljs-comment">       close:结束时拼接的字符串</span><br><span class="hljs-comment">       separator:遍历对象之间需要拼接的字符串</span><br><span class="hljs-comment">       select * from blog where 1=1 and (id=1 or id=2 or id=3)</span><br><span class="hljs-comment">     --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span>  <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;and (&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>          id=#&#123;id&#125;<br>       <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试类参照之前的代码</p><p><strong>我写的完整代码如下：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.liu8.dao.BlogMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addBlog&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>        insert into mybatis.blog (id, title, author, create_time, views)<br>        values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;if-title-author&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>            title = #&#123;title&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>            and author = #&#123;author&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlog&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>        select * from mybatis.blog<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;if-title-author&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogChoose&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>        select * from mybatis.blog<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>                    title = #&#123;title&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>                    and author = #&#123;author&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>                    and views = #&#123;views&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateBlog&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>        update mybatis.blog<br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>                title = #&#123;title&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span><br>                author = #&#123;author&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        select * from blog where 1=1 and ( id=1 or id=2 or id=3 );</span><br><span class="hljs-comment">        传入的Collection是由map提供的</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;queryBlogForeach&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>        select * from mybatis.blog<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;and (&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;or&quot;</span>&gt;</span><br>                id = #&#123;id&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><p>其实动态 sql 语句的编写主要问题就是拼接，所以我们可以先写出完整的原生sql语句，然后再根据动态SQL选择合适的标签将其划分！</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis学习四-一对多与多对一</title>
    <link href="/20201003/125ac04c/"/>
    <url>/20201003/125ac04c/</url>
    
    <content type="html"><![CDATA[<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>在实际开发中，实体对象之间的关联往往是很复杂的，在查询时往往需要连表查询！mybatis 提供了高级的关联查询功能，可以很方便地将数据库获取的结果集映射到定义的Java Bean 中。以老师和学生为例，一个班主任带着多个学生，多个学生属于一个班主任名下</p><span id="more"></span><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>建立学生、老师两张表用于测试，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `teacher` (<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> teacher(`id`, `name`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;秦老师&#x27;</span>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student` (<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`tid` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>KEY `fktid` (`tid`),<br><span class="hljs-keyword">CONSTRAINT</span> `fktid` <span class="hljs-keyword">FOREIGN</span> KEY (`tid`) <span class="hljs-keyword">REFERENCES</span> `teacher` (`id`)<br>) ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;小红&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;小张&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;小李&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `student` (`id`, `name`, `tid`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;小王&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><p>Lombok插件配合库函数可以省去我们自行编写构造函数、setter、getter方法的时间</p><p>1、IDEA安装Lombok插件（Plugin中搜索安装）</p><p>2、引入Maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="多对一情况"><a href="#多对一情况" class="headerlink" title="多对一情况"></a>多对一情况</h2><p>多个学生对同一个老师，就是从学生表去关联老师。</p><p>编写对应的pojo实体类，利用Lombok，添加注释简化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span> <span class="hljs-comment">//GET,SET,ToString，有参，无参构造</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>   <span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-comment">//多个学生可以是同一个老师，即多对一</span><br>   <span class="hljs-keyword">private</span> Teacher teacher;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写实体类对应的接口、以及对应的mapper映射文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentMapper</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TeacherMapper</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们要做的就是查询学生信息，但是学生表里，老师的信息只有外键<code>tid</code>，而不是具体的老师姓名，要查询到真实的信息，就需要做联表查询！</p><h3 id="1、按查询嵌套处理"><a href="#1、按查询嵌套处理" class="headerlink" title="1、按查询嵌套处理"></a>1、按查询嵌套处理</h3><p>通过查询嵌套来实现，就跟我们学数据库时，写的嵌套查询代码类似，是子查询</p><p>编写学生的StudentMapper接口，声明函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentMapper</span> &#123;<br><br>    <span class="hljs-comment">//查询所有的学生信息,以及对应的学生信息</span><br>    List&lt;Student&gt; <span class="hljs-title function_">getStudent</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写对应的StudentMapper.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.liu6.dao.StudentMapper&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">   需求：获取所有学生及对应老师的信息</span><br><span class="hljs-comment">   思路：</span><br><span class="hljs-comment">       1. 获取所有学生的信息</span><br><span class="hljs-comment">       2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息</span><br><span class="hljs-comment">       3. 思考问题——这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？</span><br><span class="hljs-comment">           &lt;1&gt;. 做一个结果集映射：StudentTeacher</span><br><span class="hljs-comment">           &lt;2&gt;. StudentTeacher结果集的类型为 Student</span><br><span class="hljs-comment">           &lt;3&gt;. 学生中老师的属性为teacher，对应数据库中为tid。</span><br><span class="hljs-comment">              多个 [1,...）学生关联一个老师=&gt; 一对一，一对多</span><br><span class="hljs-comment">           &lt;4&gt;. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询</span><br><span class="hljs-comment">   --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudents&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span>&gt;</span><br>    select * from student<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--association关联属性 property属性名 javaType属性类型 column表中的列名--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getTeacher&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">   这里传递过来的id，只有一个属性的时候，下面可以写任何值</span><br><span class="hljs-comment">   association中column多参数配置：</span><br><span class="hljs-comment">       column=&quot;&#123;key=value,key=value&#125;&quot;</span><br><span class="hljs-comment">       其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。</span><br><span class="hljs-comment">   --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;teacher&quot;</span>&gt;</span><br>      select * from teacher where id = #&#123;id&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在Mybatis核心配置中注册我们的mapper映射，然后编写Mytest测试代码测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">TestStudent</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br><br>    <span class="hljs-type">StudentMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentMapper.class);<br>    List&lt;Student&gt; studentList = mapper.getStudents2();<br>    <span class="hljs-keyword">for</span> (Student student : studentList)&#123;<br>        System.out.println(<br>            <span class="hljs-string">&quot;学生名:&quot;</span>+ student.getName()<br>            +<span class="hljs-string">&quot;\t老师:&quot;</span>+student.getTeacher().getName());<br>    &#125;<br><br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420180916297.png" alt="image-20230420180916297" style="zoom:80%;" /><h3 id="2、按结果嵌套查询"><a href="#2、按结果嵌套查询" class="headerlink" title="2、按结果嵌套查询"></a>2、按结果嵌套查询</h3><p>除了将查询语句嵌套，也可以按结果进行嵌套。</p><p>在接口中增加方法，并编写对应的mapper映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Student&gt; <span class="hljs-title function_">getStudents2</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">按查询结果嵌套处理</span><br><span class="hljs-comment">思路：</span><br><span class="hljs-comment">   1. 直接查询出结果，进行结果集的映射</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudents2&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;StudentTeacher2&quot;</span> &gt;</span><br>  select s.id sid, s.name sname , t.name tname<br>  from student s,teacher t<br>  where s.tid = t.id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;StudentTeacher2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span><br>   <span class="hljs-comment">&lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写测试代码并测试（就是将上面的代码，由getStudent改为getStudent2即可），结果一样</p><ul><li>按照查询进行嵌套处理就像SQL中的子查询</li><li>按照结果进行嵌套处理就像SQL中的联表查询</li></ul><h2 id="一对多情况"><a href="#一对多情况" class="headerlink" title="一对多情况"></a>一对多情况</h2><p>从学生的角度去看问题，就是多对一，那么从老师的角度去看，就刚好反过来，成了一对多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tid;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-comment">//一个老师多个学生</span><br>   <span class="hljs-keyword">private</span> List&lt;Student&gt; students;<br>&#125;<br></code></pre></td></tr></table></figure><p>在teacher接口中增加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取指定老师，及老师下的所有学生</span><br><span class="hljs-keyword">public</span> Teacher <span class="hljs-title function_">getTeacher</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure><p>编写对应的mapper文件，同样会有两种方式去实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.kuang.mapper.TeacherMapper&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!--按结果嵌套处理--&gt;</span><br>   <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">   思路:</span><br><span class="hljs-comment">       1. 从学生表和老师表中查出学生id，学生姓名，老师姓名</span><br><span class="hljs-comment">       2. 对查询出来的操作做结果集映射</span><br><span class="hljs-comment">           1. 集合的话，使用collection！</span><br><span class="hljs-comment">               JavaType和ofType都是用来指定对象类型的</span><br><span class="hljs-comment">               JavaType是用来指定pojo中属性的类型</span><br><span class="hljs-comment">               ofType指定的是映射到list集合属性中pojo的类型。</span><br><span class="hljs-comment">   --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span>&gt;</span><br>      select s.id sid, s.name sname , t.name tname, t.id tid<br>      from student s,teacher t<br>      where s.tid = t.id and t.id=#&#123;id&#125;<br>   <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherStudent&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">result</span>  <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <br>    <br>    <span class="hljs-comment">&lt;!--按查询嵌套处理--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher2&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;TeacherStudent2&quot;</span>&gt;</span><br>    select * from teacher where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;TeacherStudent2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;ArrayList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getStudentByTeacherId&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudentByTeacherId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span><br>      select * from student where tid = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>小结</strong></p><p>在一对多和多对一中，主要用到了标签<code>association</code>和<code>collection</code>，association是用于一对一和多对一，而collection是用于一对多的关系</p><p>JavaType和ofType都是用来指定对象类型的</p><ul><li>JavaType是用来指定pojo中属性的类型</li><li>ofType指定的是映射到list集合属性中pojo的类型。</li></ul><p>一对多和多对一是实际开发中很重要的部分，也是比较难的一块，光看视频和课堂的代码，还是不足以透彻理解啊，还是要多练习啊。。。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis学习三-注解开发</title>
    <link href="/20201003/c325d665/"/>
    <url>/20201003/c325d665/</url>
    
    <content type="html"><![CDATA[<h2 id="依赖倒转原则-DIP"><a href="#依赖倒转原则-DIP" class="headerlink" title="依赖倒转原则(DIP)"></a>依赖倒转原则(DIP)</h2><p>在面向对象分析与设计中，有一个很重要的原则——依赖倒转原则，定义如下</p><blockquote><p>高层模块不应该依赖低层模块，它们都应该依赖抽象；抽象不应该依赖于细节；细节应该依赖于抽象。</p><p>另一种表述：<strong>要针对接口编程，不要针对实现编程。</strong></p></blockquote><p>DIP是6大原则中最难以实现的原则，它是实现开闭原则的重要途径。关键仍然是”抽象”，抽象属于高层，细节属于低层，低层依赖于高层，而不是高层依赖于低层，这正是依赖倒置的真谛。</p><p>依赖倒转的好处</p><ul><li>可以通过抽象使各个类或模块的实现彼此独立，不互相影响，<strong>实现模块间的松耦合（也是本质）</strong>；</li><li>可以规避一些非技术因素引起的问题（例如需求变化导致的工作量剧增的情况）</li><li>可以促进并行开发</li></ul><span id="more"></span><p>【注】：依赖的三种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、构造函数传递依赖对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IDriver</span>&#123;<br><span class="hljs-comment">//是司机就应该会驾驶汽车</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IDriver</span>&#123;<br><span class="hljs-keyword">private</span> ICar car;<br><span class="hljs-comment">//构造函数注入</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Driver</span><span class="hljs-params">(ICar _car)</span>&#123;<br><span class="hljs-built_in">this</span>.car = _car;<br>&#125;<br><span class="hljs-comment">//司机的主要职责就是驾驶汽车</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">this</span>.car.run();<br>&#125;<br>&#125;<br><span class="hljs-comment">//2--Setter方法传递依赖对象 </span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IDriver</span> &#123;<br><span class="hljs-comment">//车辆型号</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCar</span><span class="hljs-params">(ICar car)</span>;<br><span class="hljs-comment">//是司机就应该会驾驶汽车</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IDriver</span>&#123;<br><span class="hljs-keyword">private</span> ICar car;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCar</span><span class="hljs-params">(ICar car)</span>&#123;<br><span class="hljs-built_in">this</span>.car = car;<br>&#125;<br><span class="hljs-comment">//司机的主要职责就是驾驶汽车</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">this</span>.car.run();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><p><strong>mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建</strong></p><p>常见的sql语句的对应注解：</p><ul><li>@select ()</li><li>@update ()</li><li>@Insert ()</li><li>@delete ()</li></ul><p><strong>【注】：</strong>利用注解开发就不需要mapper.xml映射文件了。</p><p>为接口添加注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/9/18 15:45</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from user&quot;)</span><br>    List&lt;User&gt; <span class="hljs-title function_">getUsers</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//方法存在多个参数时 所有参数前面必须加上@Param注解</span><br>    <span class="hljs-meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span><br>    User <span class="hljs-title function_">getUserByID</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span><span class="hljs-type">int</span> id2)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在mybatis的核心配置文件中注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--绑定接口--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;liu5.dao.UserMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> liu5.dao.UserMapper;<br><span class="hljs-keyword">import</span> liu5.pojo.User;<br><span class="hljs-keyword">import</span> liu5.utils.MybatisUtils;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/9/21 15:31</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserMapperTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>        <span class="hljs-comment">//Deubg可以看到：底层是通过反射实现的</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br><br>        List&lt;User&gt; userList = mapper.getUsers();<br>        <span class="hljs-keyword">for</span>(User user:userList)&#123;<br>            System.out.println(user);<br>        &#125;<br><br>        <span class="hljs-type">User</span> <span class="hljs-variable">userByID</span> <span class="hljs-operator">=</span> mapper.getUserByID(<span class="hljs-number">1</span>);<br>        System.out.println(userByID);<br><br>        sqlSession.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和之前的测试结果一样：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420180707145.png" alt="image-20230420180707145" style="zoom:67%;" /><blockquote><p>另外三个接口注释和这个类似</p></blockquote><p>利用Debug查看</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420180721396.png" alt="image-20230420180721396" style="zoom:80%;" /><h3 id="Mybatis的执行流程"><a href="#Mybatis的执行流程" class="headerlink" title="Mybatis的执行流程"></a>Mybatis的执行流程</h3><p>由上及之前的学习可知，Mybatis的执行流程如图（图片来自狂神公众号文章）：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Mybatis-annotation3.png" alt="Mybatis-annotation3" style="zoom:80%;" /><p>将注解与配置文件协同编程最能有助于我们的开发！</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybaits学习二:Mybatis配置文件</title>
    <link href="/20200928/80bab4e7/"/>
    <url>/20200928/80bab4e7/</url>
    
    <content type="html"><![CDATA[<p>Mybatis最重要的就是它的配置，而配置包含了Mybatis的至关重要的设置和属性等信息，官方文档中也专门给出一节来讲配置文件。本篇博客也是以<a href="https://mybatis.org/mybatis-3/zh/">官方中文文档</a>为主要依据记笔记</p><p>可以ctrl+鼠标左键查看mybatis-config.xml头部的dtd头文件，点进去可以看到配置文件的element。MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：</p><ul><li>configuration（配置）<ul><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li><li>environments（环境配置）<ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li></ul></li></ul><p><font color="red">注：元素节点顺序是按照上面固定的，顺序错了会报错！</font></p><p>（下面的学习顺序并不是按照结构来的，而是按照学习视频的代码去学的）</p><span id="more"></span><h3 id="环境配置（environments）"><a href="#环境配置（environments）" class="headerlink" title="环境配置（environments）"></a>环境配置（environments）</h3><p>用于配置数据库运行的环境，我们可以配置多个，实现将SQL映射到多个不同的数据库上，至于具体在哪一个上运行，通过<code>default=&quot; &quot;</code>来设置</p><p>子元素节点<code>environment</code>就是一套环境，常见属性如下：</p><ul><li>事务管理器<code>transactionManager</code>的配置（比如：type&#x3D;”JDBC”）。</li><li>数据源<code>dataSource</code>的配置（比如：type&#x3D;”POOLED”）。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;leslie61&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>数据源有三种内建类型：<code>type=&quot;[UNPOOLED|POOLED|JNDI]&quot;</code><ul><li>unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。</li><li><strong>pooled</strong>：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</li><li>jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</li><li>数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等….</li></ul></li><li>在 MyBatis 中有两种类型的事务管理器（也就是 type&#x3D;”[JDBC|MANAGED]”）：<ul><li>JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。</li><li>MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将<code> closeConnection</code> 属性设置为 false 来阻止默认的关闭行为。</li></ul></li></ul><p>更多详细的信息可以查阅<a href="https://mybatis.org/mybatis-3/zh/">官方中文文档</a>~</p><h3 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h3><p>官方文档的解释如下：</p><blockquote><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等。</p></blockquote><p>解释一下：MyBatis 是基于 sql 映射配置的框架，sql 语句都写在 Mapper 配置文件【即<code>UserMapper.xml</code>之类的文件】中，当构建 SqlSession 类之后，就需要去读取 Mapper 配置文件中的 sql 配置。而 mappers 标签就是用来配置需要加载的 sql 映射配置文件路径的。</p><p>常见的四种引入Mapper资源方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用相对于类路径的资源引用,表示文件夹下的xml文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用映射器接口实现类的完全限定类名,通过动态代理接口找到*.xml文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.builder.PostMapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 使用完全限定资源定位符（URL）,绝对路径查找,不推荐使用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:///var/mappers/BlogMapper.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file:///var/mappers/PostMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis.builder&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这些配置会告诉 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了，这就是下一篇SQL映射文件的内容了</p><h3 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h3><p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。</p><p>以我们的项目为例，资源目录下新建文件<code>db.properties</code>，代码如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span> = <span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">url</span> = <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8</span><br><span class="hljs-attr">username</span> = <span class="hljs-string">root</span><br><span class="hljs-attr">password</span> = <span class="hljs-string">leslie61</span><br><span class="hljs-attr">//看着很眼熟？内容其实就是mybatis-config.xml中datasource标签下的property部分啊</span><br></code></pre></td></tr></table></figure><p>将编写的文件导入：通过<code>properties</code>标签引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--引入外部配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;leslie61&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引入<code>db.properties</code>文件目的就是为了替换需要动态配置的属性值，原来的<code>driver、url、username、password</code>属性的value被文件中对应的value替换。</p><p>如果一个属性出现在多个地方，那么Mybatis的加载顺序：</p><ul><li>首先读取在 properties 元素体内指定的属性。</li><li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。</li><li>最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。</li></ul><p>因此，通过方法参数传递的属性具有最高优先级，resource&#x2F;url 属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。</p><h3 id="类型别名（typeAliases）"><a href="#类型别名（typeAliases）" class="headerlink" title="类型别名（typeAliases）"></a>类型别名（typeAliases）</h3><p>这个比较简单，就是为pojo设置别名，正常情况下我们的代码，用到实体类都要写明路径，使用别名就可以简化操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在核心配置文件中--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.liu2.pojo.User&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--原来的文件</span><br><span class="hljs-comment">&lt;select id=&quot;selectUser&quot; resultType=&quot;com.liu2.pojo.User&quot; &gt;</span><br><span class="hljs-comment">  select * from user</span><br><span class="hljs-comment">&lt;/select&gt;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-comment">&lt;!--mapper.xml文件中简化使用--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span> &gt;</span><br>  select * from user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当然，除了这种<code>type alias</code>方式指定别名，也可以使用<code>name</code>指定一个包名，Mybatis会在包名下搜索需要的Java Bean，没有注解的情况下采用首字母小写的非限定性类名作为别名。</p><h3 id="其他配置浏览"><a href="#其他配置浏览" class="headerlink" title="其他配置浏览"></a>其他配置浏览</h3><p>以上是一些主要的常用配置属性，下面是一些比较重要的</p><h4 id="设置（settings）"><a href="#设置（settings）" class="headerlink" title="设置（settings）"></a>设置（settings）</h4><p>中文文档：这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p><p>常见实现：</p><ul><li>懒加载</li><li>日志的实现</li><li>缓存开启关闭</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;multipleResultSetsEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useColumnLabel&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;useGeneratedKeys&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;PARTIAL&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;autoMappingUnknownColumnBehavior&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;WARNING&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultExecutorType&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SIMPLE&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultStatementTimeout&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;25&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultFetchSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;safeRowBoundsEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localCacheScope&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SESSION&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcTypeForNull&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;OTHER&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="类型处理器（typeHandlers）"><a href="#类型处理器（typeHandlers）" class="headerlink" title="类型处理器（typeHandlers）"></a>类型处理器（typeHandlers）</h4><p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。</p><p>我们也可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。</p><p>更多内容可以参看<a href="https://mybatis.org/mybatis-3/zh/">官方中文文档</a>~</p><h3 id="生命周期和作用域"><a href="#生命周期和作用域" class="headerlink" title="生命周期和作用域"></a>生命周期和作用域</h3><p>首先应该先说执行的过程：</p><ol><li>创建SqlSessionFactoryBuilder对象，调用build(inputstream)方法读取并解析配置文件，返回SqlSessionFactory对象</li><li>由SqlSessionFactory创建SqlSession 对象，没有手动设置的话事务默认开启</li><li>调用SqlSession中的api，传入Statement Id和参数，内部进行复杂的处理，最后调用jdbc执行SQL语句，封装结果返回。</li></ol><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420180557703.png" alt="image-20230420180557703" style="zoom: 70%;" /><p>关于作用域狂神说的挺好的，我就直接引用了</p><p><strong>作用域理解</strong></p><ul><li>SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 <strong>SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域</strong>（也就是局部方法变量）。</li><li>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。</li><li>由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。</li><li>因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 <strong>SqlSessionFactory 的最佳作用域是应用作用域。</strong></li><li>如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。</li><li><strong>所以 SqlSession 的最佳的作用域是请求或方法作用域。</strong></li></ul><p>它们之间的结构联系、生命周期如图：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420180611134.png" alt="image-20230420180611134" style="zoom:80%;" /><p>其实看过配置文件，多写几个demo后，就会发现常用的还是那几个，其他的配置文件感觉都是了解为主，有问题随时去<a href="https://mybatis.org/mybatis-3/zh/">官方中文文档</a>查阅，主要还是要理解配置文件怎么整、Mybatis的执行过程和它们的关系！</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/20200928/0/"/>
    <url>/20200928/0/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>学习Java必学SSM，先上手Mybatis！我是跟着B站的UP<a href="https://space.bilibili.com/95256449?spm_id_from=333.788.b_765f7570696e666f.2">狂神说</a>的视频学习，所以笔记也按照他的视频来记录。视频学习和笔记都是根据<a href="https://mybatis.org/mybatis-3/zh/index.html">Mybatis官方中文文档</a>进行</p><p>以下是Mybatis官方中文文档关于Mybatis的简介</p><blockquote><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO【Plain Old Java Objects，普通老式 Java 对象】为数据库中的记录。</p></blockquote><ul><li>Mybatis官方文档 : <a href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a></li><li>GitHub : <a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></li></ul><span id="more"></span><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a><strong>持久化</strong></h4><p><strong>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</strong></p><p>简而言之就是把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。Java中的JDBC和文件IO就是常见的持久化机制</p><p><strong>为什么需要持久化服务呢？</strong></p><p>内存的特性就是断电数据丢失，所以重要的数据不能放在内存；其次内存成本过高，用内存做数据存储性价比很低</p><h4 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h4><p><strong>什么是持久层？</strong></p><p>介绍持久层就要提到Java的分层模型。以典型的MVC架构为例——模型Model、视图View、控制器Controller相分离，Model代表一个存取数据的对象或 JAVA POJO；View代表模型包含的数据的可视化。Controller作用于模型和视图上，它控制数据流向模型对象，并在数据变化时更新视图。</p><p>对应的分层就是表示层UI、业务逻辑层BLL、数据持久层DAO。</p><p>使用分层框架可以将重复繁琐的内容封装，屏蔽细节简化程序，使得程序员可以专注于业务层面，提高开发效率！</p><ul><li>完成持久化工作的代码块 .  —-&gt;  dao层 【DAO (Data Access Object)  数据访问对象】</li><li>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。</li><li>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.</li><li>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】</li></ul><h4 id="使用Mybatis的原因"><a href="#使用Mybatis的原因" class="headerlink" title="使用Mybatis的原因"></a>使用Mybatis的原因</h4><p>传统的JDBC代码在配置、编写语句等方面非常繁琐，并且频繁的打开和释放连接对资源的消耗也较大，使用MyBatis的目的就是为了简化我们重复的操作</p><ul><li><p>MyBatis的优点</p><ul><li>MyBatis 是一个半自动化的<strong>ORM框架Object Relationship Mapping【对象关系映射</strong>】，解决面向对象编程模型和关系型数据库模型之间的映射问题</li></ul></li><li><ul><li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li><li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li><li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li><li>提供xml标签，支持编写动态sql。</li></ul></li></ul><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><p>准备Mybatis–&gt;创建相应Java项目–&gt;编写项目及配置文件–&gt;测试</p><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>本项目是利用Mybatis对数据库操作，所以需要以下准备：</p><ul><li>数据库环境</li><li>Mybatis相关jar包</li></ul><p>创建数据库的语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE `mybatis`;<br>USE `mybatis`;<br>DROP TABLE IF EXISTS `user`;<br><br>CREATE TABLE `user` (<br>`id` int(20) NOT NULL,<br>`name` varchar(30) DEFAULT NULL,<br>`pwd` varchar(30) DEFAULT NULL,<br>PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8;<br><br>insert  into `user`(`id`,`name`,`pwd`) values (1,&#x27;狂神&#x27;,&#x27;123456&#x27;),(2,&#x27;张三&#x27;,&#x27;abcdef&#x27;),(3,&#x27;李四&#x27;,&#x27;987654&#x27;);<br></code></pre></td></tr></table></figure><p>关于Mybatis：Mybatis原本是apache项目，原来被叫做 ibatis。后来移植到google code，改名为mybatis。现在在github（开源软件托管平台）脱光，官网：<a href="https://github.com/mybatis/mybatis-3/releases%E3%80%82">https://github.com/mybatis/mybatis-3/releases。</a></p><p>提示：由于本项目使用maven管理，所以可以在<a href="https://mvnrepository.com/">mvnrepository</a>中搜索导入相应的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="编写核心配置文件"><a href="#编写核心配置文件" class="headerlink" title="编写核心配置文件"></a>编写核心配置文件</h3><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。所以我们的第一步就是编写对应的核心配置文件<code>mybatis-config.xml</code></p><p>关于核心配置文件内容在官方文档中就有，只需要将它复制过来就行，然后设置具体的参数（关于配置文件的内容详细再下一篇介绍，这里主要是为了能快速跑起来第一个Mybatis程序）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420180454288.png" alt="image-20230420180454288" style="zoom:80%;" /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">    <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">    <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;leslie61&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/liu/dao/userMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当然，还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 注意 XML 头部的声明，它用来验证 XML 文档的正确性。environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。</p><p>注：也可以不使用xml构建SqlSessionFactory，不过推荐还是用xml，更直观便捷！</p><h3 id="编写Mybatis工具类"><a href="#编写Mybatis工具类" class="headerlink" title="编写Mybatis工具类"></a>编写Mybatis工具类</h3><p>查看官方文档，找到怎样<code>从 XML 中构建 SqlSessionFactory</code>，然后就可以创建一个<code>utils</code>的package存放工具类，实际编写中要注意一点细节</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420180358676.png" alt="image-20230420180358676"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liu.utils;<br><br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/9/18 11:37</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: Mybatis工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisUtils</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//获取SqlSession连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注：刚开始我遇到的问题</p><ul><li><code>getResourceAsStream</code>报异常，捕获一下就行</li><li><code>try-catch</code>用<code>static</code>修饰，不然运行时会报空指针异常<code>NullPointerException</code></li></ul><h3 id="创建实体类POJO"><a href="#创建实体类POJO" class="headerlink" title="创建实体类POJO"></a>创建实体类POJO</h3><p>创建我们要操作的对象实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liu.pojo;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/9/18 15:42</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String pwd;<br><br>    <span class="hljs-comment">//构造方法、set、get方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="编写Mapper接口类"><a href="#编写Mapper接口类" class="headerlink" title="编写Mapper接口类"></a>编写Mapper接口类</h3><p>mapper接口只是为了声明相应的函数，具体的执行代码要去mapper.xml中进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liu.dao;<br><br><span class="hljs-keyword">import</span> com.liu.pojo.User;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/9/18 15:45</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    <span class="hljs-comment">//查询全部用户</span><br>    List&lt;User&gt; <span class="hljs-title function_">selectUser</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="编写Mapper-xml配置文件"><a href="#编写Mapper-xml配置文件" class="headerlink" title="编写Mapper.xml配置文件"></a>编写Mapper.xml配置文件</h3><p>编写对应函数的执行代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.liu.dao.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.liu.pojo.User&quot;</span> &gt;</span><br>  select * from user<br> <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Mapper.xml中 标签的id即为Mapper中的函数名，一定要对应正确！</p><p>编写好的Mapper.xml要去核心配置文件中注册！！！也就是上面mybatis-config.xml中<code>&lt;mappers&gt;&lt;mappers&gt;</code>那一部分的代码</p><h3 id="测试类测试"><a href="#测试类测试" class="headerlink" title="测试类测试"></a>测试类测试</h3><p>测试类基本步骤：创建SqlSession；通过SqlSession获取对应mapper对象，并运行mapper映射的SQL语句；关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.liu2.dao;<br><br><span class="hljs-keyword">import</span> com.liu.dao.UserMapper;<br><span class="hljs-keyword">import</span> com.liu.pojo.User;<br><span class="hljs-keyword">import</span> com.liu.utils.MybatisUtils;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.log4j.Logger;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/9/18 16:01</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//第一步：获取执行SqlSession的对象</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> MybatisUtils.getSession();<br>        <span class="hljs-comment">//方法一:</span><br>        <span class="hljs-comment">//List&lt;User&gt; users = session.selectList(&quot;com.liu.dao.UserMapper.selectUser&quot;);</span><br>        <span class="hljs-comment">//方法二:</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(UserMapper.class);<br>        List&lt;User&gt; users = mapper.selectUser();<br><br>        <span class="hljs-keyword">for</span> (User user: users)&#123;<br>            System.out.println(user);<br>        &#125;<br>        <span class="hljs-comment">//关闭SqlSession</span><br>        session.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码，得到结果：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420180518646.png" alt="image-20230420180518646" style="zoom:80%;" /><p>第一个Mybatis程序就算跑起来了！</p><p>整体的流程也相对固定：环境–&gt;配置文件<code>mybatis-config.xml</code>–&gt;编写Mybatis的工具类、创建实体类pojo–&gt;编写Mapper接口类和映射的的mapper.xml配置文件–&gt;测试</p><p>一开始也磕磕绊绊的踩了不少坑，不过越学越感觉得到Mybatis的简单灵活~</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象分析与设计——用例</title>
    <link href="/20200820/b3526665/"/>
    <url>/20200820/b3526665/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是用例？"><a href="#什么是用例？" class="headerlink" title="什么是用例？"></a>什么是用例？</h3><ul><li>“一组用例的实例，其中每个实例都是系统执行的一系列活动，这些活动产生了对每个参与者而言可观察的返回值”（RUP）。</li><li>描述了从参与者（Actor）角度看系统（黑盒子）做了什么 WHAT。</li><li><strong>用例是文本形式的情节描述，用以说明某参与者使用系统以实现某些目标。</strong>常见错误就是注重于次要的UML用例图，而非重要的用例文本</li></ul><span id="more"></span><h3 id="用例的好处"><a href="#用例的好处" class="headerlink" title="用例的好处"></a><strong>用例的好处</strong></h3><ul><li>从用户的角度获取操作性需求。</li><li>对系统的功能进行清晰而一致的描述。</li><li>系统测试的基础。</li><li>提供了从功能需求跟踪到系统中真正的类和操作的能力。</li></ul><p>定义：参与者、场景、用例</p><ul><li><p>参与者（actor） 是某些具有行为的事物，可以是人（由角色标识）、计算机系统或组织，例如：收银员。</p></li><li><p>场景(scenario) 是参与者和系统之间的一系列特定的活动和交互。也称为用例实例（use case instance）。场景是使用系统的一个特定情节或用例的一条执行路径。例如：使用现金成功购买商品的场景，或者由于信用卡付款而拒绝照成的购买失败场景。</p></li><li><p>用例(use case)  就是一组相关的成功和失败场景集合，用来描述参与者如何使用系统来实现其目标。例如：处理退货（主成功场景，交替场景）。</p></li><li><p>用例和用例模型</p><ul><li>在需求科目中定义了用例模型（Use-Case Model）。首先，这是所有书面用例的集合；同时，它是系统功能性和环境的模型。 用例是文本文档，而非图形；用例建模主要是编写文本的活动，而非制图。</li></ul></li></ul><h3 id="动机：为什么使用用例"><a href="#动机：为什么使用用例" class="headerlink" title="动机：为什么使用用例"></a>动机：为什么使用用例</h3><ul><li><p>需求是很难捕获且易变的</p><img src="https://img.mubu.com/document_image/beb6a533-b979-4735-bb5f-ed83661a10fa-7976057.jpg" alt="img" style="zoom:67%;" /></li><li><p>使工作保持简单的好方法。</p></li><li><p>使领域专家或需求提供者自己编写（或参与编写）用例成为可能。</p></li><li><p>强调了用户的目标和观点。</p></li><li><p>与查询系统特性清单相比更强调以客户为中心。</p></li><li><p>用例的优越性在于能够根据需要对复杂程度和形式化程度进行增减删节。</p></li></ul><p>用例是功能需求吗？用例是：</p><ul><li>需求，主要是说明系统如何工作的功能性或行为性需求。</li><li>FURPS+中的F。用例强调了”F”(功能性和行为性)。</li><li>在UP中，用例被推荐作为发现和定义需求的核心机制。</li><li>用例定义了系统行为的契约。</li><li>用例是真正的需求（尽管不是所有的需求）。</li></ul><h3 id="参与者的三种类型"><a href="#参与者的三种类型" class="headerlink" title="参与者的三种类型"></a>参与者的三种类型</h3><p>参与者是任何具有行为的事物，在所讨论系统（System under Discussion,SuD）调用其他系统的服务时，还包括其自身。 </p><ul><li><strong>主要参与者</strong>： 具有用户目标，并通过使用SuD的服务完成。通常用来发现驱动用例的用户目标。</li><li><strong>协助参与者</strong>：为SuD提供服务（例如，信息服务）。自动付费授权服务即是一例。协助参与者通常是计算机系统，但也可以是组织或人。协助参与者通常是为了明确外部接口和协议。<ul><li>为何确定协助参阅者？为了明确外部接口或利益。</li></ul></li><li><strong>幕后参与者</strong>：在用例行为中具有影响或利益，但不是主要或协助参与者。例如，政府收税机构。通常是为了确保确定并满足所有必要的重要事物。如果不明确地对幕后参与者进行命名，则有时很容易忽略其影响或利益。</li></ul><h3 id="用例的三种形式"><a href="#用例的三种形式" class="headerlink" title="用例的三种形式"></a>用例的三种形式</h3><p><strong>摘要</strong>－－简洁的一段式概要，通常用于主成功场景。</p><p>》何时使用？在早期需求分析过程中，为快速了解主体和范围使用。可能只需要几分钟编写。</p><p><strong>非正式</strong>－－非正式的段落格式。用几个段落覆盖不同场景。</p><p>》何时使用？同上。</p><p><strong>详述</strong>－－详细编写所有步骤及各种变化，同时具有补充部分，如前置条件和成功保证。</p><p>》何时使用？确定并以摘要形式编写了大量用例后，在第一次需求讨论会中，详细地编写其中少量的具有重要架构和高价值的用例。</p><h4 id="详述风格"><a href="#详述风格" class="headerlink" title="详述风格"></a>详述风格</h4><p>详述用例是结构化的，它展示更多细节，并且更为深入。最为广泛的格式（alistair.cockburn.us上的模板）：</p><ul><li>用例名称：以动词开始</li><li>范围：界定了所要设计的系统</li><li>级别：用户目标级别或子功能级别（重用，如信用卡支付）。</li><li>主要参与者：调用系统，使之交付服务</li><li>涉众及其关注点列表：关注该用例的人及其需要。重要！能够让我们更清楚详细的系统职责</li><li>前置条件：值得告知读者的，开始前必须为真的条件</li><li>成功保证：值得告知读者的，成功完成必须满足的条件</li><li>主成功场景：典型的、无条件的、理想方式的成功场景。§描述了满足涉众关注点的典型成功路径。通常不包括条件或分支。将所有条件和分支延迟到扩展部分进行说明。</li><li>扩展：成功或失败的替代场景</li><li>特殊需求：相关的非功能需求</li><li>技术和数据变元表：不同的I&#x2F;O方法和数据格式</li><li>发生频率：影响对实现的调查、测试和时间安排</li><li>杂项：例如未解决问题。</li></ul><p>书上例子——<strong>《举例——详述的处理销售》</strong>要好好看看理解</p><h3 id="用例准则：以无用户界面的本质风格编写用例"><a href="#用例准则：以无用户界面的本质风格编写用例" class="headerlink" title="用例准则：以无用户界面的本质风格编写用例"></a><strong>用例准则：以无用户界面的本质风格编写用例</strong></h3><ul><li><font color="red"><strong>以本质风格编写用例</strong>，摒除用户界面并且关注参与者的意图。</font></li><li>具体风格－－用例文本涵盖对用户界面的决策。在早期需求工作中应该避免。</li><li>举例：假设在<code>管理用户</code>用例中需要标识身份和认证<ul><li>本质风格：1.管理员标识自己的身份 2.系统对此身份进行验证3. 。。。。。。</li><li>具体风格：1.管理员在对话框中输入ID和口令 2.系统对管理员进行验证 3.系统显示“编辑用户”界面 4.……</li></ul></li><li>摈除用户界面于考虑之外，集中于意图。</li><li><font color="red"><strong>编写简洁的用例</strong>，删除噪音词汇</font></li><li><font color="red"><strong>编写黑盒用例</strong></font>，不对系统内部工作、构件或设计进行描述，通过职责描述系统。</li><li><font color="red"><strong>采用参与者和参与者目标的视点</strong> </font></li></ul><h3 id="如何发现用例-基本过程"><a href="#如何发现用例-基本过程" class="headerlink" title="如何发现用例(基本过程)"></a>如何发现用例(基本过程)</h3><ul><li><strong>①选择系统边界</strong> 系统紧紧是软件应用，还是将硬件和作用作为整体，是一个人使用，还是整个组织使用。</li><li><strong>②寻找主要参与者</strong> 通过使用系统的服务实现目标的人或事。</li><li><strong>③为每个参与者确定他们的目标</strong>。</li><li><strong>④定义满足用户目标的用例，根据其目标对用例命名。</strong>通常，用户目标级别的用例和用户目标是一一对应的。</li></ul><h4 id="发现用例详细步骤"><a href="#发现用例详细步骤" class="headerlink" title="发现用例详细步骤"></a>发现用例详细步骤</h4><ul><li>如何发现用例——选择系统边界<ul><li>系统的边界用来说明构建的用例模型的应用范围。</li><li>描述了系统被包含在内的“信封”。</li><li>比如一台自助式售货机，系统内功能：售货、供货、提取销售款等功能，自动售货机之外的情况不考虑。</li></ul></li><li><font color="red"><strong>如何发现用例——寻找主要参与者和目标</strong> </font><ul><li>参与者是与系统交换数据的实体。参与者可以是用户，外部的硬件或者另外一个系统。</li><li>准则：首先集体讨论主要参与者，因为这样可以为将来的研究建立框架。</li><li><font color="red"><strong>什么样的问题有助于寻找参与者和目标：</strong> </font><ul><li>谁来启动和停止系统。</li><li>谁来完成用户管理和安全管理。</li><li>谁来完成系统管理。</li><li>“时间”是管理者吗。因为系统要响应时间事件而完成某些活动。</li><li>系统失败时，是否存在监控进程将系统重新启动。</li><li>软件升级是如何处理的，是推模式还是拉模式。</li><li>除了人作为主要参与者外，还有其他外部的软件或自动机器系统调用该系统的服务吗。</li><li>谁来考察系统活动或性能。</li><li>谁来考察日志，是否可以远程检索。</li><li>系统发生错误或故障时应通知谁。</li></ul></li><li>如何组织参与者和目标<ul><li>发现结果，将其绘制为用例图，以目标作为用例名称。</li><li>或者：首先写出参与者-目标列表，复查并精华之，然后绘制用例图。</li></ul></li></ul></li><li>如何发现用例——定义用例<ul><li>一般而言，为每一个用户目标定义用例。</li><li>定义用例需要交流和参与</li><li>用例的粒度问题</li></ul></li></ul><h3 id="利用测试发现有用的用例"><a href="#利用测试发现有用的用例" class="headerlink" title="利用测试发现有用的用例"></a>利用测试发现有用的用例</h3><p><strong>老板测试</strong>：老板是付钱的人。老板必须看到可量化的价值。</p><p><strong>EBP测试</strong>：EBP即基本业务过程（Elementary Business Process），定义如下： 一个人于某个时刻在一个地点所执行的行为，用以响应业务事件。该任务能够增加可量化的价值，并且以持久状态留下数据。例如，批准信用卡的信用额或者确定订购的价格。ERP测试与老板测试类似，尤其是对业务价值可量化这一限制而言。用例是在会话过程中完成的任务。用例可能只需几分钟或一个小时就能完成。正如UP的定义，用例增强可观察或可量化的业务价值，由此形成了这样的解释：系统和数据具有稳定和持久状态。</p><p><strong>规模测试</strong>：用例很少由单独的活动或步骤组成，相反，用例通常应该包括多个步骤</p><p>应用UML: 用例图</p><ul><li>在UML里, 用例图是表达用例和活动者及其之间关系的载体。</li><li>用例图是模型图，用例图可包含用例，活动者以及它们之间的关系，这些关系可以是：<ul><li>include(包含）</li><li>extend （扩展）</li><li>generalization（泛化）</li></ul></li><li>用例图的用途是为软件系统、软件子系统、类的动态行为建模。它从两个方面对其建模对象的内容进行描述，即：<ul><li>描述它们的边界。</li><li>对它们进行需求分析。</li></ul></li></ul><p>应用UML: 活动图</p><ul><li>活动图：有助于使工作流和业务过程可视化的图。</li><li>因为用例涵盖过程和工作流分析，活动图成为编写用例文本的有用的辅助措施。</li></ul><p>过程：在迭代方式中如何使用用例</p><ul><li>用例是UP和其他众多迭代方法的核心，UP提倡用例驱动开发。<ul><li>功能需求首先记录在用例（用例模型）中。</li><li>用例是迭代计划的重要部分，是预算的关键输入。</li><li>用例实现（use-case realization)驱动设计。小组设计协作对象和子系统都是为了执行或实现用例。</li><li>用例影响了用户手册和测试。</li><li>功能或系统测试应该符合用例的场景。</li><li>为重要用例的最常用场景创建UI”向导“或快捷方式可以方便执行常用任务。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见排序算法总结</title>
    <link href="/20200817/2812144/"/>
    <url>/20200817/2812144/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>先看一下维基百科关于排序算法的定义</p><blockquote><p>一个<strong>排序算法</strong>（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95">算法</a>。最常用到的排序方式是数值顺序以及<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E5%85%B8%E9%A0%86%E5%BA%8F">字典顺序</a>。有效的排序算法在一些算法（例如<a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E7%AE%97%E6%B3%95">搜索算法</a>与<a href="https://zh.wikipedia.org/w/index.php?title=%E5%90%88%E4%BD%B5%E7%AE%97%E6%B3%95&action=edit&redlink=1">合并算法</a>）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：</p><ol><li>输出结果为递增序列（递增是针对所需的排序顺序而言）</li><li>输出结果是原输入的一种<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%88%97">排列</a>、或是重组</li></ol></blockquote><p>排序可以说是数据结构与算法中最基础最重要的东西了。</p><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p><p>可以将其分为两大类：</p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_fenlei.png" style="zoom:80%;" /><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h3 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h3><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_bubble.gif" style="zoom:80%;" /><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>元素正序时最快，反序时最慢</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SortAlgorithm;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/8/23 19:46</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 冒泡排序的基本思想就是重复的遍历要排序的序列，对元素两两一次比较</span><br><span class="hljs-comment"> *               平均时间复杂度O(n^2)，最好情况O(n)就是序列已经有序了，最坏就是O(n^2)</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)<br>            System.out.print(a[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;本次结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;a.length-<span class="hljs-number">1</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(a[j]&gt;a[j+<span class="hljs-number">1</span>])<br>                    exch(a,j,j+<span class="hljs-number">1</span>);<br>            &#125;<br>            show(a);<br>            System.out.println();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;初始数组：&quot;</span>);<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">58</span>,<span class="hljs-number">92</span>,<span class="hljs-number">55</span>,<span class="hljs-number">33</span>,<span class="hljs-number">10</span>,<span class="hljs-number">38</span>&#125;;<br>        sort(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码的输出结果：<font color="blue">可以看到每次排序都会有一个值有序（即当前无序部分的最大值）</font></strong></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_bubble.png" style="zoom:80%;" /><h3 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h3><p>上面的冒泡排序是基本思想的实现代码，看图就会发现第五次排序后就已经有序了，但是只要<code>i</code>没到<code>a.length</code>就会继续，所以可以进行一点优化：</p><ol><li>参考别人的思路，通过设置标志位flag，判断第i趟是否有元素交换，没有说明已经有序了</li><li>编写一个判断函数<code>isSorted()</code>，遍历数组看是否有序了，相比设置flag的花销会更大</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//flag的思路就是出现了交换，flag就翻转表示还未完全有序，思路很简单</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//每次遍历设置，设置在外面就没用了</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;a.length-<span class="hljs-number">1</span>;j++)&#123;<br>                <span class="hljs-keyword">if</span>(a[j]&gt;a[j+<span class="hljs-number">1</span>]) &#123;<br>                    exch(a,j,j+<span class="hljs-number">1</span>);<br>                    flag = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            show(a);<br>            <span class="hljs-comment">//因为是当前遍历设置的，遍历完判断，所以会多输出一次</span><br>            <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//这里是遍历一下数组</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">isSorted</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;a.length-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i]&lt;a[i-<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_bubble_2.png" style="zoom:80%;" /><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，非常稳定，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><h3 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h3><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Sort_selection.gif" style="zoom:80%;" /><h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SortAlgorithm;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/8/23 21:32</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 选择排序就是把a[i]和a[i+1...a.length-1]中最小的交换</span><br><span class="hljs-comment"> *               可以理解为：整个序列分为有序和无序两组；一开始有序组为空，无序组就是全部序列</span><br><span class="hljs-comment"> *               每次就在无序组中找最小的元素，放到有序组</span><br><span class="hljs-comment"> *               时间复杂度一直是O(n^2)</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectionSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)<br>            System.out.print(a[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;本次结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;a.length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(a[j]&lt;a[min])<br>                    min = j;<br>            &#125;<br>            exch(a,i,min);<br>            show(a);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">58</span>,<span class="hljs-number">92</span>,<span class="hljs-number">55</span>,<span class="hljs-number">33</span>,<span class="hljs-number">10</span>,<span class="hljs-number">38</span>&#125;;<br>        sort(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个优化的思路也是可以用isSorted判断</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_selection.png" style="zoom:80%;" /><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序原理就像打扑克牌，每次将一张牌插入到已经有序的牌组的合适位置。为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。</p><p>与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。</p><p><strong>插入排序针对小规模数据或基本有序数据效率较高</strong></p><h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol><h3 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h3><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Sort_insertion.gif" style="zoom:80%;" /><h3 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SortAlgorithm;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/8/23 21:45</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 插入排序就是将第i个位置元素插入前面已经有序的序列中</span><br><span class="hljs-comment"> *               默认第一个元素已经有序了</span><br><span class="hljs-comment"> *               插入方法是逐个与前面的元素比较,两两比较交换,直到找到合适的位置</span><br><span class="hljs-comment"> *               平均时间复杂度O(n^2)，最好情况下已经有序一遍,遍历就结束了O(n)</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsertionSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)<br>            System.out.print(a[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;插排——本次结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;a.length;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;<span class="hljs-number">0</span>&amp;&amp;a[j]&lt;a[j-<span class="hljs-number">1</span>];j--)&#123;<br>                exch(a,j,j-<span class="hljs-number">1</span>);<br>            &#125;<br>            show(a);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">58</span>,<span class="hljs-number">92</span>,<span class="hljs-number">55</span>,<span class="hljs-number">33</span>,<span class="hljs-number">10</span>,<span class="hljs-number">38</span>&#125;;<br>        sort(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_insertion.png" style="zoom:80%;" /><p>我们要考虑的更一般的情况是部分有序的数组。倒置指的是数组中的两个顺序颠倒的元素。比如 E X A M P L E 中有 11 对倒置：E-A、 X-A、 X-M、 X-P、 X-L、 X-E、 M-L、 M-E、 P-L、 P-E以及 L-E。如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。下面是几种典型的部分有序的数组：</p><ol><li>数组中每个元素距离它的最终位置都不远；</li><li>一个有序的大数组接一个小数组；</li><li>数组中只有几个元素的位置不正确。</li></ol><p>插入排序对这样的数组很有效，而选择排序则不然。事实上，当倒置的数量很少时，插入排序很可能比本章中的其他任何算法都要快。</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>还有一种优化算法，叫做<strong>拆半插入</strong>。当数据量n很大时直接插入排序就不适宜了，这时折半插入相对效率更高。基本思想是利用二分法方式在已有序的系列中找到待插入的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;a.length;i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,high=a.length-<span class="hljs-number">1</span>,mid;<br>        <span class="hljs-keyword">while</span>(low&lt;=high)&#123;<span class="hljs-comment">//二分思想循环查找</span><br>            mid = low+(high-low)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(a[i]&lt;=a[mid])<br>                high = mid-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                low = mid+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-comment">//循环结束后low就是a[i]应该插入的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-<span class="hljs-number">1</span>;j&gt;=low;j--)&#123;<br>            a[j+<span class="hljs-number">1</span>]=a[j];<br>        &#125;<br>        a[low] = tmp;<br>        show(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：<strong>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</strong></p><p>可以理解为间隔h个元素比较，例如数组[3,5,1,6,2,4,8,9]：</p><ul><li>选择初始h&#x3D;5为数组一半长度，那么就将序列分为：<font color="red">[3,2]</font>、<font color="blue">[5,4]</font>、[1,8]、<font color="gree">[6,9]</font>一共4组，每组进行直接插入排序。得到数组[<font color="red">2</font>,<font color="blue">4</font>,1,<font color="gree">6</font>,<font color="red">3</font>,<font color="blue">5</font>,8,<font color="gree">9</font>]</li><li>然后增量因子变为一半h&#x3D;2，分为两组<font color="red">[2,1,3,8]</font>、<font color="blue">[4,6,5,9]</font>。排序得到<font color="red">[1,2,3,8]</font>、<font color="blue">[4,5,6,9]</font>合并[<font color="red">1</font>,<font color="blue">4</font>,<font color="red">2</font>,<font color="blue">5</font>,<font color="red">3</font>,<font color="blue">6</font>,<font color="red">8</font>,<font color="blue">9</font>]</li><li>然后增量因子h&#x3D;1，再次插入排序得到有序数组[1,2,3,4,5,6,8,9]</li></ul><h3 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><h3 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h3><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Sort_shell.gif" style="zoom:80%;" /><h3 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SortAlgorithm;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/8/23 22:18</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 希尔排序是对直接插入排序的一个改进</span><br><span class="hljs-comment"> *               通过设置增量,将原序列按增量大小为间隔分组,对分组内元素直接插入排序</span><br><span class="hljs-comment"> *               基本取法：增量因子 h = N/2 ; 也可以按照初始值1,通过3*h+1计算直到h刚好不大于数组长度,后续的 h = (h-1)/3</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShellSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)<br>            System.out.print(a[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;shell——本次结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-comment">//设置增量因子</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (factor&lt;a.length)&#123;<br>            factor = factor*<span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(factor&gt;=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//对增量分组，分组进行插入排序</span><br>            <span class="hljs-comment">//factor此时是不大于序列长度能取到的最大值,factor到a.length-1就是每个分组中的最大值</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=factor;i&lt;a.length;i++)&#123;<br>                <span class="hljs-comment">//可能交换时会覆盖a[i]，所以先存储a[i]</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[i];<br>                <span class="hljs-type">int</span> j;<br>                <span class="hljs-comment">//以增量factor为间值对当前分组进行插入排序</span><br>                <span class="hljs-keyword">for</span> (j = i-factor;j&gt;=<span class="hljs-number">0</span>&amp;&amp;a[j]&gt;tmp;j -= factor)&#123;<br>                    a[j+factor] = a[j];<br>                &#125;<br>                <span class="hljs-comment">//最后的位置放入之前a[i]</span><br>                a[j+factor] = tmp;<br>            &#125;<br>            factor = (<span class="hljs-type">int</span>)Math.floor(factor/<span class="hljs-number">3</span>);<br>            show(a);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">58</span>,<span class="hljs-number">92</span>,<span class="hljs-number">55</span>,<span class="hljs-number">33</span>,<span class="hljs-number">10</span>,<span class="hljs-number">38</span>&#125;;<br>        sort(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_shell.png" style="zoom:80%;" /><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：</p><blockquote><p>However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.</p><p>然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。</p></blockquote><p>说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。</p><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h3 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><h3 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h3><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Sort_Merge.gif" style="zoom:80%;" /><h3 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h3><p>原地归并：</p><p>​实现归并的一种直截了当的办法是将两个不同的有序数组归并到第三个数组中，方法很简单，创建一个适当大小的数组然后将两个输入数组中的元素一个个从小到大放入这个数组中。（即上面算法步骤所描述的）<br>​但是，当用归并将一个大数组排序时，我们需要进行很多次归并，因此在每次归并时都创建一个新数组来存储排序结果会带来问题。我们更希望有一种能够在原地归并的方法，这样就可以先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的空间。你可以先停下来想想应该如何实现这一点，乍一看很容易做到，但实际上已有的实现都非常复杂，尤其是和使用额外空间的方法相比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//原地归并的抽象方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(Comparable[] a,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> high)</span>&#123;<br>    <span class="hljs-comment">//将a[low...mid]和a[mid+1...high]归并</span><br>    <span class="hljs-type">int</span> i=low,j=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=low;k&lt;=high;k++)&#123;<span class="hljs-comment">//将a[low...high]复制到aux[low...high]</span><br>        aux[k]=a[k]<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=low;k&lt;=high;k++)&#123;<span class="hljs-comment">//双指针方法</span><br>        <span class="hljs-comment">//左边取完了</span><br>        <span class="hljs-keyword">if</span>   (i&gt;mid)          a[k]=aux[j++];<br>        <span class="hljs-comment">//右边取完了</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&gt;high)          a[k]=aux[i++];<br>        <span class="hljs-comment">//右边元素小于左边</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(less(aux[j],aux[i]))  a[k]=aux[j++];<br>        <span class="hljs-comment">//右边元素大于左边</span><br>        <span class="hljs-keyword">else</span>                          a[k]=aux[i++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自底向上迭代法：</p><p>自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 sz 的初始值为1，每次加倍。最后一个子数组的大小只有在数组大小是 sz 的偶数倍的时候才会等于 sz （否则它会比 sz 小）。</p><p>以序列<code>&#123;12,6,58,92,55,33,10,38&#125;</code>为例：</p><ul><li><p>初始步长为1，合并相邻区间<font color="red">10,38</font></p><p>[<font color="red">6,12</font>,58,92,55,33,10,38]、[12,6,<font color="red">58,92</font>,55,33,10,38]、[12,6,58,92,<font color="red">33,55</font>,10,38]、[12,6,58,92,55,33,<font color="red">10,38</font>]</p></li><li><p>第二次步长为2，合并相邻区间</p><p>[<font color="red">6,12,58,92</font>,55,33,10,38]、[12,6,58,92,<font color="red">10,33,38,55</font>]</p></li><li><p>第三次步长为4，合并相邻区间</p><p>[<font color="red">6,10,12,33,38,55,58,92</font>]</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SortAlgorithm;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/8/28</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 归并排序采用归并操作,是一种典型的分治算法应用,</span><br><span class="hljs-comment"> *               基本思路就是将两个有序数组归并成一个,所以归并排序就是将序列分成两个子序列排好序合并,子序列同样再分直到有序</span><br><span class="hljs-comment"> *               常用的归并方式是双指针合并数组,</span><br><span class="hljs-comment"> *               数组过大时归并占用内存过多,可以考虑原地归并</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)<br>            System.out.print(a[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;merge__本次结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//将两个有序子序列合并为一个</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> high)</span>&#123;<br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length];<br>        <span class="hljs-comment">//将a[low...mid]和a[mid+1...high]归并</span><br>        <span class="hljs-type">int</span> i=low,j=mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//先将a[low...high]复制到aux[low...high]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=low;k&lt;=high;k++)&#123;<br>            tmp[k]=a[k];<br>        &#125;<br>        <span class="hljs-comment">//双指针方法</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=low;k&lt;=high;k++)&#123;<br>            <span class="hljs-comment">//左侧取完了</span><br>            <span class="hljs-keyword">if</span>   (i&gt;mid)          a[k]=tmp[j++];<br>            <span class="hljs-comment">//右侧取完了</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&gt;high)          a[k]=tmp[i++];<br>            <span class="hljs-comment">//两边都有剩余,右边小</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp[j]&lt;tmp[i])        a[k]=tmp[j++];<br>            <span class="hljs-comment">//左边小</span><br>            <span class="hljs-keyword">else</span>                          a[k]=tmp[i++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-type">int</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> sz=<span class="hljs-number">1</span>;sz&lt;N;sz=sz+sz)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> lo=<span class="hljs-number">0</span>;lo&lt;N-sz;lo+=sz+sz)&#123;<br>                merge(a,lo,lo+sz-<span class="hljs-number">1</span>,Math.min(lo+sz+sz-<span class="hljs-number">1</span>,N-<span class="hljs-number">1</span>));<br>            &#125;<br>            show(a);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">58</span>,<span class="hljs-number">92</span>,<span class="hljs-number">55</span>,<span class="hljs-number">33</span>,<span class="hljs-number">10</span>,<span class="hljs-number">38</span>&#125;;<br>        sort(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_merge1.png" style="zoom:80%;" /><p>自顶向下递归法：</p><p>要对子数组 a[1o..hi] 进行排序，先将它分为 a[1o..mid] 和 a[mid+1..hi] 两部分，分别通过递归调用将它们单独排序，最后将有序的子数组归并为最终的排序结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将迭代的sort改为递归即可</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] aux;<span class="hljs-comment">//辅助数组</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>       aux = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length];<br>       sort(a,<span class="hljs-number">0</span>,a.length-<span class="hljs-number">1</span>);<br>       show(a);<br>   &#125;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> low,<span class="hljs-type">int</span> high)</span>&#123;<br>       <span class="hljs-keyword">if</span>(high&lt;=low)<span class="hljs-keyword">return</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> low+(high-low)/<span class="hljs-number">2</span>;<br>       sort(a,low,mid);<br>       sort(a,mid+<span class="hljs-number">1</span>,high);<br>       merge(a,low,mid,high);<span class="hljs-comment">//上面的merge抽象方法</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>以N&#x3D;16为例，对应的递归调用情况：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Sort_merge2.png" style="zoom:80%;" /><h3 id="优化改进"><a href="#优化改进" class="headerlink" title="优化改进"></a>优化改进</h3><ol><li>因为递归会使小规模问题中方法的调用过于频繁，所以改进对它们的处理方法就能改进整个算法。对排序来说，我们已经知道插入排序（或者选择排序）非常简单，因此很可能在小数组上比归并排序更快。</li><li>我们可以添加一个判断条件，如果 a[mid] 小于等于 a[mid+1] ，我们就认为数组已经是有序的并跳过 merge() 方法。这个改动不影响排序的递归调用，但是任意有序的子数组算法的运行时间就变为线性的了</li></ol><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p><strong>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</strong></p><p>快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。在第一种情况中，递归调用发生在处理整个数组之前；在第二种情况中，递归调用发生在处理整个数组之后。在归并排序中，一个数组被等分为两半；在快速排序中，切分（partition）的位置取决于数组的内容。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p><blockquote><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p></blockquote><h3 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><p>递归的最底部情形，是数列的大小是零或一。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><h3 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h3><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Sort_quick.gif" style="zoom:80%;" /><h3 id="实现代码-5"><a href="#实现代码-5" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SortAlgorithm;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/8/28 22:30</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: some description</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)<br>            System.out.print(a[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;本次结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span>&#123;<br>        <span class="hljs-keyword">if</span>(low&gt;high)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> i=low,j=high;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">povit</span> <span class="hljs-operator">=</span> a[low];<br>        <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>            <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; povit&lt;a[j])&#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(i&lt;j &amp;&amp; a[i]&lt;ovit)&#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i!=j)&#123;<br>                exch(a,i,j);<br>            &#125;<br>        &#125;<br>        exch(a,low,i);<br>        a[i]=povit;<br>        show(a);<br>        sort(a,low,i-<span class="hljs-number">1</span>);<br>        sort(a,i+<span class="hljs-number">1</span>,high);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">49</span>,<span class="hljs-number">38</span>,<span class="hljs-number">65</span>,<span class="hljs-number">97</span>,<span class="hljs-number">76</span>,<span class="hljs-number">13</span>,<span class="hljs-number">27</span>,<span class="hljs-number">49</span>&#125;;<br>        sort(a,<span class="hljs-number">0</span>,a.length-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以数组 a &#x3D; [<font color="red">49</font><font color="blue" ><sub><strong>i</strong></sub></font>，38，65，97，76，13，27，49<font color="blue" ><sub><strong>j</strong></sub></font>]为例：</p><ul><li>基准值<code>v=49</code>；初始指针<code>i=low=0</code>和<code>j=high=5</code>，两个指针是交替进行的，假设先从j开始</li><li><code>&lt;--j</code>向左移动<code>j</code>直到<code>a[j]&lt;v</code>然后赋值<code>a[i]=a[j]</code>，得到[<font color="red">27</font><font color="blue" ><sub><strong>i</strong></sub></font>，38，65，97，76，13，27<font color="blue" ><sub><strong>j</strong></sub></font>，49]；再移动<code>i</code></li><li><code>i--&gt;</code>向右移动<code>i</code>直到<code>a[i]&gt;v</code>然后赋值<code>a[j]=a[i]</code>，得到[27，38，65<font color="blue" ><sub><strong>i</strong></sub></font>，97，76，13，<font color="red">65</font><font color="blue" ><sub><strong>j</strong></sub></font>，49]；再移动<code>j</code></li><li><code>&lt;--j</code>向左移动<code>j</code>直到<code>a[j]&lt;v</code>然后赋值<code>a[i]=a[j]</code>，得到[27，38，<font color="red">13</font><font color="blue" ><sub><strong>i</strong></sub></font>，97，76，13<font color="blue" ><sub><strong>j</strong></sub></font>，65，49]；再移动<code>i</code></li><li><code>i--&gt;</code>向右移动<code>i</code>直到<code>a[i]&gt;v</code>然后赋值<code>a[j]=a[i]</code>，得到[27，38，13，97<font color="blue" ><sub><strong>i</strong></sub></font>，76，<font color="red">97</font><font color="blue" ><sub><strong>j</strong></sub></font>，65，49]；再移动<code>j</code></li><li><code>&lt;--j</code>向左移动<code>j</code>此时出现<code>i==j</code>，得到[27，38，13，<font color="red">97</font><font color="blue" ><sub><strong>i</strong></sub></font><font color="blue" ><sub><strong>j</strong></sub></font>，76，97，65，49]；令此时a[i]&#x3D;49，第一次划分结束，得到[27，38，13，<font color="red">49</font><font color="blue" ><sub><strong>i</strong></sub></font><font color="blue" ><sub><strong>j</strong></sub></font>，76，97，65，49]，此时满足<code>a[low...j-1] &lt;= a[j] &lt;= a[j+1...high]</code></li></ul><p>代码实现。。。。。。。。27和13位置不对啊。。。。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_quick.png" style="zoom:80%;" /><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><h4 id="基准选择"><a href="#基准选择" class="headerlink" title="基准选择"></a>基准选择</h4><p>对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列。</p><h5 id="随机基准-amp-三数取中"><a href="#随机基准-amp-三数取中" class="headerlink" title="随机基准&amp;三数取中"></a>随机基准&amp;三数取中</h5><p>上面默认的方法采取的是固定基准——即以第一个或最后一个元素为基准。</p><p>【固定基准分析】如果输入序列是随机的，处理时间可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为冒泡排序，时间复杂度为Θ(n^2)。而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为基准元是非常糟糕的，为了避免这个情况，就引入了随机基准——取待排序列中任意一个元素作为基准元。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">randomIndex</span> <span class="hljs-operator">=</span> rd.Next() % (high - low) + low;<span class="hljs-comment">//取数组中随机下标</span><br>exch(a,randomIndex,low);            <span class="hljs-comment">//与第一个数交换</span><br></code></pre></td></tr></table></figure><p>【随机基准分析】：这是一种相对安全的策略。由于基准元的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。实际上，随机化快速排序得到理论最坏情况的可能性仅为1&#x2F;(2^n）。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。</p><p>虽然随机选取基准时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2），要缓解这种情况，就引入了三数取中选取基准——从第一项、中间、最后一项三个数中选择中位数作为基准值。如果数据很大，也可以继续延伸到5个甚至更多个</p><p>举例：8 1 4 9 0 3 5 2 7 6，取——左8 中0 右6(即low、mid、high位置)，将三个数排序后取中间的数交换到low位置作为基准；这个序列基准值即为6</p><p>我们还可以将取样元素放在数组末尾作为“哨兵”来去掉 partition() 中的数组边界测试。</p><h4 id="优化一：切换插入排序"><a href="#优化一：切换插入排序" class="headerlink" title="优化一：切换插入排序"></a>优化一：切换插入排序</h4><p>和大多数递归排序算法一样，改进快速排序性能的一个简单办法基于以下两点：</p><ul><li>虽说插入排序的时间复杂度为O(n2)，但是实际上是：n(n-1)&#x2F;2。快速排序的时间复杂度为O(nlogn)，实际上是：n(logn+1)。经过计算后发现当n&lt;&#x3D;8时，插入排序所消耗的时间是少于快速排序的。</li><li>因为递归，快速排序的 sort() 方法在小数组中也会调用自己。</li></ul><p>因此，在排序小数组时应该切换到插入排序。简单地改动算法代码就可以做到这一点：将<code>sort() </code>中的语句<code>if (hi &lt;= lo) return;</code>替换成下面这条语句来对小数组使用插入排序：<code>if (hi &lt;= lo + M) &#123; Insertion.sort(a, lo, hi); return; &#125;</code>转换参数 M 的最佳值是和系统相关的，但是 5 ～ 15 之间的任意值在大多数情况下都能令人满意</p><h4 id="优化二：处理重复元素"><a href="#优化二：处理重复元素" class="headerlink" title="优化二：处理重复元素"></a>优化二：处理重复元素</h4><p>在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割。即将数组分为小于povit、等于povit、大于povit三个分区</p><p>举例：</p><p>待排序序列 1 4 6 7 6 6 7 6 8 6</p><p>三数取中选取基准：下标为4的数6</p><p>转换后，待分割序列：6 4 6 7 1 6 7 6 8 6    基准key：6</p><p><strong>本次划分后，未对与key元素相等处理的结果</strong>：1 4 6 6 7 6 7 6 8 6</p><p>下次的两个子序列为：1 4 6 和 7 6 7 6 8 6</p><p><strong>本次划分后，对与key元素相等处理的结果</strong>：1 4 6 6 6 6 6 7 8 7</p><p>下次的两个子序列为：1 4 和 7 8 7</p><p>经过对比，我们可以看出，在一次划分后，把与key相等的元素聚在一起，能减少迭代次数，效率会提高不少</p><p>具体过程：在处理过程中，会有两个步骤</p><p><font color="blue">第一步，在划分过程中，把与key相等元素放入数组的两端</font></p><p><font color="blue">第二步，划分结束后，把与key相等的元素移到枢轴周围</font></p><p><strong>三数取中+插排+聚集相同元素</strong>基本上能满足绝大部分需求了</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>先说一下堆的概念：堆是具有以下性质的完全二叉树——每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<strong>arr[i] &gt;&#x3D; arr[2i] &amp;&amp; arr[i] &gt;&#x3D; arr[2i+1]</strong>  </li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<strong>arr[i] &lt;&#x3D; arr[2i] &amp;&amp; arr[i] &lt;&#x3D; arr[2i+1]</strong></li></ol><p>注：以上两公式都是基于数组1位置开始存储元素</p><h3 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h3><p><strong>上浮</strong>：如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么我们就需要通过交换它和它的父结点来修复堆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//数组0位置不存储元素</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">1</span> &amp;&amp; less(k/<span class="hljs-number">2</span>,k))&#123;<br>        exch(k/<span class="hljs-number">2</span>,k);<br>        k = k/<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>下沉</strong>：如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破了，那么<br>我们可以通过将它和它的两个子结点中的较大者交换来恢复堆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">2</span>*k&lt;=N)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>*k;<br>        <span class="hljs-comment">//j没到最后且左子节点&lt;右子节点</span><br>        <span class="hljs-keyword">if</span>(j&lt;N &amp;&amp; less(j,j+<span class="hljs-number">1</span>))  j++;<br>        <span class="hljs-keyword">if</span>(!less(k,j))  <span class="hljs-keyword">break</span>;<br>        exch(k,j);<span class="hljs-comment">//交换对应元素</span><br>        k = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法步骤-6"><a href="#算法步骤-6" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><h3 id="动图演示-6"><a href="#动图演示-6" class="headerlink" title="动图演示"></a>动图演示</h3><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Sort_heap.gif" style="zoom:80%;" /><h3 id="实现代码-6"><a href="#实现代码-6" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SortAlgorithm;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/8/29 14:48</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 堆排序基本思路是将数组转化为一个堆</span><br><span class="hljs-comment"> *               本代码就是转化为一个大根堆,Heapify操作即调整结构,BuildHeap将整个数组转化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)<br>            System.out.print(a[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;本次结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//heapify操作调整二叉树结构</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Heapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> root,<span class="hljs-type">int</span> len)</span>&#123;<br>        <span class="hljs-keyword">if</span>(root&gt;=len)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>*root+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>*root+<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-comment">//判断当前子树的根、左子、右子哪个最大</span><br>        <span class="hljs-keyword">if</span>(left&lt;len &amp;&amp; a[left]&gt;a[max])&#123;<br>            max = left;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right&lt;len &amp;&amp; a[right]&gt;a[max])&#123;<br>            max = right;<br>        &#125;<br>        <span class="hljs-comment">//max!=i表示当前子树的根节点不是最大,交换</span><br>        <span class="hljs-keyword">if</span>(max!=root)&#123;<br>            exch(a,root,max);<br>            <span class="hljs-comment">//交换以后，其对应的max孩子节点的最大堆的性质可能被破坏，因此需递归调用</span><br>            Heapify(a,max,len);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">BuildHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-comment">//从最后一个父节点开始遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span>arr.length/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--) &#123;<br>            Heapify(arr,i,arr.length);<span class="hljs-comment">//调用交换节点数据的方法，将最大的数移到顶端节点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> len)</span>&#123;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-literal">null</span> || a.length&lt;=<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">//将a构建为一个大根堆</span><br>        BuildHeap(a);<br>        <span class="hljs-comment">//依次取出大根堆的堆顶元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            exch(a,<span class="hljs-number">0</span>,i);<br>            Heapify(a,<span class="hljs-number">0</span>,i);<br>            show(a);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">49</span>,<span class="hljs-number">38</span>,<span class="hljs-number">65</span>,<span class="hljs-number">97</span>,<span class="hljs-number">76</span>,<span class="hljs-number">27</span>,<span class="hljs-number">13</span>,<span class="hljs-number">49</span>&#125;;<br>        sort(a,a.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_heap.png" style="zoom:80%;" /><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>总的来说计数排序效率比较低，因为序列中的数是分散的，可能最大值100010，而大部分元素都小于100，这就导致<code>bucket</code>数组有很多空间未被利用，浪费较大</p><h3 id="算法步骤-7"><a href="#算法步骤-7" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>找出原数组中元素值最大的，记为max。</li><li>创建一个新数组count，其长度是max加1，其元素默认值都为0。</li><li>遍历原数组中的元素，以原数组中的元素作为count数组的索引，以原数组中的元素出现次数作为count数组的元素值。</li><li>创建结果数组result，起始索引index。</li><li>遍历count数组，找出其中元素值大于0的元素，将其对应的索引作为元素值填充到result数组中去，每处理一次，count中的该元素值减1，直到该元素值不大于0，依次处理count中剩下的元素。</li><li>返回结果数组result。</li></ol><h3 id="动图演示-7"><a href="#动图演示-7" class="headerlink" title="动图演示"></a>动图演示</h3><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Sort_counting.gif" style="zoom:80%;" /><h3 id="实现代码-7"><a href="#实现代码-7" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SortAlgorithm;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/8/29 22:24</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 计数排序的基本思想是存储序列中元素出现次数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)<br>            System.out.print(a[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;本次结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> value:a)&#123;<br>            <span class="hljs-keyword">if</span>(maxValue&lt;value)<br>                maxValue = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxValue;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> getMax(a);<br>        <span class="hljs-comment">//设置count数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucketLen</span> <span class="hljs-operator">=</span> max + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bucketLen];<br>        <span class="hljs-comment">//原序列数据出现一次,count对应索引＋1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> value:a)&#123;<br>            bucket[value]++;<br>        &#125;<br>        <span class="hljs-comment">//sortIndex索引用于将count数组元素返回到a</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sortedIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;bucketLen;i++)&#123;<br>            <span class="hljs-keyword">while</span>(bucket[i]&gt;<span class="hljs-number">0</span>)&#123;<br>                a[sortedIndex++] = i;<br>                bucket[i]--;<br>            &#125;<br>        &#125;<br>        show(a);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">58</span>,<span class="hljs-number">92</span>,<span class="hljs-number">55</span>,<span class="hljs-number">33</span>,<span class="hljs-number">10</span>,<span class="hljs-number">38</span>&#125;;<br>        sort(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_count.png" style="zoom:80%;" /><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><p><strong>什么时候最快</strong></p><p>当输入的数据可以均匀的分配到每一个桶中。</p><p><strong>什么时候最慢</strong></p><p>当输入的数据被分配到了同一个桶中。</p><h3 id="动图演示-8"><a href="#动图演示-8" class="headerlink" title="动图演示"></a>动图演示</h3><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Sort_bucket.gif" style="zoom:80%;" /><h3 id="实现代码-8"><a href="#实现代码-8" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SortAlgorithm;<br><br><span class="hljs-keyword">import</span> SortAlgorithm.InsertionSort;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Salute61</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2020/8/29 22:40</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 桶排序相当于计数排序的改进,思想和hash类似</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BucketSort</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a[i];<br>        a[i] = a[j];<br>        a[j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)<br>            System.out.print(a[i]+<span class="hljs-string">&quot; &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;桶排_本次结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//桶扩容、保存数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] arrAppend(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> value)&#123;<br>        a = Arrays.copyOf(a,a.length+<span class="hljs-number">1</span>);<br>        a[a.length-<span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] BucketSort(<span class="hljs-type">int</span>[] a,<span class="hljs-type">int</span> bucketSize)&#123;<br>        <span class="hljs-keyword">if</span>(a.length==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-comment">//找出序列的最大最小值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> value:a)&#123;<br>            <span class="hljs-keyword">if</span>(value&lt;min)<br>                min = value;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value&gt;max)<br>                max = value;<br>        &#125;<br>        <span class="hljs-comment">//确定桶的个数,通过 最值差值 比上 桶的范围 得到</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">bucketCount</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)Math.floor((max-min)/bucketSize)+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bucketCount][<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//利用映射函数将数据放到桶中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length;i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.floor((a[i]-min)/bucketSize);<br>            buckets[index] = arrAppend(buckets[index],a[i]);<br>        &#125;<br>        <span class="hljs-comment">//对桶内元素排序</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">arrIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] bucket:buckets)&#123;<br>            <span class="hljs-keyword">if</span>(bucket.length&lt;=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//桶内采用插入排序</span><br>            bucket = InsertionSort.sort(bucket);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> value:bucket)&#123;<br>                a[arrIndex++] = value;<br>            &#125;<br><span class="hljs-comment">//            show(a);</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">58</span>,<span class="hljs-number">92</span>,<span class="hljs-number">55</span>,<span class="hljs-number">33</span>,<span class="hljs-number">10</span>,<span class="hljs-number">38</span>&#125;;<br>        a = BucketSort(a,<span class="hljs-number">22</span>);<br>        show(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_bucket.png" style="zoom:80%;" /><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h3 id="算法步骤-8"><a href="#算法步骤-8" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>基数排序有两种方法：</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异案例看大家发的：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><h3 id="动图演示-9"><a href="#动图演示-9" class="headerlink" title="动图演示"></a>动图演示</h3><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Sort_radix.gif" style="zoom:80%;" /><h3 id="实现代码-9"><a href="#实现代码-9" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基数排序</span><br><span class="hljs-comment"> * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RadixSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IArraySort</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sort(<span class="hljs-type">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span><br>        <span class="hljs-type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxDigit</span> <span class="hljs-operator">=</span> getMaxDigit(arr);<br>        <span class="hljs-keyword">return</span> radixSort(arr, maxDigit);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取最高位数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxDigit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> getMaxValue(arr);<br>        <span class="hljs-keyword">return</span> getNumLenght(maxValue);<br>    &#125;<br>    <span class="hljs-comment">//获取最大值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>            <span class="hljs-keyword">if</span> (maxValue &lt; value) &#123;<br>                maxValue = value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxValue;<br>    &#125;<br>    <span class="hljs-comment">//获取数组num的位数</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumLenght</span><span class="hljs-params">(<span class="hljs-type">long</span> num)</span> &#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenght</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> num; temp != <span class="hljs-number">0</span>; temp /= <span class="hljs-number">10</span>) &#123;<br>            lenght++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lenght;<br>    &#125;<br>    <span class="hljs-comment">//基数排序实现</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] radixSort(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> maxDigit) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dev</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; maxDigit; i++, dev *= <span class="hljs-number">10</span>, mod *= <span class="hljs-number">10</span>) &#123;<br>           <span class="hljs-comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span><br>            <span class="hljs-type">int</span>[][] counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[mod * <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> ((arr[j] % mod) / dev) + mod;<br>                counter[bucket] = arrayAppend(counter[bucket], arr[j]);<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] bucket : counter) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : bucket) &#123;<br>                    arr[pos++] = value;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自动扩容，并保存数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arrayAppend(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> value) &#123;<br>        arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);<br>        arr[arr.length - <span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上排序算法的复杂度等：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort.png" style="zoom:80%;" /><p>相关名词：</p><p><strong>稳定性</strong>：如果a原本在b前面，且a&#x3D;b，则排序后a仍在b前面</p><p><strong>不稳定性</strong>：如果a原本在b前面，且a&#x3D;b，则排序后a可能在b后面</p><p><strong>n</strong>：数据规模</p><p><strong>k</strong>：“桶”的个数</p><p><strong>In-place</strong>：占用常数内存，不占用额外内存</p><p><strong>Out-place</strong>：占用额外内存</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/sort_bijiao.png" style="zoom:80%;" /><h3 id="【参考】"><a href="#【参考】" class="headerlink" title="【参考】"></a>【参考】</h3><ul><li><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">1.0 十大经典排序算法</a></li><li><a href="%5Bhttps://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%5D(https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)">排序算法——维基百科</a></li><li><a href="https://www.cnblogs.com/jyroy/p/11248691.html">冒泡排序及优化详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合（四）Map接口</title>
    <link href="/20200809/2d663ae/"/>
    <url>/20200809/2d663ae/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Map接口简述"><a href="#一、Map接口简述" class="headerlink" title="一、Map接口简述"></a>一、Map接口简述</h2><p><code>public interface Map&lt;K,V&gt; </code>集合采取<strong>键值对(key-value)方式</strong>存储数据，<u>其中key必须唯一；value可以不唯一且value对象类型也可以是Map</u>，类似数组中的元素还可以是数组。例如：学生教务系统中，学号和学生信息就是一个key-value映射，学号是唯一的，信息可能就名字，也可能是姓名年龄专业的一个数据结构。存储时是学号和学生信息一对放一起存进去</p><p>Map集合和Set集合很像，因为Set集合的底层就是使用了Map。</p><p>Map集合是键值对形式存储值的，所以遍历Map集合无非就是获取键和值，根据实际需求，进行获取键和值。</p><p>Map接口提供三种collection试图，允许以键集、值集或键-值集映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。</p><p>注：</p><p>将可变对象用作映射键时必须格外小心。当对象是映射中某个键时，如果以影响 equals 比较的方式更改了对象的值，则映射的行为将是不确定的。此项禁止的一种特殊情况是不允许某个映射将自身作为一个键包含。虽然允许某个映射将自身作为值包含，但请格外小心：在这样的映射上 equals 和 hashCode 方法的定义将不再是明确的。</p><p>所有通用的映射实现类应该提供两个“标准的”构造方法：</p><p>一个 void（无参数）构造方法，用于创建空映射；</p><p>一个是带有单个 Map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新映射。</p><p>实际上，后一个构造方法允许用户复制任意映射，生成所需类的一个等价映射。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 JDK 中所有通用的映射实现都遵从它。</p><span id="more"></span><h2 id="二、Map实现类"><a href="#二、Map实现类" class="headerlink" title="二、Map实现类"></a>二、Map实现类</h2><p>Map接口的常用方法及其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt;&#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;        <span class="hljs-comment">//返回此映射中的键-值映射关系数。</span><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//如果此映射未包含键-值映射关系，则返回 true。</span><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(Object key)</span>;    <span class="hljs-comment">//如果此映射包含指定键的映射关系，则返回 true。</span><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsValue</span><span class="hljs-params">(Object value)</span>    <span class="hljs-comment">//如果此映射将一个或多个键映射到指定值，则返回 true。</span><br><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span>;     <span class="hljs-comment">//根据key查找对应value数据，如果没有，则返回 null。</span><br><br>    V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span>;    <span class="hljs-comment">//向集合保存数据可选操作）。</span><br><br>    V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span>;    <span class="hljs-comment">//如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</span><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span>; <span class="hljs-comment">//从指定映射中将所有映射关系复制到此映射中（可选操作）。</span><br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//从此映射中移除所有映射关系（可选操作）。</span><br><br>    Set&lt;K&gt; <span class="hljs-title function_">KeySet</span><span class="hljs-params">()</span>;     <span class="hljs-comment">//返取出全部key。</span><br><br>    Collection&lt;V&gt; <span class="hljs-title function_">values</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//返回此映射中包含的值的 Collection 视图。</span><br><br>    Set&lt;Map, Entry&lt;K, V&gt;&gt; <span class="hljs-title function_">entrySet</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//即将Map集合转化为Set集合。</span><br><br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Entry</span>&lt;K, V&gt; &#123;<br><br>        K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>;<br><br>        V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;<br><br>        V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span>;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;        <br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;    <span class="hljs-comment">//比较指定的对象与此映射是否相等。</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;        <span class="hljs-comment">//返回此映射的哈希码值。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法描述：</strong></p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>clear()</td><td>从此映射中移除所有映射关系（可选操作）。</td></tr><tr><td>entrySet()</td><td>返回此映射中包含的映射关系的 Set 视图。</td></tr><tr><td>get(Object key)</td><td>返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</td></tr><tr><td>isEmpty()</td><td>如果此映射未包含键-值映射关系，则返回 true。</td></tr><tr><td>keySet()</td><td>返回此映射中包含的键的 Set 视图。</td></tr><tr><td>put(K key, V value)</td><td>将指定的值与此映射中的指定键关联（可选操作）。</td></tr><tr><td>remove(Object key</td><td>如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</td></tr><tr><td>equals(Object o)</td><td>比较指定的对象与此映射是否相等。</td></tr><tr><td>hashCode()</td><td>返回此映射的哈希码值。</td></tr></tbody></table><p><strong>Map接口的具体实现类：</strong></p><table><thead><tr><th align="center">实现类</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">HashMap</td><td align="center">基于hash表的实现（不同步）</td></tr><tr><td align="center">TreeMap</td><td align="center">基于红黑树的实现（排序，不同步）</td></tr><tr><td align="center">LinkedHashMap</td><td align="center">有序的hash表</td></tr><tr><td align="center">ConcurrentHashMap</td><td align="center">同步的hash表</td></tr><tr><td align="center">Hashtable</td><td align="center">同步的hash（被ConcurrentHashMap取代）</td></tr></tbody></table><h2 id="三、Map的两种取值方式"><a href="#三、Map的两种取值方式" class="headerlink" title="三、Map的两种取值方式"></a>三、Map的两种取值方式</h2><p>Map中没有直接取出元素的方法，而是要先转成Set集合，再通过迭代获取元素。取值方式：KeySet、entrySet</p><h3 id="1-KeySet"><a href="#1-KeySet" class="headerlink" title="1 KeySet"></a>1 KeySet</h3><p>将Map集合中所有的键存入到Set集合。因为Set集合具备迭代器，所以可以通过迭代方法取出所有的键，再根据get()方法，获取每一个键对应的值。</p><p><img src="http://img2.salute61.top/Java_keySet.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Map</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Entry</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;<br>&#125;<br>&#125;<br> <span class="hljs-comment">//Map.Entry是Map接口的一个内部接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hahs</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&#123;<br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>&#123;&#125;;<br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;&#125;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-entrySet"><a href="#2-entrySet" class="headerlink" title="2 entrySet"></a>2 entrySet</h3><p>先获取map中的键值关系封装成一个个的entry对象， 存储到一个Set集合中，再迭代这个Set集合， 根据entry获取对应的key和value。</p><p><img src="http://img2.salute61.top/Java_entrySet.png"></p><h2 id="四、HashMap"><a href="#四、HashMap" class="headerlink" title="四、HashMap"></a>四、HashMap</h2><p>HashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面就来分析HashMap的存取。</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h3><p>HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2 构造函数"></a>2 构造函数</h3><p>HashMap提供了三个构造函数：</p><ul><li>HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</li><li>HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</li><li>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。</li></ul><p>在这里提到了两个参数：初始容量，加载因子。其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。</p><p>对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p><p>构造函数的源码如下（JDK1.8）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h3><p>HashMap是一个散列表结构，是基于哈希表的Map接口的非同步实现，提供了所有可选的映射操作，并允许使用null作为键值对；但是它不能保证映射顺序。</p><h4 id="位桶"><a href="#位桶" class="headerlink" title="位桶"></a>位桶</h4><p>Node类型的数组，也成为Hash桶</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br></code></pre></td></tr></table></figure><h4 id="Node对象"><a href="#Node对象" class="headerlink" title="Node对象"></a>Node对象</h4><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    Node&lt;K,V&gt; next;<span class="hljs-comment">//指向链表的下一层（产生冲突时拉链）</span><br><br>    Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<span class="hljs-comment">//Node的构造方法</span><br>        <span class="hljs-built_in">this</span>.hash = hash;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br>    <span class="hljs-comment">//相应的get方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>        &#123; <span class="hljs-keyword">return</span> key; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>      &#123; <span class="hljs-keyword">return</span> value; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br>    <span class="hljs-comment">//hashCode方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>    &#125;<br>    <span class="hljs-comment">//设置值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V newValue)</span> &#123;<br>        <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> value;<br>        value = newValue;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br>    <span class="hljs-comment">//重写equals方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">//......</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//Map.Entry的实现——继承了HashMap.Node</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashMap</span>.Node&lt;K,V&gt; &#123;<br>    Entry&lt;K,V&gt; before, after;<br>    Entry(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">super</span>(hash, key, value, next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//红黑树</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;k,v&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>.Entry&lt;k,v&gt; &#123;<br>    TreeNode&lt;k,v&gt; parent;  <span class="hljs-comment">// 父节点</span><br>    TreeNode&lt;k,v&gt; left; <span class="hljs-comment">//左子树</span><br>    TreeNode&lt;k,v&gt; right;<span class="hljs-comment">//右子树</span><br>    TreeNode&lt;k,v&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-type">boolean</span> red;    <span class="hljs-comment">//颜色属性</span><br>    TreeNode(<span class="hljs-type">int</span> hash, K key, V val, Node&lt;k,v&gt; next) &#123;<br>        <span class="hljs-built_in">super</span>(hash, key, val, next);<br>    &#125;<br>    <span class="hljs-comment">//返回当前节点的根节点</span><br>    <span class="hljs-keyword">final</span> TreeNode&lt;k,v&gt; <span class="hljs-title function_">root</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (TreeNode&lt;k,v&gt; r = <span class="hljs-built_in">this</span>, p;;) &#123;<br>            <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            r = p;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-工作原理"><a href="#4-工作原理" class="headerlink" title="4 工作原理"></a>4 工作原理</h3><p>HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，计算并返回的hashCode是用于找到Map数组的bucket位置来储存Node 对象。这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Node 。</p><h4 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//取hash值方法，HashMap的put方法的也是调用了这个方法，get方法也调用这个方法</span><br><span class="hljs-comment">//保证存取时key值对应的hash值是一致的，这样才能正确对应 </span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="存储实现：put-key-vlaue"><a href="#存储实现：put-key-vlaue" class="headerlink" title="存储实现：put(key,vlaue)"></a>存储实现：put(key,vlaue)</h4><p>以JDK1.8为例，描述put的基本过程：</p><ul><li>①判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li><li>②根据键值key计算hash值得到插入的数组索引i，如果table[i]&#x3D;&#x3D;null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</li><li>③判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</li><li>④判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</li><li>⑤遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li><li>⑥插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ul><p><strong>put方法的源码如下，简单分析一下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">//调用putVal方法</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,<span class="hljs-type">boolean</span> evict)</span> &#123;<br>    <span class="hljs-comment">//Node数组tab即为hashmap的链表数组、p是链表对象、n是长度、i是索引</span><br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">//tab为空就调用resize()方法扩容</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">//通过(n - 1) &amp; hash运算得到的下标i，对应tab中为空，就newNode插入</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">//tab[i]不为空 ——&gt; 发生碰撞冲突</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//定义变量Node e ,key k</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//p的hash值等于参数hash，key也等于参数key且非空，就把p存到e中</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>        <span class="hljs-comment">//tab[i]是红黑树，直接插入键值对</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>        <span class="hljs-comment">//tab[i]是链表</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//遍历tab[i]链表</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">//如果p是最后一个node,就直接新建结点添加</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">//TREEIFY_THRESHOLD = 8</span><br>                    <span class="hljs-comment">//判断链表长度是否大于8，是就转换成红黑树</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//找到与待插入元素有相同hash值和key值的结点(碰撞节点)就停止，替换</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//e不为空,将e添加到tab中,将原来键值对中的oldVlaue用e.value替换</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 存在key的映射</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//修改次数加1</span><br>    ++modCount;<br>    <span class="hljs-comment">//判断是否超过扩容阈值,超过就扩容,先扩容再添加</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本流程可以理解为如下图：(来源：<a href="https://blog.csdn.net/alashanMt/article/details/107684187">https://blog.csdn.net/alashanMt/article/details/107684187</a>)</p><p><img src="http://img2.salute61.top/Java_Map-put.jpg"></p><h4 id="读取实现：get-key"><a href="#读取实现：get-key" class="headerlink" title="读取实现：get(key)"></a>读取实现：get(key)</h4><p>通过get方法来获取，而get方法就是通过getNode来取得元素的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-comment">//定义一个Node对象来接收</span><br>        Node&lt;K,V&gt; e;<br>        <span class="hljs-comment">//调用getNode()方法</span><br>        <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;    <br>     <br><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>        <span class="hljs-comment">//类似putVal方法,定义变量</span><br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>        <span class="hljs-comment">//判断数组table是否已初始化,长度大于0</span><br>    <span class="hljs-comment">//通过[(n - 1) &amp; hash]获取key对应的索引不为空</span><br>        <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>            (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//first就是桶中的第一项(数组元素),hash值和key值都相等,返回first结点</span><br>            <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp;<br>                ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                <span class="hljs-keyword">return</span> first;<br>            <span class="hljs-comment">//桶中不止一个结点,就用first.next找它的后继节点,并赋值给e变量 </span><br>            <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//如果首节点是树类型的，那么直接调用getTreeNode()方法去红黑树里找</span><br>                <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>                <span class="hljs-comment">//否则在链表中查找</span><br>                <span class="hljs-comment">//只要e.next不为空就遍历,找到和传进来key相符合的节点，然后返回 </span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">return</span> e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//以上条件都不满足，说明没有该key对应的数据节点，返回null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="resize方法扩容"><a href="#resize方法扩容" class="headerlink" title="resize方法扩容"></a>resize方法扩容</h4><ul><li>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；<ul><li>例如负载因子为0.75，map填满了75%的bucket时，就会创建原来hashmap两倍大小的bucket，并将原来的对象放入新的bucket数组中，这个过程叫作rehashing。</li></ul></li><li>每次扩展的时候，都是扩展2倍；</li><li>扩展后Node对象的位置要么在原位置，要么移动到&lt;原下标+OldCap&gt;位置。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<span class="hljs-comment">//oldTab指向hash桶数组</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果oldCap不为空的话，就是hash桶数组不为空</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="hljs-comment">//如果大于最大容量了，就赋值为整数最大的阀值</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<span class="hljs-comment">//返回</span><br>        &#125;<span class="hljs-comment">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold 双倍扩容阀值threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<span class="hljs-comment">//新建hash桶数组</span><br>    table = newTab;<span class="hljs-comment">//将新数组的值复制给旧的hash桶数组</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//进行扩容操作，复制Node对象值到新的hash桶数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果旧的hash桶数组在j结点处不为空，复制给e</span><br>                oldTab[j] = <span class="hljs-literal">null</span>;<span class="hljs-comment">//将旧的hash桶数组在j结点处设置为空，方便gc</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<span class="hljs-comment">//如果e后面没有Node结点</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<span class="hljs-comment">//直接对e的hash值对新的数组长度求模获得存储位置</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<span class="hljs-comment">//如果e是红黑树的类型，那么添加到红黑树中</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<span class="hljs-comment">//将Node结点的next赋值给next</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果结点e的hash值与原hash桶数组的长度作与运算为0</span><br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<span class="hljs-comment">//如果loTail为null</span><br>                                loHead = e;<span class="hljs-comment">//将e结点赋值给loHead</span><br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<span class="hljs-comment">//否则将e赋值给loTail.next</span><br>                            loTail = e;<span class="hljs-comment">//然后将e复制给loTail</span><br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果结点e的hash值与原hash桶数组的长度作与运算不为0</span><br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<span class="hljs-comment">//如果hiTail为null</span><br>                                hiHead = e;<span class="hljs-comment">//将e赋值给hiHead</span><br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<span class="hljs-comment">//如果hiTail不为空，将e复制给hiTail.next</span><br>                            hiTail = e;<span class="hljs-comment">//将e复制个hiTail</span><br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<span class="hljs-comment">//直到e为空</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果loTail不为空</span><br>                        loTail.next = <span class="hljs-literal">null</span>;<span class="hljs-comment">//将loTail.next设置为空</span><br>                        newTab[j] = loHead;<span class="hljs-comment">//将loHead赋值给新的hash桶数组[j]处</span><br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//如果hiTail不为空</span><br>                        hiTail.next = <span class="hljs-literal">null</span>;<span class="hljs-comment">//将hiTail.next赋值为空</span><br>                        newTab[j + oldCap] = hiHead;<span class="hljs-comment">//将hiHead赋值给新的hash桶数组[j+旧hash桶数组长度]</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="【参考】"><a href="#【参考】" class="headerlink" title="【参考】"></a>【参考】</h2><ul><li><a href="https://www.cnblogs.com/lixiansheng/p/11349386.html">Java集合（五）、Map接口介绍</a></li><li><a href="https://www.cnblogs.com/xiaoxi/p/7233201.html">JDK1.8 HashMap源码分析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java类与对象</title>
    <link href="/20200804/4dffdbe9/"/>
    <url>/20200804/4dffdbe9/</url>
    
    <content type="html"><![CDATA[<p>Java作为一门纯面向对象的语言，类与对象自然是其核心内容，类是最基本的抽象单位，以对象为单位编码。而最早的面向对象的概念实际上是由IBM提出的，在70年代的Smaltalk语言之中进行了应用，后来根据面向对象的设计思路，才形成C++，而由C++产生了Java这门面向对象的编程语言。</p><h2 id="一、面向对象"><a href="#一、面向对象" class="headerlink" title="一、面向对象"></a>一、面向对象</h2><h3 id="1-面向对象简述"><a href="#1-面向对象简述" class="headerlink" title="1 面向对象简述"></a>1 面向对象简述</h3><p>先看一下维基百科上关于面向对象的定义：</p><blockquote><p><strong>面向对象程序设计</strong>（英语：Object-oriented programming，缩写：OOP）是种具有<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">对象</a>概念的<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B">程序编程典范</a>，同时也是一种程序开发的抽象方针。它可能包含<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E5%B1%9E%E6%80%A7_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&action=edit&redlink=1">属性</a>、<a href="https://zh.wikipedia.org/wiki/%E6%BA%90%E4%BB%A3%E7%A0%81">代码</a>与<a href="https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%95_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">方法</a>。对象则指的是<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">类</a>的实例。它将<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">对象</a>作为<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F">程序</a>的基本单元，将程序和<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a><a href="https://zh.wikipedia.org/wiki/%E5%B0%81%E8%A3%9D_(%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)">封装</a>其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象</p></blockquote><p>面向对象的定义中，规定有一些基本特征：</p><ol><li>封装：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。</li><li>继承：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或类从父类继承方法，使得子类具有父类相同的行为。相当于一个”is a”。</li><li>多态：多态就是<strong>对象的多种形态。</strong>相同的引用通过不同的实例执行不同的操作</li></ol><p>对于面向对象的开发来讲也分为三个过程：OOA（面向对象系统分析）、OOD（面向对象设计）、OOP（面向对象编程）。</p><span id="more"></span><h3 id="2-类和对象概念"><a href="#2-类和对象概念" class="headerlink" title="2 类和对象概念"></a>2 类和对象概念</h3><p>类与对象时整个面向对象中最基础的部分。</p><p><strong>类</strong>：是抽象的概念集合，表示的是一个共性的产物，类之中定义的是属性和行为（方法）；<br><strong>对象</strong>：对象是一种个性的表示，表示一个独立的个体，每个对象拥有自己独立的属性，依靠属性来区分不同对象。</p><p>总结一下就是：类是对象的模板，对象是类的实例。编码中先写类，将类实例化为对象后，使用对象（类不能直接使用，对象可以）</p><h4 id="类的创建及初始化"><a href="#类的创建及初始化" class="headerlink" title="类的创建及初始化"></a>类的创建及初始化</h4><p>类是指一类事物的抽象，小学生、初中生、大学生都是学生，可以抽象出学生这个类，小学生张三就是学生这个类的一个具体实例。其中类的属性描述了抽象出来的类它的特点，方法描述了它的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">Study</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说一下<strong>引用</strong>的概念：<strong>如果一个变量的类型是 ’类‘ 类型，而非基本类型，那么该变量又叫做引用。</strong></p><p>例如<code>new Student()</code>创建了一个Student对象，但是创建了对象还要能访问啊，为了访问这个对象，会使用引用<code>Hero zs= new Hero();</code>其中zs是一个Student类型变量，又叫做引用。new 操作符会为我们在内存中开辟空间，zs是对象名，也是引用，在栈上分配，指向由new在堆上分配的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">zs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">18</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再来分析一下这个过程：当调用new Student()时，编译器首先检查下原类Student中是否有Student()构造方法，此处因为有public Student(String name,int age)，所以new的时候，直接调用的该方法，但是很多时候，我们并没有显示声明构造方法，此时，编译器在调用的new Student()的时候，会自动为我们的Student类添加一个无参的空Student()构造方法：Student(){}，来执行类的构造过程。</p><p><strong>构造方法与变量</strong>：不论变量放在哪儿，都会先于任意一个方法的执行前执行，包括构造方法，而构造方法是一个类必须会执行的方法，不需要显示的进行调用。同时，不论变量在哪儿分布，只要在方法外部，就一定先于方法初始化。说到这儿，我们不得不谈一下另一个关键的知识点静态块和非静态块。二者都有很简单的声明方式，只需一对大括号{}就行，静态块的话，在前面加static关键字。例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Student(&quot;</span>+id+<span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Build</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Build</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Build</span>&#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Build</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这是build的block！&quot;</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">3</span>);<br>&#125;<br><span class="hljs-comment">/*Student(1)</span><br><span class="hljs-comment"> *Student(3)</span><br><span class="hljs-comment"> *这是build的block！</span><br><span class="hljs-comment"> *student(2)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>创建对象的流程：</p><ol><li>先装载.class文件，创建Class对象，对静态数据（由static声明的）进行初始化，而且只进行一次初始化。</li><li>new Build()在堆上进行空间分配。</li><li>执行非静态块。</li><li>执行所有方法外定义的变量的初始化。</li><li>执行构造器。</li></ol><h4 id="属性-amp-方法"><a href="#属性-amp-方法" class="headerlink" title="属性&amp;方法"></a>属性&amp;方法</h4><p>描述类状态的就叫属性，可以是基本类型也可以是 ”类“ 类型；描述类功能的就叫方法，它由由方法头和方法体构成，其中包含了访问控制符、返回类型、方法名、参数列表等，还可以用关键字实现特殊的功能</p><p>当一个属性被<strong>static</strong>修饰的时候，就叫做<strong>类属性</strong>，又叫做<strong>静态属性</strong>，当一个属性被声明成类属性，那么<strong>所有的对象，都共享一个值</strong></p><p>与对象属性对比：不同对象的 对象属性 的值都可能不一样；但是所有对象的类属性的值，都是一样的</p><p>比如每个学生的姓名年龄可能会不同，但是他们都有一个共同的身份——学生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">identity</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;学生&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br> <br><span class="hljs-comment">/*静态块*/</span><br><span class="hljs-keyword">static</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;静态块！&quot;</span>);<br>&#125;<br><span class="hljs-comment">/*非静态块*/</span><br>&#123;<br>System.out.println(<span class="hljs-string">&quot;非静态块~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Student(&quot;</span> + id + <span class="hljs-string">&quot;)&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Student</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">/*静态块！</span><br><span class="hljs-comment"> *非静态块~</span><br><span class="hljs-comment"> *Student(1)</span><br><span class="hljs-comment"> *非静态块~</span><br><span class="hljs-comment"> *Student(2)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>我们new了两个对象，可是静态块只执行了一次，而非静态块执行了两个，且都是在调用构造器之前。我们似乎得出了一些结论：静态块是在类的装载时执行的（装入.class文件后），且只执行一次。而非静态块是在调用构造方法之前执行的，每生成一个实例对象，就会调用一次非静态块。</p><p>如静态块一样，其它的静态数据也具有这个特点：<font color="red">初始化只在类装载的时候执行一次。</font></p><p>对于类方法，还有一个重要的特点就是——<font color="red"><u>访问对象方法要建立在有一个对象的前提上，但是访问类方法，不需要对象存在，直接就可以访问</u></font></p><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p><strong>this</strong>这个关键字，相当于普通话里的“<strong>我</strong>”<br><strong>this即代表当前对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    Student(String stuName,<span class="hljs-type">int</span> stuAge)&#123;<br>        <span class="hljs-built_in">this</span>.name = stuName;<br>        <span class="hljs-built_in">this</span>.age = stuAge;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">zs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">33</span>);<br>        System.out.println(<span class="hljs-string">&quot;打印当前对象的虚拟地址：&quot;</span>+<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//输出Student@c17164</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h4><p>重载：是指在<strong>同一个类</strong>中，具有相同的方法名，不同的参数列表的方法之间的一种机制。参数列表的不同体现在：类型不同、个数不同、顺序不同，只要满足任一一个，就可以进行方法重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">(String math)</span>&#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">(String english,<span class="hljs-type">int</span> grade)</span>&#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">(String cs,String cs_experiment)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>同一个方法名，不同的参数，实现不同的功能，这就是方法重载。这样的机制有什么好处？</p><p>主要是：同样的功能，调用同样的方法，只需传入不同的参数，增强了程序的可读性和易于维护，当有很多个功能相似的方法的时候，如果我们为每个方法设计一个名称，想通过名称来区分它们的话，会使得程序的可读性差，设计不够巧妙！</p><p>重写：重写是在继承中存在的，在两个类（子类和父类之间存在的关系）中，子类重写父类的方法，方法名相同，参数也相同的一种机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">animal</span><span class="hljs-params">(String a)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是动物：&quot;</span>+a);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">animal</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">animal</span><span class="hljs-params">(String a)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是犬科动物：&quot;</span>+a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当子类继承了父类后，想对父类的方法功能进行扩展，就可以使用重写，这样做的目的就是：当你需要扩展新的功能的时候，不需要新建方法，在父类的方法中进行补充，这样一种面向对象思维的体现，不用重写同样可以达到这样的效果，但是用了重写更加符合OO思想。类似的还有一种概念，叫<strong>隐藏</strong>：当子类和父类方法名相同，参数不同时，子类隐藏父类的方法实现，这就是一种机制，一种叫法，没什么实际意义，相当于我们新建了方法，只是方法名和父类的相同，但是不是父类的方法的实现。</p><p><font color="blue"><strong>Java中不定参数调用</strong></font></p><p>有的时候，我们不能确定方法的参数个数，我们可以采取这种机制(String … value)，这样可以使代码量降低，使得代码尽可能简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">study</span><span class="hljs-params">(String ... value)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CS专业要学:&quot;</span> + value;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(a(<span class="hljs-string">&quot;data—structure&quot;</span>,<span class="hljs-string">&quot;algorithm&quot;</span>,<span class="hljs-string">&quot;SQL&quot;</span>,<span class="hljs-string">&quot;Operating-System&quot;</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-类与对象关系"><a href="#3-类与对象关系" class="headerlink" title="3 类与对象关系"></a>3 类与对象关系</h3><h4 id="对象与引用"><a href="#对象与引用" class="headerlink" title="对象与引用"></a>对象与引用</h4><p>我们从内存的角度分析。首先，给出两种内存空间的概念：<br>（1）堆内存：保存对象的属性内容。堆内存需要用new关键字来分配空间；<br>（2）栈内存：保存的是堆内存的地址（在这里为了分析方便，可以简单理解为栈内存保存的是对象的名字）。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Java_class.png" style="zoom:80%;" /><p>如果直接使用没有实例化的对象，就会出现报错：<code>Exception in thread &quot;main&quot; java.lang.NullPointerException</code>空指向异常。表示只声明了Student对现象，没有实例化（只有栈空间而没有对应的堆内存空间）</p><p>引用和对象：对象只有一个，但是可以有多个引用指向它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">33</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> stu1;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Java_class2.png" style="zoom:80%;" /><p>一个引用同时只能指向一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">33</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> stu1;<br><span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">18</span>);<span class="hljs-comment">//此时引用stu2指向新的对象</span><br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Java_class3.png" style="zoom:80%;" /><p>再看看下面的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">33</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-type">Student</span> <span class="hljs-variable">stu2</span> <span class="hljs-operator">=</span> stu1;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Java_class4.png" style="zoom:80%;" /><p>此时第二块堆内存空间，没有任何引用指向，这块空间就成为内存垃圾</p><h4 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h4><p>初学Java感觉抽象类和接口有点类似，</p><p>抽象类：凡是声明为形如：<code>abstract void function()</code>的方法，都是抽象方法，包含抽象方法的类就是抽象类，抽象方法只有声明没有实现。</p><p>当然一个类可以在没有抽象方法的前提下声明为抽象类，而一旦被声明为抽象类，因为抽象类没有具体实现的方法，那么它就不能直接实例化。抽象类可以说是对类的抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<span class="hljs-comment">//包含抽象方法的类就是抽象类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-comment">//没有抽象方法也可以声明为抽象类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>抽象类创建了就是为了被继承然后实现，因此一个类继承了抽象类，那么就必须实现父类的抽象方法，如果没有实现那么子类也将定义为abstract类。</p><p>接口：指供别人调用的方法或者函数。它是对行为的抽象。在Java中，定一个接口的形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">goTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeTest</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">experimentTest</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出：接口比抽象类更加 “ 抽象 ”。他可以定义变量，但是变量会被隐式地指定为public static final变量（即为常量），而方法会被隐式地指定为public abstract方法且只能是public abstract方法，并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。</p><h5 id="Java多继承"><a href="#Java多继承" class="headerlink" title="Java多继承"></a>Java多继承</h5><p>Java中只有单继承，不允许多继承，但是可以实现多个接口，相当于间接实现多继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">goStudy</span>&#123;<span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">goTest</span>&#123;<span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">goGraduate</span>&#123;<span class="hljs-keyword">void</span> <span class="hljs-title function_">graduate</span><span class="hljs-params">()</span>;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goSchool</span><span class="hljs-params">()</span>;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JuniorStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">goStudy</span>,goTest,goGraduate&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">graduate</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goSchool</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>1、接口可以实现向上转型，多个具有共同属性的类可以将它们的共同点提取出来，做成抽象，这样层次分明，统一管理。</p><p>2、接口不具有任何实现，最适合做基类。</p><p>抽象类与接口区别：</p><ul><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li><li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</li></ul><h2 id="【参考】"><a href="#【参考】" class="headerlink" title="【参考】"></a>【参考】</h2><ul><li><a href="https://blog.csdn.net/wei_zhi/article/details/52745268">Java类和对象 详解（一）</a></li><li><a href="https://blog.csdn.net/zhangerqing/article/details/8294039">Java之美[从菜鸟到高手演变]之类与对象(一)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java字符串</title>
    <link href="/20200803/96b89c5/"/>
    <url>/20200803/96b89c5/</url>
    
    <content type="html"><![CDATA[<p>Java中的字符串处理，主要涉及三个类：<font color="red"><strong>String、StringBuffer、StringBuilder</strong></font></p><p>三者共同之处：都是final类，不允许被继承。</p><p>StringBuffer是线程安全，可以不需要额外的同步用于多线程中;</p><p>StringBuilder是非同步,运行于多线程中就需要使用着单独同步处理，但是速度就比StringBuffer快多了;</p><p>StringBuffer与StringBuilder两者共同之处:可以通过append、insert进行字符串的操作。</p><p>String实现了三个接口:Serializable、Comparable &lt; String &gt;、CharSequence</p><p>StringBuilder只实现了两个接口Serializable、CharSequence，相比之下String的实例可以通过compareTo方法进行比较，其他两个不可以。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Java_String.png"></p><span id="more"></span><h2 id="一、String简介"><a href="#一、String简介" class="headerlink" title="一、String简介"></a>一、String简介</h2><p>String是一个字符串常量，一般由String声明的字符串，长度是不可变的，这也是它与StringBuffer和StringBuilder最直观的一个区别。</p><p>一般初始化方式：<code>String s = &quot;hello world&quot;;</code> 经过这条语句，JVM的栈内存中产生一个s变量，堆内存中产生hello world字符串对象。s指向了hello world的地址。像上面这种方式产生的字符串属于直接量字符串对象，JVM在处理这类字符串的时候，会进行缓存，产生时放入字符串池，当程序需要再次使用的时候，无需重新创建一个新的字符串，而是直接指向已存在的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>System.out.println(s == s2);<span class="hljs-comment">//返回为true</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;I am&quot;</span>;<br>System.out.println(str);<br>str = str + <span class="hljs-string">&quot; Salute61~&quot;</span>;<br>System.out.println(str);<br><span class="hljs-comment">//I am</span><br><span class="hljs-comment">//I am Salute61~</span><br></code></pre></td></tr></table></figure><p>String不是常量吗？可是输出好像显示str对象被更改了，其实这是一种假象，JVM对上面代码的操作流程是：</p><ul><li>创建String对象str，并把 “I am”赋值给str</li><li>而<code>str = str + &quot; Salute61~&quot;;</code>处，JVM又创建了一个新的对象str，将原str的值加上 “ Salute61~”赋值给新的str，原str被JVM的垃圾回收机制给回收了！</li></ul><p>所以对String对象操作实际上是不断创建新的对象并将旧的回收的过程！因此String的执行速度比较慢</p><h3 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h3><h4 id="1-length方法"><a href="#1-length方法" class="headerlink" title="1 length方法"></a>1 length方法</h4><p>public int length()：该方法用于获取字符串的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the length of this string.</span><br><span class="hljs-comment">     * The length is equal to the number of &lt;a href=&quot;Character.html#unicode&quot;&gt;Unicode</span><br><span class="hljs-comment">     * code units&lt;/a&gt; in the string.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  the length of the sequence of characters represented by this</span><br><span class="hljs-comment">     *          object.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这是JDK种的原始实现，count在String类里被定义为一个整型常量：private final int count;并且不论采用哪种构造方法，最终都会为count赋值。</p><h4 id="2-equals方法"><a href="#2-equals方法" class="headerlink" title="2 equals方法"></a>2 equals方法</h4><p>public boolean equals(Object anObject)：该方法用于比较给定对象是否与String相等。</p><p>在equals博客中有提到，继承了Object类的equals并重写了该方法</p><p>（由源码可知String的底层是基于字符数组的）</p><p>Java核心技术中提到equals的一些特性：</p><p>1）自反性：非空引用x，x.equals(x)应该返回true</p><p>2）对称性：任意引用x、y。y.equals(x)为true时x.equals(y)也应为true</p><p>3）传递性：：任意引用x、y、z。有x.equals(y)、y.equals(z)为true时，则有x.equals(z)为true</p><p>4）一致性：x、y引用的对象未发生变化，那么x.equals(y)应该返回同样的结果</p><p><strong>重写equals的步骤：</strong></p><ol><li>使用&#x3D;&#x3D;操作符检查“实参是否为指向对象的一个引用”。</li><li>使用instanceof操作符检查“实参是否为正确的类型”。</li><li>把实参转换到正确的类型。</li><li>对于该类中每一个“关键”域，检查实参中的域与当前对象中对应的域值是否匹配。<ul><li>对于既不是float也不是double类型的基本类型的域，可以使用&#x3D;&#x3D;操作符进行比较</li><li>对于对象引用类型的域，可以递归地调用所引用的对象的equals方法 </li><li>对于float类型的域，先使用Float.floatToIntBits转换成int类型的值，然后使用&#x3D;&#x3D;操作符比较int类型的值</li><li>对于double类型的域，先使用Double.doubleToLongBits转换成long类型的值，然后使用&#x3D;&#x3D;操作符比较long类型的值。</li></ul></li><li>当你编写完成了equals方法之后，应该检查重写的equals方法：它是否是对称的、传递的、一致的？(其他两个特性通常会自行满足)  如果答案是否定的，那么请找到这些特性未能满足的原因，再修改equals方法的代码。</li></ol><h4 id="3-CompareTo方法"><a href="#3-CompareTo方法" class="headerlink" title="3 CompareTo方法"></a>3 CompareTo方法</h4><p>因为String类实现了public interface Comparable &lt; T &gt; ，而Comparable接口里有唯一的方法：public int compareTo(T o)。所以，String类还有另一个字符串比较方法：compareTo()</p><p>比较的方法就是选择长度较小的，左边对齐，while循环逐个比较，返回首个出现不同的字符的ASCII码值，没有就返回长度差值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(String anotherString)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> value.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> anotherString.value.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">lim</span> <span class="hljs-operator">=</span> Math.min(len1, len2);<br>    <span class="hljs-type">char</span> v1[] = value;<br>    <span class="hljs-type">char</span> v2[] = anotherString.value;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; lim) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> v1[k];<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> v2[k];<br>        <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>            <span class="hljs-keyword">return</span> c1 - c2;<br>        &#125;<br>        k++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len1 - len2;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-spilt方法"><a href="#4-spilt方法" class="headerlink" title="4 spilt方法"></a>4 spilt方法</h4><p>public String[] split(String regex)：该方法用于分割字符串，得到一个String类型的数组，根据regex可知，参数是个正则表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.string;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpiltTest</span> &#123;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello.worldd&quot;</span>;<br>String[] s2 = s.split(<span class="hljs-string">&quot; &quot;</span>);<br>String[] s3 = s1.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;s2.length; i++)&#123;<br>System.out.print(s2[i]+<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//hello world</span><br>&#125;<br>System.out.println();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;s3.length; j++)&#123;<br>System.out.print(s3[j]+<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">//hello worldd</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>spilt()需要注意的事项，就是当分隔符为 . 的话，处理起来不一样，必须写成\.因为.是正则表达式里的一个特殊符号，必须进行转义</p><h2 id="二、StringBuilder和StringBuffer"><a href="#二、StringBuilder和StringBuffer" class="headerlink" title="二、StringBuilder和StringBuffer"></a>二、StringBuilder和StringBuffer</h2><p>StringBuilder和StringBuffer成为可变字符串类，可以理解为字符串变量，因此创建后可更改，速度比String快很多！</p><p>观察其源码发现，使用<code>StringBuffer()</code>时，默认开辟16个字符的长度的空间，使用<code>public StringBuffer(int paramInt)</code>时开辟指定大小的空间，使用<code>public StringBuffer(String paramString)</code>时，开辟<code>paramString.length+16</code>大小的空间。都是调用父类的构造器super()来开辟内存。这方面StringBuffer和StringBuilder都一样，且都实现AbstractStringBuilder类。</p><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>二者几乎没什么区别，基本都是在调用父类的各个方法，<strong>一个重要的区别就是StringBuffer是线程安全的</strong>，内部的大多数方法前面都有关键字synchronized，这样就会有一定的性能消耗，StringBuilder是非线程安全的，所以效率要高些。</p><p>以StringBuffer为例分析一下它们的方法</p><h4 id="1-append"><a href="#1-append" class="headerlink" title="1 append()"></a>1 append()</h4><p>append()：就是在原来的字符串后面直接追加一个新的串，和String类相比有明显的好处——String类在追加的时候，源字符串不变（这就是为什么说String是不可变的字符串类型），和新串连接后，重新开辟一个内存。这样就会造成每次连接一个新串后，都会让之前的串报废，因此也造成了不可避免的内存泄露。</p><h4 id="2-trimToSize"><a href="#2-trimToSize" class="headerlink" title="2 trimToSize()"></a>2 trimToSize()</h4><p>public synchronized void trimToSize()：该方法用于将多余的缓冲区空间释放出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;hello erqing&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;length:&quot;</span>+sb.length());<span class="hljs-comment">//length:12</span><br>System.out.println(<span class="hljs-string">&quot;capacity:&quot;</span>+sb.capacity());<span class="hljs-comment">//capacity:28</span><br>sb.trimToSize();<br>System.out.println(<span class="hljs-string">&quot;trimTosize:&quot;</span>+sb.capacity());<span class="hljs-comment">//trimTosize:12</span><br></code></pre></td></tr></table></figure><p>注：在equals那篇博客中提到过，StringBuffer没有重写equals方法，因此时直接继承的Object的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>System.out.println(sb.equals(sb2));<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h2 id="【参考】"><a href="#【参考】" class="headerlink" title="【参考】"></a>【参考】</h2><ul><li><a href="https://blog.csdn.net/zhangerqing/article/details/8093919">Java之美[从菜鸟到高手演变]之字符串</a></li><li><a href="https://www.cnblogs.com/weibanggang/p/9455926.html">java中String、StringBuffer和StringBuilder的区别(简单介绍)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中equals与==用法</title>
    <link href="/20200803/f8b67ba9/"/>
    <url>/20200803/f8b67ba9/</url>
    
    <content type="html"><![CDATA[<p>有两种用法说明:</p><p>一、对于字符串变量来说，使用“&#x3D;&#x3D;”和“equals()”方法比较字符串时，其比较方法不同。</p><ol><li><p><code>==</code>比较两个变量本身的值，<strong>即两个对象在内存中的地址</strong>。</p><p>(java中，对象的首地址是它在内存中存放的起始地址，它后面的地址是用来存放它所包含的各个属性的地址，所以内存中会用多个内存块来存放对象的各个参数，而通过这个首地址就可以找到该对象，进而可以找到该对象的各个属性)</p></li><li><p><code>equals()</code>比较字符串中所包含的内容是否相同。</p></li></ol><span id="more"></span><h2 id="一、-x3D-x3D"><a href="#一、-x3D-x3D" class="headerlink" title="一、&#x3D;&#x3D;"></a>一、&#x3D;&#x3D;</h2><p><code>==</code>比较两个变量本身的值，<strong>即两个对象在内存中的地址</strong>。（java中，对象的首地址是它在内存中存放的起始地址，它后面的地址是用来存放它所包含的各个属性的地址，所以内存中会用多个内存块来存放对象的各个参数，而通过这个首地址就可以找到该对象，进而可以找到该对象的各个属性)</p><p>上面说到&#x3D;&#x3D;比较的是对象的内存地址，然鹅下面这个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        System.out.println(a == b);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br>        System.out.println(s1 == s2);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;123&quot;</span>);<br>        System.out.println(s1 == s3);<br>    &#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230424215830342.png" alt="image-20230424215830342" style="zoom:80%;" /><p>为什么会出现这样的情况？</p><p>对于基本数据类型（byte，short，char，int，float，double，long，boolean）来说，他们是作为常量在方法区中的常量池里面以HashSet策略存储起来的。</p><p>因此我们写下<code>String s1 = &quot;123&quot;</code> 时，JVM会去常量池里找，不存在就创建一个新对象；而<code>String s2 = &quot;123&quot;</code>也是一样，在常量池里找到了<code>&quot;123&quot;</code>，就直接将s2指向之前的对象<code>“123”</code>（一个常量只会对应一块内存地址），所以此时用<code>==</code>判断的话返回是true</p><p>另外，对于基本数据的包装类型（Byte, Short, Character，Integer，Float, Double，Long,  Boolean）除了Float和Double之外，其他的六种都是实现了常量池的，因此对于这些数据类型而言，一般我们也可以直接通过&#x3D;&#x3D;来判断是否相等。</p><p>那么下面这个示例：输出的为啥是true   false 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>System.out.println(i1 == i2);<span class="hljs-comment">//true</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>System.out.println(m == n);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>因为 Integer 在常量池中的存储范围为[-128,127]，127在这范围内，因此是直接存储于常量池的，而128不在这范围内，所以会在堆内存中创建一个新的对象来保存这个值，所以m，n分别指向了两个不同的对象地址，故而导致了不相等。</p><h2 id="二、equals"><a href="#二、equals" class="headerlink" title="二、equals"></a>二、equals</h2><p>看看Java核心技术中关于equals的解释：</p><p>Object类中的equals方法用于检测一个对象是否等于另外一个对象。在Object类中，这个方法用于判断两个对象是否具有相同的引用，如果有相同的引用那么一定相等。（然鹅对于多数类这种判断没啥意义）</p><p>Object中原生的equals方法必须满足两个对象的内容地址都一直才会返回true，同时由于Object类中原生的hashCode是参照对象地址和内容根据一定算法产生的，因此他们的hashCode也是相等的</p><p>一般继承的类中都会重写equals方法。以String中重写的equals为例：先判断是不是相同地址，调整类型，再比较内容，内容长度一致就逐个比较char内容。同样String类也重写了hashCode方法，使得只要内容相等返回的hashCode也会相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *Object类中equals的实现</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *String类中的equals的实现</span><br><span class="hljs-comment"> *简单翻译下</span><br><span class="hljs-comment"> *将此字符串与指定对象进行比较。</span><br><span class="hljs-comment"> *当且仅当参数不是null且是一个String对象，表示与此对象相同的字符序列时，结果为true。</span><br><span class="hljs-comment"> * @参数  一个对象</span><br><span class="hljs-comment"> *         与这个String做对比的一个对象</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @返回  该对象是String且与要比较的String相同，返回true，否则false</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>  #compareTo(String)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>  #equalsIgnoreCase(String)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>            <span class="hljs-type">char</span> v1[] = value;<br>            <span class="hljs-type">char</span> v2[] = anotherString.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是上面的示例：equals比较的内容，所以就是true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;123&quot;</span>);<br>        System.out.println(s1 == s2);<span class="hljs-comment">//false</span><br>        System.out.println(s1.equals(s3);<span class="hljs-comment">//true</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>注意：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">StringBuffer</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-built_in">StringBuffer</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;s1.equals(s2):&quot;</span>+(s1.equals(s2)));<span class="hljs-comment">//结果为false</span><br></code></pre></td></tr></table></figure><p>解释：<u>StringBuffer类中没有重写equals方法，因此这个方法就来自Object类</u>， (Object类中的equals方法是用来比较“地址”的，所以等于false）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于非字符串变量来说，”&#x3D;&#x3D;”和”equals”方法的作用是相同的都是用来比较其，对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>      <span class="hljs-type">A</span> <span class="hljs-variable">obj1</span>   <span class="hljs-operator">=</span>   <span class="hljs-keyword">new</span>  <span class="hljs-title class_">A</span>();<br>      <span class="hljs-type">A</span> <span class="hljs-variable">obj2</span>   <span class="hljs-operator">=</span>   <span class="hljs-keyword">new</span>  <span class="hljs-title class_">A</span>();<br>&#125;<br>     obj1==obj2　　<span class="hljs-comment">//结果为false</span><br>     obj1.equals(obj2)<span class="hljs-comment">//是false</span><br>　　　<span class="hljs-comment">//但是如加上这样一句：</span><br>　　　obj1=obj2;　　<br>　　　<span class="hljs-comment">//执行后</span><br>　　　obj1==obj2  <span class="hljs-comment">//是true</span><br>     obj1.equals(obj2) <span class="hljs-comment">//是true</span><br></code></pre></td></tr></table></figure><ol><li><p>如果是基本类型比较，那么只能用&#x3D;&#x3D;来比较，不能用equals </p></li><li><p>对于基本类型的包装类型，比如Boolean、Character、Byte、Shot、Integer、Long、Float、Double等的引用变量，&#x3D;&#x3D;是比较地址的，而equals是比较内容的。</p></li><li><p>对于下面的示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span> &#123; <br><span class="hljs-type">int</span> i; <br>&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EqualsMethod2</span> &#123; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br><span class="hljs-type">Value</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Value</span>(); <br><span class="hljs-type">Value</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Value</span>(); <br>v1.i = v2.i = <span class="hljs-number">100</span>; <br>System.out.println(v1.equals(v2));<span class="hljs-comment">//（1）flase </span><br>System.out.println(v1 == v2);<span class="hljs-comment">//（2）false</span><br>&#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>如果在新类中被覆盖了equals方法，就可以用来比较内容的。但是在上面的例子中类Value并没有覆盖Object中的equals方法，而是继承了该方法，因此它就是被用来比较地址的，又v1和v2的所指向的对象不相同，故标记（1）处的v1.equals(v2)运行结果为false，标记为（2）处的v1 &#x3D;&#x3D; v2运行结果也为false。 </p></li><li><p>对于String(字符串)、StringBuffer(线程安全的可变字符序列)、StringBuilder(可变字符序列)这三个类可以看博客<a href="%5Bhttp://salute61.top/2020/08/03/Java%E5%AD%97%E7%AC%A6%E4%B8%B2/%5D(http://salute61.top/2020/08/03/Java%E5%AD%97%E7%AC%A6%E4%B8%B2/)">Java字符串</a>；</p></li></ol><h2 id="【参考】"><a href="#【参考】" class="headerlink" title="【参考】"></a>【参考】</h2><ul><li><p>Java核心技术 Object—equals</p></li><li><p><a href="https://www.cnblogs.com/weibanggang/p/9457757.html">java中equals以及&#x3D;&#x3D;的用法(简单介绍)</a></p></li><li><p><a href="https://blog.csdn.net/lcsy000/article/details/82782864">在java中&#x3D;&#x3D;和equals()的区别</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合（三）Set接口</title>
    <link href="/20200803/ca7445de/"/>
    <url>/20200803/ca7445de/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Set集合"><a href="#一、Set集合" class="headerlink" title="一、Set集合"></a>一、Set集合</h2><p>​        一个不包含重复元素的collection。更确切地讲，<u>Set不包含满足e1.equals(e2)的元素对 e1和e2，并且最多包含一个null元素。</u></p><p>　　Set集合由Set接口和Set接口的实现类组成，Set接口继承了Collection接口，因此包含了Collection接口的所有方法。其主要实现类有HashSet和TreeSet，在HashSet的基础上又延伸出了LinkedHashSet。</p><p>​         与List不同，Set提供了equals(Object o)和hashCode()，供其子类重写，以实现对集合中插入重复元素的处理；</p><p>HashSet和TreeSet的不同就在于如何判断两个数是否相同的方法上。</p><ol><li>HashSet判断两个对象是否相同的方法时继承自Object类的equals方法。</li><li>TreeSet判断两个对象是否相同的方法则是Comparable接口中的compareTo()方法。（public void int compareTo(Object o)方法不仅可以比较是否相等，还可以比较大小，如果相等返回0，调用者大于参数则返回正数，否则返回负数）</li></ol><p><font color="red">所以可以得到添加到TreeSet中的对象必须实现Comparable接口。同时如果使用HashSet建议重写equals()方法。</font></p><img src="http://img2.salute61.top/Java_Set.png" style="zoom:67%;" /><span id="more"></span><h2 id="二、HashSet"><a href="#二、HashSet" class="headerlink" title="二、HashSet"></a>二、HashSet</h2><p>HashSet实现了Set接口，底层是基于HashMap进行存储。遍历时不保证顺序，并不保证下次遍历的顺序和之前一样。HashSet中允许null值。</p><p>HashSet底层由HashMap实现，插入的元素被当做是HashMap的key，根据hashCode值来确定集合中的位置，由于Set集合中并没有角标的概念，所以并没有像List一样提供get（）方法。当获取HashSet中某个元素时，只能通过遍历集合的方式进行equals()比较来实现；</p><p><img src="http://img2.salute61.top/Java_Set2.png"></p><p>查看源码可知：HashSet的集合其实就是HashMap的key的集合，然后HashMap的val默认都是PRESENT。HashMap的定义即是key不重复的集合。使用HashMap实现，这样HashSet就不需要再实现一遍。</p><p>而增删检查遍历的源码操作中，实际的操作逻辑都是HashMap的。<strong>遍历操作其实就是HashMap的keySet的遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> map.keySet().iterator();<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.containsKey(o);<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.remove(o)==PRESENT;<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        map.clear();<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>HashSet底层实际上是一个HashMap，HashMap底层采用了哈希表数据结构</strong>。哈希表又叫散列表，哈希表底层是一个数组，这个数组中每一个元素是一个单向链表，每个单向链表都有一个独一无二的hash值，代表数组的下标。在某个单向链表中的每个节点上的hash值是相同的。hash值实际上是key调用hashCode方法，再通过“hash function”转换成的值。</p><h4 id="HashSet添加元素"><a href="#HashSet添加元素" class="headerlink" title="HashSet添加元素"></a>HashSet添加元素</h4><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSetLEARN</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSetLEARN</span><span class="hljs-params">(Integer id , String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HashSetLEARN&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Set&lt;HashSetLEARN&gt; testSet  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">HashSetLEARN</span> <span class="hljs-variable">hsl1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSetLEARN</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;leslie&quot;</span>);<br>        <span class="hljs-type">HashSetLEARN</span> <span class="hljs-variable">hsl2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSetLEARN</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;leslie&quot;</span>);<br>        testSet.add(hsl1);<br>        testSet.add(hsl2);<br><br>        testSet.forEach(hsl -&gt; System.out.println(hsl));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行输出结果：出现了两组</p><p><img src="http://img2.salute61.top/Java_Set3.png"></p><p>按理id、name都一样，那么在HashSet中就应该只保留一组</p><p>这是因为Set集合中所说的不允许重复，这个重复是指对象的重复。何为同一个对象？即在内存中的编号是一致的。内存中的编号是什么？就是哈希码（哈希码一般是 类名 和 对象所在内存地址的十六进制数字表示 的组合）。</p><p>增加对equals和hashcode方法的重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">HashSetLEARN</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> (HashSetLEARN) o;<br>    <span class="hljs-keyword">return</span> Objects.equals(id, that.id) &amp;&amp;<br>            Objects.equals(name, that.name);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Objects.hash(id, name);<br>&#125;<br></code></pre></td></tr></table></figure><p>这次就只有一组数据了</p><p><img src="http://img2.salute61.top/Java_Set4.png"></p><p>向哈希表中添加元素流程</p><ul><li>先调用存储的key的hashCode方法，经过 某个算法得到hash值，</li><li>如果这个哈希表中不存在这个hash值，则直接加入元素。</li><li>如果该hash值已经存在，继续调用key之间的equals方法，如果equals方法返回false，则将该元素添加。</li><li>如果equals方法返回true，则放弃添加该元素 ，即元素重复。</li></ul><p><strong>HashMap和HashSet的初始化容量是16，默认加载因子是0.75。</strong></p><h2 id="三、TreeSet"><a href="#三、TreeSet" class="headerlink" title="三、TreeSet"></a>三、TreeSet</h2><p>从名字上可以看出，此集合的实现和树结构有关。与HashSet集合类似，TreeSet也是基于Map来实现，具体实现<strong>TreeMap</strong>，其底层结构为<strong>红黑树</strong>（特殊的二叉查找树）；</p><p>TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和自定义排序，其中自然排序为默认的排序方式。向 TreeSet中加入的应该是同一个类的对象。</p><p>TreeSet要注意的事项：</p><ol><li>往TreeSet里面添加元素时候，如果元素本具备自然顺序特性，那么就按照元素的自然顺序排序存储.</li><li>往TreSet里面添加元素时候，如果元素不具备自然顺序特性，那么该元素就必须要实现Comparable接口，把元素的比较规则定义在compareTo(T o)方法中</li><li>如果比较元素的时候，compareTo返回的是0，那么该元素被视为重复元素，不允许添加 (注意：TreeSet与HashCode，equals没有任何关系)</li><li><strong>往TreeSet里面添加元素时候，如果元素本身不具备自然自然顺序特性，而且元素所属类也没有实现Comparable接口，通过为需要排序的类实现Comparable或者Comparator接口来实现。</strong></li></ol><p>比较器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">className</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt;&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="TreeSet设置排序"><a href="#TreeSet设置排序" class="headerlink" title="TreeSet设置排序"></a>TreeSet设置排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSetLEARN</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeSetLEARN</span><span class="hljs-params">(Integer age, String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TreeSet&lt;TreeSetLEARN&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSetLEARN</span>(<span class="hljs-number">23</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSetLEARN</span>(<span class="hljs-number">13</span>, <span class="hljs-string">&quot;李四&quot;</span>));<br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSetLEARN</span>(<span class="hljs-number">13</span>, <span class="hljs-string">&quot;周七&quot;</span>));<br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSetLEARN</span>(<span class="hljs-number">43</span>, <span class="hljs-string">&quot;王五&quot;</span>));<br>        ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSetLEARN</span>(<span class="hljs-number">33</span>, <span class="hljs-string">&quot;赵六&quot;</span>));<br><br>        System.out.println(ts);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//以上代码报错：Exception in thread &quot;main&quot; java.lang.ClassCastException: JavaCore.TreeSetLEARN cannot be cast to java.lang.Comparable</span><br></code></pre></td></tr></table></figure><p>没有告诉TreeSet怎样比较元素，所以他就会抛出这个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//指定比较的规则，需要在自定义类中实现Comparable接口，并重写接口中的compareTo方法  </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">CompareTo</span><span class="hljs-params">(Person o)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-comment">//当compareTo方法返回0的时候集合中只有一个元素</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;     <span class="hljs-comment">//当compareTo方法返回正数的时候集合会怎么存就怎么取</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    <span class="hljs-comment">//当compareTo方法返回负数的时候集合会倒序存储</span><br>&#125;<br></code></pre></td></tr></table></figure><p>原因在于TreeSet底层其实是一个二叉树机构，且每插入一个新元素(第一个除外)都会调用<code>compareTo()</code>方法去和上一个插入的元素作比较，并按二叉树的结构进行排列。</p><ol><li>如果将<code>compareTo()</code>返回值写死为0，元素值每次比较，都认为是相同的元素，这时就不再向TreeSet中插入除第一个外的新元素。所以TreeSet中就只存在插入的第一个元素。</li><li>如果将<code>compareTo()</code>返回值写死为1，元素值每次比较，都认为新插入的元素比上一个元素大，于是二叉树存储时，会存在根的右侧，读取时就是正序排列的。</li><li>如果将<code>compareTo()</code>返回值写死为-1，元素值每次比较，都认为新插入的元素比上一个元素小，于是二叉树存储时，会存在根的左侧，读取时就是倒序序排列的。</li></ol><h4 id="1-自然排序"><a href="#1-自然排序" class="headerlink" title="1 自然排序"></a>1 自然排序</h4><p><strong>实现Comparable接口比较元素</strong>：自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。</p><p>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。</p><p><strong>obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是 负数，则表明obj1小于obj2。</strong></p><p>   如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0</p><p>利用以上规则，我们就可以按照年龄来排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">CompareTo</span><span class="hljs-params">(Person o)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.age - o.age;<br>    <span class="hljs-type">return</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span> ? <span class="hljs-built_in">this</span>.name.compareTo(o.name) : num; <br>&#125;<br></code></pre></td></tr></table></figure><p>同理按照姓名排序（Unicode编码大小）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">CompareTo</span><span class="hljs-params">(Person o)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.name.compareTo(o.name);<br>    <span class="hljs-type">retrun</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span> ? <span class="hljs-built_in">this</span>.age - o.age : num;<br>&#125;<br></code></pre></td></tr></table></figure><p>按姓名长度排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">CompareTo</span><span class="hljs-params">(Person o)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.name.length() - o.name.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> length == <span class="hljs-number">0</span>? <span class="hljs-built_in">this</span>.name.compareTo(o.name) : length; <br>    <span class="hljs-type">return</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span> ? <span class="hljs-built_in">this</span>.age - o.age : num; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-自定义排序"><a href="#2-自定义排序" class="headerlink" title="2 自定义排序"></a>2 自定义排序</h4><p><strong>自定义比较器比较元素</strong></p><p>自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int **compare(To1,To2)**方法</p><p>需求:现在要制定TreeSet中按照String长度比较String。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个类，实现Comparator接口，并重写compare()方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompareByLen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String s1, String s2)</span>&#123;    <span class="hljs-comment">//按照字符串的长度比较</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> s1.length() - s2.length();    <span class="hljs-comment">//长度为主要条件</span><br>        <span class="hljs-type">return</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span> ? s1.compareTo(s2) : num;  <span class="hljs-comment">//内容为次要条件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>HashSet继承于AbstractSet，实现了Set, Cloneable, Serializable接口。</p><p>(1)HashSet继承AbstractSet类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了AbstractCollection类；</p><p>(2)HashSet实现了Set接口，获取Set接口的方法，可以自定义具体实现，也可以继承AbstractSet类中的实现；</p><p>(3)HashSet实现Cloneable，得到了clone()方法，可以实现克隆功能；</p><p>(4)HashSet实现Serializable，表示可以被序列化，通过序列化去传输，典型的应用就是hessian协议。</p><p>具有如下特点：</p><ul><li>不允许出现重复因素；</li><li>允许插入Null值；</li><li>元素无序（添加顺序和遍历顺序不一致）；</li><li>线程不安全，若2个线程同时操作HashSet，必须通过代码实现同步；</li></ul><p>TreeSet</p><p>它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。</p><p>（1）与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作；</p><p>（2）TreeSet实现NavigableSet接口，而NavigableSet又扩展了SortedSet接口。这两个接口主要定义了搜索元素的能力，例如给定某个元素，查找该集合中比给定元素大于、小于、等于的元素集合，或者比给定元素大于、小于、等于的元素个数；简单地说，实现NavigableSet接口使得TreeSet具备了元素搜索功能；</p><p>（3）TreeSet实现Cloneable接口，意味着它也可以被克隆；</p><p>（4）TreeSet实现了Serializable接口，可以被序列化，可以使用hessian协议来传输；</p><p>具有如下特点：</p><ul><li>对插入的元素进行排序，是一个有序的集合（主要与HashSet的区别）;</li><li>底层使用红黑树结构，而不是哈希表结构；</li><li>允许插入Null值；</li><li>不允许插入重复元素；</li><li>线程不安全；</li></ul><h2 id="【参考】"><a href="#【参考】" class="headerlink" title="【参考】"></a>【参考】</h2><ul><li><a href="https://www.cnblogs.com/lixiansheng/p/11349379.html">Java集合（四）、继承自Collection接口的Set接口</a></li><li><a href="https://www.jianshu.com/p/d6cff3517688">Java中的Set总结</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合（二）List接口</title>
    <link href="/20200803/2789e08f/"/>
    <url>/20200803/2789e08f/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Collection接口"><a href="#一、Collection接口" class="headerlink" title="一、Collection接口"></a>一、Collection接口</h2><p>Collection接口分别有List、Set两个子接口，根据具体实现采用的结构不同又分为ArrayList、LinkedList等</p><p><img src="http://img2.salute61.top/java_Collection2.png"></p><span id="more"></span><h3 id="1-Collection的常用功能"><a href="#1-Collection的常用功能" class="headerlink" title="1.Collection的常用功能"></a>1.Collection的常用功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> 添加功能<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> <br>        添加一个元素<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection c)</span>  <br>        添加一批元素<br><span class="hljs-number">2.</span> 删除功能<br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> <br>       删除一个元素<br><span class="hljs-number">3.</span> 判断功能<br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> <br>       判断集合是否包含指定的元素<br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>  <br>       判断集合是否为空(集合中没有元素)<br><span class="hljs-number">4.</span> 获取功能<br>   <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>  <br>      获取集合的长度<br><span class="hljs-number">5.</span> 转换功能<br>   Object[] toArray() <br>       把集合转换为数组<br></code></pre></td></tr></table></figure><h3 id="2-遍历集合的方式"><a href="#2-遍历集合的方式" class="headerlink" title="2.遍历集合的方式"></a>2.遍历集合的方式</h3><p>普通的for循环，需要索引，对数组支持的集合操作更方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;World&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) list.get(i);<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代器遍历，可以遍历任何集合，与传统的迭代器（例如C++标准模板库的迭代器）不同</p><ul><li>C++ STL中迭代器是根据数组索引建模的，给定迭代器可以查看指定位置上的元素，就像知道索引 i 可以查看数组a[i]一样，不需要查找元素就可以将迭代器前移</li><li>Java迭代器的查找操作和位置变更是紧密相连的，查找一个元素唯一的方法是调用next，执行查找操作的同时迭代器位置前移</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        c.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        c.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        c.add(<span class="hljs-string">&quot;World&quot;</span>);<br>        <span class="hljs-comment">//获取迭代器对象</span><br>        Iterator&lt;String&gt; it = c.iterator();<br>        <span class="hljs-comment">//hasNext()判断是否有下一个元素，如果有就用next()获取</span><br>        <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>            <span class="hljs-comment">//获取下一个元素</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> it.next();<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>for-each循环</strong>：用更简洁的方式表达同样的操作。编译器将for each循环翻译为带有迭代器的循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        c.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        c.add(<span class="hljs-string">&quot;Java&quot;</span>);<br>        c.add(<span class="hljs-string">&quot;World&quot;</span>);<br>        <span class="hljs-comment">//高级for遍历集合</span><br>        <span class="hljs-keyword">for</span> (String s : c)&#123;<br>            System.out.println(s);<br>        &#125;<br><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        <span class="hljs-comment">//高级for遍历数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : arr)&#123;<br>            System.out.println(a);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、List集合"><a href="#二、List集合" class="headerlink" title="二、List集合"></a>二、List集合</h2><p>List集合包含List接口及其实现类。List集合有以下特点：</p><ol><li>集合元素允许重复</li><li>集合元素有序</li><li>元素可以通过索引访问</li></ol><p>常用的实现类有：ArrayList、LinkedList、Vector。</p><h3 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h3><p>ArrayList是List接口的典型实现类，本质上，ArrayList是对象引用的一个变长数组。</p><p>ArrayList是List接口的可变数组的实现。实现了所有可选列表操作，并允许包括null在内的所有元素。除了实现List接口外，此类还提供了一些方法来操作内部用来存储列表的数组的大小。</p><p>每个ArrayList实例都有一个初始容量，该容量用来储存列表元素的数组大小。<strong>默认初始容量为10。</strong></p><p>ArrayList底层采用数组实现，因此它的优点是适合随机查找和遍历，缺点是不适合插入和删除。</p><p>注：<font color="red">Arrays.asList(…) 方法返回的 List 集合既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…)返回值是一个固定长度的 List 集合。</font></p><h4 id="1-1-添加元素"><a href="#1-1-添加元素" class="headerlink" title="1.1 添加元素"></a>1.1 添加元素</h4><p>使用ArrayList添加元素有如下方法</p><ul><li>set(int index, E element)：替换数组中已经存在的元素内容。</li><li>add(E e)：将元素添加到集合的末尾</li><li>add(int index, E element)：将元素添加到指定的索引位置</li><li>addAll(Collection&lt;? extends E&gt; c)：按照指定Collection的迭代器所返回的元素顺序，将该Collection中的所有元素添加到此列表的尾部。</li><li>addAll(inr index, Collection&lt;? extends E&gt; c)：从指定的位置开始，将指定collection中的所有元素插入到此列表中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; platformList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 添加元素</span><br>myList.add(<span class="hljs-string">&quot;靓仔&quot;</span>);<br>myList.add(<span class="hljs-string">&quot;你好&quot;</span>);<br>myList.add(<span class="hljs-string">&quot;leslie&quot;</span>);<br>myList.add(<span class="hljs-string">&quot;cheung&quot;</span>);<br><span class="hljs-comment">// 添加重复元素,会添加成功,因为List支持添加重复元素</span><br>myList.add(<span class="hljs-string">&quot;你好&quot;</span>);<br>myList.add(<span class="hljs-string">&quot;靓仔&quot;</span>);<br><br>myList.add(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;个人博客&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="1-2-获取元素"><a href="#1-2-获取元素" class="headerlink" title="1.2  获取元素"></a>1.2  获取元素</h4><p>获取ArrayList中指定索引处的元素的使用方法  get()：获取指定位置上的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;索引为3的元素为：&quot;</span> + myList.get(<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><p>如果指定的索引超出了集合的最大索引，比如<code>myList.get(10010)</code>就会抛出异常<code>java.lang.IndexOutOfBoundsException</code>：</p><h4 id="1-3-获取集合元素个数"><a href="#1-3-获取集合元素个数" class="headerlink" title="1.3 获取集合元素个数"></a>1.3 获取集合元素个数</h4><p>获取ArrayList元素个数的使用方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;myList的元素个数为：&quot;</span> + myList.size());<br></code></pre></td></tr></table></figure><h4 id="1-4-删除元素"><a href="#1-4-删除元素" class="headerlink" title="1.4 删除元素"></a>1.4 删除元素</h4><p>使用ArrayList删除元素有以下两个重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br></code></pre></td></tr></table></figure><p><code>E remove(int index);</code>是删除集合中指定索引处的元素，<code>boolean remove(Object o);</code>是删除集合中的指定元素。</p><p>使用方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 指定索引删除重复的元素 &quot;你好&quot; &quot;靓仔&quot;</span><br>myList.remove(<span class="hljs-number">4</span>);<br>myList.remove(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 删除指定元素 &quot;个人博客&quot;</span><br>myList.remove(<span class="hljs-string">&quot;靓仔&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="1-5-修改元素"><a href="#1-5-修改元素" class="headerlink" title="1.5 修改元素"></a>1.5 修改元素</h4><p>修改ArrayList中指定索引处的元素值的使用方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;salute&quot;</span>);<br>myList.set(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;LiuYi&quot;</span>);<br>myList.set(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Bob Dylan&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="1-6-判断集合是否为空"><a href="#1-6-判断集合是否为空" class="headerlink" title="1.6 判断集合是否为空"></a>1.6 判断集合是否为空</h4><p>判断ArrayList是否为空的使用方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;isEmpty:&quot;</span> + myList.isEmpty());<br></code></pre></td></tr></table></figure><h4 id="1-7-清空集合"><a href="#1-7-清空集合" class="headerlink" title="1.7 清空集合"></a>1.7 清空集合</h4><p>清空ArrayList中所有元素的使用方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">myList.clear();<br></code></pre></td></tr></table></figure><p><strong>小结</strong>：</p><ul><li>ArrayLlist内部是由数组来实现的。在存放数据的数组长度不够时，会进行扩容，即增加数组长度。扩展为原来的1.5倍。</li><li>由于是数组来实现，所以，优点是查找元素很快。可以通过下标查找元素，查找效率高。缺点是每次添加和删除元素都会进行大量的数组元素移动。长度不够会扩容。效率底下。</li><li>ArrayList每次的增、删、改操作都伴随着数组的复制和元素的移动。这意味着新的内存空间的开辟。</li></ul><h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2.LinkedList"></a>2.LinkedList</h3><p>LinkedList也是List接口的实现类，内部使用链表结构存储数据</p><ul><li>分配内存空间不是必须是连续的；</li><li>插入、删除操作很快，只要修改前后指针就OK了，时间复杂度为O(1)；</li><li>访问比较慢，必须得从第一个元素开始遍历，时间复杂度为O(n)；</li></ul><p>LinkedList类的代码声明如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;<br>    <span class="hljs-comment">//。。。。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>LinkedList类的使用方法和ArrayList基本一样，只需修改下声明处的代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; platformList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><h4 id="2-1-push、pop、poll"><a href="#2-1-push、pop、poll" class="headerlink" title="2.1 push、pop、poll"></a>2.1 push、pop、poll</h4><ol><li>void push(E e)：与addFirst一样，实际上它就是addFirst； </li><li>E pop()：与removeFirst一样，实际上它就是removeFirst； </li><li>E poll()：查询并移除第一个元素；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <br>        linkedList.push(<span class="hljs-string">&quot;first&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;second&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;second&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;third&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;four&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;five&quot;</span>);<br>        System.out.println(linkedList);<br><br>        System.out.println(<span class="hljs-string">&quot;pop: &quot;</span> + linkedList.pop());<br>        <span class="hljs-comment">//pop: five</span><br>        System.out.println(<span class="hljs-string">&quot;after pop: &quot;</span> + linkedList);<br>        <span class="hljs-comment">//after pop: [four,third,second,second,first]</span><br>        System.out.println(<span class="hljs-string">&quot;poll: &quot;</span> + linkedList.poll());<br>        <span class="hljs-comment">//poll: four</span><br>        System.out.println(<span class="hljs-string">&quot;after poll: &quot;</span> + linkedList);<br>        <span class="hljs-comment">//after poll: [third,second,second,first]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>push、pop的操作很接近stack的操作。</p><p>在链表为空时，poll与pop的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        System.out.println(<span class="hljs-string">&quot;pop: &quot;</span> + linkedList.poll());<br>        <span class="hljs-comment">//pop: null</span><br>        System.out.println(<span class="hljs-string">&quot;poll: &quot;</span> + linkedList.pop());<br>        <span class="hljs-comment">//poll报错: Exception in thread &quot;main&quot; java.util.NoSuchElementException</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-peek"><a href="#2-2-peek" class="headerlink" title="2.2 peek"></a>2.2 peek</h4><p>获取元素，可以指定第一个peekFirst，也可以时最后一个peekLast，只能获取不会移除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        linkedList.push(<span class="hljs-string">&quot;first&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;second&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;second&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;third&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;four&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;five&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;linkedList: &quot;</span> + linkedList);<br>        <span class="hljs-comment">//linkedList: [five,four,third,second,second,first]</span><br>        System.out.println(<span class="hljs-string">&quot;peek: &quot;</span> + linkedList.peek());<br>        <span class="hljs-comment">//peek: five</span><br>        System.out.println(<span class="hljs-string">&quot;peekFirst: &quot;</span> + linkedList.peekFirst());<br>        <span class="hljs-comment">//peekFirst: five</span><br>        System.out.println(<span class="hljs-string">&quot;peekLast: &quot;</span> + linkedList.peekLast());<br>        <span class="hljs-comment">//peekLast: first</span><br>        System.out.println(<span class="hljs-string">&quot;linkedList: &quot;</span> + linkedList);<br>        <span class="hljs-comment">//linkedList: [five,four,third,second,second,first]</span><br>        <br>        <span class="hljs-comment">//如果没找到对应元素，输出为null</span><br>        LinkedList&lt;String&gt; linkedList2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        System.out.println(<span class="hljs-string">&quot;linkedList2: &quot;</span> + linkedList2);<br>        System.out.println(<span class="hljs-string">&quot;peek: &quot;</span> + linkedList2.peek());<br>        System.out.println(<span class="hljs-string">&quot;peekFirst: &quot;</span> + linkedList2.peekFirst());<br>        System.out.println(<span class="hljs-string">&quot;peekLast: &quot;</span> + linkedList2.peekLast());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-offer"><a href="#2-3-offer" class="headerlink" title="2.3 offer"></a>2.3 offer</h4><ol><li>boolean offer(E e)：在链表尾部插入一个元素； </li><li>boolean offerFirst(E e)：与addFirst一样，实际上它就是addFirst； </li><li>boolean offerLast(E e)：与addLast一样，实际上它就是addLast；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        linkedList.push(<span class="hljs-string">&quot;first&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;second&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;second&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;third&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;four&quot;</span>);<br>        linkedList.push(<span class="hljs-string">&quot;five&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;linkedList: &quot;</span> + linkedList);<br>        <span class="hljs-comment">//linkedList: [five,four,third,second,second,first]</span><br>        linkedList.offer(<span class="hljs-string">&quot;six&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;linkedList: &quot;</span> + linkedList);<br>        <span class="hljs-comment">//linkedList: [five,four,third,second,second,first,six]</span><br>        linkedList.offerFirst(<span class="hljs-string">&quot;zero&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;linkedList: &quot;</span> + linkedList);<br>        <span class="hljs-comment">//linkedList: [zero,five,four,third,second,second,first,six]</span><br>        linkedList.offerLast(<span class="hljs-string">&quot;seven&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;linkedList: &quot;</span> + linkedList);<br>        <span class="hljs-comment">//linkedList: [zero,five,four,third,second,second,first,six,seven]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Vector"><a href="#3-Vector" class="headerlink" title="3.Vector"></a>3.Vector</h3><p>Vector也是List接口的实现类，内部也是通过数组来实现。</p><p>java.util.vector提供了向量类(Vector)以实现类似动态数组的功能。<br>创建了一个向量类的对象后，可以往其中随意插入不同类的对象，即不需顾及类型也不需预先选定向量的容量，并可以方便地进行查找。</p><p>对于预先不知或者不愿预先定义数组大小，并且需要频繁地进行查找，插入，删除工作的情况，可以考虑使用向量类。</p><p>向量类提供了三种构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">vector</span><span class="hljs-params">()</span> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialcapacity,<span class="hljs-type">int</span> capacityIncrement)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">vector</span><span class="hljs-params">(<span class="hljs-type">int</span> initialcapacity)</span><br></code></pre></td></tr></table></figure><p>使用第一种方法系统会自动对向量进行管理，若使用后两种方法，则系统将根据参数，initialcapacity设定向量对象的容量（即向量对象可存储数据的大小），当真正存放的数据个数超过容量时。系统会扩充向量对象存储容量。</p><p>参数capacityincrement给定了每次扩充的扩充值。当capacityincrement为0的时候，则每次扩充一倍，利用这个功能可以优化存储。</p><p>Vector类的代码声明如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与ArrayList不同的是，<strong>Vector是线程安全的</strong>，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性。不过这也造成Vector的缺点：实现线程的同步需要额外的花费，因此它的访问速度会比ArrayList慢一些。</p><p>可以认为Vector是ArrayList在多线程环境下的实现版本。所以Vector类的使用方法和ArrayList基本一样，只需修改下声明处的代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; platformList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>由于要支持线程同步，因此Vector类的很多方法都有synchronized关键字，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">return</span> <span class="hljs-variable">elementCount</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> elementCount;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addElement</span><span class="hljs-params">(E obj)</span> &#123;<br>    modCount++;<br>    ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);<br>    elementData[elementCount++] = obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、ArrayList、LinkedList、Vector区别"><a href="#三、ArrayList、LinkedList、Vector区别" class="headerlink" title="三、ArrayList、LinkedList、Vector区别"></a>三、ArrayList、LinkedList、Vector区别</h2><h3 id="1-底层实现"><a href="#1-底层实现" class="headerlink" title="1 底层实现"></a>1 底层实现</h3><p><strong>ArrayList和Vector是基于数组实现的，LinkedList是基于双向链表实现的。</strong></p><p>这也就导致ArrayList适合随机查找和遍历，而LinkedList适合动态插入和删除元素。</p><h3 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2 线程安全性"></a>2 线程安全性</h3><p><strong>ArrayList和LinkedList是线程不安全的，Vector是线程安全的。</strong></p><p>Vector可以看做是ArrayList在多线程环境下的另一种实现方式，这也导致了Vector的效率没有ArraykList和LinkedList高。</p><p>如果要在并发环境下使用ArrayList或者LinkedList，可以调用Collections类的synchronizedList()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collections.synchronizedList(myList);<br></code></pre></td></tr></table></figure><h3 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3 扩容机制"></a>3 扩容机制</h3><p><strong>ArrayList和Vector都是使用Object类型的数组（Object[ ] array）来存储数据的，ArrayList的默认容量是10，Vector的默认容量是0。</strong></p><p>当向这两种类型中添加元素时，若容量不够，就会进行扩容，扩容的本质是产生一个新数组，将原数组的数据复制到新数组，再将新的元素添加到新数组中，使用的方法是<code>Arrays.copyOf()</code>，其中<strong>ArrayList扩容后的容量是之前的1.5倍，Vector默认情况下扩容后的容量是之前的2倍</strong>。</p><p>查看ArrayList的源码，就明白为什么会这样扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>     <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>         <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>     &#125;<br>     <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>     modCount++;<br><br>     <span class="hljs-comment">// overflow-conscious code</span><br>     <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>       grow(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>     <span class="hljs-comment">// overflow-conscious code</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>     <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>         newCapacity = minCapacity;<br>     <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>         newCapacity = hugeCapacity(minCapacity);<br>     <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>     elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>最核心的代码就是<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>，所以ArrayList扩容后的容量是之前的1.5倍。</p><p>查看Vector的源码，就明白为什么会这样扩容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addElement</span><span class="hljs-params">(E obj)</span> &#123;<br>    modCount++;<br>    ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);<br>    elementData[elementCount++] = obj;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>            grow(minCapacity);<br>    &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>     <span class="hljs-comment">// overflow-conscious code</span><br>     <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ?<br>                                      capacityIncrement : oldCapacity);<br>     <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>         newCapacity = minCapacity;<br>     <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>         newCapacity = hugeCapacity(minCapacity);<br>     elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>最核心的代码就是<code>int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?capacityIncrement : oldCapacity);</code>，所以Vector默认情况下扩容后的容量是之前的2倍。</p><h2 id="【参考】"><a href="#【参考】" class="headerlink" title="【参考】"></a>【参考】</h2><ul><li><p><a href="https://www.cnblogs.com/zwwhnly/p/11265599.html">Java集合系列(二)：ArrayList、LinkedList、Vector的使用方法及区别</a></p></li><li><p><a href="https://www.cnblogs.com/lixiansheng/p/11349369.html">Java集合（三）、继承自Collection接口的List接口</a></p></li><li><p>Java核心技术 卷一：集合</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合（一）概述</title>
    <link href="/20200802/95f49cfb/"/>
    <url>/20200802/95f49cfb/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么是集合"><a href="#一、什么是集合" class="headerlink" title="一、什么是集合"></a>一、什么是集合</h2><p>关于Java集合框架的维基百科定义如下：</p><blockquote><p><strong>Java集合框架</strong>(<strong>Java collections framework</strong>)是一个包含一系列实作可重复使用集合的<a href="https://zh.m.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B">数据结构</a>的<a href="https://zh.m.wikipedia.org/wiki/%E9%A1%9E%E5%88%A5_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">类别</a>和<a href="https://zh.m.wikipedia.org/wiki/%E4%BB%8B%E9%9D%A2_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)">界面</a>集合。 虽然称为“框架”，其使用方式却像个<a href="https://zh.m.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">函式库</a>。集合框架提供了定义各式各样集合的界面和实作上述集合的类别。</p></blockquote><span id="more"></span><p>Java中集合是一个用于存放对象引用的容器，在开发时我们不能确定对象的数量也不能确定它们的类型，因此在存放上就不能用存放同一类型数据的数组，Java为解决这一问题，开发了集合</p><p>以下是集合和数组的区别：</p><ol><li><p>数组和集合都是Java中的容器。</p></li><li><p>数组长度固定，且只能存放相同类型数据；而集合不限数量，不同类型的数据。</p></li><li><p>数组只能存放的相同类型数据，可以实基本数据类型也可以是引用类型。</p></li><li><p>集合只能存放对象。比如要存int类型，是转换为了Integer类后存入的。即会将基本数据类型转换为对应的引用类型存入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;<span class="hljs-type">int</span>&gt; intList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">int</span>&gt;();<span class="hljs-comment">//此处会报错：类型参数不能是原始数据</span><br>List&lt;Integer&gt; intList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<span class="hljs-comment">//改为对应的包装类即可</span><br></code></pre></td></tr></table></figure></li><li><p>集合存放的都是对象的引用，而非对象本身。所以我们称集合中的对象就是集合中对象的引用。对象本身还是放在堆内存中。</p></li></ol><p>相应的Java原始类型(基本数据类型)与其对应的包装类：</p><table><thead><tr><th>原始类型(基本数据类型)</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h4 id="集合的接口与实现分离"><a href="#集合的接口与实现分离" class="headerlink" title="集合的接口与实现分离"></a>集合的接口与实现分离</h4><p>与常见的数据结构类库一样，<strong>Java中集合类库也将接口与实现分离</strong>。以*队列(queue)*为例</p><p><em>队列接口</em>指出可以在队列尾部添加元素，在首部删除元素，并可以查找元素个数，当需要手机对象，并按照”先进先出“规则检索对象时就应该使用队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt;&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E element)</span>;<br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口并没有说明队列是如何实现的。通常有两种实现：一是循环数组；一是链表</p><p>当在程序中使用队列时，一旦构建了集合就不需要知道究竟使用了那种实现方法。因此只有在构建集合对象时使用具体的类才有意义，可以使用接口类型存放集合的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Customer&gt; expressLane = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircularArrayQueue</span>&lt;&gt;(<span class="hljs-number">100</span>);<br>expressLane.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(<span class="hljs-string">&quot;Harry&quot;</span>));<br></code></pre></td></tr></table></figure><p>利用这种方式，可以轻松修改实现，即修改调用构造器的部位即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Customer&gt; expressLane = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedListQueue</span>&lt;&gt;(<span class="hljs-number">100</span>);<br>expressLane.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>(<span class="hljs-string">&quot;Harry&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="二、集合框架"><a href="#二、集合框架" class="headerlink" title="二、集合框架"></a>二、集合框架</h2><p>首先看一下集合的框架图</p><p><img src="http://img2.salute61.top/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.gif"></p><p>图中可以看到，集合主要分为Collection（集合）和Map（图）两个接口，Collection存储元素集合，Map存储键&#x2F;值对映射。（其中Collection接口继承(extends)了Iterable接口，具体体现是实现了Iterator）</p><ul><li>Collection分别被Queue、List和Set继承。下面是一些抽象类，然后是具体类。<ul><li>List被AbstractList实现，然后分为3个子类，ArrayList，LinkList和VectorList。</li><li>Set被AbstractSet实现，又分为2个子类，HashSet和TreeSet。</li><li>Map被AbstractMap实现，又分为2个子类，HashMap和TreeMap。</li><li>Map被Hashtable实现。</li></ul></li><li><strong>接口：</strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li><li><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</li><li><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li></ul><img src="http://img2.salute61.top/Java-coll.png" style="zoom:67%;" /><h2 id="三、Iterator迭代器"><a href="#三、Iterator迭代器" class="headerlink" title="三、Iterator迭代器"></a>三、Iterator迭代器</h2><p>它是Java集合的顶层接口（不包括map系列的集合，Map接口是map系列集合的顶层接口）</p><ul><li>Object next()：通过反复调用next方法可以组个访问集合中的元素。但是到达了末尾next方法会抛出NoSuchElementException。因此调用next前先调用hasNext</li><li>遍历还可以用forEach实现，任何实现了Iterable接口的对象都可以使用</li><li>boolean hasNext()：判断容器内是否还有可供访问的元素。</li><li>void remove()：删除迭代器刚越过的元素。</li></ul><p>所以除了map系列的集合，我么都能通过迭代器来对集合中的元素进行遍历。</p><p>注意：我们可以在源码中追溯到集合的顶层接口，比如Collection接口，可以看到它继承的是类Iterable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// Query Operations</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那这就得说明一下Iterator和Iterable的区别：</p><p>Iterable：存在于java.util包中。　</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns an iterator over elements of type &#123;<span class="hljs-doctag">@code</span> T&#125;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> an Iterator.</span><br><span class="hljs-comment">     */</span><br>    Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>看源码可知，Iterable接口里面封装了 Iterator 接口。所以只要实现了Iterable接口的类，就可以使用Iterator迭代器了。</p><p>Iterator：存在于java.util包中。核心的方法next()，hasNext()，remove()。</p><h2 id="四、Collection操作简介"><a href="#四、Collection操作简介" class="headerlink" title="四、Collection操作简介"></a>四、Collection操作简介</h2><p>Collection的作用就是规定了一个集合有哪些基本的操作。在IDEA中ctrl+F12可以查看</p><img src="http://img2.salute61.top/Java_Collection1.png" style="zoom:67%;" /><p>可以看到基本上是插入数据、清除数据、是否包含、是否相等、移除元素、转换数组等操作</p><p>比如：</p><p>　　int size()　获取元素个数</p><p>　　boolean isEmpty()　是否个数为零</p><p>　　boolean contains(Object element)　是否包含指定元素</p><p>　　boolean add(E element)　添加元素，成功时返回true</p><p>　　boolean remove(Object element)　删除元素，成功时返回true</p><p>　　Iterator<E> iterator()　获取迭代器</p><p>还有些操作整个集合的方法，比如：</p><p>　　boolean containsAll(Collection c)     是否包含指定集合 c 的全部元素</p><p>　　boolean addAll(Collection&lt;? extends E&gt; c)　添加集合 c 中所有的元素到本集合中，如果集合有改变就返回 true</p><p>　　boolean removeAll(Collection&lt;?&gt; c)　删除本集合中和 c 集合中一致的元素，如果集合有改变就返回 true</p><p>　　boolean retainAll(Collection c)    保留本集合中 c 集合中两者共有的，如果集合有改变就返回 true</p><p>　　void clear()    删除所有元素</p><p>还有对数组操作的方法：</p><p>　　Object[] toArray()　返回一个包含集合中所有元素的数组</p><p>　　<T> T[] toArray(T[] a)　返回一个包含集合中所有元素的数组，运行时根据集合元素的类型指定数组的类型</p><p>与Collection接口相关还有一个抽象类AbstractCollection：</p><p>AbstractCollection是一个抽象类，实现了Collection接口的部分功能，实现了一些最基本的通用操作，把复杂的和业务相关的延迟到子类实现。</p><p>在AbstractCollection中，主要实现了contains(), isEmpty(), toArray(), remove(), clear() 这几个操作。</p><h2 id="五、Collection源码分析"><a href="#五、Collection源码分析" class="headerlink" title="五、Collection源码分析"></a>五、Collection源码分析</h2><p><strong>Collection是一个接口，继承自Iterable。</strong>先看一下Iterable接口的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.</span><br><span class="hljs-comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><span class="hljs-keyword">import</span> java.util.Spliterator;<br><span class="hljs-keyword">import</span> java.util.Spliterators;<br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现了这个接口可以使对象成为for-each循环的target，即可以使用foreach遍历</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@jls</span> 14.14.2 The enhanced for statement</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回一个元素类型为&lt;T&gt;的迭代器</span><br><span class="hljs-comment">     */</span><br>    Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *对&#123;<span class="hljs-doctag">@code</span> Iterable&#125;的每个元素执行给定的操作，直到处理完所有元素或该操作引发异常为止。</span><br><span class="hljs-comment">     *除非实现类另行指定，否则操作将以迭代顺序执行（如果指定了迭代顺序）。</span><br><span class="hljs-comment">     *该操作引发的异常将中继给调用者。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> action The action to be performed for each element</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException if the specified action is null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;<br>            action.accept(t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在IDEA中ctrl+F12查看Collection的源码，简要分析源码中变量、方法的含义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.</span><br><span class="hljs-comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">package</span> java.util;<br><br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.stream.Stream;<br><span class="hljs-keyword">import</span> java.util.stream.StreamSupport;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *这是一个集合分层的根接口。集合代表了一组包含元素的对象。有些集合允许有重复的元素，有些不允许。</span><br><span class="hljs-comment"> *有些集合是有序的有些无序的。</span><br><span class="hljs-comment"> *jdk不对这个接口提供任何直接的实现，但是再一些直接子接口例如Set和List有实现了某些接口方法。</span><br><span class="hljs-comment"> *所有继承Collection的类必须提供两个默认的构造函数，一个不带参数的、一个带Collection类型参数。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 查询操作</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @返回集合元素个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 集合为空返回true</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *集合包含某个特定元素，返回true</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o 要测试de是否存在于集合的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 集合包含某个特定元素o，返回true</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> 抛出ClassCastException 如果该对象与集合类型不相容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> 抛出NullPointerException 如果对象为空而该集合不允许空引用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回迭代器Iterator，并未说明元素的迭代顺序，除非特别的集合有此要求</span><br><span class="hljs-comment">     */</span><br>    Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回一个包含该集合全部对象的数组 </span><br><span class="hljs-comment">     *如果集合保证是有序的，那么通过迭代器返回数组有相同顺序</span><br><span class="hljs-comment">     </span><br><span class="hljs-comment">     *返回的数组是安全的，也就是说集合有自己的引用，数组开辟新的堆内存，也有自己的引用。所以调</span><br><span class="hljs-comment">     *用者可以随意操作返回的数组。</span><br><span class="hljs-comment">     *这个方法是数组和列表之间的桥梁</span><br><span class="hljs-comment">     */</span><br>    Object[] toArray();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回一个集合元素类型的数组。如果集合满足指定的数组并且有足够的空间，则在其中返回此集合</span><br><span class="hljs-comment">     * 否则返回此集合大小的新数组。</span><br><span class="hljs-comment">     * 如果集合有序，那么返回此集合迭代器遍历顺序的数组</span><br><span class="hljs-comment">     * 如果数组大小比集合元素多，那么在数组满足集合元素后在末尾设置为null  </span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 如果在这个集合中指定数组运行时类型不是运行时元素类型的超类，那么抛ArrayStoreException异常</span><br><span class="hljs-comment">     * 如果指定数组为空，则抛出NullPointerException</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; T[] toArray(T[] a);<br><br>    <span class="hljs-comment">//修改操作</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 确保此集合包含特定的元素类型。</span><br><span class="hljs-comment">     * 如果此集合增加元素成功返回true。</span><br><span class="hljs-comment">     * 如果此集合不允许有重复元素并且已经包含所传参数，那么返回false</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 支持此操作的集合可能会限制向该集合添加哪些元素。特别的，有些集合会拒绝null元素，有些</span><br><span class="hljs-comment">     * 会对要增加的元素强加一些限制。</span><br><span class="hljs-comment">     * Collection实现类应该在文档中明确指出所有的限制。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 如果集合以除已经包含元素之外的任何原因拒绝添加特定元素，则必须抛出异常</span><br><span class="hljs-comment">     *(而不是返回false)。这保留了集合在此调用返回后始终包含指定元素的不变式。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此集合中存在此元素，那么移除一个特定元素类型的实例。更正式的说，如果集合中包含一个或多个这样的元素，</span><br><span class="hljs-comment">     * 那么删除这样的元素(o==null?e==null:o.equals(e))。如果集合包含指定的元素(或集合因调用而发生改变)，那么返回true。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 如果指定元素的类型和集合不相容，抛出ClassCastException异常(可选的限制条件)</span><br><span class="hljs-comment">     * 如果指定元素是null并且这个集合不允许null元素存在，那么抛出NullPointerException异常(可选的限制条件)</span><br><span class="hljs-comment">     * 如果此集合不支持remove操作那么抛出UnsupportedOperationException异常(可选的限制条件)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br><br><br>    <span class="hljs-comment">// 容量操作</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果this集合包含指定集合的所有元素，返回true</span><br><span class="hljs-comment">     * c集合必须要检查是否被包含在this集合</span><br><span class="hljs-comment">     * 如果指定元素的类型和集合不相容，抛出ClassCastException异常(可选的限制条件)</span><br><span class="hljs-comment">     * 如果指定元素是null并且这个集合不允许null元素存在，那么抛出NullPointerException异常(可选的限制条件)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定集合的所有元素到this集合中(可选的操作)。</span><br><span class="hljs-comment">     * 如果指定的集合在操作进行时被修改了，那么此操作行为未定义。</span><br><span class="hljs-comment">     * (这意味着如果指定的集合是这个集合，并且这个集合是非空的，那么这个调用的行为是未定义的。)</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @参数:c集合包含了要被添加到这个集合的元素</span><br><span class="hljs-comment">     * @返回:如果调用结果改变了this集合返回true</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>:如果 addAll操作不被此集合支持，那么抛出UnsupportedOpertaionException异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>: 如果指定集合包含了空元素而this集合不允许有空元素，那么抛出NullPointerException异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>:如果this集合阻止hiding集合元素类型添加，那么抛出ClassCastException异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>:如果指定集合的元素的某些属性阻止将其添加到此集合，则抛出IllegalArgumentException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>:由于插入限制，如果不是所有元素都可以在此时添加，则抛出IllegalStateException异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除此集合中所有的包含在指定集合中的元素(可选的操作)。调用过此函数之后，那么此集合和指定集合将不再包含相同元素。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>:包含要从该集合中删除的元素的c集合</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>:如果此集合因调用而更改那么返回true</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>:如果此集合不支持removeAll方法，则抛出UnsupportedOperationException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>:如果集合中一个或多个元素的类型与指定集合不兼容，则抛出ClassCastException(可选的操作)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>:如果该集合包含一个或多个空元素，且指定的集合不支持空元素(optional)，或者指定的集合为空，</span><br><span class="hljs-comment">     * 则抛出NullPointerException异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除此集合中所有符合给定Predicate的元素。在迭代期间或由Predicate引发的错误或运行时异常将被转发给调用方</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@implSpec</span></span><br><span class="hljs-comment">     * 默认实现使用其迭代器遍历集合的所有元素。每一个匹配的元素使用iterator.remove()来移除。</span><br><span class="hljs-comment">     * 如果集合的iterator不支持移除将会抛出UnsupportedOperationException异常在匹匹厄到</span><br><span class="hljs-comment">     * 第一个元素时。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> 过滤一个predicate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> 筛选要删除的元素返回true的Predicate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果任何一个元素被删除返回true</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> 指定过滤器为空，抛出NullPointerException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> 如果元素没有被删除，或者移除操作不支持，</span><br><span class="hljs-comment">     *  则立即抛出UnsupportedOperationException异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span> &#123;<br>        <span class="hljs-comment">//如果filter为null抛出NullPointerException</span><br>        Objects.requireNonNull(filter);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> Iterator&lt;E&gt; each = iterator();<br>        <span class="hljs-keyword">while</span> (each.hasNext()) &#123;<br>            <span class="hljs-keyword">if</span> (filter.test(each.next())) &#123;<br>                each.remove();<br>                removed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 只保留此集合中包含在指定集合中的元素(可选的操作)。</span><br><span class="hljs-comment">     * 也就是说，此集合中不包含在指定集合中的所有元素。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>:要保留的元素的集合c</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>:如果此集合改变了返回true</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>:如果此集合不支持retainAll，则抛出UnsupportedOperationException异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>:如果集合中一个或多个元素的类型与指定集合不兼容，则抛出ClassCastException(可选的操作)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>:如果该集合包含一个或多个空元素，且指定的集合不支持空元素(optional)，或者指定的集合为空</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除此集合中所有元素(可选操作),调用此方法后集合里将为空。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span>: 如果此集合clear操作不支持将会抛出UnsupportOperationException异常。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">// 比较和哈希</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 比较指定的对象与此集合是否相等</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @参数 o 比较的对象</span><br><span class="hljs-comment">     * @返回 相等返回true</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回这个集合的hashCode。当集合接口没有对Object.hashCode方法的一般协议做任何规定，编程</span><br><span class="hljs-comment">     *人员应该注意在重写equals方法时必须重写hashCode方法，以便满足一般协议对这个</span><br><span class="hljs-comment">     *Object.hashCode方法。特别的，c1.equals(c2)表明c1.hashCode()==c2.hashCode()。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建分流器、流操作</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">parallelStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="【参考】"><a href="#【参考】" class="headerlink" title="【参考】"></a>【参考】</h2><ul><li><a href="https://www.cnblogs.com/lixiansheng/p/11348050.html">Java集合（一）、什么是Java集合？</a></li><li><a href="https://www.runoob.com/java/java-collections.html">Java 集合框架</a></li><li><a href="http://www.manongjc.com/article/66616.html">Java之Collection接口介绍与剖析，看完后再也忘不掉</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven学习</title>
    <link href="/20200731/e5dd7f0f/"/>
    <url>/20200731/e5dd7f0f/</url>
    
    <content type="html"><![CDATA[<h3 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h3><p>Mavern:项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。</p><p>Maven是一个Apache的开源项目，是一个项目管理和综合工具。Maven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。</p><p>例如：两个项目A B，项目A需要依赖一些jar包，项目B也需要依赖这些jar包，那么此时如果都把jar包引入到项目中，就是在重复造轮子，我们应该把这些所有的jar包放到一个地方，需要用的时候过去取即可。</p><span id="more"></span><h4 id="1-什么是依赖管理"><a href="#1-什么是依赖管理" class="headerlink" title="1.什么是依赖管理"></a>1.什么是依赖管理</h4><p>一个java项目需要外部的第三方jar包来进行支持。我们说这个java项目依赖了这些jar包。<br>依赖管理就是将项目所依赖的jar包按照一定规则进行规范化管理。</p><h4 id="2-传统项目的依赖管理"><a href="#2-传统项目的依赖管理" class="headerlink" title="2.传统项目的依赖管理"></a>2.传统项目的依赖管理</h4><p>传统的依赖管理就是程序员需要什么jar包，去网上进行下载，然后手动添加到工程中。<br>缺点：</p><ul><li>jar包从网上不好找</li><li>jar包没有进行统一管理，容易造成jar包重复及版本冲突</li><li>jar包全部添加到工程中，造成工程过大</li></ul><h4 id="3-maven项目的依赖管理"><a href="#3-maven项目的依赖管理" class="headerlink" title="3.maven项目的依赖管理"></a>3.maven项目的依赖管理</h4><p>maven项目有一个文件叫pom.xml。我们通过在此文件中配置jar包的坐标即可将jar包引入到工程中。Jar包的坐标可从maven仓库中获取。<br>好处：</p><ul><li>通过pom配置来引入jar包，避免了jar包的版本冲突。</li><li>Maven团队维护了一个jar包仓库，十分全，避免了去网上寻找jar包的尴尬，节省时间。</li></ul><h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><h4 id="目录含义"><a href="#目录含义" class="headerlink" title="目录含义"></a>目录含义</h4><p>以我的安装目录<code>D:\Apache\apache-maven-3.6.3</code>为例，分析一下文件夹的内容</p><ul><li>bin目录：maven的运行文件。例如mvn.cmd正常运行mvn；mvnDebug.cmd以Debug方式运行</li><li>boot目录：maven运行需要的类加载器</li><li>conf目录：maven的配置文件目录，核心文件是setting.xml</li><li>lib目录：maven所需的jar包</li></ul><h4 id="Maven结构"><a href="#Maven结构" class="headerlink" title="Maven结构"></a>Maven结构</h4><p>setting.xml主要用于配置maven的运行环境等一系列通用的属性，是全局级别的配置文件；而pom.xml主要描述了项目的maven坐标，依赖关系，开发者需要遵循的规则，缺陷管理系统，组织和licenses，以及其他所有的项目相关因素，是项目级别的配置文件。</p><p>一个maven项目的基本结构如下</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/maven8.png" alt="img"></p><p>项目的根目录<code>a-maven-project</code>是项目名，它有一个项目描述文件<code>pom.xml</code>，存放Java源码的目录是<code>src/main/java</code>，存放资源文件的目录是<code>src/main/resources</code>，存放测试源码的目录是<code>src/test/java</code>，存放测试资源的目录是<code>src/test/resources</code>，最后，所有编译、打包生成的文件都放在<code>target</code>目录里。这些就是一个Maven项目的标准目录结构。</p><p>所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。</p><p>如图是一个典型的pom文件，我们可以为要导入的jar包添加依赖</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/maven7.png" alt="img"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，<code>groupId</code>类似于Java的包名，通常是公司或组织名称，<code>artifactId</code>类似于Java的类名，通常是项目名称，再加上<code>version</code>，一个Maven工程就是由<code>groupId</code>，<code>artifactId</code>和<code>version</code>作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。</p><p>使用<code>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。而在</code>中可以引入多个依赖。</p><p>更多的maven依赖可以在要使用时去<a href="https://mvnrepository.com/"><em>Maven</em> Repository: Search&#x2F;Browse&#x2F;Explore</a>查找</p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><ul><li>在<a href="http://maven.apache.org/">maven官网</a>左侧的download栏中，选择对应的maven版本下载，下载的压缩包</li><li>解压，并配置环境变量</li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/maven1.png" style="zoom: 67%;" /><p>环境变量的配置与JDK类似：</p><ul><li>新建系统变量MAVEN_HOME。值为maven的安装目录</li><li>在path变量中添加：<code>%MAVEN_HOME%\bin</code></li></ul><p>配置完成后，在命令行输入<code>mvn -version</code>查看是否配置成功</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/maven2.png" style="zoom:67%;" /><h4 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h4><p>在maven的安装目录的conf目录下，有一个settings.xml文件，找到文件中的<code>&lt;mirrors&gt;&lt;/mirrors&gt;</code>标签，添加阿里镜像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 阿里云仓库 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/maven3.png" style="zoom: 67%;" /><h4 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h4><p>maven仓库用来存储jar包。maven项目都是从仓库中获取jar包。maven仓库分三种：本地仓库，远程仓库，中央仓库。<br><strong>本地仓库</strong>：用来存储从远程仓库及中央仓库下载的jar包，自己来维护。项目使用的jar包优先从本地仓库获取。本地仓库的默认位置在user.home&#x2F;.m2&#x2F;repository。user.home&#x2F;.m2&#x2F;repository。{user.home}表示用户所在的位置。<br><strong>远程仓库</strong>：如果本地仓库没有所需要的jar包，默认去远程仓库下载。远程仓库由公司来进行维护又可称为私服。<br><strong>中央仓库</strong>：中央仓库由maven团队来进行维护，服务于整个互联网。其仓库中存储大量的jar包。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/maven4.png"></p><p>修改本地仓库直接复制<code>&lt;localrepository&gt;</code>语句，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\Apache\maven-repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="Maven配置IDEA"><a href="#Maven配置IDEA" class="headerlink" title="Maven配置IDEA"></a>Maven配置IDEA</h4><p>在Setting中找到如图位置Maven设置，可以按需设置Maven</p><p>下面的importing可以设置自动导入，导入内容选择等；Repositories可以选择仓库，更新仓库等。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/maven6.png"></p><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>maven依赖管理的流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ascii">┌──────────────┐<br>│Sample Project│<br>└──────────────┘<br>        │<br>        ▼<br>┌──────────────┐<br>│     abc      │<br>└──────────────┘<br>        │<br>        ▼<br>┌──────────────┐<br>│     xyz      │<br>└──────────────┘<br></code></pre></td></tr></table></figure><p>当我们声明了<code>abc</code>的依赖时，Maven自动把<code>abc</code>和<code>xyz</code>都加入了我们的项目依赖，不需要我们自己去研究<code>abc</code>是否需要依赖<code>xyz</code>。</p><p>因此，Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要<code>abc</code>，Maven会自动导入<code>abc</code>的jar包，再判断出<code>abc</code>需要<code>xyz</code>，又会自动导入<code>xyz</code>的jar包，这样，最终我们的项目会依赖<code>abc</code>和<code>xyz</code>两个jar包。</p><p>我们来看一个复杂依赖示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们声明一个<code>spring-boot-starter-web</code>依赖时，Maven会自动解析并判断最终需要大概二三十个其他依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ascii">spring-boot-starter-web<br>  spring-boot-starter<br>    spring-boot<br>    sprint-boot-autoconfigure<br>    spring-boot-starter-logging<br>      logback-classic<br>        logback-core<br>        slf4j-api<br>      jcl-over-slf4j<br>        slf4j-api<br>      jul-to-slf4j<br>        slf4j-api<br>      log4j-over-slf4j<br>        slf4j-api<br>    spring-core<br>    snakeyaml<br>  spring-boot-starter-tomcat<br>    tomcat-embed-core<br>    tomcat-embed-el<br>    tomcat-embed-websocket<br>      tomcat-embed-core<br>  jackson-databind<br>  ...<br></code></pre></td></tr></table></figure><p>如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。</p><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>Maven定义了几种依赖关系，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>：</p><table><thead><tr><th align="left">scope</th><th align="left">说明</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">compile</td><td align="left">编译时需要用到该jar包（默认）</td><td align="left">commons-logging</td></tr><tr><td align="left">test</td><td align="left">编译Test时需要用到该jar包</td><td align="left">junit</td></tr><tr><td align="left">runtime</td><td align="left">编译时不需要，但运行时需要用到</td><td align="left">mysql</td></tr><tr><td align="left">provided</td><td align="left">编译时需要用到，但运行时由JDK或某个服务器提供</td><td align="left">servlet-api</td></tr></tbody></table><p>其中，默认的<code>compile</code>是最常用的，Maven会把这种类型的依赖直接放入classpath。</p><p><code>test</code>依赖表示仅在测试时使用，正常运行时并不需要。最常用的<code>test</code>依赖就是JUnit：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>runtime</code>依赖表示编译时不需要，但运行时需要。最典型的<code>runtime</code>依赖是JDBC驱动，例如MySQL驱动：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.48<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>provided</code>依赖表示编译时需要，但运行时不需要。最典型的<code>provided</code>依赖是Servlet API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最后一个问题是，Maven如何知道从何处下载所需的依赖？也就是相关的jar包？答案是Maven维护了一个中央仓库（<a href="https://repo1.maven.org/">repo1.maven.org</a>），所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。</p><p>Maven并不会每次都从中央仓库下载jar包。一个jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的<code>.m2</code>目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。</p><h4 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一ID</h4><p>对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包：</p><ul><li>groupId：属于组织的名称，类似Java的包名；</li><li>artifactId：该jar包自身的名称，类似Java的类名；</li><li>version：该jar包的版本。</li></ul><p>通过上述3个变量，即可唯一确定某个jar包。Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。</p><p>因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。</p><p>注：只有以<code>-SNAPSHOT</code>结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT。</p><h3 id="【参考】"><a href="#【参考】" class="headerlink" title="【参考】"></a>【参考】</h3><ul><li><a href="https://www.cnblogs.com/baizihua/p/11519509.html">maven学习笔记(超详细总结)</a></li><li><a href="https://www.bilibili.com/video/BV12J411M7Sj?p=8">【狂神说Java】JavaWeb入门到实战</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200">廖雪峰——Maven基础</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 HTTPS协议详解.md</title>
    <link href="/20200731/dc4a4f4/"/>
    <url>/20200731/dc4a4f4/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTPS简介"><a href="#HTTPS简介" class="headerlink" title="HTTPS简介"></a>HTTPS简介</h3><p><strong>HTTP协议是一种使用明文数据传输的网络协议。</strong>这样会存在很大的隐患——数据在传输过程中可能会被截获，截获者因此可以获取你的信息，甚至篡改你发送的数据，导致服务器接收到错误的数据！！！</p><p>因此在HTTP协议基础上增加数据加密，即为HTTPS，他的维基百科定义如下</p><blockquote><p><strong>安全超文本传输协议</strong>（<strong>HTTPS</strong>）是<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">超文本传输协议</a>（HTTP）的扩展。它用于在<a href="https://en.wikipedia.org/wiki/Network_operating_system">计算机网络上</a>进行<a href="https://en.wikipedia.org/wiki/Secure_communications">安全通信</a>，并在Internet上广泛使用。在HTTPS中，使用<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">传输层安全协议</a>（TLS）或(以前)使用安全套接字层（SSL）对<a href="https://en.wikipedia.org/wiki/Communication_protocol">通信协议</a>进行加密。因此，该协议也被称为<strong>HTTP over TLS</strong>，或<strong>over SSL的HTTP</strong>。</p><p>HTTPS的主要动机是对访问的<a href="https://en.wikipedia.org/wiki/Website">网站</a>进行<a href="https://en.wikipedia.org/wiki/Authentication">身份验证</a>，以及在传输过程中保护交换数据的<a href="https://en.wikipedia.org/wiki/Information_privacy">隐私</a>和<a href="https://en.wikipedia.org/wiki/Data_integrity">完整性</a>。它可以防止<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a>，并且客户端与服务器之间的双向通信<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">加密</a>可以保护通信免遭<a href="https://en.wikipedia.org/wiki/Eavesdropping">窃听</a>和<a href="https://en.wikipedia.org/wiki/Tamper-evident#Tampering">篡改</a>。实际上，这可以合理地保证人们在与预期的网站进行通信而不受攻击者的干扰。</p></blockquote><span id="more"></span><p>数据加密传输，是HTTP和HTTPS之间的本质性区别</p><p>HTTPS特点：</p><ol><li>内容加密：采用混合加密技术，中间者无法直接查看明文内容</li><li>验证身份：通过证书认证客户端访问的是自己的服务器</li><li>保护数据完整性：防止传输的内容被中间人冒充或者篡改</li></ol><p>HTTPS 协议就是 HTTP+SSL&#x2F;TLS，即在 HTTP 基础上加入 SSL &#x2F;TLS 层，提供了内容加密、身份认证和数据完整性3大功能，目的就是为了加密数据，用于安全的数据传输。</p><h3 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h3><p>客户端使用HTTPS方式与web服务器通信的基本步骤</p><ol><li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</li><li>Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</li><li>客户端的浏览器与Web服务器开始协商SSL&#x2F;TLS连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>Web服务器利用自己的私钥解密出会话密钥。</li><li>Web服务器利用会话密钥加密与客户端之间的通信。</li></ol><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/https1.png"></p><h4 id="HTTPS：TSL-x2F-SSL原理"><a href="#HTTPS：TSL-x2F-SSL原理" class="headerlink" title="HTTPS：TSL&#x2F;SSL原理"></a>HTTPS：TSL&#x2F;SSL原理</h4><p>HTTPS协议的主要功能基本都依赖于TLS&#x2F;SSL协议。<br>TLS&#x2F;SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p><p>关于这三类算法在网络安全基础知识博文中有详细介绍</p><p><strong>SSL和TLS区别</strong></p><p>SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</p><p>TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。</p><h4 id="HTTP跳转HTTPS过程"><a href="#HTTP跳转HTTPS过程" class="headerlink" title="HTTP跳转HTTPS过程"></a>HTTP跳转HTTPS过程</h4><p>以进入leetcode为例：</p><ul><li>在浏览器中输入<a href="http://leetcode-cn.com/%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9B">http://leetcode-cn.com/，浏览器与服务器三次握手；</a></li><li>服务器收到请求后响应状态码301，让用户跳转到HTTPS，重新请求<a href="https://leetcode-cn.com/%EF%BC%9B">https://leetcode-cn.com/；</a></li><li>用户重新发起HTTPS请求，再次与服务器三次TCP握手</li></ul><h3 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h3><p>  1、HTTPS是加密传输协议，HTTP是名文传输协议;<br>  2、HTTPS需要用到SSL证书，而HTTP不用;<br>  3、HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO<br>  4、 HTTPS标准端口443，HTTP标准端口80;<br>  5、 HTTPS基于传输层，HTTP基于应用层;<br>  6、 HTTPS在浏览器显示绿色安全锁，HTTP没有显示;</p><h3 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h3><ul><li>HTTPS降低用户访问速度（需多次握手）</li><li>网站改用 HTTPS 以后，由 HTTP 跳转到 HTTPS 的方式增加了用户访问耗时（多数网站采用 301、302 跳转）</li><li>HTTPS 涉及到的安全算法会消耗 CPU 资源，需要增加服务器资源（https 访问过程需要加解密）</li></ul><h3 id="HTTPS优化"><a href="#HTTPS优化" class="headerlink" title="HTTPS优化"></a>HTTPS优化</h3><h5 id="1、HSTS重定向技术"><a href="#1、HSTS重定向技术" class="headerlink" title="1、HSTS重定向技术"></a>1、HSTS重定向技术</h5><p>HSTS（HTTP Strict Transport Security）技术，启用HSTS后，将保证浏览器始终连接到网站的 HTTPS 加密版本。</p><ol><li><p>用户在浏览器里输入 HTTP 协议进行访问时，浏览器会自动将 HTTP 转换为 HTTPS 进行访问，确保用户访问安全；</p></li><li><p>省去301跳转的出现，缩短访问时间；</p></li><li><p>能阻止基于 SSL Strip 的中间人攻击，万一证书有错误，则显示错误，用户不能回避警告，从而能够更加有效安全的保障用户的访问。</p></li></ol><h5 id="2、TLS握手优化"><a href="#2、TLS握手优化" class="headerlink" title="2、TLS握手优化"></a>2、TLS握手优化</h5><p>​    在传输应用数据之前，客户端必须与服务端协商密钥、加密算法等信息，服务端还要把自己的证书发给客户端表明其身份，这些环节构成 TLS 握手过程。</p><p>​    采用 False Start （抢先开始）技术，浏览器在与服务器完成 TLS 握手前，就开始发送请求数据，服务器在收到这些数据后，完成 TLS 握手的同时，开始发送响应数据。</p><p>​    开启 False Start 功能后，数据传输时间将进一步缩短。</p><h5 id="3、Session-Identifier（会话标识符）复用"><a href="#3、Session-Identifier（会话标识符）复用" class="headerlink" title="3、Session Identifier（会话标识符）复用"></a>3、Session Identifier（会话标识符）复用</h5><p>​    如果用户的一个业务请求包含了多条的加密流，客户端与服务器将会反复握手，必定会导致更多的时间损耗。或者某些特殊情况导致了对话突然中断，双方就需要重新握手，增加了用户访问时间。</p><p>​    （1）服务器为每一次的会话都生成并记录一个 ID 号，然后发送给客户端；</p><p>​    （2）如果客户端发起重新连接，则只要向服务器发送该 ID 号；</p><p>​    （3）服务器收到客户端发来的 ID 号，然后查找自己的会话记录，匹配 ID 之后，双方就可以重新使用之前的对称加密秘钥进行数据加密传输，而不必重新生成，减少交互时间。</p><h5 id="4、开启OSCP-Stapling，提高TLS握手效率"><a href="#4、开启OSCP-Stapling，提高TLS握手效率" class="headerlink" title="4、开启OSCP Stapling，提高TLS握手效率"></a>4、开启OSCP Stapling，提高TLS握手效率</h5><p>​    采用OCSP Stapling ，提升 HTTPS 性能。服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而客户端可直接通过 Web Server 验证证书，提高 TLS 握手效率。</p><p>​    服务器模拟浏览器向 CA 发起请求，并将带有 CA 机构签名的 OCSP 响应保存到本地，然后在与客户端握手阶段，将 OCSP 响应下发给浏览器，省去浏览器的在线验证过程。由于浏览器不需要直接向 CA 站点查询证书状态，这个功能对访问速度的提升非常明显。</p><h5 id="5、完全前向加密PFS，保护用户数据，预防私钥泄漏"><a href="#5、完全前向加密PFS，保护用户数据，预防私钥泄漏" class="headerlink" title="5、完全前向加密PFS，保护用户数据，预防私钥泄漏"></a>5、完全前向加密PFS，保护用户数据，预防私钥泄漏</h5><p>​    非对称加密算法 RSA，包含了公钥、私钥，其中私钥是保密不对外公开的，由于此算法既可以用于加密也可以用于签名，所以用途甚广，但是还是会遇到一些问题：</p><p>（1） 假如我是一名黑客，虽然现在我不知道私钥，但是我可以先把客户端与服务器之前的传输数据（已加密）全部保存下来</p><p>（2）如果某一天，服务器维护人员不小心把私钥泄露了，或者服务器被我攻破获取到了私钥</p><p>（3）那我就可以利用这个私钥，破解掉之前已被我保存的数据，从中获取有用的信息</p><p>​    所以为了防止上述现象发生，我们必须保护好自己的私钥。</p><p>​    如果私钥确实被泄漏了，那我们改如何补救呢？那就需要PFS（perfect forward secrecy）完全前向保密功能，此功能用于客户端与服务器交换对称密钥，起到前向保密的作用，也即就算私钥被泄漏，黑客也无法破解先前已加密的数据。维基解释是：<strong>长期使用的<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5">主密钥</a>泄漏不会导致过去的<a href="https://zh.wikipedia.org/wiki/%E6%9C%83%E8%A9%B1%E5%AF%86%E9%91%B0">会话密钥</a>泄漏</strong></p><p>​    实现此功能需要服务器支持以下算法和签名组合：</p><p>（1）ECDHE 密钥交换、RSA 签名；</p><p>（2）ECDHE 密钥交换、ECDSA 签名；</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="%5Bhttps://blog.csdn.net/qq_35642036/article/details/82788421#HTTP%E4%B8%8EHTTPS%E4%BB%8B%E7%BB%8D%5D(https://blog.csdn.net/qq_35642036/article/details/82788421#HTTP%E4%B8%8EHTTPS%E4%BB%8B%E7%BB%8D)">HTTP与HTTPS的区别，详细介绍</a></li><li><a href="https://segmentfault.com/p/1210000009272802/read">详解全站 HTTPS 访问优化</a></li><li><a href="https://blog.csdn.net/hherima/article/details/52469360">HTTPS协议详解(二)：TLS&#x2F;SSL工作原理</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 安全基础知识.md</title>
    <link href="/20200730/4011708/"/>
    <url>/20200730/4011708/</url>
    
    <content type="html"><![CDATA[<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>在介绍HTTPS协议之前，因该先了解网络安全的知识，这样才能知道为什么HTTP协议升级为HTTPS协议。</p><h3 id="网络安全问题概述"><a href="#网络安全问题概述" class="headerlink" title="网络安全问题概述"></a>网络安全问题概述</h3><p>计算机网络通信主要面临两大类威胁，即<strong>主动攻击</strong>与<strong>被动攻击</strong></p><p>被动攻击指：攻击者从网络上窃取他人通信内容，通常称为截获。被动攻击中，攻击者只是观察和分析某一个<u>协议数据单元PDU</u>而不干扰信息流，主要通过观察协议控制信息部分了解正在通信的协议实体地址和身份、研究PDU的长度和传输的频度，也称<u>流量分析</u>。</p><p>主动攻击有以下几种形式：</p><ul><li>篡改：恶意篡改网络上传送的报文</li><li>恶意程序：计算机病毒；计算机蠕虫；特洛伊木马；逻辑炸弹；后门入侵；流氓软件等</li><li>拒绝服务DoS：指攻击者不停向服务器发送大量分组，使该服务器无法正常工作</li></ul><span id="more"></span><p>对于主动攻击可以采取措施检测，被动攻击通常检测不出来，根据这些特点可以得出计算机网络通信安全的目标如下：</p><ol><li>防止析出报文内容和流量分析</li><li>防止恶意程序</li><li>检测更改报文流和拒绝服务</li><li>采用加密技术对服被动攻击；将加密技术和鉴别技术结合对服主动攻击</li></ol><p>一个安全的计算机网络应该达到以下四个目标：</p><ol><li>保密性</li><li>端点鉴别</li><li>信息的完整性</li><li>运行安全性</li></ol><h4 id="数据加密模型"><a href="#数据加密模型" class="headerlink" title="数据加密模型"></a>数据加密模型</h4><p>一般加密模型如下图，用户A向用户B发送<em>明文X</em>，通过<em>加密算法E</em>运算后，得到<em>密文Y</em>。</p><p>加密解密所用的<em>密钥K(Key)<em>是一串秘密的字符串。在接收端使用</em>解密算法D</em>运算和<em>解密密钥K</em>，解出明文X。</p><p>解密算法是加密算法的逆运算，如果解密时不采用事先约定好的密钥就无法解密出明文。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418180034801.png" alt="image-20230418180034801" style="zoom:80%;" /><h3 id="两类密码体制"><a href="#两类密码体制" class="headerlink" title="两类密码体制"></a>两类密码体制</h3><p>密码学分为：密码编码学、密码分析学。如果截获者无论获取多少密文都不能找到足够的信息来唯一确定对应明文，则称这一密码体制是<u>无条件安全的</u>（或<u>理论上不可破的</u>）</p><h4 id="对称密钥密码体制"><a href="#对称密钥密码体制" class="headerlink" title="对称密钥密码体制"></a>对称密钥密码体制</h4><p>所谓对称密钥密码体制，即<strong>加密密钥和解密密钥是使用相同的密码体制</strong>，上面加密模型图就是采用这种。</p><p>数据加密标准DES属于对称密钥密码体制，由IBM研制。DES是一种分组密码，在加密前将整个明文分组，每组为64位长的二进制数据；然后对每一个64位二进制数据进行加密处理，产生一组64位密文数据；最后将各组密文串接得到整个密文，使用的密钥占64位（实际密钥56位，奇偶校验位8位）</p><p>DES的保密性取决于对密钥的保密，而算法是公开的。DES的问题是密钥长度是56位，即有2^56中可能密钥。但是现在的计算机是可以搜索破解的。因此有学者提出了三重DES方法：将一个64明文用一个密钥加密，再用另一个密钥解密，再用另一个密钥加密 *Y&#x3D;DES <sub>k1</sub>(DES<sup>-1</sup> <sub>k2</sub>( DES<sub>k3</sub>(X)))*；</p><h4 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h4><p>公钥密码体制是由斯坦福大学的研究人员Diffie与Hellman提出的。<strong>公钥密码体制使用不同的加密密钥和解密密钥</strong></p><p>产生原因：</p><ul><li>对称密钥密码体制的密钥分配问题</li><li>由于对数字签名的需求</li></ul><p>目前最著名的是美国三位科学家Rivest、Shamir、Adleman提出的<strong>RSA体制</strong>，它是一种基于数论中的大数分解问题的体制。</p><p>在公钥密码体制中，加密密钥*PK(Primary Key)<em>是向公众公开的，解密密钥</em>SK(Secret Key)*则是要保密的，加密算法E和解密算法D也是公开的。</p><p>公钥密码体制加密解密过程特点：</p><ol><li><strong>密钥对</strong>产生器产生出接收者B的一对密钥：加密密钥PK<sub>B</sub>和解密密钥SK<sub>B</sub>。发送者A所用的加密密钥PK<sub>B</sub>就是接收者B的公钥，它向公众公开，而B所用的解密密钥SK<sub>B</sub>就是接收者B的私钥，对别人保密。</li><li>发送者A用B的公钥PK<sub>B</sub>通过E运算对明文X加密，得出密文Y，发送给B。<em>Y &#x3D; E<sub> PK<sub>B</sub> </sub>( X )</em></li><li>B用自己的私钥SK<sub>B</sub>通过D运算进行解密，恢复出明文。D <sub>SK<sub>B</sub></sub>( Y ) &#x3D; D <sub>SK<sub>B</sub></sub>( E<sub> PK<sub>B</sub> </sub>( X ) ) &#x3D; X</li><li>虽然在计算机上很容易生产成对的PK<sub>B</sub>和SK<sub>B</sub>，但是由已知的PK<sub>B</sub>推导出SK<sub>B</sub>属实“计算上不可能的”</li><li>公钥可以用来加密，但是不能用来解密。D <sub>PK<sub>B</sub></sub>( E<sub> PK<sub>B</sub> </sub>( X ) )  不等于 X</li><li>先对X进行D运算再E运算，和先E运算再D运算结果是一样的</li></ol><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418180225954.png" alt="image-20230418180225954" style="zoom:80%;" /><p>对称密钥中双方使用相同的密钥，可以实现通信信道上的一对一双向保密通信；公开密钥中通信信道上可以实现双方多对一的单向保密通信</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>数字签名功能：</p><ol><li>报文鉴别：接收者能何时发送者对报文的签名，即确认发送者信息。</li><li>报文完整性：接收者确信接收的数据与发送者发送是完全一致未被篡改的。</li><li>不可否认：发送者事后不能抵赖对报文的签名。</li></ol><p>现在已经有多种实现数字签名的方法，其中采用公钥算法更容易实现。</p><p>为进行签名，A用其私钥SK<sub>A</sub>对报文X进行D运算（此处的D运算并非指解密运算），得到不可读的密文，将密文传送给B。B为了核实签名，用A的公钥PK<sub>A</sub>进行E运算还原出明文X（注：任何人用A的公钥进行E运算后都可以得到A发送的明文）。这里的通信不是为了保密，而是为了签名和核实签名，即确认发送者信息</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418180244090.png" alt="image-20230418180244090" style="zoom:80%;" /><p>上述功能分析：</p><ul><li>由于除A外没有人拥有A的私钥SK<sub>A</sub>，那么除了A就没人能产生密文D<sub>SK<sub>A</sub></sub>(X)。这样B就能相信X是A签名发送的，这就是报文鉴别功能</li><li>同理，其他人若篡改报文，但由于没有A的私钥SK<sub>A</sub>来对X进行加密，那么B对篡改后的报文解密时将会得到不可读的明文，由此知道报文被篡改过了，这就是报文完整性</li><li>若A抵赖发送过报文给B，B可以将明文X和密文D<sub>SK<sub>A</sub></sub>(X)出示给公证的第三者，第三者很容易用PK<sub>A</sub>去证实A确实发送过保温给B，这就是不可否认。</li></ul><p>上述过程中A仅对报文签名，未对报文保密，因此接获到密文D<sub>SK<sub>A</sub></sub>(X)后，可以通过查手册知道公钥PK<sub>A</sub>从而知道报文内容X。可以使用A、B两者的公钥实现保密和签名</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418180257317.png" alt="image-20230418180257317" style="zoom:80%;" /><h3 id="鉴别"><a href="#鉴别" class="headerlink" title="鉴别"></a>鉴别</h3><p>鉴别(Authentication)是网络安全中非常重要的一个话题。鉴别与加密不同。<strong>鉴别是要验证通信的对方确实是自己所要通信的对象，而不是其他冒充者，并且所传送的报文是完整的，未被篡改过</strong>。</p><h4 id="报文鉴别"><a href="#报文鉴别" class="headerlink" title="报文鉴别"></a>报文鉴别</h4><p><strong>1.密码散列函数</strong></p><p>理论上讲上述的签名就可以实现对报文的鉴别，不过这种方法很大的一个缺点就是对较长的报文进行数字签名会是计算机负担增大很多，因此需要一个相对简单的方法——<strong>密码散列函数</strong>。前面所讲过的校验和其实就是散列函数的一种应用。散列函数有如下特点：</p><p>(1)散列函数的输入长度可以很长，但是<strong>输出长度是固定的，并且较短</strong>。散列函数的输出值叫做<strong>散列值</strong>，简称散列</p><p>(2)不同散列值肯定对应于不同输入，但是不同输入可能会有相同散列值。即散列函数的输入和输出是多对一的</p><p>密码散列函数最重要的特点：要找到两个不同的报文，使得他们的散列密码输出相同，在计算上是不可行的</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418180308755.png" alt="image-20230418180308755" style="zoom:80%;" /><p><strong>2.实用密码散列函数MD5和SHA-1</strong></p><p>最出名的密码散列函数MD5和SHA-1。以MD5为例，算法大致过程如下：</p><ol><li>先把任意长度的报文按模2<sup>64</sup>计算余数，追加在报文后面</li><li>在报文和余数之间填充1~512位，使得填充后的总长度是512的整数倍。填充的首位是1后面全0</li><li>把追加的和填充的报文分割为一个个的512位数据块，每512位报文数据再分成4个128位的数据块送到不同散列函数进行4轮计算，每一轮又按32位小数据块进行运算，直到最后计算出MD5报文摘要代码(128位)</li></ol><p>这样得出的MD5报文摘要代码的每一位都与原报文的每一位有关！</p><p>SHA和MD5相似，但是码长为160位（比MD5的128位多了25%），也是用512位长的数据块运算得出</p><p><strong>3.报文鉴别码</strong></p><p>接下来说说怎样在报文鉴别中用散列函数，基本步骤：</p><ol><li><p>用户A根据自己的明文<em>X</em>计算出散列*H(X)*。为方便起见称其H<sub>1</sub>。</p></li><li><p>用户将散列H拼接在明文<em>X</em>后面，生成了拓展的报文*(X,H<sub>1</sub>)*，然后发送给B。</p></li><li><p>B收到拓展的报文，由于散列长度是已知的固定值，因此可将散列H<sub>1</sub>和明文X分开。B、通过散列函数运算，计算出收到的明文X的散列H<sub>2</sub>(X)，若H<sub>2</sub>&#x3D;H<sub>1</sub>似乎就可以相信是A发送的，但是这是不行的（有可能攻击者伪造了一个报文M，同样计算出H<sub>2</sub>(X)后，再将拼接有散列的拓展保温发送给B，B收到拓展保温(M,H<sub>2</sub>(X) )后验证发现正常，就会出现错误！）</p></li><li><p>解决方法就是对散列进行一次加密</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418180323015.png" alt="image-20230418180323015" style="zoom:80%;" /></li></ol><h4 id="实体鉴别"><a href="#实体鉴别" class="headerlink" title="实体鉴别"></a>实体鉴别</h4><p>报文鉴别是对每一个报文都要鉴别报文发送者，而实体鉴别是在系统接入的全部持续时间内对和自己通信的对方实体进行一次验证即可</p><p>最简单的过程：A像远端B发送带有自己信息和口令的报文，并约定双方使用共享对称密钥K<sub>AB</sub>加密。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418180334162.png" alt="image-20230418180334162" style="zoom:80%;" /><p>这样的方法有很明显的漏洞：攻击者C可以截获A发送的报文，不需要破译，而是直接将其发送给B，使得B误认为C的身份是A，然后B向C发送本该发送给A的报文。这就叫**重放攻击(replay attack)**，C甚至还可以截获A的IP地址将其冒充为自己的IP（IP欺骗），使B更容易受骗。</p><p>为对付重放攻击，可以使用<strong>不重数</strong>，即一个<strong>不重复使用的大随机数</strong></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418180343328.png" alt="image-20230418180343328" style="zoom:80%;" /><p>A用明文发送身份A和一个不重数R<sub>A</sub>给B。B响应A的查问，用共享密钥K<sub>AB</sub>对R<sub>A</sub>加密后发回A，同时也给出自己的不重数R<sub>B</sub>。最后A响应B的查问，用共享密钥K<sub>AB</sub>对R<sub>B</sub>加密后发回B。（注：A与B在不同对话中必须使用不同的不重数）由于不重数不能重复使用，C在重放攻击时就无法重复使用截获的不重数</p><p>即使这样，还是会有收到攻击的可能，常见的就是中间人攻击</p><h3 id="密钥分配"><a href="#密钥分配" class="headerlink" title="密钥分配"></a>密钥分配</h3><p>由于密码算法是公开的，网络的安全性就完全基于密钥的保护上，因此产生了一个重要分支——密钥管理。主要包括密钥的产生、分配、注入、验证和使用</p><h4 id="1-对称密钥分配"><a href="#1-对称密钥分配" class="headerlink" title="1.对称密钥分配"></a>1.对称密钥分配</h4><p>假设n个人中两两都有通信，那么就要n(n-1)&#x2F;2个密钥，接近n<sup>2</sup>情况，n很大时密钥数量就会非常大</p><p>目前常用的密钥分配方式是<strong>密钥分配中心KDC（Key Distribution Center）</strong>。基本流程：</p><ul><li>A向KDC发送明文，说明想和B通信，并给出A、B在KDC登记的身份</li><li>KDC用随机数产生”一次一密”的会话密钥K<sub>AB</sub>，向A发送回答报文（用K<sub>A</sub>加密），报文包括本次会话使用的密钥K<sub>AB</sub>和请A转给B的票据(ticket)，票据包含A、B在KDC等级的身份以及会话密钥（票据用K<sub>B</sub>加密）A无法知道票据内容。</li><li>B收到A转发来的票据后使用K<sub>B</sub>解密，就知道A要和自己通信，也知道了KDC为此次会话分配的密钥K<sub>AB</sub></li><li>A、B就可以开始通信了</li></ul><p>注：在网络上传送的密钥都是经过加密的。KDC还可以在报文中加入时间戳，以防止报文截取这利用以前记录的报文进行重放攻击。</p><p>目前最出名的密钥分配协议是Kerberos V5。由MIT开发，Kerberos既是鉴别协议也是KDC</p><h4 id="2-公钥分配"><a href="#2-公钥分配" class="headerlink" title="2.公钥分配"></a>2.公钥分配</h4><p>在公钥密码体制中，使用**认证中心CA(Certification Authority)<strong>来将公钥与对应实体</strong>绑定(binding)**，它一般由政府出资建立。</p><p>在IE浏览器中，选择工具&#x2F;Internet选项&#x2F;内容&#x2F;证书。即可查看有关证书发行机构的信息。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 HTTP协议详解.md</title>
    <link href="/20200730/5806080f/"/>
    <url>/20200730/5806080f/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h3><p>超文本传输协议（英文：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是面向事务的应用层协议，是万维网的数据通信的基础。</p><h3 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h3><p>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p><span id="more"></span><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><h4 id="原理概念"><a href="#原理概念" class="headerlink" title="原理概念"></a>原理概念</h4><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/http1.png" style="zoom:67%;" /><p>每个万维网都有一个服务器进程，不断监听TCP的80端口，一边发现是否有浏览器向她发送连接建立请求，一旦监听到连接建立请求并创建了TCP连接后，浏览器就向万维网发出浏览某个页面的请求，服务器响应返回相应的页面，结束后释放TCP连接</p><h4 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h4><ol><li>客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。</li><li>发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li><li>服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li><li>释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li><li>客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li></ol><p><font color="red"><strong>例如，浏览器中输入<code>www.baidu.com</code>后流程如下：</strong></font></p><ul><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</li><li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li><li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li><li>释放 TCP连接;</li><li>浏览器将解析该 html 文本并渲染界面。</li></ul><h3 id="HTTP是无状态的"><a href="#HTTP是无状态的" class="headerlink" title="HTTP是无状态的"></a>HTTP是无状态的</h3><p>HTTP是一种不保存状态,即无状态(stateless)协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别,协议对于发送过的请求或响应都不做持久化处理。同一个客户第二次访问同一个服务器页面时，服务器的响应与第一次被访问时是相同的。</p><p>无状态特性简化了服务器设计，使服务器更容易支持大量并发的HTTP请求</p><h3 id="HTTP是无连接的"><a href="#HTTP是无连接的" class="headerlink" title="HTTP是无连接的"></a>HTTP是无连接的</h3><p>HTTP协议本身是无连接的，即虽然HTTP使用了TCP连接，但是在通信双方交换HTTP报文之前不需要建立HTTP连接。它的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次响应一次，服务端和客户端就中断了。</p><p>HTTP请求一个万维网文档所需时间是该文档的传输时间加上两倍往返时间RTT(一个用于建立TCP连接；一个用于请求和接受文档)，<u>其中TCP建立连接的三报文握手中第三个报文段中的数据就是客户端对服务器的请求报文</u></p><h4 id="HTTP1-1持续连接"><a href="#HTTP1-1持续连接" class="headerlink" title="HTTP1.1持续连接"></a>HTTP1.1持续连接</h4><p>现在的http协议1.1版本不是直接就断开了，而是等一段时间，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的。</p><p>HTTP&#x2F;1.1协议的持续连接有两种方式：<strong>非流水式</strong>和<strong>流水方式</strong></p><p>非流水式：再客户收到前一个的响应后才发送下一个请求，节省了建立TCP连接所需的一个RTT时间</p><p>流水式：在收到服务器的响应报文之前就能继续发送新的请求报文，<u>客户端访问所有的对象只需花费一个RTT时间</u></p><h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><p>HTTP报文有两类：请求报文；响应报文</p><p>两种报文就是开始行不同，各内容之间用空格隔开</p><p>请求报文：方法（HTTP请求方法）、请求资源的URL、HTTP版本</p><p>响应报文：HTTP版本、状态码、描述状态的短语</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/http2.png"></p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/http3.png"></p><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><p><strong>OPTION</strong></p><p>请求一些选项的信息。这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p><p><strong>GET</strong></p><p>请求读取由URL所标志的信息。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</p><p><strong>HEAD</strong></p><p>请求读取由URL所标志的信息的首部。与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</p><p><strong>POST</strong></p><p>给服务器添加信息（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p><p><strong>PUT</strong></p><p>在指明的URL下上传存储一个文档</p><p><strong>DELETE</strong></p><p>删除指定的URL所标识的资源</p><p><strong>TRACE</strong></p><p>用来进行环回测试的请求报文，主要用于测试和诊断</p><p><strong>CONNECT</strong></p><p>用于代理服务器</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>状态码（Status-Code）分为五大类</p><table><thead><tr><th align="left">状态码分类</th><th>类别&amp;原因短语</th></tr></thead><tbody><tr><td align="left"><strong>1xx</strong></td><td>表示通知信息，如收到请求或正在处理</td></tr><tr><td align="left"><strong>2xx</strong></td><td>表示成功，如接受或知道了</td></tr><tr><td align="left"><strong>3xx</strong></td><td>表示重定向，如要完成请求还必须采取进一步行动</td></tr><tr><td align="left"><strong>4xx</strong></td><td>表示客户端的差错，如请求中有语法错误或不能完成</td></tr><tr><td align="left"><strong>5xx</strong></td><td>表示服务器的差错，如服务器失效</td></tr></tbody></table><p>常见状态码：</p><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL（http重定向https即为301）</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li><li>502 - 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li></ul><h3 id="浏览器实例"><a href="#浏览器实例" class="headerlink" title="浏览器实例"></a>浏览器实例</h3><p>以点击百度为例，查看请求行和状态行的信息</p><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Request URL: https:<span class="hljs-comment">//www.baidu.com/  //请求地址</span><br>Request Method: GET<span class="hljs-comment">//请求方法</span><br>Status Code: <span class="hljs-number">200</span> OK<span class="hljs-comment">//状态码</span><br>Remote Address: <span class="hljs-number">112.80</span><span class="hljs-number">.248</span><span class="hljs-number">.75</span>:<span class="hljs-number">443</span><span class="hljs-comment">//地址</span><br>Referrer Policy: unsafe-url<br></code></pre></td></tr></table></figure><p><strong>请求标头</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Accept: text/html......<span class="hljs-comment">//支持的数据类型</span><br>Accept-Encoding: gzip, deflate, br<span class="hljs-comment">//编码格式</span><br>Accept-Language: zh-CN,zh;q=<span class="hljs-number">0.9</span>,en;q=<span class="hljs-number">0.8</span>,en-GB;q=<span class="hljs-number">0.7</span>,en-US;q=<span class="hljs-number">0.6</span><span class="hljs-comment">//语言环境</span><br>Cache-Control: max-age=<span class="hljs-number">0</span><span class="hljs-comment">//缓存控制</span><br>Connection: keep-alive<span class="hljs-comment">//连接</span><br>......<br>User-Agent: Mozilla/<span class="hljs-number">5.0</span> (Windows NT <span class="hljs-number">10.0</span>; Win64; x64) AppleWebKit/<span class="hljs-number">537.36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">84.0</span><span class="hljs-number">.4147</span><span class="hljs-number">.105</span> Safari/<span class="hljs-number">537.36</span> Edg/<span class="hljs-number">84.0</span><span class="hljs-number">.522</span><span class="hljs-number">.49</span><span class="hljs-comment">//客户端信息</span><br></code></pre></td></tr></table></figure><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Bdpagetype: <span class="hljs-number">1</span><br>Bdqid: <span class="hljs-number">0xfa9c8c0b0007119f</span><br>Cache-Control: <span class="hljs-keyword">private</span><span class="hljs-comment">//缓存控制</span><br>Connection: keep-alive<span class="hljs-comment">//连接</span><br>Content-Encoding: gzip<br>Content-Type: text/html;charset=utf-<span class="hljs-number">8</span><br>......<br></code></pre></td></tr></table></figure><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h3><p>HTTP使用URI来传输数据和建立连接。URL(统一资源定位符)是一类特殊的URI，</p><p>一般形式：</p><blockquote><p>协议:&#x2F;&#x2F;&lt;主机IP&gt;:&lt;端口&gt;&#x2F;&lt;路径&gt;</p></blockquote><p>以我的博客<code>http://salute61.top/2020/07/22/操作系统--进程管理/</code>为例</p><p>协议是http；<a href="http://www.salute61.top是对应主机服务器(默认省略了80端口);/2020/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F--%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E6%98%AF%E8%B7%AF%E5%BE%84">www.salute61.top是对应主机服务器（默认省略了80端口）；/2020/07/22/操作系统--进程管理/是路径</a></p><p>后面还可以有查询（以<code>?</code>为起点，参数用<code>&amp;</code>隔开再以<code>=</code>分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）;片段（以<code>#</code>字符为起点）</p><h3 id="拓展：Cookie"><a href="#拓展：Cookie" class="headerlink" title="拓展：Cookie"></a>拓展：Cookie</h3><p>上面说到过HTTP是无状态的，这样简化了服务器设计，但是实际工作中网站是希望能感识别用户的。例如网上购物时，一个用户要买多个商品，将一件商品加入购物车后还想继续浏览选购；或者网站相对某些用户的访问做限制等等。。。</p><p>要实现这些可以在HTTP中使用Cookie，表示在HTTP服务器和客户之间传递的状态信息。</p><p><strong>Cookie工作方式</strong></p><ul><li>当用户A在浏览某个使用Cookie的网站时，该网站的服务器就为A产生一个唯一的识别码，并以此作为索引在服务器后端数据库中产生一个项目，然后给A的HTTP响应报文添加一个Set-Cookie首部行。<ul><li>例如<code>Set-Cookie：31d5b4c6d4c620ads15</code>。</li></ul></li><li>A收到响应后浏览器就在管理的特定Cookie文件中添加这一行。A以后继续浏览这个网站时，浏览器就会从Cookie文件中取出这个网站识别码并放到HTTP请求报文Cookie首部行中<ul><li>例如<code>Cookie：31d5b4c6d4c620ads15 </code>。</li></ul></li><li>于是网站就能追踪用户31d5b4c6d4c620ads15（即用户A）在该网站的活动</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 5.设备管理</title>
    <link href="/20200727/fb650d11/"/>
    <url>/20200727/fb650d11/</url>
    
    <content type="html"><![CDATA[<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul><li>输入输出控制方式</li><li>缓冲区的管理</li><li>设备分配和设备处理</li><li>磁盘调度</li><li>虚拟设备</li><li>对通道的理解</li><li>Spooling技术。</li></ul><span id="more"></span><h2 id="5-1-I-x2F-O系统"><a href="#5-1-I-x2F-O系统" class="headerlink" title="5.1 I&#x2F;O系统"></a>5.1 I&#x2F;O系统</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><ul><li>I&#x2F;O系统：在操作系统中负责管理输入输出设备的部分称为I&#x2F;O系统。</li><li>I&#x2F;O系统的基本功能：是为数据传输选择输入输出设备；在选定的输入输出设备和CPU（或主存）之间交换数据。</li><li>操作系统内核通过设备驱动程序与外部设备进行交互。驱动程序是设备与内核其他部分之间的唯一接口。</li><li>文件系统是对设备操作的组织与抽象，而设备操作则是对文件操作的最终实现。</li></ul><h3 id="2-I-x2F-O设备分类"><a href="#2-I-x2F-O设备分类" class="headerlink" title="2.I&#x2F;O设备分类"></a>2.I&#x2F;O设备分类</h3><ul><li>信息组织方式：字符设备；块设备(有结构可寻址)</li><li>设备使用的可共享性：独占设备；共享设备；虚拟设备</li><li>设备使用特性：存储设备；输入&#x2F;输出设备</li></ul><h3 id="I-x2F-O体系结构"><a href="#I-x2F-O体系结构" class="headerlink" title="I&#x2F;O体系结构"></a>I&#x2F;O体系结构</h3><h4 id="1-总线"><a href="#1-总线" class="headerlink" title="1.总线"></a>1.总线</h4><ul><li><p>在计算机系统中，数据信息是通过数据通道在CPU、RAM 和I&#x2F;O设备之间流动的。这些数据通道又称为总线。</p><p><img src="https://img.mubu.com/document_image/932491b3-7b3a-4340-89ca-0c1405cd0954-7976057.jpg" alt="img"></p></li></ul><h4 id="2-I-x2F-O-总线"><a href="#2-I-x2F-O-总线" class="headerlink" title="2.I&#x2F;O 总线"></a>2.I&#x2F;O 总线</h4><ul><li><p>I&#x2F;O总线是用来连接CPU和I&#x2F;O设备的总线。每个I&#x2F;O设备都依次连接到I&#x2F;O总线上，这种连接使用了有3个元素的硬件构件层次：I&#x2F;O端口、I&#x2F;O接口和设备控制器。</p><p><img src="https://img.mubu.com/document_image/c69843fb-aa47-4f9f-8d00-729f24b7fbcf-7976057.jpg" alt="img"></p></li><li><p><strong>(1)I&#x2F;O端口</strong>（I&#x2F;O port),即为连接到I&#x2F;O总线上的设备的I&#x2F;O地址。例IBM PC 体系结构中的I&#x2F;O地址空间，一共有65536个8位的I&#x2F;O端口。CPU在执行指令时，使用地址总线选择所请求的I&#x2F;O端口，使用数据总线在CPU寄存器和I&#x2F;O端口之间传送数据。若 I&#x2F;O端口能被映射到内存物理地址空间，CPU和I&#x2F;O设备之间的通信就可以通过使用对内存进行操作的汇编语言指令（如，mov、and、or等等）来实现。现代的硬件设备倾向于把I&#x2F;O端口映射到内存物理地址空间。为了实现起来方便，操作系统设计者把每个设备的I&#x2F;O端口都组织成一组专用寄存器：控制寄存器、状态寄存器、输入寄存器、输出寄存器。</p></li><li><p><strong>(2)I&#x2F;O接口起翻译器的作用：</strong>把I&#x2F;O端口中的值转换成设备所需要的命令和数据；检测设备状态的变化，并对设备状态寄存器（某一I&#x2F;O端口）进行相应地更新。I&#x2F;O接口通过一条IRQ线连接到可编程中断控制器上，以使它代表相应的设备发出中断请求。有两种类型的接口：专用I&#x2F;O接口和通用I&#x2F;O接口。</p></li><li><p>专用I&#x2F;O接口:专用于特定的硬件设备。有时专用I&#x2F;O接口与设备控制器处于同一块卡中。</p></li><li><p>通用I&#x2F;O接口:是用于连接外部设备的。并口可用于连接打印机、可移动磁盘、扫描仪、备份设备、其他计算机等等</p></li><li><p><strong>(3)设备控制器的主要作用</strong>：对从I&#x2F;O接口接收到的高级命令进行解释，并通过向设备发送适当的电信号序列强制设备执行特定的操作；对从设备接收到的电信号进行转换和适当地解释，并通过I&#x2F;O接口修改状态寄存器的值。复杂的设备通常需要设备控制器来驱动，而较简单的设备可以没有设备控制器，如可编程中断控制器、可编程间隔定时器。</p></li><li><p>所有的PC机都包含DMAC（Direct Memory Access Controller）辅助处理器。DMA（直接内存访问）作为一种输入输出方式，主要用来连接高速外围设备，如磁盘、磁带等，控制数据在RAM和I&#x2F;O设备之间传送。</p></li></ul><h3 id="I-x2F-O系统的功能"><a href="#I-x2F-O系统的功能" class="headerlink" title="I&#x2F;O系统的功能"></a>I&#x2F;O系统的功能</h3><p>1.概述：用户对I&#x2F;O设备的使用要求是方便、高效、安全和正确。I&#x2F;O系统的功能也就应该在计算机硬件结构提供的既定设备范围及其连接模式下，完成用户对I&#x2F;O设备的使用要求。</p><p>2.I&#x2F;O系统的功能：</p><ul><li>(1)方便性：为了让用户能方便使用I&#x2F;O设备，提供简便易用的对逻辑设备进行逻辑操作的抽象接口；实现抽象接口到物理接口的转化，即将高级逻辑操作转化为低级物理操作。</li><li>抽象接口除了掩蔽硬件细节外还要掩蔽依赖于硬件的软件技术细节。</li><li>设备抽象接口是由设备管理功能接口和文件系统功能接口共同提供的，更准确地说，设备抽象接口包含在文件系统统一接口中。</li><li>抽象接口使广义的设备独立性成为可能，向用户展示一个大大简化了的计算环境观点，同时，抽象接口也是提高效率技术的前提。</li><li>广义的I&#x2F;O设备独立性是指整个设备管理功能的抽象接口，程序不关心物理设备的操作和组织细节，而只看到具有逻辑名称和逻辑性质的逻辑设备和逻辑操作，不关心具体I&#x2F;O设备是哪一个具体设备或是哪一个文件，设备改变而程序不变，不必修改，也不必重新编译。用户不必关心设备的改变，这一事实所带来的问题应该由操作系统来管理。所使用的设备的变化对程序是透明的。块设备的设备独立性是由文件系统的文件目录概念提供的。</li><li>(2)效率：非系统用户关心其程序的运行效率，系统用户关心系统的利用率；非系统用户不希望程序等待设备，系统用户不希望设备等待程序。</li><li>在现代操作系统中，已引入了大量的技术以提高设备与CPU的效率，例如中断、缓冲、DMA、通道等。因此，操作系统设备管理的一个主要功能是采用各种纯软件或与硬件配合的软件技术来提高设备效率和与此相关的系统效率，提供物理I&#x2F;O设备的共享并优化这些设备的使用，同时借助抽象接口使得这些优化技术得以在内部实施而对用户透明。</li><li>(3)保护:用户希望能安全正确地使用设备，即希望由设备传送或管理的数据应该是安全的，不被破坏和泄密。另外，对设备拥有所有权的用户希望设备不能被破坏。</li><li>系统如何阻止用户访问他们无权访问的设备呢？微机系统多半不设保护，任何进程能做它想做的任何事情。在大多数主机系统中，用户进程对I&#x2F;O设备的访问完全被禁止。在UNIX系统中，对应于I&#x2F;O设备的特别文件受一般的rwx位保护。系统管理员据此为每台设备确定适当的授权。</li></ul><h2 id="5-2-I-x2F-O控制方式"><a href="#5-2-I-x2F-O控制方式" class="headerlink" title="5.2 I&#x2F;O控制方式"></a><font color="red">5.2 I&#x2F;O控制方式</font></h2><h3 id="【输入-x2F-输出控制-程序直接控制方式】"><a href="#【输入-x2F-输出控制-程序直接控制方式】" class="headerlink" title="【输入&#x2F;输出控制-程序直接控制方式】"></a><font color="red">【输入&#x2F;输出控制-程序直接控制方式】</font></h3><ul><li><p>程序直接控制方式是指由程序直接控制内存或CPU和外围设备之间进行信息传送的方式。通常又称为“忙—等”方式或循环测试方式。</p></li><li><p>在数据传送过程中，必不可少的一个硬件设备是I&#x2F;O控制器，它是操作系统软件和硬件设备之间的接口，它接收CPU的命令，并控制I&#x2F;O设备进行实际的操作。</p><p><img src="https://img.mubu.com/document_image/4a1260d0-6c78-4589-94bc-4b82fdd024d9-7976057.jpg" alt="img"></p></li><li><p>程序直接控制方式下输出数据时的工作过程。</p><ul><li><p>①把一个启动位为“1”的控制字写入该设备的控制状态寄存器。</p></li><li><p>②将需输出数据送到数据缓冲寄存器。</p></li><li><p>③测试控制状态寄存器中的“完成位”，若为0，转③ ，否则转④。</p></li><li><p>④输出设备将数据缓冲寄存器中的数据取走进行实际的输出。</p><img src="https://img.mubu.com/document_image/6b59639a-1f18-4f19-b15c-29b39cdadb42-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="【输入-x2F-输出控制-中断控制方式】"><a href="#【输入-x2F-输出控制-中断控制方式】" class="headerlink" title="【输入&#x2F;输出控制-中断控制方式】"></a><font color="red">【输入&#x2F;输出控制-中断控制方式】</font></h3><ul><li><p>中断驱动方式的思想是，<strong>允许I&#x2F;O设备主动打断CPU的运行并请求服务，从而“解放”CPU，使得其向I&#x2F;O控制器发送读命令后可以继续做其他有用的工作</strong>。我们从I&#x2F;O控制器和CPU两个角度分别来看中断驱动方式的工作过程：</p></li><li><p>从I&#x2F;O控制器的角度来看——I&#x2F;O控制器从CPU接收一个读命令，然后从外围设备读数据。一旦数据读入到该I&#x2F;O控制器的数据寄存器，便通过控制线给CPU发出一个中断信号，表示数据已准备好，然后等待CPU请求该数据。I&#x2F;O控制器收到CPU发出的取数据请求后，将数据放到数据总线上，传到CPU的寄存器中。至此，本次I&#x2F;O操作完成，I&#x2F;O控制器又可幵始下一次I&#x2F;O操作。</p></li><li><p>从CPU的角度来看——CPU发出读命令，然后保存当前运行程序的上下文（现场，包括程序计数器及处理机寄存器），转去执行其他程序。在每个指令周期的末尾，CPU检查中断。当有来自I&#x2F;O控制器的中断时，CPU保存当前正在运行程序的上下文，转去执行中断处理程序处理该中断。这时，CPU从I&#x2F;O控制器读一个字的数据传送到寄存器，并存入主存。接着， CPU恢复发出I&#x2F;O命令的程序（或其他程序）的上下文，然后继续运行。</p></li><li><p>中断驱动方式比程序直接控制方式有效，但由于数据中的每个字在存储器与I&#x2F;O控制器之间的传输都必须经过CPU,这就导致了中断驱动方式仍然会消耗较多的CPU时间。</p><img src="https://img.mubu.com/document_image/22d2a30f-60fa-4f86-bbd4-c3ab885d9102-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h3 id="【输入-x2F-输出控制-DMA方式】"><a href="#【输入-x2F-输出控制-DMA方式】" class="headerlink" title="【输入&#x2F;输出控制- DMA方式】"></a><font color="red">【输入&#x2F;输出控制- DMA方式】</font></h3><ul><li><p>DMA方式又称直接存储器访问（Direct Memory Access）方式。其基本思想是在外设和主存之间开辟直接的数据交换通路。DMA方式的特点是：</p><ul><li>(1)数据传送的基本单位是数据块。</li><li>(2)所传送的数据是从设备送内存，或者相反。</li><li>(3)仅在传送一个或多个数据块的开始和结束时，才需中断CPU，请求干预，整块数据的传送是在DMA控制器控制下完成的。</li></ul></li><li><p>为了实现在主机与控制器之间成块数据的直接交换，必须在DMA控制器中设置如下四类寄存器</p><ul><li>命令&#x2F;状态寄存器(CR)：用于接收从CPU发来的I&#x2F;O命令或有关控制信息，或设备的状态。</li><li>内存地址寄存器(MAR)：在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</li><li>数据寄存器(DR)：用于暂存从设备到内存，或从内存到设备的数据。</li><li>数据计数器(DC)：存放本次CPU要读或写的字（节）数。</li></ul></li><li><p>DMA方式的工作过程是：CPU读写数据时，它给I&#x2F;O控制器发出一条命令，启动DMA控制器，然后继续其他工作。之后CPU就把控制操作委托给DMA控制器，由该控制器负责处理。DMA控制器直接与存储器交互，传送整个数据块，每次传送一个字，这个过程不需要CPU参与。当传送完成后，DMA控制器发送一个中断信号给处理器。因此只有在传送开始和结束时才需要CPU的参与。</p></li><li><p>DMA控制方式与中断驱动方式的主要区别是中断驱动方式在每个数据需要传输时中断CPU，而DMA控制方式则是在所要求传送的一批数据全部传送结束时才中断CPU；此外，中断驱动方式数据传送是在中断处理时由CPU控制完成的，而DMA控制方式则是在DMA 控制器的控制下完成的。</p><img src="https://img.mubu.com/document_image/cfa4c179-273f-4920-b239-a638c957b16e-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h3 id="【输入-x2F-输出控制-通道控制方式】"><a href="#【输入-x2F-输出控制-通道控制方式】" class="headerlink" title="【输入&#x2F;输出控制- 通道控制方式】"></a><font color="red">【输入&#x2F;输出控制- 通道控制方式】</font></h3><ul><li>I&#x2F;O通道是指专门负责输入&#x2F;输出的处理机。I&#x2F;O通道方式是DMA方式的发展，它可以进一步减少CPU的干预，<strong>即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。</strong>同时，又可以实现CPU、通道和I&#x2F;O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</li><li>例如，当CPU要完成一组相关的读（或写）操作及有关控制时，只需向I&#x2F;O通道发送一条I&#x2F;O指令，以给出其所要执行的通道程序的首地址和要访问的I&#x2F;O设备，通道接到该指令后，通过执行通道程序便可完成CPU指定的I&#x2F;O任务，数据传送结束时向CPU发中断请求。I&#x2F;O通道与一般处理机的区别是：通道指令的类型单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说通道与CPU共享内存。</li><li>I&#x2F;O通道与DMA方式的区别是：DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。另外，每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。</li></ul><h2 id="5-3-缓冲管理"><a href="#5-3-缓冲管理" class="headerlink" title="5.3 缓冲管理"></a>5.3 缓冲管理</h2><p>几乎所有的I&#x2F;O设备在与处理机（内存）交换数据时，都使用了缓冲区。缓冲就是在通信问题中为了通信双方的速度匹配而引入的一个中间层次，这个层次的速度比通信双方中较慢的一方快，而与较快的一方更匹配。</p><p><strong>引入缓冲的目的</strong></p><ul><li>①缓和处理机和I&#x2F;O设备间速度不匹配的矛盾</li><li>②减少对CPU的中断次数</li><li>③提高CPU和I&#x2F;O设备之间的并行性</li></ul><p>缓冲区分类</p><ul><li><p>按照缓冲所在的位置分，缓冲区可分为：</p></li><li><p>①CACHE；②I&#x2F;O设备或控制器内部的纯硬件缓冲区，如打印机内部的硬件缓冲区；</p></li><li><p>③I&#x2F;O在内存开设的缓冲区，如OS在内存开设的I&#x2F;O缓冲区和文件系统缓冲区；</p></li><li><p>④脱机与假脱机技术实质上也属于缓冲技术，它是为慢速I&#x2F;O设备在外存开设的缓冲区。</p><img src="https://img.mubu.com/document_image/2c0df3f6-9a90-4769-a718-14cda90b8816-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><ul><li><p>单缓冲是操作系统提供的最简单的一种缓冲形式。<strong>单缓冲是指在设备和处理机之间设置一个缓冲。</strong>设备和处理机交换数据时，先把被交换数据写入缓冲区，之后需要数据的设备或处理机再从缓冲区取走数据。设备和处理机对缓冲区的操作是串行的。单缓冲工作示意如下图</p><p><img src="https://img.mubu.com/document_image/68653532-a781-467c-8e92-d29f6d5cbd26-7976057.jpg" alt="img"></p></li></ul><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><ul><li><p>双缓冲是指在应用程序进程发出I&#x2F;O请求时，在内存为之分配两个缓冲区，以便加快I&#x2F;O速度并提高设备利用率。</p></li><li><p>双缓冲方式和单缓冲方式相比，虽然双缓冲方式能进一步提高CPU和外设的并行程度，并能使输入设备和输出设备并行工作，但是在实际系统中很少采用这一方式，这是因为在计算机系统中的外设很多，又有大量的输入和输出，同时双缓冲很难匹配设备和CPU的处理速度。因此现代计算机系统中一般使用环形缓冲或缓冲池结构。</p><p><img src="https://img.mubu.com/document_image/e4a9a99c-b3e0-4ace-b4b8-a6946b287300-7976057.jpg" alt="img"></p></li></ul><h3 id="环形缓冲"><a href="#环形缓冲" class="headerlink" title="环形缓冲"></a>环形缓冲</h3><ul><li><p>循环缓冲是指引入多个缓冲区并将之组织成环形。用作输入的循环缓冲，输入进程不断地向环形缓冲中的下一个空缓冲输入数据，计算进程不断地从中取走数据并计算。循环缓冲也仅适用于某个特定的输入输出进程和计算进程，属于专用缓冲。</p><p><img src="https://img.mubu.com/document_image/cd679b23-68bb-49e4-baa1-e81d0ae3ede0-7976057.jpg" alt="img"></p></li></ul><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>现代的操作系统通常将多个缓冲区组织成缓冲池，供多个进程在I&#x2F;O操作时共享，以提高缓冲区的利用率。在缓冲池中，可能有的缓冲区为空，有的缓冲区装满输入数据，有的缓冲区装满输出数据。为了便于管理，操作系统内核可将相同类型的缓冲区链接在一起，从而形成多个缓冲队列 。</p><p>①缓冲池的组成：空闲缓冲区、装输入数据的缓冲区和装输出数据的缓冲区</p><img src="https://img.mubu.com/document_image/bc46e8cb-bb0d-4d80-9141-6a7af6683746-7976057.jpg" alt="img" style="zoom:67%;" /><p>②缓冲池的工作方式：缓冲区可以在收容输入、提取输入、收容输出和提取输出四种方式下工作。</p><img src="https://img.mubu.com/document_image/378e2613-4351-4a80-8842-f6e35e967f3a-7976057.jpg" alt="img" style="zoom:67%;" /><p>对缓冲池的操作由如下几个过程组成：</p><ul><li><p>1、从缓冲区队列中取出一个缓冲区的过程Takebuf(type)。</p></li><li><p>2、把缓冲区插入到相应的缓冲队列的过程Addbuf(type,number)。</p></li><li><p>3、进程申请缓冲区用的过程Getbuf(type,number)。</p></li><li><p>4、进程将缓冲区插入到相应缓冲区队列的过程Putbuf(type,workbuf)。</p></li><li><p>Type: 缓冲队列类型   number: 缓冲区号  workbuf:工作缓冲区类型</p><img src="https://img.mubu.com/document_image/3bc864a1-a2a9-4246-918d-e79f3bfb1828-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h2 id="5-4-设备分配"><a href="#5-4-设备分配" class="headerlink" title="5.4 设备分配"></a>5.4 设备分配</h2><h3 id="设备分配技术"><a href="#设备分配技术" class="headerlink" title="设备分配技术"></a>设备分配技术</h3><p>设备依据使用特性可分为共享设备技术、独占设备技术和虚拟设备技术。</p><h4 id="独占设备技术"><a href="#独占设备技术" class="headerlink" title="独占设备技术"></a>独占设备技术</h4><ul><li>对独享设备，系统一般采用静态分配方式。即在一个作业执行前，将它所需要使用的这类设备分配给它，当作业结束撤离时，才将分配给它的独享设备收回。</li><li>独占设备每次只能分配给一个进程使用，这种使用特性隐含着死锁的必要条件，所以在考虑独占设备的分配时，一定要结合有关防止和避免死锁的安全算法。</li></ul><h4 id="共享设备技术"><a href="#共享设备技术" class="headerlink" title="共享设备技术"></a>共享设备技术</h4><ul><li>对共享设备的分配一般采用动态分配这一方式 。 在解决设备与CPU的速度匹配问题上，为了使设备和CPU的利用率达到最大程度，系统希望根据每个设备的特征来全局调度设备的操作。</li></ul><h4 id="脱机输入输出技术"><a href="#脱机输入输出技术" class="headerlink" title="脱机输入输出技术"></a>脱机输入输出技术</h4><ul><li><p>为了解决人机矛盾及CPU和I&#x2F;O设备间速度不匹配的矛盾，50年代末出现了该技术。</p></li><li><p>事先将装有用户程序和数据的纸带(卡片)装入纸带输入机，在一台外围机的控制下把纸带上的数据(程序)输入到磁带上。当CPU需要这些数据时再从磁带上高速的调入内存。</p></li><li><p>类似的，当CPU需要输出时可由CPU直接高速的把数据从内存送到磁带上，然后再在另一台外围机的控制下，将磁带上的结果通过相应的输出设备输出。</p><img src="https://img.mubu.com/document_image/7f68c9da-4aee-40a4-bc57-fe16554ec0de-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h4 id="虚拟设备技术"><a href="#虚拟设备技术" class="headerlink" title="虚拟设备技术"></a>虚拟设备技术</h4><ul><li>系统中的独占设备是有限的，往往不能满足诸多进程的要求，会引起大量进程由于等待某些独占设备而阻塞。另一方面，申请到独占设备的进程在其整个运行期间虽然占有设备，利用率却常常很低，设备经常处于空闲状态。解决的办法，就是用共享设备操作来模拟独占设备的操作，以提高系统效率和设备利用率。这种技术就称为虚拟设备技术，实现这一技术的软、硬件系统被称为假脱机（Simultaneous Peripheral Operation On Line, SPOOL）系统，又叫SPOOLing系统.</li></ul><h3 id="SPOOLing系统"><a href="#SPOOLing系统" class="headerlink" title="SPOOLing系统"></a>SPOOLing系统</h3><h4 id="SPOOLing系统的组成："><a href="#SPOOLing系统的组成：" class="headerlink" title="SPOOLing系统的组成："></a>SPOOLing系统的组成：</h4><p>(1)输入井和输出井</p><ul><li>这是在磁盘上开辟出来的两个存储区域。</li><li>输入井模拟脱机输入时的磁盘，用于收容I&#x2F;O设备输入的数据。输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。</li></ul><p>(2)输入缓冲区和输出缓冲区</p><ul><li>这是在内存中开辟的两个缓冲区。</li><li>输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备。</li></ul><p>(3)输入进程和输出进程</p><ul><li>输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井。当CPU需要输入数据时，直接从输入井读如内存。输出进程模拟脱机输出时的外围控制机，把用户要求输出的数据，先从内存送到输入井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备上。</li></ul><p>SPOOLing系统的组成如图5.17所示。该系统必须有高速块设备的支持，该高速块设备通常是指磁盘。SPOOLing技术需要在磁盘上开辟两个大的存储空间，分别用作输入井和输出井。输入井模拟脱机输入时的磁盘，收容从输入设备输入的数据。 </p><img src="https://img.mubu.com/document_image/e340e190-8283-4c5b-b1ca-6d16b54b806f-7976057.jpg" alt="img" style="zoom:67%;" /><h3 id="共享打印机"><a href="#共享打印机" class="headerlink" title="共享打印机"></a>共享打印机</h3><ul><li>打印机是经常要用到的输出设备，属于独占设备。利用 SPOOLing 技术，可将之改造为一台可供多个用户共享的设备，从而提高设备的利用率，也方便了用户。共享打印机技术已被广泛地用于多用户系统和局域网络中。<strong>当用户进程请求打印输出时，SPOOLing 系统同意为它打印输出，但并不真正立即把打印机分配给该用户进程，而只为它做两件事</strong>：① 由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中；② 输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到请求打印队列上。如果还有进程要求打印输出，系统仍可接受该请求，也同样为该进程做上述两件事。</li><li>如果打印机空闲，输出进程将从请求打印队列的队首取出一张请求打印表，根据表中的要求将要打印的数据，从输出井传送到内存缓冲区，再由打印机进行打印。打印完后，输出进程再查看请求打印队列中是否还有等待打印的请求表。若有，又取出队列中的第一张表，并根据其中的要求进行打印，如此下去，直至请求打印队列为空，输出进程才将自己阻塞起来。仅当下次再有打印请求时，输出进程才被唤醒。</li></ul><h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><p>在多道程序环境中，用户不能自行使用系统中的设备。进程首先需要向设备管理程序提出申请，然后由设备分配程序按照一定的分配算法给进程分配必要的资源。如果进程的申请没有成功，就要在资源的等待队列中排队等待，直到获得所需的资源。</p><h4 id="1-设备管理的数据结构"><a href="#1-设备管理的数据结构" class="headerlink" title="(1)设备管理的数据结构"></a>(1)设备管理的数据结构</h4><ul><li><p>操作系统为了实现对设备的管理和分配，需要对每台设备的情况进行登记，即对所管理的对象建立相应的数据结构，如设备控制表（DCT）、控制器控制表（COCT）、通道控制表（CHCT）和系统设备表（SDT）。图5-18给出了这些表的数据结构。</p><img src="https://img.mubu.com/document_image/a75fdd62-fe89-4359-9f31-5b1eacadaa8e-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h4 id="2-设备分配的原则"><a href="#2-设备分配的原则" class="headerlink" title="(2)设备分配的原则"></a>(2)设备分配的原则</h4><ul><li><p>提高设备的利用率；避免不合理的分配方式造成的系统死锁或系统工作紊乱。与进程的调度相似，设备的分配也需要一定的策略，通常采用先来先服务（FCFS）和优先级高者优先等。独占设备每次只能分配给一个进程使用。虚拟设备的分配同共享设备。</p><img src="https://img.mubu.com/document_image/6644e493-adc4-4139-a906-218984be4007-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h2 id="5-5-I-x2F-O软件"><a href="#5-5-I-x2F-O软件" class="headerlink" title="5.5 I&#x2F;O软件"></a>5.5 I&#x2F;O软件</h2><p><strong>I&#x2F;O软件被组织成为一系列的层，即采用层次结构。</strong></p><p><strong>I&#x2F;O软件一般分为四层：中断处理程序，设备驱动程序，独立于设备的系统软件以及用户空间的I&#x2F;O软件</strong>。各层之间的界面并不是死的，各层之间的确切界面是依赖于具体系统的。</p><p><strong>I&#x2F;O软件设计的一个关键目标是设备独立性</strong>。除了直接与设备打交道的低层软件之外，其他部分的软件不依赖于硬件。I&#x2F;O软件独立于设备，当I&#x2F;O设备更新时，没有必要重新编写全部设备软件。在一些操作系统中，只要安装了相应的设备驱动程序，就可以很方便地安装好新的I&#x2F;O设备。甚至不必重新编译就能将设备管理程序移到别处执行。</p><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><h4 id="1-中断和中断的分类"><a href="#1-中断和中断的分类" class="headerlink" title="1.中断和中断的分类"></a>1.中断和中断的分类</h4><ul><li>中断是指计算机在执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前的执行程序而转去执行相应的事件处理程序，待处理完毕后又返回原来被中断处继续执行或调度新的进程执行。</li><li>开中断和关中断是为了保证某段程序执行的原子性。中断又分为外中断和内中断。外中断是指来自处理器和内存之外的中断，如I&#x2F;O设备发出的I&#x2F;O中断等。内中断是指在处理器和内存内部产生的中断，又称为陷阱（trap）。</li></ul><h4 id="2-处理器与I-x2F-O设备之间数据传输"><a href="#2-处理器与I-x2F-O设备之间数据传输" class="headerlink" title="2.处理器与I&#x2F;O设备之间数据传输"></a>2.处理器与I&#x2F;O设备之间数据传输</h4><ul><li><p>I&#x2F;O系统采用了中断方式来控制I&#x2F;O设备和内存与CPU之间的数据传送。在硬件结构上，这种方式要求CPU与I&#x2F;O设备（或控制器）之间有相应的中断请求线，而且在I&#x2F;O设备控制器的控制状态寄存器上有相应的中断允许位。</p></li><li><p>在中断方式下，CPU与I&#x2F;O设备之间数据传输的步骤</p><ul><li>（1）某个进程需要数据时，处理器发出指令启动I&#x2F;O设备准备数据。同时，该指令还打开I&#x2F;O设备控制状态寄存器中的中断允许位，以便在需要时，中断程序可以被调度执行。</li><li>（2）该进程放弃处理器，等待相关I&#x2F;O操作完成，此时进程调度程序会调度其他就绪进程使用处理器。另一种方式是该进程在能够运行的情况下将继续运行，直到中断信号来临。</li><li>（3）当I&#x2F;O操作完成时，I&#x2F;O设备控制器通过中断请求线向处理器发出中断信号。处理器收到中断信号后，转向预先设计好的中断处理程序对数据传送工作进行相应的处理。</li><li>（4）得到数据的进程，转入就绪状态。在随后的某个时刻，进程调度程序会选中该进程继续工作。</li></ul></li></ul><h4 id="3-中断处理过程"><a href="#3-中断处理过程" class="headerlink" title="3.中断处理过程"></a>3.中断处理过程</h4><ul><li>I&#x2F;O设备完成了I&#x2F;O操作后，控制器便向CPU发出一中断请求，CPU响应中断后便转向中断处理程序。无论是哪种I&#x2F;O设备，其中断处理程序的处理过程大体相同，其步骤如下：</li><li>（1）CPU响应中断后，则关中断，使其进入不可再次响应中断的状态。</li><li>（2）当中断处理程序开始执行时，用信号或信号量机制，将处于阻塞状态的设备驱动程序进程唤醒。</li><li>（3）保护被中断进程的执行现场。即将当前处理机状态字PSW、程序计数器PC以及被中断进程的CPU现场（包含所有的CPU寄存器）等都保存到中断栈中。</li><li>（4）分析中断原因，调用相应的设备中断处理程序。由处理器对各个中断源进行测试，以确定引起本次中断的I&#x2F;O设备，并发送应答信号给发中断请求信号的进程，使之消除该中断请求信号，然后将中断处理程序的入口地址装入到程序计数器中，使处理机转向中断处理程序。</li><li>（5）执行中断处理程序。该程序从设备控制器中读出设备状态。若是正常完成中断，则驱动程序进程便可做结束处理；若还有命令，可再向控制器发送新的命令。若是异常中断，则根据发生异常的原因做相应处理。</li><li>（6）恢复被中断进程的现场或调度新进程占据处理器。</li><li>（7）开中断，CPU继续执行。</li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><h4 id="1-设备驱动程序的特点"><a href="#1-设备驱动程序的特点" class="headerlink" title="1.设备驱动程序的特点"></a>1.设备驱动程序的特点</h4><ul><li>（1）设备驱动程序是在请求I&#x2F;O的进程和设备控制器之间的一个通信程序。它把进程的I&#x2F;O请求传送给设备控制器，然后把设备控制器中所记录的设备状态、I&#x2F;O操作完成情况传回请求I&#x2F;O的进程。</li><li>（2）它与I&#x2F;O设备的特性紧密相关，对于不同类型的设备，应配置不同的驱动程序。</li><li>（3）它与I&#x2F;O控制方式紧密相关，常用的设备控制方式为中断驱动和DMA方式。</li><li>（4）设备驱动程序与I&#x2F;O设备的硬件结构密切联系。其中全部是依赖于设备的代码。设备驱动程序是操作系统中唯一知道设备控制器细节及其用途的部分。</li></ul><h4 id="2-设备驱动程序的处理过程"><a href="#2-设备驱动程序的处理过程" class="headerlink" title="2.设备驱动程序的处理过程"></a>2.设备驱动程序的处理过程</h4><ul><li><p>（1）将接收到的抽象请求转换为具体要求。</p></li><li><p>（2）检查用户I&#x2F;O请求的合法性。一个I&#x2F;O设备只能完成一组特定的功能，若超出这些特定的功能，则认为这次I&#x2F;O请求非法。</p></li><li><p>（3）读出和检查设备的状态。在启动设备之前，要从设备控制器的状态寄存器中读出设备的状态。若设备正处于空闲状态，则可以启动该设备进行I&#x2F;O操作。</p></li><li><p>（4）向设备控制器发出控制命令。驱动程序向控制器中的命令寄存器传送控制命令，启动I&#x2F;O设备。随后的I&#x2F;O是在设备控制器的控制下进行的。若I&#x2F;O操作所要完成的工作较多，需要一定的时间，驱动程序进程会把自己阻塞起来，直到中断到来时才被唤醒。若I&#x2F;O操作毫无拖延地完成，驱动程序无需阻塞。</p></li><li><p>（5）对各种可能的有关设备排队、挂起、唤醒等操作进行处理。</p></li><li><p>（6）及时响应由控制器发来的中断请求，并根据中断类型调用相应的中断处理程序进行处理。</p></li><li><p>独立于设备的系统</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 6.文件管理</title>
    <link href="/20200727/71ea2d2a/"/>
    <url>/20200727/71ea2d2a/</url>
    
    <content type="html"><![CDATA[<h2 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h2><ul><li><p>文件的逻辑结构和物理结构</p></li><li><p>文件外存空间的管理</p></li><li><p>文件目录结构的管理</p></li><li><p>文件的保护与共享</p></li><li><p>目录的搜索</p></li><li><p>文件外存空间的管理</p></li></ul><span id="more"></span><h2 id="6-1-文件和文件系统"><a href="#6-1-文件和文件系统" class="headerlink" title="6.1 文件和文件系统"></a>6.1 文件和文件系统</h2><h3 id="6-1-1文件"><a href="#6-1-1文件" class="headerlink" title="6.1.1文件"></a>6.1.1文件</h3><p>文件是具有标识符（文件名）的一组相关信息的集合。标识符是用来标识文件的。不同的系统对标识符的规定有所不同。文件的确切定义有两种说法：文件是具有标识符的相关字符流(也有称记录)的集合。</p><h3 id="6-1-2-文件类型和文件系统"><a href="#6-1-2-文件类型和文件系统" class="headerlink" title="6.1.2 文件类型和文件系统"></a>6.1.2 文件类型和文件系统</h3><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>操作系统中负责管理和存取文件信息的软件机构叫做文件管理。</p><p><strong>文件系统：操作系统中与文件管理有关的那部分软件和被管理的文件，以及实现管理所需要的一些数据结构的总体。</strong></p><p>从系统角度看，文件系统是对文件存储空间进行组织、分配，并负责文件的存储、保护和检索的系统。</p><p>从用户角度来看，文件系统主要是实现“按名存取”，并向用户提供简便、统一的使用文件的接口。</p><h4 id="1-文件系统功能"><a href="#1-文件系统功能" class="headerlink" title="1.文件系统功能"></a>1.文件系统功能</h4><ul><li>（1）实现文件的“按名存取”功能。</li><li>（2）实现能够快速定位文件的目录结构，如树型目录；考虑如何组织目录文件，即目录项的设计和文件控制块的存储组织方法，这也直接影响到检索文件的速度。</li><li>（3）向用户提供一套使用方便、简单的操作命令。</li><li>（4）管理磁盘、磁带等组成的文件存储器。</li><li>（5）实现逻辑文件到物理文件的转换。</li><li>（6）保证文件信息的安全可靠。</li><li>（7）便于文件的共享。</li></ul><h4 id="2-常用文件系统举例"><a href="#2-常用文件系统举例" class="headerlink" title="2. 常用文件系统举例"></a>2. 常用文件系统举例</h4><ul><li>EXT2：Linux最为常用的文件系统，设计易于向后兼容，所以新版的文件系统代码无需改动就可以支持已有的文件系统。</li><li>NFS：网络文件系统，允许多台计算机之间共享文件系统，易于从网络中的计算机上存取文件。</li><li>HPFS：高性能文件系统，是IBM OS&#x2F;2的文件系统。</li><li>FAT：经过了MS-DOS，Windows 3.x，Windows 9x，Windows NT，Windows 2000&#x2F;XP和OS&#x2F;2等操作系统的不断改进，它已经发展成为包含FAT12，FAT16和FAT32的庞大家族。</li><li>NTFS：NTFS是微软为了配合Windows NT的推出而设计的文件系统，为系统提供了极大的安全性和可靠性。</li></ul><h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><p>一个文件包括文件体和文件属性两个部分。文件体是一系列的记录或字符流，以物理块存放在外存上，也叫文件内容。文件属性是对文件进行说明的信息。</p><ul><li>文件名称：文件名称是供用户使用的外部标识，也是文件最基本的属性。文件名称通常由一串ASCII码或者汉字构成，现在常常由Unicode字符串组成。</li><li>文件物理位置：具体标明文件在存储介质上所存放的物理位置。</li><li>文件拥有者：操作系统通常是多用户的，不同的用户拥有各自不同的文件，对这些文件的操作权限也不同。通常文件创建者对自己所建的文件拥有一切权限，而对其它用户所建的文件则拥有有限的权限。</li><li>文件权限；文件类型；文件长度；文件时间</li></ul><h4 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h4><ul><li>（1）按照文件的逻辑结构的不同，可以把文件分成流式文件和纪录式文件。</li><li>（2）按照用途将文件分为系统文件、库文件和用户文件。</li><li>（3）按照性质可以把文件分为普通文件、目录文件和特殊文件。</li><li>（4）按照保护级别将文件分为只读文件、只写文件，可读可写文件、可执行文件和不保护文件等。例如只读文件只允许授权用户读，但不能写。</li><li>（5）按照文件数据的形式将文件分为源文件，目标文件和可执行文件。</li><li>（6）按照保存期限可以分为临时文件和永久文件。</li></ul><p>文件的分类主要便于对不同文件进行有针对性的管理，从而提高操作系统的性能。 </p><h4 id="UNIX文件类型"><a href="#UNIX文件类型" class="headerlink" title="UNIX文件类型"></a>UNIX文件类型</h4><ul><li>（1）正规文件：是指系统所规定的普通格式的文件，包括系统文件、库文件以及各种用户文件等。</li><li>（2）目录文件：是由文件目录构成的一类文件。是用来维护文件系统结构和管理普通文件和目录的文件。</li><li>（3）符号链接：又称为软链接。它是一个短文件，其中包含了另一个文件的任意一个路径名。这个路径名可以指向位于任意一个文件系统的任意文件，甚至可以指向一个不存在的文件。硬链接是指目录表中的目录项所确定的文件名和索引节点之间的对应关系。硬链接的次数就是同一索引节点被目录项引用的次数。</li><li>（4）设备文件：包括块设备文件和字符设备文件。在UNIX系统中，所有的输入输出设备都被看成是文件，甚至在使用形式上也和普通文件相同。</li><li>（5）管道（pipe）文件：系统使用管道文件的目的是希望将一个进程的输出作为另一个进程的输入。管道文件使用一块专用的内存区域来保存中间信息。</li><li>（6）套接字（socket）：又称插口。通过在发送方和接收方分别创建一个称为套接字的通信端点可以获得TCP服务。每个套接字有一个套接字序号（地址），包含主机的IP地址和一个端口。每条连接由两端的套接字标识符来识别，即（socket1,socket2）。</li></ul><h3 id="6-1-3文件操作"><a href="#6-1-3文件操作" class="headerlink" title="6.1.3文件操作"></a>6.1.3文件操作</h3><p>为了方便用户使用文件系统，文件系统向用户提供了两类操作接口。第一类是与文件有关的操作命令或作业控制语言中与文件有关的JCL 语句；第二类是提供给用户程序使用的文件类系统调用</p><p>文件系统向用户提供的对文件的操作可以分为两大类：一类是对文件自身的操作，例如，创建新文件、打开文件、删除文件、读写文件等；另一类是对记录的操作，例如，检索文件中的记录、插入记录、删除记录等。常用的文件操作如下</p><h2 id="6-2-文件的逻辑结构"><a href="#6-2-文件的逻辑结构" class="headerlink" title="6.2 文件的逻辑结构"></a>6.2 文件的逻辑结构</h2><p>文件的逻辑结构是指从用户的观点出发，用户所观察到的文件组织形式。</p><p>文件的逻辑结构可分为两种：一类是有结构文件或称记录式文件;一类是无结构文件或称流式文件。</p><h3 id="1-有结构的文件"><a href="#1-有结构的文件" class="headerlink" title="(1)有结构的文件"></a>(1)有结构的文件</h3><p>有结构的文件是指由若干个相关的记录构成的文件，又称记录式文件。用户存取文件是以记录为单位进行的。记录又分为定长的和变长的记录。</p><p>根据用户和系统管理的需要，可采用多种方式组织这些记录：</p><h4 id="1、顺序文件"><a href="#1、顺序文件" class="headerlink" title="1、顺序文件"></a>1、顺序文件</h4><p>在顺序文件中的记录可以按照不同的顺序进行排列。</p><ul><li>一种是按照存入的时间先后排序，各记录之间的顺序与记录的关键字或内容无关。这种顺序文件主要应用在日志文件和各种现场记录文件等场合；</li><li>另一种是按照记录中的关键字排序，这是顺序文件的常见形式，讨论顺序文件也以此种文件为主。</li></ul><p>顺序文件中的记录可以是定长的，也可以是变长的。对顺序文件可以顺序存取也可以直接存取，但是直接存取不定长记录的顺序文件效率极低。顺序存取：只要在系统中分别设置读写指针Rptr和Wptr，读完或写完一条记录后修改该指针指向下一条记录。直接存取：也叫随机存取。主要适用于定长记录的顺序文件，因为在这种文件中，任何记录的位置都很容易通过记录长度计算出来</p><img src="https://api2.mubu.com/v3/document_image/89980d32-caf7-4035-81ca-bf674e5c664f-7976057.jpg" alt="img" style="zoom:80%;" /><p>顺序文件的最佳应用场合是在对诸记录进行批量存取时，即每次要读或写一大批记录时。此时，对顺序文件的存取效率是所有逻辑文件中最高的；此外，也只有顺序文件才能存储在磁带上，并能有效地工作。</p><h4 id="2、索引文件"><a href="#2、索引文件" class="headerlink" title="2、索引文件"></a>2、索引文件</h4><p>为了解决顺序文件变长记录查找问题，可为变长记录文件建立一张索引表，对主文件中的每个记录，在索引表中设有一个相应的表项，用于记录该记录的长度 L 及指向该记录的指针(指向该记录在逻辑地址空间的首址)。由于索引表是按记录键排序的，因此，索引表本身是一个定长记录的顺序文件，从而也就可以方便地实现直接存取。</p><img src="https://api2.mubu.com/v3/document_image/6817a7ec-e65d-42e7-ac1d-be0cb739072d-7976057.jpg" alt="img" style="zoom:80%;" /><p>索引文件可以根据不同的关键字建立索引，形成包含多个索引表的索引文件。</p><ul><li>主要优点：通过建立索引极大地提高了对文件的查找速度，同时，对增加和删除记录也非常方便，所以已经成为当今应用最为广泛的一种文件形式</li><li>主要缺点：除了主文件外，还必须配置一张索引表，而且每个记录都要有一个索引项，存储开销变大，增删记录时还需要修改索引表</li></ul><h4 id="3、索引顺序文件"><a href="#3、索引顺序文件" class="headerlink" title="3、索引顺序文件"></a>3、索引顺序文件</h4><p>它是顺序文件和索引文件相结合的产物。它将顺序文件中的所有记录分为若干个组(例如，50 个记录为一个组)；为顺序文件建立一张索引表，在索引表中为每组中的第一个记录建立一个索引项，其中含有该记录的键值和指向该记录的指针。</p><img src="https://api2.mubu.com/v3/document_image/4c59d5af-7405-491c-8001-1dd644d1310a-7976057.jpg" alt="img" style="zoom:80%;" /><p>查找方法：首先也是利用用户（程序）所提供的关键字，以及某种查找算法去检索索引表，找到该记录所在记录组中第一个记录的表项，从中得到该记录组第一个记录在主文件中的位置。再利用顺序查找法去查找主文件，从中找到所要求的记录。</p><p>主要优点：索引表占用空间小，同时查找效率比顺序文件又高，因此在文件记录比较多时采用索引顺序文件比较适合。</p><h4 id="4、哈希文件"><a href="#4、哈希文件" class="headerlink" title="4、哈希文件"></a>4、哈希文件</h4><p>这是目前应用最为广泛的一种直接文件。它利用 Hash 函数(或称散列函数)，可将记录键值转换为相应记录的地址。但为了能实现文件存储空间的动态分配，通常由 Hash 函数所求得的并非是相应记录的地址，而是指向一目录表相应表目的指针，该表目的内容指向相应记录所在的物理块</p><img src="https://api2.mubu.com/v3/document_image/018a41aa-513c-4607-a019-d4c8a8c98896-7976057.jpg" alt="img" style="zoom:80%;" /><h3 id="2-无结构文件"><a href="#2-无结构文件" class="headerlink" title="(2)无结构文件"></a>(2)无结构文件</h3><p>无结构文件又称流式文件，流式文件指文件内的数据不组成记录，只是依次的一串信息集合，如字节流或字符流，它也可以看成是无结构的或只有一个记录的记录式文件，所以也称作无结构文件</p><p>字节或字符是访问流式文件的基本单位，顺序存取时读&#x2F;写指针每次步进1个字节或1个字符长度。</p><p>在系统中存在很多流式文件，如<em>源程序文件、可执行文件和库函数文件</em>等。这些类型的文件并不需要分记录，如用户作业的源程序就是一个顺序字符流，硬要分割源程序文件成若干记录只会带来操作复杂、开销增大的缺点。</p><h3 id="记录式文件和流式文件的关系"><a href="#记录式文件和流式文件的关系" class="headerlink" title="记录式文件和流式文件的关系"></a>记录式文件和流式文件的关系</h3><ul><li>流式文件没有结构，但用户在使用流式文件时可以自己定义文件的结构。如可将３０个字节作为一个记录。</li><li>若每个记录只包含一个域，而且该域的类型为字符型时，记录式文件便退化为流式文件，因而可以说流式文件是记录式文件的特例。</li></ul><h2 id="6-3-文件的物理结构"><a href="#6-3-文件的物理结构" class="headerlink" title="6.3 文件的物理结构"></a>6.3 文件的物理结构</h2><p>为了有效地管理文件存储器，通常把文件存储空间划分成若干个大小相等的物理块，物理块是分配及传输信息的基本单位。块的大小通常是扇区的倍数，如512B、1KB、2KB或者4KB。</p><p>一个物理块中可以存放若干个逻辑记录，一个逻辑记录也可以存放在若干个物理块中。</p><p>为了有效地利用外存和便于系统管理，一般也把文件信息划分为与物理存储块大小相等的逻辑块。</p><p>常见的文件物理结构有三种：连续结构、链接结构和索引结构。</p><h3 id="1-连续分配"><a href="#1-连续分配" class="headerlink" title="1.连续分配"></a>1.连续分配</h3><p>连续分配(Continuous Allocation)要求为每一个文件分配一组相邻接的盘块。一组盘块的地址定义了磁盘上的一段线性地址。例如，第一个盘块的地址为 b，则第二个盘块的地址为b+1，第三个盘块的地址为 b+2……。</p><img src="https://api2.mubu.com/v3/document_image/36021a2b-712e-4fad-b71d-b766fb7736fc-7976057.jpg" alt="img" style="zoom:80%;" /><ul><li><p>连续结构的主要优点是<strong>实现简单和存取速度快</strong>，只要记住文件的第一块号和块数就能确定该文件在外存上的位置。<strong>当文件是定长记录文件时，还可根据文件起始地址及记录长度进行随机访问</strong>。</p></li><li><p>缺点：<strong>不利于文件的动态增长</strong>，因为文件末尾处可能已经没有空闲块了，一旦增长，就需要进行大量的改动；<strong>反复增删文件以后，存储设备中便会产生类似于内存分配中出现的磁盘空间碎片</strong>。因此，连续结构只适用于长度固定的文件。</p></li></ul><h3 id="2-链接结构"><a href="#2-链接结构" class="headerlink" title="2.链接结构"></a>2.链接结构</h3><p>链接结构是指可以将文件存储在外部存储介质上的若干个不必连续的物理块中，其中的每个物理块都设有一个指针字段，指向下一个物理块的位置，从而使得存放同一个文件的物理块链接起来。以链接结构存放的文件称为链接文件。</p><img src="https://api2.mubu.com/v3/document_image/ff71b79f-3daa-489e-9a34-ab15b7e4e333-7976057.jpg" alt="img" style="zoom:80%;" /><p>链接结构的优点是可以解决文件存储空间的碎片问题，提高了文件存储空间的利用率，同时允许文件动态增长。</p><p>缺点：但链接文件只能按照文件的链接指针顺序访问，为了访问文件的第i块，必须从第一块开始访问，然后一块接着一块，直到找到第i块。另一个缺点是必须为指针字段分配空间。</p><h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>隐式链接是指每个物理块自身存放下一物理块的链接指针。在文件的目录项的“物理地址”字段中只要保存该文件的起始块号和结束块号的指针，中间的各个块由前一个块内保存的链接指针指示。 隐式链接分配方式的主要问题在于：它只适合于顺序访问，它对随机访问是极其低效的。</p><h4 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h4><p>为了克服链接结构文件的缺点，可以把所有链接文件里的指针从物理块中取出，存放在一张链接表中，表的长度就是文件存储器能划分的物理块数，表的序号就是物理块号。在每个表项中，存放链接指针，即下一个物理块号。该链接表存放在内存里。</p><p>由于分配给文件的所有物理块的块号都在该链接表中，故把该链接表称为文件分配表FAT（FileAllocation Table），MS-DOS及OS&#x2F;2等操作系统都采用FAT。</p><p>显式链接也不支持高效的直接存取，对一个较大的文件进行存取时，须在FAT中顺序地查找许多盘块号；</p><h3 id="3-索引结构"><a href="#3-索引结构" class="headerlink" title="3.索引结构"></a>3.索引结构</h3><p>基于的思想：显示链接分配的FAT表记录了每个文件的物理块的占用情况，不管系统打开多少个文件，必须把整个FAT表调入内存。事实上，当打开一个文件时，只需要把该文件占用的盘块的编号调入内存即可，为此，应将每个文件所对应的盘块号集中地放在一起，访问到这个文件时再将它所对应的盘块号信息一起调入内存。</p><p>索引分配结构：系统为每个文件建立一个索引表，集中记录该文件占用的盘块号。索引表可以直接存放在文件控制块FCB中，但是，大文件的索引表往往很大，所以大多数文件系统让索引表置于单独的物理块中且可驻留在磁盘的任意位置，文件控制块的“物理地址”字段只要保存该索引表所在的盘块号（即索引表地址）。</p><p>索引表可以有不同的索引形式</p><ul><li><p>（1）无键索引表，该索引表记录的是组成指定文件的磁盘块号，这种索引只是盘块号的序列，适用于流式文件；</p></li><li><p>（2）另一种是有键索引表，该索引表的索引表项包含逻辑记录键及其磁盘块号，指出了每条逻辑记录在磁盘上的存放地址，即物理块号，适用于纪录式文件。</p></li></ul><p>索引结构就是把每个文件占用磁盘的物理块号集中存放在一张表中，即每一个文件都有一张索引表。每一个索引表项存放文件数据所占用的一个磁盘块的地址。以索引结构存放的文件称为索引文件。</p><img src="https://api2.mubu.com/v3/document_image/c84bc8f4-fa8a-4e7d-9b3d-f4b794cc6037-7976057.jpg" alt="img" style="zoom:80%;" /><p>多级索引</p><img src="https://api2.mubu.com/v3/document_image/e5384270-0faf-442f-9710-906b3565559f-7976057.jpg" alt="img" style="zoom:80%;" /><h3 id="文件的存取方法"><a href="#文件的存取方法" class="headerlink" title="文件的存取方法"></a>文件的存取方法</h3><p>文件存取方法是指用户在使用文件时按怎样的次序存取文件。文件的存取方法是由文件的性质和用户使用文件的情况决定的。根据对文件信息的存取次序不同，把文件存取方法分为顺序存取、随机存取、索引存取等。</p><h4 id="1-顺序存取"><a href="#1-顺序存取" class="headerlink" title="1.顺序存取"></a>1.顺序存取</h4><p>顺序存取是最简单的方法。它严格按照文件信息单位排列的顺序依次存取，后一次存取总是在前一次存取的基础上进行，所以不必给出具体的存取位置。在文件读写过程中总有两个位置指针指向其中要读写的字节位置或要读写的记录位置。</p><h4 id="2-随机存取"><a href="#2-随机存取" class="headerlink" title="2.随机存取"></a>2.随机存取</h4><p>随机存取又称直接存取，在存取时必须先确定进行存取时的起始位置（如记录号、字符序号等）。直接存取通常是对记录式文件而言的。</p><p>对于定长记录式文件来说，直接存取方便、高效。</p><p>对于变长记录文件，采用顺序存取方法会更高效。磁盘是支持随机存取的典型设备</p><h4 id="3-按键存取"><a href="#3-按键存取" class="headerlink" title="3.按键存取"></a>3.按键存取</h4><p>文件索引存取又称为按键存取，即对文件中的记录按某个数据项的值进行排序，从而可以根据键值来快速存取。</p><h2 id="6-4-目录管理"><a href="#6-4-目录管理" class="headerlink" title="6.4 目录管理"></a>6.4 目录管理</h2><p>通过文件目录来对外存上所存储的文件进行管理的，功能有：</p><ul><li>(1)按名存取。这是文件系统向用户提供的最基本功能。</li><li>(2)提高检索速度。合理地组织目录结构，可以加快对目录的检索速度，从而提高对文件的存取速度。</li><li>(3)文件共享。允许多个用户共享同一文件，以节省存储空间，同时也方便用户。</li><li>(4)允许文件重名。以方便用户按照自己的习惯来命名和使用文件。</li></ul><h4 id="6-4-1-文件控制块和索引节点"><a href="#6-4-1-文件控制块和索引节点" class="headerlink" title="6.4.1 文件控制块和索引节点"></a>6.4.1 文件控制块和索引节点</h4><p>用于描述和控制文件的数据结构被称为文件控制块（FCB，File Control Block）。文件控制块的有序集合称为文件目录，即一个文件控制块占用一个文件目录项。通常文件目录也是以文件的形式保存在外存上的，称为目录文件。</p><p>1.文件控制块</p><p>在文件控制块中常用的属性如下：</p><ul><li>(1)<strong>文件名</strong>。用户利用文件名来存取文件。</li><li>(2)文件的物理地址。包括：文件所在的设备名、盘块号、占用的盘块数。</li><li>(3)<strong>文件的逻辑结构</strong>。文件是流式文件还是记录式文件。</li><li>(4)文件的物理结构。指示文件是顺序结构，还是链接结构或索引结构。</li><li>(5)<strong>存取权限</strong>。文件主、核准用户、一般用户的存取权限。</li><li>(6)日期和时间。文件建立、修改的日期和时间。</li><li>(7)<strong>当前使用信息</strong>。当前已打开该文件的进程数，文件在内存中是否被修改过但尚未写回磁盘上。</li></ul><p>目录文件的组织是指目录项的设计和FCB的存储组织方法。</p><p>不同的组织方法直接影响到检索文件的速度，对整个文件系统的效率、性能和可靠性都有很大的影响。</p><h4 id="常用的组织方法"><a href="#常用的组织方法" class="headerlink" title="常用的组织方法"></a>常用的组织方法</h4><h5 id="1-FCB线性表"><a href="#1-FCB线性表" class="headerlink" title="1. FCB线性表"></a>1. FCB线性表</h5><p>FCB线性表的方式最简单，也是最早使用的一种组织方式。在这种方法中，目录文件中直接存放该目录下所有文件和子目录的FCB信息，组成了一个FCB线性表，即每个目录项记录了该文件或子目录对应的完整FCB信息</p><img src="https://api2.mubu.com/v3/document_image/dd136c2e-86c7-4675-9a41-a86f57e14711-7976057.jpg" alt="img" style="zoom:80%;" /><h5 id="2-索引节点"><a href="#2-索引节点" class="headerlink" title="2. 索引节点"></a>2. 索引节点</h5><p>通过分析可发现，在检索目录文件的过程中，只用到了<strong>文件名</strong>。仅当找到一个目录项（即其中的文件名与指定要查找的文件名相匹配）时，才需从该目录项中读出该文件的物理地址。属性信息在检索目录时无需调入内存。因此可把文件名和文件属性信息分开，<strong>即把文件属性信息用一个称为索引节点的数据结构来描述，而在文件目录的每个目录项中，仅存有文件名和该文件的索引节点编号。</strong></p><p>检索文件的过程：检索文件时，先从目录文件中找到文件名匹配的目录项，在目录项中找到该文件的索引节点号，根据索引节点号就可以在索引节点区中找到该文件的索引节点，找到了i节点，就获得了它所对应的文件的一切必要属性信息。</p><h5 id="3-哈希表组织"><a href="#3-哈希表组织" class="headerlink" title="3. 哈希表组织"></a>3. 哈希表组织</h5><p>为了加快目录检索的速度，目录文件还可以采用哈希表存储，采用散列法管理FCB，即目录文件采用以文件名为关键字的直接文件的组织形式。</p><h4 id="6-4-2-目录结构"><a href="#6-4-2-目录结构" class="headerlink" title="6.4.2 目录结构"></a>6.4.2 目录结构</h4><p>目录的逻辑结构分为：单级目录结构、两级目录结构、树型目录结构。</p><h5 id="1-单级目录结构"><a href="#1-单级目录结构" class="headerlink" title="1.单级目录结构"></a>1.单级目录结构</h5><ul><li>单级目录结构是指在整个文件系统中只建立一张目录表，其中每个目录项对应一个文件。</li><li>创建及删除文件涉及到目录项申请与回收。</li><li>单级目录结构的主要优点是实现简单。</li><li>其缺点：不允许文件重名；文件查找速度慢。</li></ul><h5 id="2-两级目录结构"><a href="#2-两级目录结构" class="headerlink" title="2.两级目录结构"></a>2.两级目录结构</h5><p>两级目录结构是指把系统中的目录分为一个主目录表和多个次目录表。在多用户系统中，可以为每个用户建立一个次目录表，而主目录表则存储着各个次目录表的信息。</p><p>两级目录结构的优点：提高了文件检索速度；在不同的用户目录中，可以使用相同的文件名。其缺点：不便于用户之间共享文件；同一用户内不允许文件重名。</p><img src="https://api2.mubu.com/v3/document_image/770699e0-f233-4b37-b494-29e5201efb65-7976057.jpg" alt="img" style="zoom:80%;" /><h5 id="3-树型目录结构"><a href="#3-树型目录结构" class="headerlink" title="3.树型目录结构"></a>3.树型目录结构</h5><p>树型目录结构是两级目录结构的推广。为了克服两级目录结构不够灵活的缺点，方便文件查找，提高系统效率，在现代操作系统中采用了树型目录结构</p><img src="https://api2.mubu.com/v3/document_image/9a7ade26-32e6-4de7-b041-28f167682ca8-7976057.jpg" alt="img" style="zoom:80%;" /><p>从树的根目录到任何数据文件，都只有一条唯一的路径，在该路径上从根目录开始，把全部目录文件名和数据文件名，依次用“&#x2F;”连接起来，就构成了该数据文件的绝对路径名。如a.out文件的路径名为“&#x2F;home&#x2F;Liu&#x2F;a.out”。</p><p>通常，一个进程在运行时所要访问的文件只局限于某个范围之内，因此可为每个进程设置一个“当前工作目录”。因此路径名又分为相对路径名和绝对路径名。</p><p>树型目录结构的优点：可以把不同类型和不同用途的文件分类，查找速度快；允许文件重名，不同的文件有不同的路径名；利用多级层次关系，能更方便地制定文件的存取权限，有利于保护文件；有利于文件共享。</p><img src="https://api2.mubu.com/v3/document_image/2603f5ff-3ac8-4323-8851-f8d5fb4fc85a-7976057.jpg" alt="img" style="zoom: 67%;" /><h2 id="6-5-文件存储空间的管理"><a href="#6-5-文件存储空间的管理" class="headerlink" title="6.5 文件存储空间的管理"></a>6.5 文件存储空间的管理</h2><p>文件管理的主要功能之一是如何在外部存储介质上为创建或扩充文件而分配空间，为删除文件而回收空间以及对空闲空间的管理。磁盘可以随机存取的特性非常适合文件系统的实现，因此磁盘是最常用的文件外部存储介质</p><p>文件存储空间管理主要涉及两个问题：</p><ul><li>一是磁盘空间的分配</li><li>二是磁盘空闲空间的有效管理</li></ul><h3 id="一、磁盘空间的分配"><a href="#一、磁盘空间的分配" class="headerlink" title="一、磁盘空间的分配"></a>一、磁盘空间的分配</h3><ul><li>（1）连续分配<ul><li>连续分配是指文件被存放在外存空间连续存储区 (连续的物理块号) 中，在建立文件时，用户必须给出文件大小，然后，查找到能满足的连续存储区供使用，否则文件不能建立，用户进程必须等待。</li></ul></li><li>（2）非连续分配<ul><li>非连续分配是指以物理块（扇区）为单位，按文件动态要求分配物理块，这些物理块不一定要连续，属于同一文件的块按文件记录的逻辑次序用链接指针连接或用索引表指示，即链接分配和索引分配。</li></ul></li></ul><h3 id="二、磁盘空闲空间的有效管理"><a href="#二、磁盘空闲空间的有效管理" class="headerlink" title="二、磁盘空闲空间的有效管理"></a>二、磁盘空闲空间的有效管理</h3><p>为了记录空闲磁盘空间，也就是那些尚未分配给文件或目录的块，需要采用一定的数据结构来实现：</p><ul><li><p>（1） 空闲区表法</p><ul><li>空闲区表法是指系统为外存上的所有空闲块建立一张空闲区表，每个表项记录了一个空闲区，主要包括该空闲区的第一个空闲盘块号、该区的空闲盘块和状态等信息，再将所有的空闲区按其起始盘块号递增的次序排列。</li></ul></li><li><p>（2） 空闲块链表法</p><ul><li><p>空闲块链表法是将所有空闲块连接在一起，组成一个空闲块链表。</p></li><li><p>空闲块链表的一个变种是空闲盘区链，将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）组成一个链表，也适合连续文件的组织形式。</p></li></ul></li><li><p>（3）位示图法</p><ul><li>空闲空间表还可由位图或位矢量的方法来实现。每一个磁盘块由1位（bit）来表示。如果该磁盘块是空闲的，这个位就置0；否则，就置1。</li></ul></li></ul><h2 id="6-6-文件共享与文件保护"><a href="#6-6-文件共享与文件保护" class="headerlink" title="6.6 文件共享与文件保护"></a>6.6 文件共享与文件保护</h2><p>文件操作的实现</p><p>文件系统向应用程序提供了一组系统调用，包括创建、删除、打开、关闭文件和对文件的读写控制，通过这些系统调用，程序员能获得文件系统的各种服务。思路就是把常用的和正在使用的那些文件目录复制进内存，这样，既不增加太多的内存开销，又可明显缩短查找时间。</p><p>具体实现：系统为每个用户进程建立一张打开文件表，并在系统中再维护一张记录系统中所有正在使用文件信息的系统打开文件表，正在使用文件的索引节点也会从外存索引节点区复制到内存索引节点表（即活动索引节点表）中。</p><p>使用文件时为什么要打开和关闭？</p><ul><li><p>用户使用文件之前先通过“打开”操作，把此文件的文件目录信息（包括索引节点信息）复制到指定的内存区域，当不再使用这个文件时，使用“关闭”操作撤销该文件存放在内存的使用信息，以切断用户进程和该文件目录的联系。</p></li><li><p>这样，文件被打开后，很多信息就已经调入内存，可被用户多次使用，直至文件被关闭或撤销，大大减少访盘次数，提高了文件系统的效率。</p></li></ul><h2 id="6-7-数据一致性控制"><a href="#6-7-数据一致性控制" class="headerlink" title="6.7 数据一致性控制"></a>6.7 数据一致性控制</h2>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 3.处理机调度与死机</title>
    <link href="/20200725/72fb2483/"/>
    <url>/20200725/72fb2483/</url>
    
    <content type="html"><![CDATA[<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p><strong>调度层次和调度队列模型；</strong></p><p><strong>处理机调度算法及其运用；</strong></p><p><strong>如何理解实时调度的“实时”含义；</strong></p><p><strong>实时调度算法；</strong></p><p><strong>死锁概念的理解，产生死锁的原因；</strong></p><p><strong>产生死锁的必要条件；</strong></p><p><strong>死锁解决措施。</strong></p><span id="more"></span><h2 id="3-1-处理机调度的层次"><a href="#3-1-处理机调度的层次" class="headerlink" title="3.1 处理机调度的层次"></a>3.1 处理机调度的层次</h2><h3 id="3-1-1三级调度"><a href="#3-1-1三级调度" class="headerlink" title="3.1.1三级调度"></a>3.1.1三级调度</h3><ul><li><p>高级调度：即作业调度，宏观调度或长程调度。其任务是对那些提交给系统后被收容的作业, 按照一定策略选择出某些作业, 为其分配内存等必要的资源, 建立与之对应的进程, 并将进程的PCB表放入就绪队列中, 使其具备参与竞争使用CPU的权利。作业状态变迁如图</p><img src="https://img.mubu.com/document_image/6a2f7ca7-427b-455e-aacc-fae3f1c42171-7976057.jpg" alt="img" style="zoom:67%;" /></li><li><p>低级调度：即进程调度，微观调度或短程调度。其任务是在进入内存并处于就绪队列的进程中, 确定哪个进程真正获得CPU及其使用CPU的时间。用执行指针指向选中进程的PCB表，将它从就绪队列移出并重布现场，使其运行。进程状态变迁如图</p><img src="https://img.mubu.com/document_image/0c4a61b0-4883-4a06-b680-0e40a80677b6-7976057.jpg" alt="img" style="zoom: 67%;" /></li><li><p>中级调度：将就绪状态细化为内存就绪和外存就绪状态，    阻塞状态细化为内存阻塞和外存阻塞状态后，中级调度完成进程在内存与外存之间的对换。其任务是周期性地将那些在内存中暂时不用的进程换出并放到外存，而将那些在外存上需要运行的进程换入到内存。进程状态变迁如图</p><img src="https://img.mubu.com/document_image/1d015e6d-37d4-4c81-9014-5d1759a24e8e-7976057.jpg" alt="img" style="zoom:67%;" /></li><li><p>三级调度模型</p><img src="https://img.mubu.com/document_image/49ec4338-8651-4f2e-865e-31788558c6e7-7976057.jpg" alt="img" style="zoom:80%;" /></li></ul><h3 id="3-1-2进程调度的功能"><a href="#3-1-2进程调度的功能" class="headerlink" title="3.1.2进程调度的功能"></a>3.1.2进程调度的功能</h3><ul><li>在某一给定时刻，决定哪个就绪进程运行、运行多长时间以及如何保证进程的运行，就是进程调度的主要工作<ul><li>记录系统中所有进程的状态、优先数和资源的需求情况。</li><li>确定调度算法。决定将CPU分配给哪个进程及多长时间。</li><li>分配处理机给进程。进行CPU现场的保护和移交，并实现CPU使用权的移交。</li></ul></li></ul><h3 id="3-1-3进程调度方式"><a href="#3-1-3进程调度方式" class="headerlink" title="3.1.3进程调度方式"></a>3.1.3进程调度方式</h3><ul><li>1.非抢占方式：在非抢占方式下，调度程序一旦把 CPU分配给某一进程后便让它一直运行下去，直到进程完成或发生某事件而不能运行时，才将CPU分给其它进程。这种调度方式通常用在批处理系统中。它的主要优点是简单、系统开销小。</li><li>2.抢占方式：当一个进程正在执行时，系统可以基于某种策略剥夺CPU给其它进程。剥夺的原则有：优先权原则、短进程优先原则和时间片原则。这种调度方式多用在分时系统和实时系统中，以便及时响应各进程的请求。</li></ul><h3 id="3-1-4-引起进程调度的时机（因素）"><a href="#3-1-4-引起进程调度的时机（因素）" class="headerlink" title="3.1.4 引起进程调度的时机（因素）"></a>3.1.4 引起进程调度的时机（因素）</h3><ul><li>进程调度的时机是与进程调度的方式有关的。通常当发现以下情况时，当前运行进程的CPU被收回，需要重新进行进程调度：<ul><li>正在执行的进程正确完成,或由于某种错误而终止运行(陷阱或中断)；</li><li>执行中的进程提出I&#x2F;O请求, 等待I&#x2F;O完成时;</li><li>在分时系统中，分给进程的时间片用完时；</li><li>按照优先级调度时,有更高优先级进程变为就绪时(抢占方式)；</li><li>在进程通信或进程同步过程中,执行中的进程执行了某种原语操作, 如P （wait）操作、阻塞原语和唤醒原语时, 都可能引起进程调度。</li></ul></li></ul><h2 id="3-2-调度评价准则"><a href="#3-2-调度评价准则" class="headerlink" title="3.2 调度评价准则"></a>3.2 调度评价准则</h2><ul><li><p>1）面向系统的调度性能准则</p><ul><li>系统吞吐量：单位时间内处理的进程数。</li><li>处理机利用率：CPU利用率&#x3D;CPU有效工作时间&#x2F;CPU总的运行时间</li><li>各种设备的均衡利用：如CPU繁忙的作业和I&#x2F;O繁忙（指次数多，每次时间短）的作业搭配。</li></ul></li><li><p>2） 面向用户的调度性能准则</p><ul><li><p>周转时间：作业从提交到完成所经历的时间——批处理系统。（公式中Tsi为实际运行时间）。</p><p><img src="https://img.mubu.com/document_image/08fe48f0-a940-4880-a90f-2b4344242665-7976057.jpg" alt="img"></p></li><li><p>响应时间：用户输入一个请求（如击键）到系统给出首次响应（如屏幕显示）的时间——分时系统</p></li><li><p>截止时间：开始截止时间和完成截止时间——实时系统。</p></li><li><p>公平性：不因作业或进程本身的特性而使上述指标过分恶化。如长作业等待很长时间。</p></li><li><p>优先级：可以使关键任务达到更好的指标。</p></li></ul></li></ul><h2 id="3-3-调度算法"><a href="#3-3-调度算法" class="headerlink" title="3.3 调度算法"></a><font color="red">3.3 调度算法</font></h2><h3 id="1-先来先服务FCFS-先进先出调度算法，FIFO"><a href="#1-先来先服务FCFS-先进先出调度算法，FIFO" class="headerlink" title="1.先来先服务FCFS(先进先出调度算法，FIFO)"></a><font color="red">1.先来先服务FCFS(先进先出调度算法，FIFO)</font></h3><ul><li><p>【算法思想】：最简单的算法</p><ul><li>按照进程进入就绪队列的先后次序，分派CPU；</li><li>当前进程占用CPU，直到执行完或阻塞，才出让CPU（非抢占方式）。</li><li>在进程唤醒后（如I&#x2F;O完成），并不立即恢复执行，通常等到当前进程让出CPU。</li></ul></li><li><p>【特点】：</p><ul><li>比较有利于长作业，而不利于短作业。</li><li>有利于CPU繁忙的作业，而不利于I&#x2F;O繁忙的作业。</li></ul></li><li><p>结构图&amp;&amp;算法流程</p><img src="https://img.mubu.com/document_image/d1945676-31de-492e-8d7c-acf3a0545351-7976057.jpg" alt="img" style="zoom:67%;" /><img src="https://img.mubu.com/document_image/e13972e5-4fcf-43b2-bd11-fa07d8158b73-7976057.jpg" alt="img" style="zoom:67%;" /></li><li><p>【例题】</p><ul><li><p>题目：系统中现有5 个作业A、B、C、D、E同时提交（到达顺序也为ABCDE），其预计运行时间分别10、1、2、1、5个时间单位，如表所示，计算FCFS调度下作业的平均周转时间和平均带权周转时间</p><img src="https://img.mubu.com/document_image/926312d5-ed1f-468a-9053-95058d015bbb-7976057.jpg" alt="img" style="zoom: 67%;" /></li><li><p>解答：<strong>设作业到达时刻为0</strong>，根据定义计算，系统运行情况 </p><img src="https://img.mubu.com/document_image/5aeb1d1c-0297-45fd-bcb2-e3e838186695-7976057.jpg" alt="img" style="zoom: 67%;" /></li></ul></li></ul><h3 id="2-短进程优先调度算法-SJF-SPF"><a href="#2-短进程优先调度算法-SJF-SPF" class="headerlink" title="2.短进程优先调度算法(SJF,SPF)"></a><font color="red">2.短进程优先调度算法(SJF,SPF)</font></h3><ul><li><p>【算法思想】：选择就绪队列中估计运行时间最短的进程投入运行。通常后来的短作业不抢先正在执行的作业。</p></li><li><p>【优点】：</p><ul><li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li><li>提高系统的吞吐量；</li></ul></li><li><p>【缺点】：</p><ul><li>对长作业非常不利，可能长时间得不到执行；</li><li>未能依据作业的紧迫程度来划分执行的优先级；</li><li>难以准确估计作业（进程）的执行时间，从而影响调度性能。</li></ul></li><li><p>【例题】</p><ul><li><p>问题：同FCFS题目</p></li><li><p>解答：采用SJF算法调度作业</p><img src="https://img.mubu.com/document_image/43f0acc2-cc96-4539-a82a-ff31eb1c261e-7976057.jpg" alt="img" style="zoom: 67%;" /></li></ul></li></ul><h3 id="3-最短剩余时间优先（Shortest-Remaining-Time-First，SRTF）"><a href="#3-最短剩余时间优先（Shortest-Remaining-Time-First，SRTF）" class="headerlink" title="3.最短剩余时间优先（Shortest Remaining Time First，SRTF）"></a><font color="red">3.最短剩余时间优先（Shortest Remaining Time First，SRTF）</font></h3><ul><li><p>【算法思想】：若一就绪状态的新作业所需的CPU时间比当前正在执行的作业剩余任务所需CPU时间还短，SRTF将打断正在执行作业，将执行权分配给新作业</p></li><li><p>【特点】：</p><ul><li>长进程仍有可能出现饥饿现象</li><li>必须计算运行、剩余时间，系统开销增大</li><li>因抢占式调度，系统性能会比SJF要好</li></ul></li><li><p>【例题】</p><ul><li><p>问题：作业A、B、C、D需要运行的时间分别为20ms、15ms、10ms、5ms。A作业在0ms到达，B作业在1ms到达，C作业在2ms到达，D作业在3ms到达。计算SRTF调度下作业的平均周转时间和平均带权周转时间 </p></li><li><p>解答：如图</p><img src="https://img.mubu.com/document_image/946e28df-1154-4462-ab6e-ac0ced61393e-7976057.jpg" alt="img" style="zoom: 67%;" /></li></ul></li></ul><h3 id="4-高响应比优先（Highest-Response-Ratio-First，HRRF）"><a href="#4-高响应比优先（Highest-Response-Ratio-First，HRRF）" class="headerlink" title="4.高响应比优先（Highest Response Ratio First，HRRF）"></a><font color="red">4.高响应比优先（Highest Response Ratio First，HRRF）</font></h3><ul><li><p>【算法思想】：是FCFS与SJF两种算法的折衷——既考虑作业等待时间，又考虑作业的运行时间，既照顾短作业又不使长作业等待过久，改善了调度性能，仍属于非抢占式算法</p><ul><li>响应比为作业的响应时间与作业所需运行时间之比，简化为：响应比 ＝1 +（已等待的时间 &#x2F; 估计运行时间）</li></ul></li><li><p>【适用性】</p><ul><li>由定义可知，短作业容易得到较高响应比，长作业在等待了足够长的时间后，也将获得足够高的响应比，因此不会发生饥饿现象</li><li>需要经常计算作业的响应比，导致额外的开销</li><li>HRRF算法的平均周转时间和平均带权周转时间都介于FCFS与SJF算法之间，比SJF算法差，比FCFS算法优</li><li>虽然HRRF算法的平均周转时间和平均带权周转时间不及SJF算法，但是，在现实中其可以实现，结果也比较可靠</li><li>如果在算法中引入抢占调度，则算法过程会更复杂。因为所有作业的响应比是动态变化的，抢占时间的计算需要解多个方程得到</li></ul></li><li><p>【例题】</p><ul><li><p>问题：系统中现有3 个作业A、B、C先后提交（到达），其参数如表所示，计算HRRF调度下作业的平均周转时间和平均带权周转时间 </p><img src="https://img.mubu.com/document_image/6954bfe1-d34f-4ce4-a80c-0f06f8c75863-7976057.jpg" alt="img" style="zoom:67%;" /></li><li><p>解答：如图</p><img src="https://img.mubu.com/document_image/907d8e1c-4731-4995-b545-846e9f5eff0c-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul></li></ul><h3 id="5-优先级调度算法-HPF—Highest-Priority-First"><a href="#5-优先级调度算法-HPF—Highest-Priority-First" class="headerlink" title="5.优先级调度算法(HPF—Highest Priority First)"></a><font color="red">5.优先级调度算法(HPF—Highest Priority First)</font></h3><ul><li><p>【算法思想】：优先选择就绪队列中优先级最高的进程投入运行。分为：</p><ul><li>非抢占式优先级算法：仅发生在进程放弃CPU。</li><li>抢占式优先级算法：可剥夺当前运行进程CPU。</li></ul></li><li><p>【优先权的类型】</p><ul><li>静态优先级：在进程创建时指定优先级,在进程运行时优先数不变。</li><li>动态优先级：在进程创建时创立一个优先级，但在其生命周期内优先数可以动态变化。如等待时间长优先数可改变。</li></ul></li><li><p>【确定优先级的依据】</p><ul><li>进程类型、对资源的需求、根据用户要求。</li></ul></li><li><p>【确定优先级的原则】</p><ul><li>静态优先数的确定：<ul><li>用户要求：用户可以根据作业情况提出自己的优先级要求；</li><li>资源利用率：请求I&#x2F;O服务密集的进程优先级较高；</li><li>系统内部要求：系统进程的优先级高于用户进程的优先级。</li></ul></li><li>动态优先数的确定：<ul><li>进程运行前被赋予一个优先数。运行中根据进程等待时间的长短、执行时间的多少、输入与输出信息量的大小等，通过计算得到新的优先数。每次调度时，仍然是从就绪队列中选择优先级最高的进程率先调度，同级的采用先来先服务（FCFS）。</li></ul></li></ul></li><li><p>【例题】</p><ul><li><p>问题：系统的进程调度采用抢占式优先权调度算法，<strong>优先数越小优先级越高</strong>，其参数如表所示，求平均周转时间和平均等待时间</p><img src="https://img.mubu.com/document_image/2eb04bc2-ac6e-476e-bf52-6d0154b0ab91-7976057.jpg" alt="img" style="zoom:67%;" /></li><li><p>解答：如图</p><img src="https://img.mubu.com/document_image/da74a52a-25a7-49f4-b492-7609db5d9d64-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul></li></ul><h3 id="6-时间片轮转"><a href="#6-时间片轮转" class="headerlink" title="6.时间片轮转"></a><font color="red">6.时间片轮转</font></h3><ul><li>【算法思想】：通过时间片轮转，提高进程并发性和响应时间特性，从而提高资源利用率。<ul><li>将系统中所有的就绪进程按照FCFS原则，排成一个队列。</li><li>每次调度时将CPU分派给队首进程，让其执行一个时间片。时间片的长度从几个ms到几百ms。</li><li>在一个时间片结束时，发生时钟中断。</li><li>调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过CPU现场切换执行当前的队首进程。</li><li>进程可以未使用完一个时间片，就出让CPU（如阻塞）。</li></ul></li><li>【时间片长度变化的影响】：<ul><li>过长－&gt;退化为FCFS算法，进程在一个时间片内都执行完，响应时间长。</li><li>过短－&gt;用户的一次请求需要多个时间片才能处理完，CPU现场切换次数增加，响应时间长。</li></ul></li><li>【对响应时间的要求】：<ul><li>(响应时间)&#x3D;N(进程数目)*q(时间片)</li></ul></li><li>【时间片长度的影响因素】：<ul><li>就绪进程的数目：数目越多，时间片越小（当响应时间一定时）。</li><li>系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间，平均周转时间和平均带权周转时间延长。</li></ul></li></ul><h3 id="7-1多级队列调度算法"><a href="#7-1多级队列调度算法" class="headerlink" title="7.1多级队列调度算法"></a><font color="red">7.1多级队列调度算法</font></h3><ul><li><p>【基本思想】</p><ul><li><p>根据进程的类型不同，将进程就绪队列分为若干个独立的就绪队列，不同的就绪队列采用不同的调度算法，同一个就绪队列采用同一种进程调度算法。</p></li><li><p>按照用户作业的性质不同，就绪队列进行不同组织。</p><ul><li><p>如：按照进程优先级组织的多个进程就绪队列：</p><img src="https://img.mubu.com/document_image/a8895054-cfda-4022-af85-f0da783254c6-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul></li></ul></li></ul><h3 id="7-2多级反馈队列算法-多队列轮转法MFQ"><a href="#7-2多级反馈队列算法-多队列轮转法MFQ" class="headerlink" title="7.2多级反馈队列算法(多队列轮转法MFQ)"></a><font color="red">7.2多级反馈队列算法(多队列轮转法MFQ)</font></h3><ul><li>【算法思想】：<ul><li>设置多个就绪队列，分别赋予不同的优先级，队列1的优先级最高，其他逐级降低。每队列分配不同的时间片，规定优先级越低则时间片越长。</li><li>新进程就绪后，先投入队列1的末尾，按FCFS算法调度。若一个时间片未能执行完，则降低投入到队列2的末尾；依此类推，降低到最后的队列，则按“时间片轮转”算法调度直到完成。</li><li>进程由于等待事件而放弃CPU后,进入等待队列, 一旦等待的事件发生, 则回到原来的就绪队列。</li><li>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾。</li></ul></li><li>【补充说明】<ul><li>I&#x2F;O型进程：让其进入最高优先级队列，以及时响应I&#x2F;O交互。通常执行一个小时间片，要求可处理完一次I&#x2F;O请求的数据，然后转入到阻塞队列。</li><li>计算型进程：每次都执行完时间片，进入更低级队列。最终采用最大时间片来执行，减少调度次数。</li><li>I&#x2F;O次数不多，而主要是CPU处理的进程：在I&#x2F;O完成后，放回优先I&#x2F;O请求时离开的队列，以免每次都回到最高优先级队列后再逐次下降。</li><li>时间片的增加和优先级的降低体现了反馈；</li></ul></li><li>【算法优点】：<ul><li>为提高系统吞吐量和缩短平均周转时间而照顾短进程。</li><li>为获得较好的I&#x2F;O设备利用率和缩短响应时间而照顾I&#x2F;O型进程。</li><li>不必估计进程的执行时间，动态调节。</li></ul></li></ul><h3 id="各算法总结"><a href="#各算法总结" class="headerlink" title="各算法总结"></a>各算法总结</h3><p>在所学的调度算法中，对所有进程和作业都是公平合理的调度算法是 (1) ；最有利于提高系统吞吐量的作业调度算法是 (2) ；能兼顾作业等待时间和作业执行时间调度算法是 (5) ；最有利于提高资源的使用率、能使短作业、长作业及交互作业用户都比较满意的调度算法是 (4) ；为实现人机交互作用应采用调度算法是 (3) ；能对紧急作业进行及时处理的调度算法是 (6) 。</p><ul><li>A—F：(1)FCFS调度算法； (2)短作业优先调度算法；(3)时间片轮转法； (4)多级反馈队列调度算法；(5)高响应比优先算法；(6)基于优先权的剥夺调度算法。</li></ul><h2 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4 实时调度"></a>3.4 实时调度</h2><ul><li>所谓<strong>实时是指系统能够对外部请求做出即时响应</strong>，外部请求是指与系统相连的设备提出的服务要求和数据采集。与前面介绍的进程调度算法相比，主要是<strong>及时响应和及时处理</strong>，即满足实时任务的时间要求。</li></ul><h3 id="1-实时调度的基本条件"><a href="#1-实时调度的基本条件" class="headerlink" title="1.实时调度的基本条件"></a>1.实时调度的基本条件</h3><ul><li>⑴ 就绪时间。</li><li>⑵ 开始截止时间和完成截止时间。</li><li>⑶ 处理时间。</li><li>⑷ 资源要求。</li><li>⑸ 优先级。</li></ul><h3 id="2-实时调度的时机与算法"><a href="#2-实时调度的时机与算法" class="headerlink" title="2.实时调度的时机与算法"></a>2.实时调度的时机与算法</h3><h4 id="⑴时间片轮转调度算法："><a href="#⑴时间片轮转调度算法：" class="headerlink" title="⑴时间片轮转调度算法："></a>⑴时间片轮转调度算法：</h4><p>当一个实时任务到达时，它被<strong>挂在轮转队列的末尾</strong>，用于分时系统中。这种调度算法能获得数秒至数十秒的响应时间，只适用于一般实时信息处理系统。</p><h4 id="⑵非抢占优先级调度算法"><a href="#⑵非抢占优先级调度算法" class="headerlink" title="⑵非抢占优先级调度算法"></a>⑵非抢占优先级调度算法</h4><p>系统为每一个实时任务都赋予一个相应的优先级，当实时任务到达时，<strong>将依据它的优先级高低插入到就绪队列中</strong>。紧迫的实时任务有可能获得数秒至数百毫秒级的响应时间，故该方法可用于要求不太严格的实时控制系统中。</p><h4 id="⑶抢占式优先级调度算法"><a href="#⑶抢占式优先级调度算法" class="headerlink" title="⑶抢占式优先级调度算法"></a>⑶抢占式优先级调度算法</h4><p>在该方法中，若到达的实时任务<strong>优先级高于当前任务的优先级</strong>，则该实时任务就可以抢夺CPU。调度程序可由时钟中断触发，也可由代表紧迫任务的外部中断触发。这要求操作系统<strong>具有快速响应外部事件中断的能力</strong>。这种调度算法能获得很好的响应效果，其调度延迟可降为几十毫秒至100微秒，因此它可用于大多数的实时系统中。</p><h4 id="【实时调度的时机】"><a href="#【实时调度的时机】" class="headerlink" title="【实时调度的时机】"></a>【实时调度的时机】</h4><img src="https://img.mubu.com/document_image/5f43142b-a79b-470b-bc4e-f8009c580d74-7976057.jpg" alt="img" style="zoom:67%;" /><h3 id="3-实时调度实例"><a href="#3-实时调度实例" class="headerlink" title="3.实时调度实例"></a>3.实时调度实例</h3><h4 id="【最早开始截止时间优先】"><a href="#【最早开始截止时间优先】" class="headerlink" title="【最早开始截止时间优先】"></a>【最早开始截止时间优先】</h4><p>如图</p><img src="https://img.mubu.com/document_image/3a8a357b-7305-47f0-9029-491ff40f9261-7976057.jpg" alt="img" style="zoom:67%;" /><h4 id="【剥夺式调度】"><a href="#【剥夺式调度】" class="headerlink" title="【剥夺式调度】"></a>【剥夺式调度】</h4><p>如图，在该例中，设C的开始截止时间是5，则在t＝5时，A还没有运行完，但C的开始截止时间已到，为了保证任务的时效性，就要采用可剥夺式调度。既在t＝5时改调度C任务运行，在t＝10时再调度A任务执行剩余的部分，这样A、B两个任务均在指定时间内完成了。</p><img src="https://img.mubu.com/document_image/d113221b-86ab-415d-a844-004460d1e442-7976057.jpg" alt="img" style="zoom:67%;" /><h2 id="3-5-死锁"><a href="#3-5-死锁" class="headerlink" title="3.5 死锁"></a>3.5 死锁</h2><p>一个进程集合中的每个进程都在等待只能由该集合中的其它一个进程才能引发的事件，则称一组进程或系统此时发生了死锁 </p><h3 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h3><ul><li>并发进程对临界资源的竞争</li><li>并发进程推进顺序不当、</li></ul><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><ul><li>1）互斥条件（Mutual exclusion）——资源的使用是互斥的</li><li>2）请求与保持条件（Hold and wait）——已经得到某些资源的进程可以再申请新的资源。</li><li>3）不剥夺条件（No pre-emption）——系统或其它进程不能剥夺进程已经获得的资源。</li><li>4）环路等待条件（Circular wait）——系统中若干进程间形成等待环路</li></ul><h3 id="死锁的解决方法"><a href="#死锁的解决方法" class="headerlink" title="死锁的解决方法"></a>死锁的解决方法</h3><p>解决方法分为预防和避免</p><h4 id="①死锁的预防"><a href="#①死锁的预防" class="headerlink" title="①死锁的预防"></a>①死锁的预防</h4><p>在系统运行之前就采取措施，即在系统设计时确定资源分配算法，消除发生死锁的任何可能性。</p><ul><li>1．静态资源分配法（摒弃“占有并请求条件”）<ul><li>系统规定每一个进程在开始运行前，都必须一次性地申请其在整个运行过程所需的全部资源。此时，若系统有足够的资源，便把进程想要的全部资源一次性地分配给它；若不能全部满足进程的资源请求，则一个资源也不分给它。</li><li>简单、安全、易实现。（1）资源被严重浪费；（2）进程延迟运行。</li></ul></li><li>2．摒弃“不可剥夺条件”<ul><li>进程在需要资源时才提出请求。即：一个已经保持了某些资源的进程，当它再提出新的资源要求而不能立即得到满足时，必须释放它已经保持的所有资源，待以后再需要时再重新申请。</li><li>采用剥夺式调度方法，只适用于CPU和内存分配；实现起来比较复杂；进程的周转时间较长，系统开销大。</li></ul></li><li>3．有序资源使用法（摒弃“循环等待条件”）<ul><li>系统中的所有资源按类都被赋予一个唯一的编号，每个进程只能按编号的升序申请资源。</li><li>安全且资源利用率比静态资源分配法有所提高；实现较困难，因为难给出合适的资源编号；仍有一定的资源浪费现象</li></ul></li></ul><h4 id="系统资源分配图"><a href="#系统资源分配图" class="headerlink" title="系统资源分配图"></a>系统资源分配图</h4><ul><li><p>圆圈表示进程，资源类用方框表示，框中的圆点代表单个该类资源，有向边连接进程和资源</p></li><li><p>申请边从进程指向资源类方框，表示进程正在等待资源；分配边从单个资源圆点指向进程，表示进程已经获得资源</p></li><li><p>根据进程-资源分配图定义得出如下结论</p><img src="https://img.mubu.com/document_image/60e62020-e49e-4deb-b988-9c2f8f9730a4-7976057.jpg" alt="img" style="zoom:67%;" /><ul><li>1）如果进程-资源分配图中无环路，则此时系统没有发生死锁</li><li>2）如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充要条件，环路中的进程便为死锁进程</li><li>3）如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件</li></ul></li></ul><p>系统为死锁状态的充分条件是：<strong>当且仅当该状态的进程-资源分配图是不可完全简化的——死锁定理。</strong></p><h4 id="②-死锁的避免"><a href="#②-死锁的避免" class="headerlink" title="② 死锁的避免"></a>② 死锁的避免</h4><ul><li><p>系统在运行过程中采取动态的资源分配策略，保证系统不进入可能导致系统陷入死锁状态的所谓不安全状态，以避免死锁发生。</p></li><li><p>系统状态</p><ul><li><p>1.安全状态</p><ul><li><p>若在某一时刻，系统能按某种进程顺序，如&lt;P1,P2,…,Pn&gt;，来为每个进程分配其所需的资源，直至最大需求，使每个进程均可顺利完成。则称此时系统的状态为安全状态，称这样的一个进程序列&lt;P1,P2,…,Pn&gt;为安全序列。</p></li><li><p><strong>安全序列的实质</strong>是：序列中的每一个进程Pi（i&#x3D;1,2,…,n）到以后运行完成尚需要的资源量不超过系统当前剩余的资源量与所有在序列中排在它前面的进程当前所占有的资源量之和。</p></li><li><p>举例</p><img src="https://img.mubu.com/document_image/be129ce6-3512-4a11-9e1c-16487de281c7-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul></li><li><p>2.不安全状态</p><ul><li>若在某一时刻，系统不按照安全序列分配资源，导致系统中不存在一个安全序列，则称系统处于不安全状态。</li></ul></li><li><p>1）系统在某一时刻的安全状态可能不唯一，但这不影响对系统安全性的判断。</p></li><li><p>2）安全状态是非死锁状态，而不安全状态并不一定是死锁状态。即系统处于安全状态一定可以避免死锁，而系统处于不安全状态则仅仅可能进入死锁状态。</p></li></ul></li></ul><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a><font color="red"><strong>银行家算法</strong></font></h4><h5 id="【思路】"><a href="#【思路】" class="headerlink" title="【思路】"></a>【思路】</h5><ul><li>1）在某一时刻，各进程已获得所需的部分资源。有一进程提出新的资源请求，系统将剩余资源试探性地分配给该进程。</li><li>2）如果此时剩余资源能够满足余下的某些进程的需求，则将剩余资源分配给能充分满足的、资源需求缺口最大的进程，运行结束后释放的资源再并入系统的剩余资源集合。</li><li>3）反复执行第2步，直到所有的进程都能够获得所需而运行结束。说明第1步的进程请求是可行的，系统处于安全状态，相应的进程执行序列称为系统的安全序列。如果所有的进程都试探过而不能将资源分配给进程，即不存在安全序列，则系统是不安全的。</li></ul><h5 id="【银行家算法中所用的主要数据结构】"><a href="#【银行家算法中所用的主要数据结构】" class="headerlink" title="【银行家算法中所用的主要数据结构】"></a>【银行家算法中所用的主要数据结构】</h5><ul><li>(1)可利用资源向量Available</li><li>(2)最大需求矩阵Max：资源最大需求量</li><li>(3)Allocation：已分配的资源</li><li>(4)需求矩阵Need：Need&#x3D;Max－Allocation</li><li>(5)请求向量Request：记录某个进程当前对各类资源的申请量，是银行家算法的入口参数</li></ul><h5 id="【算法步骤】"><a href="#【算法步骤】" class="headerlink" title="【算法步骤】"></a>【算法步骤】</h5><ul><li>当Pi发出资源请求后，系统按下述步骤进行检查：<ul><li>1.判断请求向量Request的有效性——如果Request[i] &gt;该进程 i 的总需求，则出错。</li><li>2.如果Request[i]&gt;Available,则Pi阻塞；</li><li>3.系统试探把要求的资源分配给进程Pi，并修改下面数据结构中的数值：<ul><li>Available[i]&#x3D;Available[i]-Request[i]；Allocation[i]&#x3D;Allocation[i]+Request[i]；Need[i] &#x3D;Need[i]-Request[i];</li></ul></li><li>4.系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，正式将资源分配给进程Pi，以完成本次分配；否则，将试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</li></ul></li></ul><h5 id="【子算法描述】"><a href="#【子算法描述】" class="headerlink" title="【子算法描述】"></a>【子算法描述】</h5><ul><li>1.设置两个向量<ul><li>①工作向量Work：表示系统可提供给进程继续运行所需要的各类资源的数目，开始时，Work:&#x3D;Available。</li><li>②Finish：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i]:&#x3D;false；当有足够的资源分配给进程时，令Finish[i]:&#x3D;true。</li></ul></li><li>2.执行过程的描述<ul><li>(1)初始化：work&#x3D;available；finish&#x3D;false；</li><li>(2)若按进行编号顺序找到了一个可加入安全序列的进程<ul><li>即：满足条件finishi&#x3D;false且need[i]≤work的进程Pi</li><li>则①假设该进程不久将完成任务归还资源，置work&#x3D;work+allocationi和finishi&#x3D;true</li><li>②重复执行这一步；</li></ul></li><li>(3)若所有进程的可完成标志finish为真，则返回逻辑真值（表示系统处于安全状态）；</li><li>(4)否则，返回逻辑假值（表示不安全）；</li></ul></li></ul><h5 id="【银行家算法示例】"><a href="#【银行家算法示例】" class="headerlink" title="【银行家算法示例】"></a>【银行家算法示例】</h5><ul><li><p>假定系统中有四个进程{P1、P2、P3、P4}和三种类型的资源{R1，R2，R3}，资源的数量分别为9、3、6，在T0时刻的资源分配情况如图：</p><img src="https://img.mubu.com/document_image/a74932ef-1213-4e4c-aae1-715bd758c6d3-7976057.jpg" alt="img" style="zoom:67%;" /></li><li><p>解决方案：可以看出{ P2、P1、P3、P4 }是一个安全的执行序列</p><img src="https://img.mubu.com/document_image/f9dc5a1f-e8c0-48b5-91b6-1c289060080f-7976057.jpg" alt="img" style="zoom:67%;" /><img src="https://img.mubu.com/document_image/557e4a4a-b9c7-42cd-a9c6-536fbf164194-7976057.jpg" alt="img" style="zoom:67%;" /><img src="https://img.mubu.com/document_image/e83f7835-759c-4f29-9a02-1a729724c139-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h4 id="③-死锁的检测和恢复"><a href="#③-死锁的检测和恢复" class="headerlink" title="③ 死锁的检测和恢复"></a>③ 死锁的检测和恢复</h4><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><ul><li>死锁的检测算法可以采用基于死锁定理的检测，也可以采用类似于银行家算法中的安全性测试算法</li><li>在系统中，需要决定死锁检测的频率。如果检测太频繁，会花大量的时间检测死锁，浪费CPU的处理时间；如果检测的频率太低，死锁进程和系统资源被锁定的时间过长，资源浪费大。</li><li>通常的方法是在CPU的使用率下降到一定的阈值时实施检测。当死锁发生次数多，死锁进程数增加到一定程度时，CPU的处理任务减少，CPU空闲时间增多。</li></ul><h5 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h5><ul><li>重启：重新启动死锁进程，甚至重启操作系统。</li><li>撤销：撤销死锁进程，回收资源，优先选择占用资源最多或者撤销代价最小的，撤销一个不行就继续选择撤销进程，直至解除死锁。</li><li>剥夺：剥夺死锁进程资源再分配，选择原则同上。</li><li>回滚：根据系统保存的检查点，使进程或系统回退到死锁前的状态。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 4.内存管理</title>
    <link href="/20200725/7f3441af/"/>
    <url>/20200725/7f3441af/</url>
    
    <content type="html"><![CDATA[<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p><strong>调度层次和调度队列模型；</strong></p><p><strong>处理机调度算法及其运用；</strong></p><p><strong>如何理解实时调度的“实时”含义；</strong></p><p><strong>实时调度算法；</strong></p><p><strong>死锁概念的理解，产生死锁的原因；</strong></p><p><strong>产生死锁的必要条件；</strong></p><p><strong>死锁解决措施。</strong></p><span id="more"></span><h2 id="重难点"><a href="#重难点" class="headerlink" title="重难点"></a>重难点</h2><ul><li><p>程序的装入方式</p></li><li><p><strong>连续分配方式的管理</strong></p></li><li><p><strong>离散分配方式的管理</strong></p></li><li><p>虚拟存储的基本理论</p></li><li><p>地址变换的实现</p></li><li><p>虚拟存储的理解</p></li><li><p>页面置换算法的实现</p></li></ul><h2 id="4-1-存储管理的原理"><a href="#4-1-存储管理的原理" class="headerlink" title="4.1  存储管理的原理"></a>4.1  存储管理的原理</h2><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><img src="https://api2.mubu.com/v3/document_image/6f647060-677c-45f6-a82e-768e792153cb-7976057.jpg" alt="img" style="zoom:80%;" /><p>计算机存储层次示意图&amp;&amp;存储方式一览表</p><img src="https://api2.mubu.com/v3/document_image/51ccfd73-e925-4e88-9ca0-6c4e07919ec1-7976057.jpg" alt="img" style="zoom:80%;" /><img src="https://api2.mubu.com/v3/document_image/dbef4e01-d5ec-41c7-93ad-62d7b3be5074-7976057.jpg" alt="img" style="zoom:80%;" /><p>通常将用户的作业放在主存中执行；而把那些不立即使用的程序、数据放在外存中，用到时再将它们调入内存中；在程序运行时，为了提高对数据的存取速度，会将一些常用的表格，变量，临时数据等放入到高速缓存中。</p><img src="https://api2.mubu.com/v3/document_image/fcc7d948-d94a-4e91-9ed9-c4d945a87de4-7976057.jpg" alt="img" style="zoom:80%;" /><p>主存：程序的指令和数据只有放在内存中，CPU才能对其进行直接存取，或者说该程序才能被执行。可见内存资源是进程执行时不可或缺的条件之一。</p><img src="https://api2.mubu.com/v3/document_image/2ae8607b-a4a8-4b6a-a620-73527cefe13f-7976057.jpg" alt="img" style="zoom:80%;" /><h3 id="存储管理的原理"><a href="#存储管理的原理" class="headerlink" title="存储管理的原理"></a>存储管理的原理</h3><h4 id="存储管理的原理-1"><a href="#存储管理的原理-1" class="headerlink" title="存储管理的原理"></a>存储管理的原理</h4><ul><li><p>(1)程序执行过程：首先CPU通过程序计数器中的值从内存中取得相应的指令，指令被译码后根据要求可能会从存储器中再取得操作数。对操作数处理完成后，操作结果又会存储到存储器中；进程在运行过程中依据任务的要求也会请求内存空间，如I&#x2F;O需要缓冲区、存放临时数据等，这涉及到内存的分配与回收问题。</p></li><li><p>(2)存储管理的主要工作：就是负责内存空间的使用管理，即为进程分配与回收空间，将程序装入指定内存区域；再从指定的存储单元中读写数据，而内存单元的读写操作是由主存硬件完成的，所以对主存发出的读写请求只要指定主存单元就行。</p></li></ul><h4 id="存储单元与物理地址空间"><a href="#存储单元与物理地址空间" class="headerlink" title="存储单元与物理地址空间"></a>存储单元与物理地址空间</h4><ul><li><p>(1)物理地址（绝对地址）：内存是由若干个存储单元组成的，每个存储单元有一个编号，这种编号可唯一标识一个存储单元，称为内存地址（或物理地址）。</p></li><li><p>(2)物理地址空间：是指物理地址的集合，也叫绝对地址空间或实空间或存储空间，亦即内存空间。存储空间中的单元一般都是按字节从0开始连续编址的，内存空间的最大容量由地址总线决定。如地址总线有24根，则其地址范围是0～～16M-1(2^24-1)，最大容量为16M。</p></li><li><p>(3)存储单元的访问：存储器只能通过物理地址访问内存单元。即给出欲访问的存储单元绝对地址，存储器即可对其进行读写操作。</p></li></ul><h4 id="作业的装入"><a href="#作业的装入" class="headerlink" title="作业的装入"></a>作业的装入</h4><ul><li><p>(1)作业的处理过程：用户的作业总是由一个或若干个源程序文件组成，编译或汇编程序可对源程序文件进行编译或汇编形成相应的目标模块，再由连接程序将这些目标模块和库函数连接成一个完整的装入模块，最后将其装入内存执行。</p></li><li><p>(2)名字空间：用汇编语言或高级语言编写程序时，总是通过符号名来访问某一单元。我们把程序中由符号名组成的空间称为名空间。</p></li><li><p>(3)逻辑地址空间：源程序经过汇编或编译并再经过链接程序所装配形成的程序，通常是以0为基址进行顺序编址，或者是分成若干个部分，每个部分以0为基址，这样的地址表示形式称为相对地址,也叫做逻辑地址或虚地址，把该程序逻辑地址组成的集合叫做程序的逻辑地址空间(简称地址空间，也叫相对地址空间或虚空间 ) 。</p></li></ul><h4 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a>地址重定位</h4><p>(1)地址变换：作业运行时不能按其相对地址访问内存单元，而应按相应的物理地址访问。因此将一个逻辑地址空间的程序装入到物理地址空间时，由于两个空间不一致，需要进行相对地址到物理地址的转换，即地址的重定位。也就是说将虚地址映射为内存地址，这种作法叫做地址重定位或地址变换或地址映射。地址重定位有两种方式：静态重定位和动态重定位。</p><p>(2)静态地址重定位：静态地址重定位是在程序执行之前由操作系统的重定位装入程序完成的。在装入一个作业时，把作业中的指令地址全部转换为绝对地址（地址转换工作是在作业执行前集中一次完成的）在作业执行过程中就无须再进行地址转换工作。</p><ul><li><p>静态地址重定位示例：静态地址重定位的优点是容易实现，无需硬件支持。其主要缺点是程序经地址重定位后就不能移动了，因而不能重新分配内存，不利于内存的有效利用。</p><img src="https://api2.mubu.com/v3/document_image/7f2f15f0-b2e5-4697-a186-672d02e847e1-7976057.jpg" alt="img" style="zoom:80%;" /></li></ul><p>(3)动态地址重定位 ：动态地址重定位是在程序执行期间进行的。在CPU访问内存之前,将要访问的程序或数据地址转换成内存地址。</p><ul><li>动态地址重定位的优点是程序在内存中的搬移不会对程序的正确执行造成影响，使内存得以被充分利用，其缺点是需要附加的硬件支持，实现存储管理的软件算法比较复杂。</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接是指多个目标模块在执行时的地址空间分配和相互引用。</p><p>链接方法</p><ul><li><p>静态链接（static-linking）：静态链接是在生成可执行文件时进行的。</p></li><li><p>动态链接(dynamic-linking)：在装入或运行时进行链接。通常被链接的共享代码称为动态链接库(DLL, Dynamic-Link Library)</p><ul><li>优点：共享；部分装入；便于局部代码修改；便于运行环境适应。缺点：链接开销；管理开销</li></ul></li></ul><h3 id="存储管理的机制和策略"><a href="#存储管理的机制和策略" class="headerlink" title="存储管理的机制和策略"></a>存储管理的机制和策略</h3><p>【存储管理的功能】</p><p><strong>1.内存的分配与回收</strong></p><ul><li><p>每一个进程运行时都需要内存资源， 因此内存空间的分配和回收是存储管理的基本功能。</p></li><li><p>为了记录内存的使用情况，存储管理会依据存储策略采用相应的数据结构。系统通过所采用的数据结构来管理内存空间。</p></li><li><p>（1）静态存储分配：内存分配是在作业运行前一次性完成的</p></li><li><p>（2）动态存储分配：分配工作可以在作业运行前及运行过程中逐步完成。</p></li></ul><p><strong>2.地址映射与存储保护</strong></p><ul><li><p>为防止内存中各程序相互干扰，必须对内存中的程序和数据进行保护。规定每一个进程只能在自己的存储区内活动，否则产生越界中断。</p></li><li><p>存储保护一般以硬件保护机制为主，软件为辅。</p></li><li><p>存储保护机制应设置在主存操作之前，也就是存储保护机制对每一个欲访问的主存地址都要进行检查。</p></li><li><p>（1）上、下界存储保护：系统可设置一对上、下界寄存器，分别用来存放当前运行进程在内存空间的上、下边界地址</p></li><li><p>（2）基址—限长存储保护：上下界保护的变种，在限长寄存器中存放作业的长度，地址转换前进行测试，若逻辑地址的值大于限长值，就属于非法访问，产生一个越界中断</p></li></ul><p><strong>3.内存共享与扩充</strong></p><ul><li><p>一是指内存被多个并发进程所共用，即每一个进程占据内存的一段相对独立的区域；二是指内存中某一区域的信息可被多个进程共享。</p></li><li><p>(1)覆盖技术，节约内存使用；</p></li><li><p>(2)交换技术，轮流使用内存；</p></li><li><p>(3)虚拟存储管理技术，用外存补充内存的不足。</p></li></ul><h2 id="4-2-连续分配存储管理"><a href="#4-2-连续分配存储管理" class="headerlink" title="4.2  连续分配存储管理"></a>4.2  连续分配存储管理</h2><h3 id="单连续存储管理"><a href="#单连续存储管理" class="headerlink" title="单连续存储管理"></a>单连续存储管理</h3><p>单一连续分配是一种简单的存储分配方案，主要用于单用户单任务操作系统。</p><ul><li><p>1.内存分配与回收：一道用户程序独占用户区，如图所示</p><p><img src="https://api2.mubu.com/v3/document_image/4bf2f77b-a7b7-4203-a4c9-858f2cfaa34f-7976057.jpg" alt="img"></p></li><li><p>2.地址映射：物理地址&#x3D;用户区基地址+逻辑地址。</p></li><li><p>3.内存保护：通过基址寄存器保证用户程序不会从系统区开始；另外系统需要一个界限寄存器，里边存储程序逻辑地址范围，若需要进行映射的逻辑地址超过了界限寄存器中的值，则产生一个越界中断信号送CPU。</p></li><li><p>4.单一连续分配方案的优缺点</p><ul><li><p>优点：方法简单，易于实现；</p></li><li><p>缺点：它仅适用于单道程序，因而不能使处理机和内存得到充分利用。</p></li></ul></li></ul><h3 id="固定分区存储管理"><a href="#固定分区存储管理" class="headerlink" title="固定分区存储管理"></a>固定分区存储管理</h3><p>分区存储管理是把主存储器中的用户区分成若干个连续区进行管理，每个连续区中可装入一个作业。</p><p>1.分区划分方法：把主存中可分配的用户区域预先划分成若干个连续的分区，每个连续区的大小可以相同，也可以不同。但是，一旦划分好分区之后，主存中分区的个数就固定了，且每个分区的大小也固定不变。</p><img src="https://api2.mubu.com/v3/document_image/cb137b62-44ad-4b6d-9ab2-b919c65160d5-7976057.jpg" alt="img" style="zoom:80%;" /><p>2.主存分配表：由于主存中有多个分区，为了管理主存空间的使用，必须设置一张“主存分配表”</p><img src="https://api2.mubu.com/v3/document_image/fd468b69-2175-4b94-9b36-a3936cd3b20e-7976057.jpg" alt="img" style="zoom:80%;" /><p>3.主存空间的分配与释放：主存分配表中应指出各分区的起始地址和长度，并为每个分区设一个标志位。当标志位为“0”时，表示对应的分区是空闲分区，当标志位为非“0”时，表示对应的分区已被某作业占用。</p><img src="https://api2.mubu.com/v3/document_image/71b31aeb-c091-410d-8475-5728a514919f-7976057.jpg" alt="img" style="zoom:80%;" /><ul><li><p>等待进入主存的作业排成一个作业队列。当主存中有空闲的分区时，依次从作业队列中选择一个能装入该分区的作业。当所有的分区都已装有作业，则其他的作业暂时不能再装入，绝对不允许在同一分区中同时装入两个或两个以上的作业。</p></li><li><p>当作业队列中有作业要装入主存时，存储管理可采用“顺序分配算法”进行主存空间的分配。</p></li></ul><p>4.地址转换：固定分区管理方式下作业的地址转换常采用静态重定位技术。物理地址&#x3D;分区始址+逻辑地址</p><p>5.存储保护 ：常采用“界限寄存器对”法。</p><p>6.固定分区的缺点：碎片大，存在小分区占用大作业的情况。不利于提高内存资源的利用率 。可调入的作业大小受分区大小的严格限制。  </p><h3 id="可变分区存储管理"><a href="#可变分区存储管理" class="headerlink" title="可变分区存储管理"></a><font color="red"><strong>可变分区存储管理</strong></font></h3><p>根据进程的实际需求动态地划分内存的分区方法。它是在进程装入和处理过程中建立分区，并要使分区的容量能正好适应进程的大小。而整个内存分区数目随着进程数目的变化而动态改变，各个分区的大小随着各个进程的大小各有不同，所以称之为动态分区分配。</p><h4 id="1-动态分区中的数据结构"><a href="#1-动态分区中的数据结构" class="headerlink" title="1. 动态分区中的数据结构"></a>1. 动态分区中的数据结构</h4><p>动态分区也可以采用表格的形式来管理内存空间。可用一张已分区表来表示被分配出去的分区，用一张空闲分区（未分区）表来表示空闲分区（为了节省内存空间，系统中的空闲分区也可采用空闲区链表的方法来管理，空闲区链表不占用额外的存储空间）</p><img src="https://api2.mubu.com/v3/document_image/4ea9c7f6-5339-492a-8b3f-bdde8bb9497c-7976057.jpg" alt="img" style="zoom:80%;" /><h4 id="2-动态分区分配算法"><a href="#2-动态分区分配算法" class="headerlink" title="2. 动态分区分配算法"></a><strong>2. 动态分区分配算法</strong></h4><p>1、首次适应算法（FF, First Fit）</p><ul><li><p>空闲分区链或空闲分区表以地址递增的顺序链接，分配时从链首开始查找，找到第一个大小可以满足的分区为止</p></li><li><p>采用这种方法时，每次分配都需要从链首也就是低地址开始查找，所以低地址由于被划分的可能性比较大，容易形成多个过小分区而难以利用，成为外部碎片（前面所描述的在每个分区内的“碎片”相应称为内部碎片）同时这些小分区增加了查寻时的判断时间，降低了效率。</p></li></ul><p>2、循环首次适应算法</p><ul><li><p>为了改变首次适应算法每次从链首开始查寻造成的缺陷，可以增加一个起始查寻指针，指向下一次开始查寻时的起始分区，在查寻过程中，该指针向后移动，当移动到最后一个空闲分区后，重新回到链首。找到适当分区后，按首次适应算法的划分分区方式进行。</p></li><li><p>首次适应算法实现比较简单直接，易于释放时合并相邻空间分区。比较容易的满足大作业的需要。完成一次分配平均需要的搜索次数较大，影响了工作效率。</p></li></ul><p>3、最佳适应算法</p><ul><li><p>搜索整个空闲区以找出满足进程要求的最小空闲区。</p></li><li><p>空闲分区链按照分区容量递增的方式形成，分配时从链首开始查找，这样找到的第一个大小可以满足的分区肯定是与进程申请空间大小最接近，甚至是完全吻合的分区，而且平均查找次数为分区数的一半，也就是说它是“最佳适应”的。</p></li><li><p>尽可能的保留了较大的空间。产生大量的不易被使用的很小的空闲区。该算法不一定是最佳的。</p></li></ul><p>4、最差适应算法</p><ul><li><p>总是搜索整个链表以找到够用的最大的空闲区，使分裂出来的小空闲区比较大，因而可以继续使用</p></li><li><p>因此空闲分区链按照分区容量递减的方式形成，分配时从链首开始，若链首分区大小不满足，则可以肯定不存在能够满足要求的分区；否则对链首分区进行划分，剩余空间成为“碎片”的可能性肯定是最小的。</p></li><li><p>最差适应算法具有查找速度快，分区碎片少，分割后产生的空闲区一般仍可以供以后分配使用。但是工作一段时间后，不能满足大作业对空闲区的请求。</p></li></ul><p>在这几种分配算法中，一般情况下，首次适应算法是最简单，而且是最快和最好的算法。循环首次适应算法比首次适应算法稍差一些，而最佳适应算法虽然名字中有“最佳”，但实际上是性能最差的。但在某些应用情况下，上述比较结果会有所变化。</p><h4 id="3-动态分区的回收"><a href="#3-动态分区的回收" class="headerlink" title="3.动态分区的回收"></a>3.动态分区的回收</h4><p>回收内存空间，关键是修改两个表。</p><img src="https://api2.mubu.com/v3/document_image/f1936a64-40a6-421b-961b-2732a2d7c8e0-7976057.jpg" alt="img" style="zoom:80%;" /><h4 id="4-动态重定位分区分配"><a href="#4-动态重定位分区分配" class="headerlink" title="4.动态重定位分区分配"></a>4.动态重定位分区分配</h4><p>在动态分区分配中，消除了固定分区管理造成的“内碎片”，但是不可避免的在内存空间造成“外碎片”。多个无法利用的小分区所形成的“碎片”是一种很大的资源浪费。</p><p>为了解决类似问题，可以采用一种称为“紧凑”的方法，通过移动程序将原来分散的空闲小分区拼接为一个大的分区，就可以使某些比较大的进程进入。</p><p>经过紧缩后的进程在内存中的位置发生了变化，若不对程序和数据的地址进行修改，在进程就无法运行。要使其运行，必须采用“动态重定位”进行地址变换，于是称这种方案为动态重定位分区分配。</p><h4 id="5-分区分配方案的评价"><a href="#5-分区分配方案的评价" class="headerlink" title="5.分区分配方案的评价"></a>5.分区分配方案的评价</h4><p>在分区分配方案中，地址映射都遵循“物理地址&#x3D;分区始地址+逻辑地址”，固定分区分配与动态分区分配的分区始地址都来自于硬件“基址寄存器”，动态重定位分区分配的分区始地址来自于“重定位寄存器”。</p><p>优点</p><ul><li><p>(1) 多道程序下的内存共享，改善了系统吞吐量，在内存利用率方面，从固定式分区到动态分区，再到动态重定位分区依次提高。</p></li><li><p>(2) 相对于后面介绍的存储管理方式，为实现分区分配所使用的数据结构占用的存储容量相对较少，算法也相对简单。</p></li><li><p>(3) 实现存储保护的措施也比较简单。</p></li></ul><p>缺点</p><ul><li><p>(1)内存仍不能充分利用，除了动态重定位式分区法外，都存在着严重的碎片问题。</p></li><li><p>(2) 不能实现对内存的扩充，因此进程的大小受到内存可用空间的限制。</p></li><li><p>(3)与单一连续分配一样，要求一个进程在执行之前必须全部装入内存，因此在内存中可能包含不会被使用的信息。</p></li><li><p>(4) “紧凑”提高了内存利用率，但是进程移动所产生的额外开销增加了CPU的负担。</p></li><li><p>(5)几个并行进程之间不能共享存入内存的单一信息副本(如公用子程序、数据段等)。</p></li></ul><h3 id="连续分配中内存扩充技术"><a href="#连续分配中内存扩充技术" class="headerlink" title="连续分配中内存扩充技术"></a>连续分配中内存扩充技术</h3><h4 id="1-覆盖（overlay技术）"><a href="#1-覆盖（overlay技术）" class="headerlink" title="1.覆盖（overlay技术）"></a>1.覆盖（overlay技术）</h4><p>所谓覆盖，是指同一主存区可以被不同的程序段重复使用。让那些不会同时执行的程序段共用同一个主存区。</p><p>覆盖区长度由相应覆盖段中最大程序段的长度确定。处理过程是先把常驻内存部分调入，然后将首先需要的可覆盖程序段由辅存调入，随着进程执行，再将其它存放在辅存的覆盖部分陆续调入。</p><p>覆盖的基本原理可用图例说明。图中A、B是同一层不同时间执行的程序，可以共用一段主存区；X、M、N是另外的一层不同时间执行的程序，共用另一段主存区；即选择AB中最大的为覆盖区1，XMN中最大的为覆盖区2，再加上常驻内存部分，即为该作业所需内存</p><img src="https://api2.mubu.com/v3/document_image/275a4d89-77af-40f8-ac4b-87173bcedc5e-7976057.jpg" alt="img" style="zoom:67%;" /><p>覆盖技术的主要特点是打破了必须将一个作业的全部信息装入主存后才能运行的限制。在一定程度上解决了小主存运行大作业的矛盾。</p><p>缺点：(1)用户难以预知他的程序的覆盖情况。(2)用户只能有效地利用自己程序所占用的内存。(3)各进程占用的分区仍会存在碎片。</p><h4 id="2-交换（swapping）技术"><a href="#2-交换（swapping）技术" class="headerlink" title="2.交换（swapping）技术"></a>2.交换（swapping）技术</h4><p>所谓交换，就是系统根据需要把主存中暂时不运行的某个(或某些)作业部分或全部移到外存，而把外存中的某个(或某些)作业移到相应的主存区，并使其投入运行。所以，交换技术也叫对换或滚进滚出（roll-in,roll-out）</p><p>被换出到外存的程序只是临时被剥夺了对内存的使用权，过一段时间，还必须换入内存运行。因此，交换是一种用时间换空间的技术。</p><p>它的主要特点是打破了一个程序一旦进入主存便一直运行到结束的限制。</p><p>交换的时机通常在以下情况发生：</p><ul><li><p>①作业的进程用完时间片或等待输入输出；</p></li><li><p>②作业要求扩充存贮而得不到满足时。</p></li></ul><p>采用对换技术可以很好地提高内存的利用率和CPU的处理效率。同覆盖技术一样，交换技术也是利用外存来逻辑地扩充主存。</p><h2 id="4-3-离散分配存储管理"><a href="#4-3-离散分配存储管理" class="headerlink" title="4.3  离散分配存储管理"></a><font color="red"><strong>4.3  离散分配存储管理</strong></font></h2><h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><h4 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h4><p>以一个例子说明：假设一个酒店，所有的客房都是标准的双人间，部分客房已经住进客人，现在又有一个旅游团要求入住。接待员统计了一下，对旅游团领队说：“贵团全体成员都能住下，两人一个房间，但是不能住在同一楼层了，因为每层空着的客房不够，更没有几个挨着的。请原谅！”。对于这样的安排，一般人不会感到奇怪。因为旅游团本来就是由一位位个人或夫妻等组成的，而饭店的客房本来也是两人一间的，两人一组正好可住在一个客房里；另外，饭店几乎每天都有入住的和退房的客人，想在同一楼层找几间挨着的客房实在不容易。</p><ul><li><p>①将整个系统的内存空间划分成一系列大小相等的块，每一块称为一个物理块、物理页或实页，页架或页帧（frame），可简称为块（block）。所有的块按物理地址递增顺序连续编号为0、1、2、……。</p></li><li><p>②每个作业的地址空间也划分成一系列与内存块一样大小的块，每一块称为一个逻辑页或虚页，也有人叫页面，可简称为页（page）。所有的页按照逻辑地址递增顺序连续编号为0、1、2、……。</p></li></ul><p>这里的块相当于饭店的客房，系统对内存分块相当于饭店把大楼所有的客房都设计成标准的双人间。这里，对作业地址空间分页就相当于把旅游团成员分成两人一组。 </p><ul><li><p>③一个作业，只要它的总页数不大于内存中的可用块数，系统就可以对它实施分配。系统装入作业时，以页为单位分配内存，一页分配一个块，作业所有的页所占的块可以不连续。系统同时为这个作业建立一个页号与块号的对照表，称为页表。 </p></li><li><p>④每个块的大小是固定的，一般是个1&#x2F;2KB～4KB之间的数值，而且必须是2的幂次方。</p></li></ul><p>这好象饭店有个记录客户入住情况的客户登记表一样。另外，饭店安排客户入住是要查看全部客房的使用情况一览表，相应地系统给作业分配内存时要查看主存分配表或者内存块说明表。对块尺寸这样规定相当于饭店规定客房是双人间。</p><h4 id="2-地址结构及页面大小设置"><a href="#2-地址结构及页面大小设置" class="headerlink" title="2.地址结构及页面大小设置"></a>2.地址结构及页面大小设置</h4><p>前一部分为页号 P，后一部分为位移量 W(或称为页内地址)。其中 0～11 位为页内地址，即每页的大小为 4 KB；12～31 位为页号，地址空间最多允许有 1 M 页。</p><img src="https://api2.mubu.com/v3/document_image/620a70a1-7966-473c-9b93-53e11b33ec19-7976057.jpg" alt="img" style="zoom:80%;" /><p>若给定某一个逻辑地址（或相对地址），通过下面式子可以得出页号和页内偏移量：页号&#x3D;逻辑地址 DIV 页面大小；页内偏移量&#x3D;逻辑地址 MOD 页面大小。</p><p>例如页面大小为4 KB的系统中，若逻辑地址为28024。由上式求得28024 div 4096&#x3D;6（页号）；28024 mod 4096&#x3D;3448（页内偏移量）</p><p>过小会造成页面过多，页表过长，页表又会占用较大的内存空间，而且在虚拟存储中增加了页面换入换出次数，增加了系统开销；过大又会造成页内碎片太大，内存利用率不高。</p><h4 id="3-页表与地址映射"><a href="#3-页表与地址映射" class="headerlink" title="3.页表与地址映射"></a>3.页表与地址映射</h4><p>在分页系统中，允许将作业（进程）的任一页装入到内存中的任一可用的物理块中，但系统应保证作业仍能正确运行，即能在内存中找到每个页面对应的物理块。系统就要记录用户程序的逻辑页与内存物理块之间的对应关系，这通过为每个应用程序建立一张页面映射表来实现，简称页表。</p><p>地址变换机构的任务实际上只是将逻辑地址中的页号，转换为内存中的物理块号。又因为页面映射表的作用就是用于实现从页号到物理块号的变换，因此，地址变换任务是借助于页表来完成的。</p><img src="https://api2.mubu.com/v3/document_image/a5eb1038-8b54-4716-bf51-8483355f888a-7976057.jpg" alt="img" style="zoom:67%;" /><p>在系统中只设置一个页表寄存器 PTR(Page-Table Register)，在其中存放页表在内存的始址和页表的长度。平时，进程未执行时，页表的始址和页表长度存放在本进程的 PCB 中。当调度程序调度到某进程时，才将这两个数据装入页表寄存器中。</p><p>【地址变换过程】：当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址(相对地址)分为页号和页内地址两部分，再以页号为索引去检索页表。查找操作由硬件执行。在执行检索之前，先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间。于是，这一错误将被系统发现并产生一地址越界中断。若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号，将之装入物理地址寄存器中。与此同时，再将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中。这样便完成了从逻辑地址到物理地址的变换。</p><img src="https://api2.mubu.com/v3/document_image/7c7cb718-0a10-40b3-b0ff-f6eb872a3246-7976057.jpg" alt="img" style="zoom:80%;" /><h4 id="4-内存的分配与回收"><a href="#4-内存的分配与回收" class="headerlink" title="4.内存的分配与回收"></a>4.内存的分配与回收</h4><p>在页式存储方式中，由于内存块等长，故常用三种方式记录内存物理页面空闲情况。</p><ul><li><p>⑴ 位示图 用一个二进制位（bit）表示内存中一个物理页面的状态。规定其值为0时，表示该物理块空闲；其值为1时，表示该块被占用。</p></li><li><p>⑵ 空闲页面表 系统将连续的若干空闲页面作为一组登记在空闲页面表中</p></li><li><p>⑶ 空闲页面链表 将所有空闲页面组成一个链表，每一个空闲页面设有指向下一个页面的指针，系统保留空闲链表的头指针。</p></li></ul><h4 id="5-快表"><a href="#5-快表" class="headerlink" title="5.快表"></a>5.快表</h4><p>因为页表是存放在内存中的，故CPU要存取一个数据，需访问主存两次。首先访内存中的页表，找到该页的的物理块号，将此块号与页内地址拼结形成物理地址；其次真正访问该物理地址，存取其中的内容。因而程序的执行速度降低了一倍。</p><p>为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”(Associative Memory)，或称为“快表”</p><p>【地址变换过程】：在 CPU 给出有效地址后，由地址变换机构自动地将页号 P 送入高速缓冲寄存器，并将此页号与高速缓存中的所有页号进行比较，若其中有与此相匹配的页号，便表示所要访问的页表项在快表中。于是，可直接从快表中读出该页所对应的物理块号，并送到物理地址寄存器中。如在块表中未找到对应的页表项，则还须再访问内存中的页表，找到后，把从页表项中读出的物理块号送地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中，亦即，重新修改快表。但如果联想寄存器已满，则 OS 必须找到一个老的且已被认为不再需要的页表项，将它换出。</p><img src="https://api2.mubu.com/v3/document_image/c0e24e67-46b9-4aaa-94be-d94f4f251aae-7976057.jpg" alt="img" style="zoom:80%;" /><p>二级页表&amp;多级页表</p><h4 id="页式存储的缺点"><a href="#页式存储的缺点" class="headerlink" title="页式存储的缺点"></a>页式存储的缺点</h4><ul><li><p>(1)采用动态地址映射会增加计算机成本和降低处理机的速度。</p></li><li><p>(2)各种表格要占用一定容量的内存空间，而且还要花费一部分处理机时间来建立和管理这些表格。</p></li><li><p>(3) 虽然消除了大量碎片，但每个作业的最后一页一般都有不能充分利用的空白区。</p></li><li><p>(4) 存储扩充问题仍未得到解决。当没有足够空间能装下整个作业地址空间时，该作业还是无法运行。</p></li></ul><h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><h4 id="1-分段原理"><a href="#1-分段原理" class="headerlink" title="1.分段原理"></a>1.分段原理</h4><p>一个用户作业的程序按其逻辑结构可划分为若干段，例如主程序段、子程序段、数据段、堆栈段等。这些段中的每一段在逻辑上都是完整的，因此每一段都是一组逻辑信息，有自己的名字，且都有一段连续的地址空间。这样的分段组织便于实现段共享和保护，便于实现动态链接和数据动态增长。</p><p>当一个用户程序装入内存时，系统为每个段分配一个连续的内存区域，而各个段之间可以离散存放。如果用户程序只含有一个段，则段式存储就退化为可变分区方式了。</p><p>在分段式存储管理中，段名用段号代替，段地址从0开始编址，因为各段的逻辑信息内容不同，所以段长度不同。这样用段号和段内地址构成一个如图所示的二维地址空间。它表示程序最多为256段，段最大长度为64 KB。</p><img src="https://api2.mubu.com/v3/document_image/15f31284-67cb-48c4-a708-45035ca3c2f6-7976057.jpg" alt="img" style="zoom:80%;" /><p>为了记录用户程序与内存之间的对应关系，系统为每个用户程序建立一张段表。同时系统中还要设立一张内存空闲区表，以记录内存中空闲区的使用情况，用于为段分配和回收内存。</p><img src="https://api2.mubu.com/v3/document_image/fd09a5fc-2a25-4326-ab7f-6191e492acb4-7976057.jpg" alt="img" style="zoom:80%;" /><h4 id="2-地址变换"><a href="#2-地址变换" class="headerlink" title="2.地址变换"></a>2.地址变换</h4><p>系统提供一对寄存器：段表始址寄存器和段表长度寄存器。用于存放当前进程的段表起始地址和段表长度。</p><p>对于每一条用户指令或数据的访问，要根据段号访问段表。先判断段号是否超出段表长，若超出既为越界交给操作系统处理；否则将段号与段表项长度相乘再加上段表起始地址得到该段在段表中的位置，查段表得到该段在内存的首地址。然后判断段内地址是否大于段长，若大于则产生越界中断交由操作系统处理，否则将段内地址加到该段在内存的首地址上，就得到了该指令或数据的物理地址。</p><p>段表存放在内存中。为了加快地址映射，亦可以采用快表技术。为此，系统设置一组联想寄存器（相联存储器），用于存放正在运行进程段表的一部分。</p><p>分段存储管理的地址变换机构和工作流程（给定逻辑地址中段号为3，段内地址为723）：① 段号3与段表寄存器存放的段表长度比较以判断是否越界，如果越界，则转错误中断处理，否则转②；②计算：段表始地址+段号×段表项长度，得到段表中3号段这一项在内存中的地址，访问该地址得到对应段基址为8K；③8 K(段基址)+723(段内地址)&#x3D;8915(物理地址)；④ 访问内存8915单元，得到需要的数据365。</p><img src="https://api2.mubu.com/v3/document_image/c167443e-bced-42b3-aba3-2b2e20187353-7976057.jpg" alt="img" style="zoom:80%;" /><h4 id="3-页式与段式的比较"><a href="#3-页式与段式的比较" class="headerlink" title="3.页式与段式的比较"></a>3.页式与段式的比较</h4><p>二者均采用离散存储方式，通过页表或段表进行地址转换，为了加快查找，均设置了快表。</p><ul><li>(1)页是信息的物理单位，分页是系统的行为，是系统为了对内存进行规范管理而采取的措施。而分段是信息的逻辑单位，是为了满足用户的需要而设置的；</li><li>(2)在页式存储系统中，作业的地址空间是一维的线性地址空间，而在段式存储系统中，作业的地址空间是二维的；</li><li>(3)页的大小是固定的。而段长是不定的。</li></ul><h4 id="4-段的共享与保护"><a href="#4-段的共享与保护" class="headerlink" title="4.段的共享与保护"></a>4.段的共享与保护</h4><p>在多道程序环境下，许多应用程序、子程序是可被多个用户所使用的。随着多窗口及各种工具软件的流行，被共用的程序和数据都在急剧增长。如果用户对每一个所使用的程序和数据都保留副本的话，那么空间的浪费太大。若在内存中只保留一个副本，就可供多个用户使用，称这种技术为共享技术。</p><p>段式存储管理可以方便地实现内存信息的共享并进行有效的内存保护。这是因为段是按逻辑意义来划分的，可以按段名访问的缘故。如果多个用户进程或作业需要共享某段程序或数据，可以使用不同的段名，在各自的段表中填入己在内存中的共享段的起始地址、并设置适当的读写控制权，就可以做到共享一个内存段的信息。</p><p>在多道程序的情况下，为了保证段的共享并使程序顺利执行，必须对段的访问进行检查：</p><ul><li><p>⑴利用段表及段长来实现段的保护，防止程序执行时地址越界。</p></li><li><p>⑵存取权限保护法  通过在段表中设置“存取权限”一项，可防止对该段的非法访问。</p></li><li><p>⑶存储保护键法  通过对内存块设置保护键，来防止对该内存的非法访问。</p></li></ul><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p>分段和分页存储管理方式都各有优缺点，分段能很好地满足用户的需要，易于实现共享、保护、及动态连接，但其内存管理碎片很多，影响了系统的效率。而页式存储中，内存划分规整，易于管理。因此人们想到将二者结合起来，取长补短，于是就有了段页式存储管理方式 </p><p>在段页式存储管理中，先将用户作业分成若干个段，每个段都有一个段名，再将每个段划分为若干页，再将页离散地装入到内存的块中。在这种方式下，内存空间是采用页式存储，但对于用户来说，作业是分段管理的。因此系统要将用户眼中的段式存储转换成内存所需要的页式存储，这种转换是通过段表和页表实现的。此时的逻辑地址结构是由段号、页号、及页内地址三部分组成的，若32位的地址结构采用下面的设置：</p><img src="https://api2.mubu.com/v3/document_image/af6960c5-4136-4dde-90ce-bfe2c5ccae63-7976057.jpg" alt="img" style="zoom:80%;" /><p>表示页长为4k(2^12)，作业最多可有1k个段，每段最多有1k个页，即段长最大为4M，作业最大可以达到4G。由于每个段都要分页存储，因此要为每个段设置一个页表，段表和页表的关系如下图所示。</p><img src="https://api2.mubu.com/v3/document_image/22d032e3-df32-4e3c-864e-eb3ab5bd30e0-7976057.jpg" alt="img" style="zoom:80%;" /><h2 id="4-4-内核主存管理"><a href="#4-4-内核主存管理" class="headerlink" title="4.4  内核主存管理"></a>4.4  内核主存管理</h2><p>操作系统除了需要为内核代码和静态数据结构预留空间外，内核在运行时还需要临时的主存块。如路径名分析进程要求分配缓冲区以复制路径名副本，进程通信要请求缓冲区，进程控制要求进程控制块、线程控制块、信号量、I节点、文件控制块等等。这些小内存的使用是动态请求和释放的，故内核也需要存储管理。  </p><p>内核中请求使用的主存空间通常较小，需要专门的存储方法来为内核提供各种尺寸的主存块。如2次幂空闲表分配器，伙伴算法，延迟伙伴算法等。通常系统会为内核存储管理预留一部分专用的存储空间，也可以向用户存储管理借用存储空间，或者双向借用。 </p><p>4.4.1 二次幂空闲表存储管理</p><p>4.4.2 伙伴算法</p><h2 id="4-5-虚拟存储技术"><a href="#4-5-虚拟存储技术" class="headerlink" title="4.5  虚拟存储技术"></a>4.5  虚拟存储技术</h2><p>这是一种利用虚拟存储器来逻辑扩充物理内存的技术。其基本思想是用软硬件技术把内存与外存这两级存储器当成一级存储器来用，从而给用户提供了一个比内存也比任何应用程序大得多的虚拟存储器，使得用户编程时再也不用考虑内存大小的限制了，给用户编程带来极大的方便。</p><p>虚拟内存技术的实现也利用了自动覆盖和交换技术。</p><h3 id="4-5-1-程序局部性原理"><a href="#4-5-1-程序局部性原理" class="headerlink" title="4.5.1 程序局部性原理"></a>4.5.1 程序局部性原理</h3><p><strong>1.局部性原理(principleof locality)：指程序在执行过程中的一个较短时期内，所执行的指令地址和指令的操作数地址，分别局限于一定区域。</strong></p><p>2.局部性主要表现：</p><ul><li>时间局部性：是指一段指令在某一时间段内会被反复执行。即程序某一部分的数据或指令被重复性地访问，它们对应于程序结构中的循环、子程序、常用到的变量及数据等；</li><li>空间局部性：是指一旦某一个存储单元被访问，那么它附近的单元也将很快被访问。这对应于程序结构中的顺序执行的指令、线性数据结构以及在相邻位置存放的数据或变量等。而程序中的分支和调用子程序只是将程序的访问空间从一处移到另外一处，仍具有局部性。</li><li>排他性：程序运行不但体现在时间、空间的局部性，还体现在某些程序段执行的排他性。</li></ul><p>综上所述：程序只要装入内存一部分就可以运行，当用到不在内存的部分时，再将其装入内存。换句话就是说程序全部装入内存并不是程序运行的必要条件。</p><h3 id="4-5-2-虚拟存储的实现"><a href="#4-5-2-虚拟存储的实现" class="headerlink" title="4.5.2 虚拟存储的实现"></a>4.5.2 虚拟存储的实现</h3><p>1、虚拟存储技术：如果把程序部分装入内存，其余大部分放在外存，而程序又能运行，这样我们就拥有了一个比有限的实际内存空间大得多的、逻辑的虚拟内存空间。即用大容量的外存来模拟内存，这种存储模式就称之为虚拟存储技术。</p><p>2、虚拟技术实现的关键</p><ul><li><p>(1)怎样才能发现欲执行的指令或数据不在内存：简单有效方法就是进行标识</p></li><li><p>(2)怎样将不在内存的部分调入进来：通常系统采用中断技术完成调入工作。</p></li><li><p>(3)在内存中的作业如何组织：一个进程可被分为多次调入内存，这样很难保证进程在内存中占据一个连续的空间，实际上进程在内存中是离散存储的。</p></li><li><p>虚拟存储技术是将内存与外存有机地结合在一起，从而得到一个容量很大的虚拟空间。使用户感到有一个很大的内存，不用再考虑内存的容量限制。</p></li></ul><p>引入虚拟存储技术的好处</p><ul><li>总容量不超过物理内存和外存交换区容量之和。其运行速度接近于内存，每位的成本又接近于外存，是一种性能非常优越的存储管理技术</li></ul><p>虚拟存储技术的特征</p><ul><li><p>不连续性：物理内存分配的不连续，虚拟地址空间使用的不连续（数据段和栈段之间的空闲空间，共享段和动态链接库占用的空间）</p></li><li><p>部分交换：与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的；</p></li><li><p>大空间：通过物理内存和快速外存相结合，提供大范围的虚拟地址空间</p></li></ul><h2 id="4-6-虚拟页式存储管理"><a href="#4-6-虚拟页式存储管理" class="headerlink" title="4.6  虚拟页式存储管理"></a><strong>4.6  虚拟页式存储管理</strong></h2><h3 id="4-6-1-虚拟页式存储的实现"><a href="#4-6-1-虚拟页式存储的实现" class="headerlink" title="4.6.1 虚拟页式存储的实现"></a>4.6.1 虚拟页式存储的实现</h3><h4 id="1-基本原理-1"><a href="#1-基本原理-1" class="headerlink" title="1.基本原理"></a>1.基本原理</h4><p>系统自动地将作业的地址空间分页，将系统的主存空间分块，页与块等大小，在作业运行前，只把初始需要的一部分页面装入内存块里，运行中需要访问自己地址空间中的但当前不在内存的页面时产生缺页中断，由缺页中断服务程序将所需的页面调入内存，若此时内存中没有空闲物理块安置请求调入的新页面，则系统按预定的置换策略自动选择一个或一些在内存的页面，把它们换出到外存。</p><p>这里的请求调入和置换功能都是比实分页存储管理增加的内容，是实现虚拟存储的主要功能。</p><h4 id="页面的动态调度步骤"><a href="#页面的动态调度步骤" class="headerlink" title="页面的动态调度步骤"></a>页面的动态调度步骤</h4><p>1、找到被访问页面在外存的地址；</p><p>2、在内存中找一个空闲页面；</p><ul><li><p>（1）如果没有，按照淘汰算法选择一个内存页面；</p></li><li><p>（2）将此内存页面写回外存，修改页表及页面分配表；</p></li></ul><p>3、读入所需的页面，修改页表及页面分配表；</p><p>4、重新启动进程执行被中断的指令。</p><h4 id="2-页表机制"><a href="#2-页表机制" class="headerlink" title="2.页表机制"></a>2.页表机制</h4><p>标记某页是否在内存，用于查询要访问的页在不在内存。页表如下：</p><img src="https://api2.mubu.com/v3/document_image/b6b3fcba-fd92-4930-b8b1-f4f7932365b7-7976057.jpg" alt="img" style="zoom:80%;" /><h4 id="3-动态地址变换"><a href="#3-动态地址变换" class="headerlink" title="3.动态地址变换"></a>3.动态地址变换</h4><p>在虚拟页式存储中，应采用动态地址变换方式，因为某一欲执行的指令可能不在内存，只能在指令执行之前完成地址变换。任一作业都应在自己的虚拟地址空间中执行，所以要为用户作业设置一个虚拟地址指针VP，虚拟地址依然是由页号和页内偏移地址组成的。</p><p>系统总是执行VP虚指针所指向的指令，为了将虚拟地址VP变换为对应的实存地址，因此先要查找页表。若从页表中查出此页不在内存（状态位为0），则产生一个缺页中断。此时，进程暂停当前指令执行，CPU转去执行缺页中断处理程序。若该页已在内存，则指令的地址映射过程与页式存储是一样的。即将块号和页内地址相并接形成物理地址IP，处理器再从IP中取指令执行。</p><h4 id="4-缺页中断"><a href="#4-缺页中断" class="headerlink" title="4.缺页中断"></a>4.缺页中断</h4><p>缺页中断处理流程</p><img src="https://api2.mubu.com/v3/document_image/25fdf50e-1905-47e2-82e3-516682e00f3d-7976057.jpg" alt="img" style="zoom:80%;" /><h4 id="5-缺页率"><a href="#5-缺页率" class="headerlink" title="5.缺页率"></a>5.缺页率</h4><p>为了标识缺页中断发生的频度，可以引入缺页率来表示。</p><p>设进程在其执行期间共进行了S次访页操作，其中成功访页次数为A（访问时该页在主存），不成功的访页次数为B（即发生了缺页中断），显然有：S&#x3D;A+B，则该进程的缺页率f定义为：f＝B&#x2F;S。显然缺页率越低越好。</p><h3 id="4-6-2-页面分配策略"><a href="#4-6-2-页面分配策略" class="headerlink" title="4.6.2 页面分配策略"></a>4.6.2 页面分配策略</h3><h4 id="1-空闲页面管理"><a href="#1-空闲页面管理" class="headerlink" title="1.空闲页面管理"></a>1.空闲页面管理</h4><p>虚拟存储方式下的空闲页面的管理也可以采用位示图或空闲页面链的形式。</p><p>在实际的系统中，总是维持一定数量的空闲块，而不是耗尽所有的空闲块。即空闲块数可以在某一区间浮动，一旦空闲块数小于下限值，系统就进行页面置换，以释放出一些空闲块，使得总的空闲块数不超过系统规定的上限值即可。即系统设置专门的独立进程负责页面置换，以保证链表的适当规模。</p><h4 id="2-分配策略（内存）"><a href="#2-分配策略（内存）" class="headerlink" title="2 分配策略（内存）"></a>2 分配策略（内存）</h4><p>可变分配：是指一个进程所拥有的物理块数是不定的，这种分配方式称之为可变分配。</p><p>固定分配是指为每个进程分配一固定页数的内存空间，在整个运行期间都不再改变。</p><p>⑴平均分配算法，是将系统中所有可供分配的物理块，平均分配给每一个进程。例如，当系统中有80个空闲块，4个进程时，每个进程可分得20个物理块。这种平均分配方式因其未考虑各进程本身的大小，会造成事实上的不公平。如有一个进程其大小为100页，只分配给它20个块，这样它必将会有很高的缺页率；而另一个进程只有10页，却有10个块在闲置未用。所以在平均的思想下，还要考虑进程的大小。</p><p>⑵按比例分配算法，根据进程的大小按比例分配空闲块。设系统中现有m个进程、n个空闲块，每个进程拥有的页数为Si，则系统中所有进程页数之和为：S &#x3D; S1 + S2 + S3 + …+ Sm。则为每个进程分配的物理块数为：Bi &#x3D; （Si&#x2F; S）×n ，Bi应向下取整。</p><p>⑶优先权分配算法，为优先权高的作业分配较多的内存空间，这样可以使重要或紧迫的任务尽快完成。这时可以将内存中的空闲块分成两部分：一部分按比例分配给各进程，另一部分则根据各进程的优先权，适当地为其增加相应份额。</p><h4 id="2-分配策略（外存）"><a href="#2-分配策略（外存）" class="headerlink" title="2 分配策略（外存）"></a>2 分配策略（外存）</h4><p>1、静态分配：一个进程在运行之前，将其页面全部装入外存。当某一外存页面被调入内存时，并不释放所占用的外存页面。</p><p>2、动态分配：一个进程在运行之前，仅将未装入内存的那部分页面装入外存。当某一外存页面被调入内存时，释放所占用的外存页面。</p><h4 id="3-工作集"><a href="#3-工作集" class="headerlink" title="3.工作集"></a>3.工作集</h4><p>(1)为保证进程能正常运行最少需要多少物理块。</p><p>从理论上讲，进程只要获得一个物理块就可以运行。但是进程正常运行所需的最少物理块数与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。由于分页是系统的行为，系统应保证任一条指令执行时，其所涉及的虚拟地址所在的页都应在内存中。这个页数就是进程所需要的最小块数，若系统为进程所分配的物理块数少于此值时，进程将无法运行。 </p><p>所谓工作集就是进程在某段时间里实际上要访问的页的集合。依据程序执行时的局部特性，可以利用程序过去的行为来估计它未来的行为。故定义运行进程在t－w到t这个时间间隔内所访问的页的集合为该进程在时间t的工作集，记为W（t，w）。并把变量w称之为“工作集窗口尺寸”，工作集中所包含的页面数称为“工作集尺寸”，记为|W(t,w)|。</p><h4 id="4-页面调入时机"><a href="#4-页面调入时机" class="headerlink" title="4.页面调入时机"></a>4.页面调入时机</h4><p>即何时将一个页面由外存调入内存。</p><h5 id="⑴预调页策略"><a href="#⑴预调页策略" class="headerlink" title="⑴预调页策略"></a>⑴预调页策略</h5><ul><li>也称先行调度，即一页面被访问前就已经预先置入内存，以减少今后的缺页率。主要适于进程的许多页存放在外存的连续区域中的情况。有的系统结合请求调入使用，即每次缺页时装入多个页面。</li><li>优点：提高调页的I&#x2F;O效率。</li><li>缺点：基于预测，若调入的页在以后很少被访问，则效率低。预调页的成功率仅约50%，常用于程序装入时的调页。</li></ul><h5 id="⑵-请求调页策略"><a href="#⑵-请求调页策略" class="headerlink" title="⑵ 请求调页策略"></a>⑵ 请求调页策略</h5><ul><li>当发生页面故障时进行调度，即当进程访问不在内存的页面引发缺页中断时，由系统根据这种访问请求把所缺页面装入内存。</li><li>优点：由请求调入策略装入的页一定会被访问，再加之比较容易实现，故在目前的虚拟存储器中，大多采用此策略。</li><li>缺点：每次仅调入一页，增加了磁盘I&#x2F;O的启动频率。</li></ul><h4 id="5-从何处调入页面"><a href="#5-从何处调入页面" class="headerlink" title="5.从何处调入页面"></a>5.从何处调入页面</h4><p>在请求分页系统中，常把外存分为两部分：一部分是文件区，用于存放文件；另一部分是对换区，用于存放对换页面。通常，对换区的磁盘输入输出速度比文件区的高，这是因为对换区所规定的盘块要比文件区的大得多。</p><p>⑴ 从交换区调入</p><ul><li>若系统拥有足够的对换区空间，可在进程运行前，将与该进程有关的文件拷贝到对换区。以后就从对换区调入所需页面，以提高调页速度。</li></ul><p>⑵ 从交换区及文件区调入</p><ul><li>若系统缺少足够的对换区空间，则在交换区中只保存被修改过的页面。因为未被修改的页面在文件区中有副本。因此凡是没被修改的页，均从文件区调入；而已修改过的页面则从交换区调入。</li></ul><h3 id="4-6-3-页面置换方法"><a href="#4-6-3-页面置换方法" class="headerlink" title="4.6.3  页面置换方法"></a>4.6.3  页面置换方法</h3><h4 id="1-页面置换方式"><a href="#1-页面置换方式" class="headerlink" title="(1)页面置换方式"></a>(1)页面置换方式</h4><p>页面淘汰可以在整个内存空间范围内进行，称之为全局置换。也可以只在一个进程空间范围内考虑，称之为局部置换。</p><h4 id="2-空闲块分配方式"><a href="#2-空闲块分配方式" class="headerlink" title="(2) 空闲块分配方式"></a>(2) 空闲块分配方式</h4><p>若为进程分配固定的物理块数，在其执行期间再也不改变，则称为固定分配。</p><p>为进程分配的物理块数在其运行期间是可变的，则称为可变分配。</p><p>在页面置换算法讨论中，为了比较各种方法的优劣，总是限定为固定分配局部置换。</p><h4 id="2-页面置换算法"><a href="#2-页面置换算法" class="headerlink" title="2.页面置换算法"></a><font color="red"><strong>2.页面置换算法</strong></font></h4><h5 id="1-最佳淘汰算法——OPT-Optimal"><a href="#1-最佳淘汰算法——OPT-Optimal" class="headerlink" title="(1)最佳淘汰算法——OPT(Optimal)"></a>(1)最佳淘汰算法——OPT(Optimal)</h5><p>该算法每次都淘汰以后永不使用的，或者过最长的时间后才会被访问的页面。显然，采用这种算法会保证最低的缺页率，但它是无法实现的，因为它必须知道页面“将来”的访问情况。不过，该算法仍有一定意义，可作为衡量其他算法优劣的一个标准。 </p><p>OPT置换算法示例</p><img src="https://api2.mubu.com/v3/document_image/36958961-7f49-4a80-81d1-3cedc46dd7ee-7976057.jpg" alt="img" style="zoom:80%;" /><h5 id="2-先进先出淘汰算法——FIFO"><a href="#2-先进先出淘汰算法——FIFO" class="headerlink" title="(2)先进先出淘汰算法——FIFO"></a>(2)先进先出淘汰算法——FIFO</h5><p>总是淘汰最先进入内存的页面。它实现简单，只需把进程中已调入内存的页面，按先后次序链成一个队列，并设置一个所谓的替换指针，使它总是指向内存中最老的页面。</p><p>缺点：效率不高，因为它与进程实际的运行规律不相适应，比如常用的全局变量所在的页面或者循环体所在页面都可能被它选为淘汰对象。出现belady现象。</p><ul><li><p>Belady现象：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多，缺页率反而提高的异常现象。</p></li><li><p>Belady现象的描述：一个进程P要访问M个页，OS分配N个内存页面给进程P；对一个访问序列S，发生缺页次数为PE（S,N）。当N增大时，PE(S,N)时而增大，时而减小。</p></li><li><p>Belady现象的原因：FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，即被置换的页面并不是进程不会访问的。</p></li></ul><p>FIFO淘汰算法示例</p><img src="https://api2.mubu.com/v3/document_image/0734bfab-8aa8-4e10-871e-c4aa74f5975e-7976057.jpg" alt="img" style="zoom:80%;" /><h5 id="3-最近最久未使用算法-LRU-Least-Recently-Used）"><a href="#3-最近最久未使用算法-LRU-Least-Recently-Used）" class="headerlink" title="(3)最近最久未使用算法(LRU, Least Recently Used）"></a>(3)最近最久未使用算法(LRU, Least Recently Used）</h5><p>【算法描述】根据页面调入内存后的使用情况，选择内存中最近最久未使用的页面被置换。这是局部性原理的合理近似，性能接近最佳算法。OPT算法使用页面将要被访问的时间，LRU算法使用页面最后一次被访问的时间。二者唯一的差别是：OPT是向后看的，而LRU是向前看的。 </p><p>【算法示例】</p><img src="https://api2.mubu.com/v3/document_image/0baca92f-bffc-46b9-beb3-0f8aac04acda-7976057.jpg" alt="img" style="zoom:80%;" /><p>【实现方法(硬件支持)】</p><ul><li>①计时法：对于每一页面增设一个访问时间计时器，每当一个页面被访问时，就将当时的绝对时钟拷贝到对应的访问时间计时器中，这样系统记录了内存中所有页面最后一次被访问的时间。淘汰时，选取访问时间计时器的值最小的页面。</li><li>②堆栈法：每当进程访问某页面时，便将该页面的页号从栈中移出，将它压入栈顶。栈顶始终是最新被访问的页面的编号。栈底则是最近最久未被使用的页面的页面号。</li></ul><h5 id="4-二次机会淘汰算法—SC-Second-Chance"><a href="#4-二次机会淘汰算法—SC-Second-Chance" class="headerlink" title="(4)二次机会淘汰算法—SC(Second Chance)"></a>(4)二次机会淘汰算法—SC(Second Chance)</h5><p>这是一种LRU的近似算法，是通过对FIFO算法进行简单改造，结合页表中的访问位而得来一种淘汰算法。</p><p>该算法首先检查位于FIFO链链首的页，如果它的访问位为0，则选择该页淘汰；如果它的访问位为1，则清除其访问位，将它移至FIFO链的链尾，重复此算法的查找过程，直至遇到新链首页是一个访问位为0的较早进入内存的页为止，把它选为被淘汰的页。</p><h5 id="5-时钟-Clock-淘汰算法"><a href="#5-时钟-Clock-淘汰算法" class="headerlink" title="(5)时钟(Clock)淘汰算法"></a>(5)时钟(Clock)淘汰算法</h5><p>SC算法的缺点就是需要把访问位为1的处于链首的页移至链尾，这需要一定的开销。一种改进的方法就是把进程所访问的页面链成一个环形链表，再设一个指针指向最老的页面，于是形成了一种简单实用的LRU近似算法——时钟淘汰算法。</p><p>该算法首先检测指针所指的页面，如果它的访问位为0，则淘汰该页，新装入的页插入到此位置，然后指针前进一个位置；如果它的访问位为1，则清除为0，并将指针前进一个位置，继续检查访问位。重复此过程，直到找到访问位为0的页面为止。</p><h5 id="6-最近未用淘汰算法—NUR-Not-Used-Recently"><a href="#6-最近未用淘汰算法—NUR-Not-Used-Recently" class="headerlink" title="(6)最近未用淘汰算法—NUR(Not Used Recently)"></a>(6)最近未用淘汰算法—NUR(Not Used Recently)</h5><p>它把FIFO算法的思想与页面的访问位和修改位结合起来确定一个接近LRU算法的淘汰对象。</p><p>该算法每次都尽量选择最近最久未被写过的页面淘汰，这种干净的页面可以不被写回到磁盘。在实现时，为每一个页面设置初始值为0的访问位和修改位。当对某页面执行写操作时，其修改位和访问位均由硬件置成1；当对某页面执行读操作时，只有其访问位被硬件置成1。</p><img src="https://api2.mubu.com/v3/document_image/36f86661-edf8-4591-9110-72d683d0288e-7976057.jpg" alt="img" style="zoom:80%;" /><h4 id="3-影响缺页中断率的因素"><a href="#3-影响缺页中断率的因素" class="headerlink" title="3.影响缺页中断率的因素"></a>3.影响缺页中断率的因素</h4><ul><li>(1)分配给作业的内存块数 </li><li>(2)页面大小的选择</li><li>(3)用户程序编制的方法 </li><li>(4)页面调度算法</li></ul><p>抖动又叫颠簸，是指一段时间里，页面在内存与外存之间频繁地调度或换入换出，以至于系统用于调度页面所需要的时间比进程实际运行所占用的时间还要多。显然，抖动是由于缺页中断率很高而引起的一种坏现象，它将严重影响系统的效率，甚至可能使系统全面崩溃。 </p><p>防止抖动现象的产生和扩展，具体方法</p><ul><li><p>⑴采取局部置换策略</p><ul><li>这样，即使有某个进程发生了“抖动”，也不致引起其它进程也产生抖动，从而把抖动局限于较小的范围内。这种方法并不很好，因为它不能从根本上防止抖动的发生；而且在某进程发生抖动后，还会长期地处于磁盘输入输出的等待队列中，这又会使其它进程缺页中断的处理时间增长，从而延长了等效的访问时间。</li></ul></li><li><p>⑵ L&#x3D;S准则</p><ul><li>Denning于1980年提出了“L&#x3D;S准则”，用来调整多道程序度，以使产生缺页的平均时间L等于系统处理进程缺页的平均时间S。理论和实践表明，此时的CPU利用得最好。该准则也得到其它研究人员的证实。</li></ul></li><li><p>⑶挂起若干进程</p><ul><li>当多道程序度偏高时，为了防止发生“抖动”，可用的一个简单易行的办法是挂起一些进程，以便腾出内存空间来分配给抖动的进程。被挂起的进程通常是选择优先权最低或较低的；当内存非常拥挤时，也可以选择一个并不很重要的、但确较大的进程挂起，以便能一次释放出较大的内存空间；或者是将具有最多剩余执行时间的进程挂起。</li></ul></li></ul><h3 id="4-6-4-虚拟页式存储的优缺点"><a href="#4-6-4-虚拟页式存储的优缺点" class="headerlink" title="4.6.4  虚拟页式存储的优缺点"></a>4.6.4  虚拟页式存储的优缺点</h3><p>1.优点</p><ul><li><p>⑴主存利用率比较高。平均每个用户作业只浪费一半的页空间，内存规范易于管理。</p></li><li><p>⑵对磁盘管理比较容易。因为页的大小一般取磁盘物理块大小的整数倍。</p></li><li><p>⑶地址映射和变换的速度比较快。在把用户程序装入到主存储器的过程中，只要建立用户程序的虚页号与主存储器的实页号之间的对应关系即可（拼接得到物理地址），不必使用整个主存的地址长度，也不必考虑每页的长度等。</p></li></ul><p>2.缺点</p><ul><li>⑴程序的模块化性能不好。<ul><li>由于用户程序是强制按照固定大小的页来划分的，而程序段的实际长度一般是不固定的。因此，虚拟页式存储器中一页通常不能表示一个完整的程序功能。一页可能只是一个程序段中的一部分，也可能在一页中包含了两个或两个以上程序段。</li></ul></li><li>⑵页表很长，需要占用很大的存储空间。<ul><li>通常，虚拟存储器中的每一页在页表中都要占一个页表项。假设有一个虚拟页式存储器，它的虚拟存储空间大小为4GB，每一页的大小为1KB，则页表的容量为4M（个页表项）。如果每个页表项占用4个字节，则页表的存储容量为16MB。</li></ul></li></ul><h2 id="4-7-虚拟段式存储管理"><a href="#4-7-虚拟段式存储管理" class="headerlink" title="4.7  虚拟段式存储管理"></a><strong>4.7  虚拟段式存储管理</strong></h2><h3 id="4-7-1-虚拟段式存储的实现"><a href="#4-7-1-虚拟段式存储的实现" class="headerlink" title="4.7.1 虚拟段式存储的实现"></a>4.7.1 虚拟段式存储的实现</h3><h4 id="1-虚拟段式存储原理"><a href="#1-虚拟段式存储原理" class="headerlink" title="1.虚拟段式存储原理"></a>1.虚拟段式存储原理</h4><p>为了能实现虚拟存储，段式逻辑地址空间中的程序段在运行时并不全部装入内存，而是如同请求式分页存储管理，首先调入一个或若干个程序段运行，在运行过程中调用到哪段时，就根据该段长度在内存分配一个连续的分区给它使用。若内存中没有足够大的空闲分区，则考虑进行段的紧凑或将某段或某些段淘汰出去。相应于请求式分页存储管理，这种存储管理技术称为请求式分段存储管理。</p><h4 id="2-段表"><a href="#2-段表" class="headerlink" title="2.段表"></a>2.段表</h4><p>类似于请求式分页存储管理的页表，为了实现动态地址变换和存储保护，系统要为每一个作业建立一张段表。段表中的每一个表目对应着作业地址空间的一个程序段，其一般格式为</p><img src="https://api2.mubu.com/v3/document_image/b159913c-1ee6-4995-93a3-88238b227891-7976057.jpg" alt="img" style="zoom:80%;" /><h4 id="3-请求式分段动态地址变换过程"><a href="#3-请求式分段动态地址变换过程" class="headerlink" title="3.请求式分段动态地址变换过程"></a>3.请求式分段动态地址变换过程</h4><p>请求分段系统中的地址变换机构是在分段系统地址变换机构的基础上形成的。因为被访问的段并非全在内存，所以在地址变换时，若发现所要访问的段不在内存，必须先将所缺的段调入内存，并修改段表，然后才能再利用段表进行地址变换。</p><img src="https://api2.mubu.com/v3/document_image/d32041e1-279e-46f2-b827-4e91046514ed-7976057.jpg" alt="img" style="zoom:80%;" /><h4 id="4-缺段中断"><a href="#4-缺段中断" class="headerlink" title="4.缺段中断"></a>4.缺段中断</h4><p>在虚拟段式存储系统中，采用的是请求调段策略。即每当进程所要访问的段尚未调入内存时，便由缺段中断机构产生一缺段中断信号，进入OS后由缺断中断处理程序将所需的段调入内存。</p><p>在调入新段时，也会有内存空间不够用的情况，也需要淘汰内存中的一个或多个段。如果此程序段从装入内存起一直没有被修改过，只要用新调入的程序段把它覆盖掉即可。若这个程序段被修改过，则必须先把该程序段全部写回到磁盘存储器中，才能占用被淘汰段原来存放的空间。</p><p>因为段要占用连续的空间，因此当内存中没有能够满足段长需要的空闲区时，系统还要合并空闲区，以便满足分段的需求。</p><p>流程如图</p><img src="https://api2.mubu.com/v3/document_image/725346e9-80b9-458b-858e-45b857f651f4-7976057.jpg" alt="img" style="zoom:80%;" /><h3 id="4-7-2-段的共享和保护"><a href="#4-7-2-段的共享和保护" class="headerlink" title="4.7.2 段的共享和保护"></a>4.7.2 段的共享和保护</h3><h4 id="1-段的共享"><a href="#1-段的共享" class="headerlink" title="1.段的共享"></a>1.段的共享</h4><p>在多道环境下，常常有许多子程序和应用程序是被多用户所使用的。最好的办法是在内存中只保留一个副本，供多个用户使用，称为共享。</p><p>段共享时，用户可以使用不相同的段名来共享同一个段。进程将共享段填写到自己的段表中，并置以适当的读写控制权，就可以做到共享一个逻辑上完整的内存段信息。</p><p>由于系统中有许多的共享段，而每一个共享段都可能被多个进程共享。因此系统需要对共享段进行统一的管理，设一张共享段表，每一个共享段都在表中占据一个表项。</p><p>共享段应该是可重入的。共享段表如图。</p><img src="https://api2.mubu.com/v3/document_image/bad137bb-ee91-470e-a03c-b1e08151ed89-7976057.jpg" alt="img" style="zoom:80%;" /><p>其中存在位表示该共享段是否已被调入内存，共享计数是用来统计当前有多少个进程共享该段。系统可以为不同的进程使用该段设置不同的权限，以防止进程越权操作。</p><p>当进程请求共享段时，若该共享段未在内存，也是由缺段中断将其调入内存，同时为该段建立相应的共享段表项，共享计数设为1，将进程填写到共享段表项中，再将共享段填写到进程的段表中。若该共享段已在内存，只要将共享计数加1，再修改相应的表项即可。不用时做相反工作。</p><h4 id="2-段的保护-两种保护方式"><a href="#2-段的保护-两种保护方式" class="headerlink" title="2.段的保护(两种保护方式)"></a>2.段的保护(两种保护方式)</h4><p>(1)地址越界保护法。主要是利用段表寄存器中的段表长及段表中的段长信息实现的。首先将逻辑地址空间的段号与段表长度进行比较;其次还要检查段内地址是否等于或大于段长。从而保证了每个进程只能在自己的地址空间内运行。</p><p>(2)存取方式控制保护法。是利用段表项中的“存取控制”字段实现的，存取控制字段规定了对该段的访问方式。通常的访问方式有：⑴只读；⑵只执行，只允许进程调用该段去执行，但不准读写该段；⑶读&#x2F;写，允许进程对该段进行读写访问。</p><p>对于共享段更应对不同的进程设置不同的存取权限控制。既要保证信息的安全，又要满足运行需要。</p><h3 id="4-7-3虚拟段式存储管理的优缺点"><a href="#4-7-3虚拟段式存储管理的优缺点" class="headerlink" title="4.7.3虚拟段式存储管理的优缺点"></a>4.7.3虚拟段式存储管理的优缺点</h3><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h4><ul><li>⑴ 程序的模块化性能好。由于各个程序段在功能上是相互独立的，因此，一个程序段的修改和增删等不会影响其它程序，从而可以缩短程序的编制和调试时间。</li><li>⑵ 便于实现信息的保护。在一般情况下，一段程序是否需要保护是根据这个程序段的功能来决定的。因此，只要在段表中设置一个信息保护字段，就能根据需要很方便地实现对该程序段的保护。</li><li>⑶ 便于程序和数据的共享。被共享的程序段只要在主存中装入一次即可，同时将该共享段填入调用进程的段表中。对于进程来讲其使用与普通段没有什么差别，即实现程序段的共享很容易。</li><li>⑷ 程序的动态链接和调度比较容易。</li></ul><h4 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2.缺点"></a>2.缺点</h4><ul><li>⑴ 地址变换所花费的时间比较长：要使用主存全地址（段长和段基址），每次地址变换都要做加法运算。</li><li>⑵ 主存储器的利用率往往比较低：由于每个程序段的长度是不同的，一个程序段通常要装在一个连续的主存空间中，程序段在主存储器中不断地调入调出，有些程序段在执行过程中还要动态增加长度，从而使得主存储器中有很多的空隙存在。当然，也可以采用一些好的算法来减少空隙的数量，或者通过定时运行回收程序来合并这些空隙，但这无疑增加了系统开销。</li></ul><h3 id="4-7-4-虚拟段页式存储管理"><a href="#4-7-4-虚拟段页式存储管理" class="headerlink" title="4.7.4 虚拟段页式存储管理"></a>4.7.4 虚拟段页式存储管理</h3><p>将虚拟段式和虚拟页式存储管理技术结合起来，就形成了虚拟段页式存储管理方式。虚拟段页式存储方式兼具虚拟段式和虚拟页式的优点，例如，用户程序可以模块化编写，程序段的共享和信息的保护都比较方便等。另一方面也具有虚拟页式存储的优点，例如，主存储器的利用率高，对磁盘存储器的管理比较容易等。</p><h4 id="1-虚拟段页式存储原理"><a href="#1-虚拟段页式存储原理" class="headerlink" title="1.虚拟段页式存储原理"></a>1.虚拟段页式存储原理</h4><p>在虚拟段页式存储方式中，程序员仍然按照逻辑的程序段来编写程序，但每个程序段又被分成若干个固定大小的页，相似于段页式存储管理。系统将作业的部分页装入内存，执行时用到不在内存的段或页时再将其调入内存。</p><p>在虚拟段页式存储中，用户看到的逻辑地址仍然是二维的，即段号和段内地址。但系统对内存的管理则是采用了虚拟页式管理方式。</p><h4 id="2-地址映射"><a href="#2-地址映射" class="headerlink" title="2.地址映射"></a>2.地址映射</h4><p>在虚拟段页式管理中，用户作业仍是在自己的虚拟地址空间中运行，虚拟地址由三部分组成，即段号S、虚页号P和页内偏移地址D。在程序运行过程中，要把用户程序中的虚拟地址变换成主存实地址，必须分两步进行。首先查段表，若该段的存在位为0则产生一个缺段中断，读入该段的页表；其次再查找页表，看该页是否在内存，若不在内存则产生一个缺页中断，调入该页；最后把块号p与页内偏移地址d拼接起来就得到了主存的实地址。</p><p>虽然虚拟段页式存储方式兼具虚拟段式和虚拟页式的优点，但也有不足之处，功能的增强导致实现变得复杂及管理开销加大，需要更多的硬件支持。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 2.进程管理</title>
    <link href="/20200722/83908933/"/>
    <url>/20200722/83908933/</url>
    
    <content type="html"><![CDATA[<p>进程管理涉及到进程调度、CPU分配等问题，是操作系统中最重要的部分之一</p><span id="more"></span><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h3><p>程序的并发执行。程序的执行有两种方式：顺序执行和并发执行。</p><ul><li>顺序执行是单道批处理系统的执行方式，也用于简单的单片机系统；</li><li>现在的操作系统多为并发执行，具有许多新的特征。引入并发执行的目的是为了提高资源利用率。</li></ul><p>首先引入前驱图，再用前趋图表示程序的运行流程：前趋图是一个有向无循环图DAG(Directed Acyclic Graph)。</p><ul><li><p><strong>顺序执行</strong>：是指一个程序运行时独占整个系统资源, <strong>处理机严格按照程序所规定的顺序进行操作</strong>。在一个程序段中，只有前面的一个操作执行完，才能进行后面一个操作。</p><p><img src="https://img.mubu.com/document_image/a02f2386-6381-4c09-b299-749fa4bec992-7976057.jpg" alt="img"></p><ul><li>顺序性</li><li>封闭性</li><li>结果可再现性</li></ul></li><li><p><strong>并发执行</strong>：是指在一个时间段内，多个程序段在计算机系统中“一起”执行，<strong>若干程序段在执行时间上有重叠, 即一个程序段的执行过程中插入了其它程序的操作，称为并发执行</strong>。例如，在一个时间段内，一个CPU在为多道程序工作，而在某一个瞬间，一个CPU只能运行一道程序，它只是在多道程序中快速切换，给人以CPU“同时”运行几道程序的感觉。每个程序内部仍是按顺序执行，但是多个程序的执行过程是可以交叉的，这是一种<strong>伪并行</strong>，称之为并发执行。</p><p><img src="https://img.mubu.com/document_image/ab5fad32-5585-497f-8d45-d76d7e13ceb5-7976057.jpg" alt="img"></p><ul><li>间断(异步)性</li><li>失去封闭性</li><li>失去可再现性</li><li>相互作用和制约性</li></ul></li></ul><p>为了强调进程并发性和动态性的特点，将其定义为：<strong>进程是程序的一次执行，该程序可以与其它程序并发执行。</strong></p><ul><li>结构性：由程序+数据+进程控制块PCB组成了进程实体，其中PCB是进程存在的标志。 </li><li>动态性：进程是进程实体的执行过程, 它由创建而产生, 由调度而执行,因某事件而暂停, 由撤销而消亡。</li><li>并发性：多个进程同时存于内存中,一起向前推进,并发执行。</li><li>独立性：进程是独立获得资源和独立调度的基本单位。</li><li>异步性：各进程都各自独立的不可预知的速度向前推进。</li></ul><p>进程与程序的区别</p><ul><li><p>进程是动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行。通常进程不可在计算机之间迁移；而程序通常对应着文件、静态和可以复制。</p></li><li><p>进程是暂时的，程序的永久的：进程是一个状态变化的过程，程序可长久保存。</p></li><li><p>进程与程序的对应关系：通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序。</p></li><li><p>进程与程序的组成不同：进程的组成包括程序、数据和进程控制块PCB（即进程状态信息）。</p></li><li><p>进程的表示：程序 + 数据 + 进程控制块PCB</p><ul><li>程序：描述了进程所要完成的功能，是进程执行时不可修改的部分。</li><li>数据集合：程序执行时所需要的数据和工作区，为一个进程专用，可修改。</li><li>进程控制块PCB(Process Control Block)：包含了进程的描述信息和控制信息，是进程的动态特性的集中反映。</li></ul></li></ul><p>进程控制块PCB：为了对进程进行有效的控制和管理，系统为每一进程设置一个进程控制块，PCB是进程存在的唯一标志。PCB表常驻内存，属于系统空间，只有操作系统程序才能够访问，用户程序不得访问。通常PCB包含以下几类信息：</p><ul><li>进程描述信息：进程标识名(Process ID)、进程名</li><li>进程控制信息：当前状态、优先级、程序和数据的地址、队列指针或链接字</li><li>资源占用信息：进程执行时除CPU外的资源的需求、分配和控制信息。 </li><li>CPU现场保护结构：它由处理机各种寄存器的内容所组成，该类信息使进程被中断后重新执行时能恢复现场从断点处继续运行。</li></ul><p>PCB表的组织形式：PCB是一个线性表结构，系统中的PCB个数是有限的。常驻内存的。操作系统在内存专门开辟一个PCB表区，每个PCB是一片连续的存储单元。常用的组织方式有2种</p><ul><li><p>链接方式：用PCB表中的队列指针项将具有相同状态的进程的PCB表链接起来，这样PCB表就形成就绪队列、空闲队列及阻塞队列等。其中，空闲队列是一个，而就绪队列与阻塞队列可以是多个。也可以将不同优先级的进程的PCB表排入不同的就绪队列中。</p><p><img src="https://img.mubu.com/document_image/31552717-fca6-4af5-a375-4c4dd44e54c6-7976057.jpg" alt="img"></p></li><li><p>索引方式：根据进程的状态，在内存中建立相应的索引表，系统中的某些固定单元保存各索引表的首地址。各索引表的表目中记录相应状态的PCB表的首地址。</p><p><img src="https://img.mubu.com/document_image/19df087f-65e2-4599-9b5c-13351ed74712-7976057.jpg" alt="img"></p></li></ul><h3 id="进程的三种基本状态及其转换"><a href="#进程的三种基本状态及其转换" class="headerlink" title="进程的三种基本状态及其转换"></a>进程的三种基本状态及其转换</h3><ul><li><p>运行态（Running）：当一个进程在处理机上运行时，则称该进程处于运行状态。</p></li><li><p>就绪态（Ready）：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。</p></li><li><p>阻塞态（Blocked）：当一个进程正在等待某一事件发生（例如请求I／O而等待I／O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。注意与就绪状态的不同在于即使处理机处于空闲状态也无法运行。</p></li><li><p>① 就绪→运行：调度程序选择一个新的进程运行</p></li><li><p>② 运行→就绪：运行进程用完时间片被中断或在抢占调度方式中,因为一高优先级进程进入就绪状态</p></li><li><p>③ 运行→阻塞：进程发生I&#x2F;O请求或等待某事件时</p></li><li><p>④ 阻塞→就绪：当I&#x2F;O完成或所等待的事件发生时</p></li><li><p>转化如图</p><img src="https://img.mubu.com/document_image/eaac84da-7f96-40f7-83fc-677105ffabe6-7976057.jpg" alt="img" style="zoom:67%;" /><p><img src="https://img.mubu.com/document_image/c3ba7447-9bce-4be7-a1e8-4a79995f4585-7976057.jpg" alt="img"></p></li><li><p>细分的进程调度状态——挂起状态：由于终端用户及操作系统的需要(排除故障或为系统减负)，为了能够将指定进程暂时静止下来，增加了静止阻塞 (阻塞挂起) 和静止就绪 (就绪挂起)态，原阻塞和就绪改称为活动阻塞和活动就绪状态。</p><ul><li><p>①运行或活动就绪→静止就绪，活动阻塞→静止阻塞 通过挂起操作(suspend)。</p></li><li><p>②静止就绪→活动就绪, 静止阻塞→活动阻塞 通过激活操作(activate)。</p></li><li><p>③静止阻塞→静止就绪 当等待的事件发生时。</p></li><li><p>如图</p><img src="https://img.mubu.com/document_image/171825d5-5c70-478f-b063-39f0e3fcc8d3-7976057.jpg" alt="img" style="zoom:67%;" /><p><img src="https://img.mubu.com/document_image/8208aaef-69d6-4001-b44d-5d59f41d7268-7976057.jpg" alt="img"></p></li></ul></li></ul><h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><ul><li>处理机的执行状态<ul><li>系统态(核心态、管态)：有特权，能执行所有指令，能访问所有寄存器和存储区。</li><li>用户态(目态、算态)：无特权，只能执行规定指令，只能访问指定的寄存器和存储区。</li><li>用户程序运行在用户态，它不能执行OS指令不能访问OS区域，防止对OS的破坏。OS内核运行在系统态。进程控制包含在OS的内核（Kernel）中，它常驻内存，执行效率高。</li><li>操作系统内核是系统硬件的首次延伸，通过执行各种原语操作来实现对进程的控制功能（创建、调度、通讯、撤销等）。</li></ul></li></ul><h3 id="原语-Primitive"><a href="#原语-Primitive" class="headerlink" title="原语(Primitive)"></a>原语(Primitive)</h3><p><strong>由若干条机器指令构成的并用以完成特定功能的一段程序，而且这段程序在执行期间不允许中断</strong>。原语又称为“原子操作(Atomic Operation)”过程，作为一个整体而不可分割——要么全都完成，要么全都不做。</p><h4 id="1）进程创建原语"><a href="#1）进程创建原语" class="headerlink" title="1）进程创建原语"></a>1）进程创建原语</h4><ul><li><p>引起创建进程的事件：用户登录、作业调度、提供服务、应用请求四类</p></li><li><p>进程图：允许进程创建子进程，子进程还可以创建自己的子进程，从而形成树型的进程家族。进程图是用于描述进程家族关系的有向图，子进程可以继承父进程所拥有的资源。</p><img src="https://img.mubu.com/document_image/90204e85-600b-48f4-9236-40fe15f37af8-7976057.jpg" alt="img" style="zoom:67%;" /></li><li><p>树型结构系统的优点：</p><ul><li>资源分配严格。祖先拥有进程家族的所有资源，子进程可在祖先进程所拥有的资源中进行分配、使用与归还。</li><li>进程控制灵活。可根据需要给予进程不同的控制权力，而且可根据需要创建多个子进程并行工作，协同完成任务。</li><li>进程层次清晰，关系明确。</li></ul></li><li><p>进程的建立有两种方式：</p><ul><li><strong>系统生成时就建立起一些系统进程</strong>。主要用于创建常驻内存的系统进程；</li><li><strong>经创建原语产生进程</strong>。主要用于创建非常驻的系统进程和用户进程。</li></ul></li><li><p>进程的创建过程：一旦发现了要求创建新进程的事件，OS便调用创建原语, 按以下过程创建新进程。</p><ul><li>分配一个唯一的进程标识符,索取一个空白PCB；</li><li>为新进程的程序和数据分配内存空间</li><li>初始化进程控制块：初始化标识符信息(填入)、处理机的状态信息(指令指针,栈指针)和控制信息(状态,优先级…)</li><li>设置相应的链接。如:把新进程加到就绪队列的链表中</li></ul></li></ul><h4 id="2）进程撤消原语"><a href="#2）进程撤消原语" class="headerlink" title="2）进程撤消原语"></a>2）进程撤消原语</h4><ul><li><p>进程何时中止</p><ul><li>正常结束：批处理系统中,进程已运行完成遇到 Halt 指令；分时系统中, 用户退出登录</li><li>异常结束：本进程发生出错和故障事件；存储区越界、保护性错(如:写只读文件)、特权，指令错、非法指令(如:程序错转到数据区)、算术运算错、运行超时、等待超过时、I&#x2F;O 失败、</li><li>外界干预：操作系统干预、父进程请求、父进程终止</li></ul></li><li><p>进程的终止过程：一旦发生终止进程的事件，OS便调用撤消原语，按以下过程终止该进程。</p><ul><li>从PCB中读取进程的状态；</li><li>若进程处于执行态,应立即终止该进程的执行，并置调度标志为真（以便该进程终止后系统重新进行调度,将处理机分配给新选择的进程）</li><li>若有子孙进程则将其全部终止，以防它们失控</li><li>将该进程所占有的全部资源还给父进程或系统</li><li>将该进程的PCB从所在队列中移出。</li></ul></li><li><p>创建与撤销流程图</p><p><img src="https://img.mubu.com/document_image/48720bb1-53b2-49bd-abb0-8e60ff1f49ed-7976057.jpg" alt="img"></p></li></ul><h4 id="3）阻塞原语、唤醒原语"><a href="#3）阻塞原语、唤醒原语" class="headerlink" title="3）阻塞原语、唤醒原语"></a>3）阻塞原语、唤醒原语</h4><ul><li><p>进程的阻塞</p><ul><li>处于运行状态的进程，在其运行过程中期待某一事件发生（如：请求系统服务、等待键盘输入、等待数据传输完成、等待其它进程发送消息）当被等待的事件未发生时, 由进程调用阻塞原语(block),将自己阻塞。</li><li>阻塞原语使处于运行态的进程停止运行，将运行现场保存在其PCB的CPU现场保护区，然后将 PCB中的现行状态由运行态变为阻塞态，并将该进程插入到相应事件的阻塞队列中。最后，转进程调度程序重新调度，将处理机分配给一个就绪进程，按新进程PCB中的处理机状态设置CPU环境，使它投入运行。</li></ul></li><li><p>进程的唤醒</p><ul><li>当被阻塞进程期待的事件到来时,由中断处理进程或其它产生该事件的进程调用唤醒原语(Wakeup),将期待该事件的进程唤醒。</li><li>唤醒原语执行时, 将被阻塞进程从相应等队列中移出, 并将其 PCB中的现行状态由阻塞改为就绪态, 然后将该进程插入就绪队列中。</li><li>若事件是等待 I&#x2F;O 完成, 则由硬件提出中断请求, CPU响应中断, 暂停当前进程的执行, 转去中断处理。检查有无等待该 I&#x2F;O完成的进程。若有, 则将它唤醒。然后结束中断处理。返回被中断进程或重新调度。</li><li>若事件是等待某进程发一个信息, 则由发送进程把该等待进程唤醒。</li></ul></li><li><p>阻塞与唤醒流程图</p><p><img src="https://img.mubu.com/document_image/8ee73fea-931a-4fe3-9957-70f37ffa5e59-7976057.jpg" alt="img"></p></li></ul><h4 id="4）挂起原语、激活-解挂-原语"><a href="#4）挂起原语、激活-解挂-原语" class="headerlink" title="4）挂起原语、激活(解挂)原语"></a>4）挂起原语、激活(解挂)原语</h4><ul><li>进程的挂起<ul><li>当进程请求将自己挂起或父进程请求将子进程挂起时, 调用挂起原语(suspend),将指定进程挂起。</li><li>执行过程: 检查要挂起进程的状态，若处于活动就绪态就将其改为静止就绪态，对于活动阻塞态的进程则将其改为静止阻塞态。如果被挂起的进程正在执行则还要转到调度程序重新调度。</li></ul></li><li>进程的激活：<ul><li>要激活指定进程，调用激活原语(active)将它激活。</li><li>执行过程：将要激活的进程调入内存, 并检查它的状态, 若是静止就绪态则将其改为活动就绪态,若为静止阻塞态就将其改为活动阻塞态。如果采用的是抢占调度策略,被激活的进程优先级高则引起重新调度。</li></ul></li></ul><h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a><font color="red"><strong>进程同步与互斥</strong></font></h3><h4 id="并发的问题"><a href="#并发的问题" class="headerlink" title="并发的问题"></a>并发的问题</h4><ul><li><p>并发进程之间的关系</p><ul><li>合作关系：一组进程协同完成一个任务，它们之间是合作关系（直接制约关系）。例如，一个计算进程和一个打印进程共同完成一个任务。</li><li>竞争关系：多个进程因为使用共享资源而产生竞争关系（间接制约关系）。例如，多个进程共同使用一台打印机。</li></ul></li><li><p>进程并发执行相互间的影响</p><ul><li>同步：多个进程在执行过程中，<strong>为了共享资源与相互合作而在执行次序上的协调，称为同步</strong>，即共享同一资源的进程和相互关联进程以通信手段来保障完成任务时所必须保持一种固定的时间关系。</li><li>互斥：<strong>当某一进程访问某一资源时，不允许别的进程同时访问，这种限制称为互斥</strong>，即多个进程在访问某些资源（如临界资源）时，也要有一种执行次序上的协调，当一个进程访问完毕，另一个进程才能访问。所以就其本质来讲，互斥仍是一种同步。</li></ul></li><li><p>临界资源</p><ul><li>限定进程只能互斥地访问的资源叫临界资源（指一次仅允许一个进程使用的资源 ）<ul><li>临界资源限定了使用者只能互斥地使用它,操作系统也不能中途从抢先者手中把临界资源抢来给其他进程用。因此，临界资源也是不可剥夺性资源。</li></ul></li><li>临界区：进程中访问临界资源的那段程序代码称为临界区或临界段。</li><li>使用同一临界资源的不同进程中的临界区称为同类临界区或相关临界区。</li><li>临界区的使用原则，即“<strong>空则让进，忙则等待，等则有限，等则让权</strong>”。</li></ul></li></ul><h4 id="临界区的互斥进入方法"><a href="#临界区的互斥进入方法" class="headerlink" title="临界区的互斥进入方法"></a>临界区的互斥进入方法</h4><ul><li>(1)<strong>采用询问方式</strong>，当其他进程不用时，则自己进入。此法实现复杂。</li><li>(2)<strong>采用加锁方式</strong>，加锁是一种最简单的进程互斥方法，它使用一个锁变量W来表示某种临界资源的状态，<ul><li>W&#x3D;0表示资源空闲可用</li><li>W&#x3D;1表示资源正被使用</li></ul></li><li>(3)<strong>信号灯机制</strong>。</li><li>(4)<strong>管程机制等</strong>。</li></ul><h4 id="互斥的加锁实现"><a href="#互斥的加锁实现" class="headerlink" title="互斥的加锁实现"></a>互斥的加锁实现</h4><ul><li><p>1）为临界区加锁——每当进程想要进入临界区，就要测试锁的状态，若W＝0，就马上将其设置为1，以防止其它进程进入临界区。若W＝1，则进程就进入等待状态。这时临界区的控制描述如下：（若同时有进程检测到W&#x3D;0，控制机制就会导致失败！）</p><p><img src="https://img.mubu.com/document_image/d8334f1b-9dff-4d18-ad2c-94008a916c70-7976057.jpg" alt="img"></p></li><li><p>2）由硬件提供相应指令</p></li><li><p>3）加锁实现互斥访问</p><ul><li><p>如图</p><img src="https://img.mubu.com/document_image/3304a866-f93d-40c5-b3ae-1c25ef3ecff3-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul></li><li><p>4）加锁原语</p><ul><li><p>如图</p><img src="https://img.mubu.com/document_image/bd3487aa-983e-4515-aa86-540d77c55d57-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul></li><li><p>5）用上锁和开锁原语</p><ul><li><p>用上锁用上锁原语和开锁原语来实现进程的互斥的确很简单，但处理机效率不高，因为上锁原语中的条件测试操作可能引起CPU“忙等”。</p><img src="https://img.mubu.com/document_image/8e6b987d-2e26-4ec6-af4c-2cd9a744a902-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul></li></ul><h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a><font color="red"><strong>信号量机制</strong></font></h4><ul><li><p>信号量的思想：两个或多个进程可以利用彼此间收发的简单的信号来实现“正确的”并发执行，一个进程在收到一个指定信号前，会被迫在一个确定的或者需要的地方停下来，从而保持同步或互斥。</p></li><li><p>信号量类型</p><ul><li><p>P（Passeren&#x2F;proberen ）、 V（Vrijgeren&#x2F;verhogen ）是荷兰语，分别代表 “通过&#x2F;测试或等待”及 “释放&#x2F;增加或发信号”。</p><p><img src="https://img.mubu.com/document_image/f6a12b0a-0381-4177-b673-93ee5fff1a58-7976057.jpg" alt="img"></p></li><li><p>整型信号量定义：</p><p><img src="https://img.mubu.com/document_image/98735f6e-6d9f-4b9a-99d4-4227f989a29f-7976057.jpg" alt="img"></p></li><li><p>记录型信号量：信号量的数据结构。C语言为例——struct结构体</p><p><img src="https://img.mubu.com/document_image/d8bcad67-4438-4979-b03f-cf0cbdfc7d02-7976057.jpg" alt="img"></p></li></ul></li><li><p>信号量S的值含义（S的值只能由P、V操作来改变）</p><ul><li>当S≥0时，表示某类可用资源的数目，或者说表示可以执行P操作而不会被阻塞的进程的数目；</li><li>当S＜0时，其绝对值表示信号量S的阻塞队列中的进程数，即系统中因请求该类资源而被阻塞的进程的数目，亦即被信号灯挡住的进程数目，这些进程需要别的进程发出相应的信号灯来唤醒。</li></ul></li><li><p>P(S)、V(S)操作含义</p><ul><li>P(S)操作表示“等信号”，即测试一个要等的信号是否到达；</li><li>V(S)操作表示“发信号”。这个信号在实现同步时就是“合作者的伙伴进程已完成前趋任务”，在实现互斥时就是“临界资源可用”。</li><li>另外，在互斥问题中，每执行一次P(S)操作的含义，也可理解为进程请求一个单位的S类资源；每执行一次V(S)操作的含义，也可理解为进程释放一个单位的S类资源。</li></ul></li><li><p>信号量集</p><ul><li><p>假如进程一次需要共享多种临界资源，且每种资源个数不限于一个时，则P、V操作就显得效率不高，这种情况下我们可以用信号量集来解决。在信号量集机制中，进程一次可以申请多个不同种类的临界资源，当可用资源个数低于系统规定的某一下限值时，不予分配。</p></li><li><p>AND型信号量：进程同时请求若干类资源，每类资源请求一个</p><p><img src="https://img.mubu.com/document_image/9fe131a8-e21b-485f-8ebe-de1a38169c9d-7976057.jpg" alt="img"></p></li><li><p>信号量集SP(s1,t1,d1；s2,t2,d2；…；sn,tn,dn)</p><ul><li><p>si：系统i类资源可用的个数（信号量）；</p></li><li><p>di：进程当前需要的i类资源个数（需求数）；</p></li><li><p>ti：系统保留的i类资源数目，或者说是分配下限（下限值）；</p></li><li><p>若si≥ti且si≥di时，作si&#x3D;si- di，表示资源申请成功；否则，资源申请失败,则将申请资源的进程放入第一个不满足条件的si的等待队列，转进程调度程序入口。</p><p><img src="https://img.mubu.com/document_image/2f36815f-1a91-442d-a5ae-20309b88cd31-7976057.jpg" alt="img"></p></li><li><p>操作说明：进程使用信号量操作申请资源时，即使有一个资源申请不到，也将此次申请作废，程序计数器拨回到进程执行信号量时的初始位置。下次进程运行时再重新申请所有资源。</p></li><li><p>特例：</p><ul><li>1)SP(s,d,d)表示只有一个信号量：此时在信号量集中只有一个信号量 S，但允许它每次申请 d 个资源，当现有资源数少于 d 时，不予分配。</li><li>2)SP(s,1,1)：相当于P(s)，；此时的信号量集已蜕化为一般的记录型信号量(S&gt;1 时)或互斥信号量(S&#x3D;1 时)。</li><li><ol start="3"><li>SP(s,1,0)：相当于一个可控开关。即当s≥1时，允许多个进程进入某特定区；当s&lt;1时，禁止任何进程进入某特定区。</li></ol></li><li><ol start="4"><li>将SP(s，1，0)作一引伸，如SP(s，n，0)，则表示当s≥n时，允许多个进程进入某特定区；当s&lt;n时，禁止任何进程进入某特定区。</li></ol></li></ul></li></ul></li></ul></li></ul><h4 id="信号量应用"><a href="#信号量应用" class="headerlink" title="信号量应用"></a>信号量应用</h4><h5 id="P、V操作-信号量-实现进程的互斥"><a href="#P、V操作-信号量-实现进程的互斥" class="headerlink" title="P、V操作(信号量)实现进程的互斥"></a><font color="red"><strong>P、V操作(信号量)实现进程的互斥</strong></font></h5><ul><li><p>即保证进程互斥地进入各自的临界区。</p></li><li><p>为使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥信号量 mutex，并设其初始值为 1，然后将各进程访问该资源的临界区 CS 置于 wait(mutex)和 signal(mutex)操作之间即可。（注：wait(mutex)和 signal(mutex)必须成对地出现。）</p></li><li><p>用P、V操作原语实现进程互斥的效率更高一些，因为P操作中引入了阻塞机制，所以消除了CPU忙等现象。</p></li><li><p>三个进程互斥进入临界区</p><p><img src="https://img.mubu.com/document_image/347dcd44-06c7-44b6-bd47-6bc1e4cafb8a-7976057.jpg" alt="img"></p></li></ul><h5 id="P、V操作-信号量-实现前趋关系"><a href="#P、V操作-信号量-实现前趋关系" class="headerlink" title="P、V操作(信号量)实现前趋关系"></a><font color="red"><strong>P、V操作(信号量)实现前趋关系</strong></font></h5><ul><li><p>先确定前驱关系；再设信号量值</p><p><img src="https://img.mubu.com/document_image/22db57d0-5745-4a0e-86c7-f3b8b282693d-7976057.jpg" alt="img"></p><ul><li>设有两个并发执行的进程P 1 和P 2 。P 1 中有语句 S 1 ；P 2 中有语句 S 2 。我们希望在 S 1 执行后再执行 S 2 。为实现这种前趋关系，</li><li>我们只须使进程 P 1 和 P 2 共享一个公用信号量 S，并赋予其初值为 0，将 signal(S)操作放在语句 S 1 后面；而在 S 2 语句前面插入 wait(S)操作，即在进程 P 1 中，用 S 1 ；signal(S)；在进程 P 2 中，用 wait(S)；S 2 ；</li><li>由于 S 被初始化为 0，这样，若 P 2 先执行必定阻塞，只有在进程 P 1 执行完 S 1 ；signal(S)；操作后使 S 增为 1 时，P 2 进程方能执行语句 S 2 成功。</li></ul></li><li><p>更复杂的示例：</p><p><img src="https://img.mubu.com/document_image/22db57d0-5745-4a0e-86c7-f3b8b282693d-7976057.jpg" alt="img"></p><p><img src="https://img.mubu.com/document_image/3b62c1d1-be87-42a8-9910-aa264b2ff8b6-7976057.jpg" alt="img"></p></li></ul><h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><ul><li>自行使用PV操作可能的问题：P、V操作没有成对出现——只有P，而没有V，或者只有V，而没有P；P、V操作颠倒；两个P操作颠倒等。</li></ul><h4 id="管程定义"><a href="#管程定义" class="headerlink" title="管程定义"></a>管程定义</h4><p>一个管程指定义了一个数据结构和能为并发程序在该数据结构上执行的一组操作，这组操作能同步进程和改变管程中的数据（将对临界资源的控制与管理集中起来，用户只要提出使用要求，其它诸如互斥、同步等问题则不需要用户自己解决，而由系统统一解决。）</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>(1) 管程标识符；</li><li>(2) 局部于管程的共享变量说明（局部于管程内部的数据结构，仅能被局部于管程内部的过程所访问，任何管程外的过程都不能访问它）；</li><li>(3) 对该数据结构进行操作的一组过程；</li><li>(4) 对局部于管程内部的共享数据的初始化过程。</li></ul><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><ul><li>在利用管程实现进程同步时，必须设置同步工具，如两个同步操作原语 wait 和 signal。</li><li>考虑一种情况：当一个进程调用了管程，在管程中时被阻塞或挂起，直到阻塞或挂起的原因解除，而在此期间，如果该进程不释放管程，则其它进程无法进入管程，被迫长时间地等待。为了解决这个问题，引入了条件变量condition。其形式为：Var x，y：condition。</li><li>① x.wait：正在调用管程的进程因 x 条件需要被阻塞或挂起，则调用 x.wait 将自己插入到 x 条件的等待队列上，并释放管程，直到 x 条件变化。此时其它进程可以使用该管程。</li><li>② x.signal：正在调用管程的进程发现 x 条件发生了变化，则调用 x.signal，重新启动一个因 x 条件而阻塞或挂起的进程。如果存在多个这样的进程，则选择其中的一个，如果没有，则继续执行原进程，而不产生任何结果。</li></ul><h4 id="进程同步定义"><a href="#进程同步定义" class="headerlink" title="进程同步定义"></a>进程同步定义</h4><p>指的是两个或多个进程为了合作完成同一个任务，在执行速度或某些个确定的时序点上必须相互协调，即一个进程的执行依赖于另一个进程——其合作伙伴的消息，当一个进程到达了某一确定点而没有得到合作伙伴发来的“已完成某些操作”的消息时必须等待，直到该消息到达被唤醒后，才能继续向前推进。</p><h4 id="进程同步和互斥间的关系"><a href="#进程同步和互斥间的关系" class="headerlink" title="进程同步和互斥间的关系"></a>进程同步和互斥间的关系</h4><ul><li>相似处：<strong>进程的互斥实际上是进程同步的一种特殊情况</strong>； 进程的互斥和同步统称为进程同步。</li><li>差别：进程互斥是进程间共享资源的使用权，这种竞争没有固定的必然联系，哪个进程竞争到使用权就归那个进程使用，直到不需要使用时再归还；而进程同步则涉及共享资源的并发进程间有一种必然的联系，当进程必须同步时，即使无进程在使用共享资源时，那么尚未得到同步消息的进程也不能去使用这个资源。</li></ul><h4 id="PV操作实现进程同步"><a href="#PV操作实现进程同步" class="headerlink" title="PV操作实现进程同步"></a>PV操作实现进程同步</h4><ul><li>P、V操作也都是配对出现，但对同一个信号量的P、V操作却不是同时出现在每一个进程的程序里，而是分别出现在一个进程和它的合作伙伴的代码中。</li><li>解答这类进程同步问题的主要步骤也是有三步：<ul><li>(1)分析清楚题目涉及的进程间的制约关系</li><li>(2)设置信号量（包括信号量的个数和初值及其物理含义），合作进程间需要收发几条消息相应就设置几个信号量。同步信号量的初值一般为0，表示得到合作进程的消息后才能向前推进。</li><li>(3)给出进程相应程序的算法描述或流程控制，并把P、V操作加到程序的适当处。</li></ul></li></ul><h3 id="经典进程同步问题"><a href="#经典进程同步问题" class="headerlink" title="经典进程同步问题"></a><font color="red"><strong>经典进程同步问题</strong></font></h3><h4 id="生产者—消费者问题"><a href="#生产者—消费者问题" class="headerlink" title="生产者—消费者问题"></a>生产者—消费者问题</h4><ul><li>生产者—消费者问题是相互合作进程关系的一种抽象</li></ul><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><ul><li>①生产者—消费者之间的同步关系表现为：一旦缓冲池中所有缓冲区均装满产品时，生产者必须等待消费者提供空缓冲区；一旦缓冲池中所有缓冲区全为空时，消费者必须等待生产者提供满缓冲区。</li><li>②生产者—消费者之间还有互斥关系：由于缓冲池是临界资源，所以任何进程在对缓冲区进行存取操作时都必须和其他进程互斥进行。</li></ul><h5 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h5><ul><li><p>①所用信号量设置如下：</p><ul><li>Ⅰ）同步信号量empty，初值为n，表示消费者已把缓冲池中全部产品取走，有n个空缓冲区可用。</li><li>Ⅱ）同步信号量full，初值为0，表示生产者尚未把产品放入缓冲池，有0个满缓冲区可用。</li><li>Ⅲ）互斥信号量mutex，初值为1，以保证同时只有一个进程能够进入临界区，访问缓冲池。</li></ul></li><li><img src="https://img.mubu.com/document_image/65d91b1c-e904-48cb-9776-cd1a12821a82-7976057.jpg" alt="img" style="zoom: 50%;" /><img src="https://img.mubu.com/document_image/088c2a1d-7471-4597-8e45-476a09919c4a-7976057.jpg" alt="img" style="zoom:50%;" /></li></ul><h4 id="读者—写者问题"><a href="#读者—写者问题" class="headerlink" title="读者—写者问题"></a>读者—写者问题</h4><ul><li>读者—写者问题是共享数据对象的非合作进程关系的一种抽象</li></ul><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><ul><li>一组读者与一组写者循环访问共享的同一个数据对象。</li><li>读者：指能对共享数据对象读的进程，写者：指对共享数据对象只要求写的进程。</li><li>规定：多个读者可以同时读这个数据对象，但决不允许多个写者同时对这个数据对象进行写操作，也不允许读者、写者同时访问这个数据对象。</li></ul><h5 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h5><ul><li>①读者—写者之间的互斥关系：<ul><li>写者与写者的互斥、写者与读者的互斥。设一个公用的初值为1的互斥信号量 RW_mutex ？但是实现了读者与读者的互斥。引入一个读者计数器变量RC。</li></ul></li><li>②读者—读者之间又有了互斥关系：<ul><li>再设一个读者公用的初值为1的互斥信号量R_mutex实现各个读者间互斥的访问RC</li></ul></li></ul><h5 id="问题解答-1"><a href="#问题解答-1" class="headerlink" title="问题解答"></a>问题解答</h5><ul><li><p>①所用信号量和其他变量设置如下：</p><ul><li>Ⅰ）互斥信号量RW_mutex，初值为1，用于实现写者与其他写者或读者互斥地访问共享的数据对象。</li><li>Ⅱ）互斥信号量R_mutex，初值为1，用于实现诸读者互斥地访问读者计数器变量。</li><li>Ⅲ）整型变量RC，初值为0，用于对读者进行记数。</li></ul></li><li><p>算法描述&amp;伪代码</p><img src="https://img.mubu.com/document_image/e8b13462-ec60-4399-bdf3-3fe51a2dae75-7976057.jpg" alt="img" style="zoom:67%;" /><img src="https://img.mubu.com/document_image/a1dc9963-7f23-4c94-9605-fdb6c4f47567-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><ul><li><p>有5个哲学家，围坐在圆桌旁，他们的生活方式是交替地进行思考和进餐；圆桌上间隔地摆放着5把叉子和1个装有通心粉的盘子，规定第i号哲学家固定坐在第i把椅子上（i&#x3D;0,1,2,3,4），且每个哲学家必须两手分别拿起他左右两旁的那两把叉子，才能吃通心粉；假定通心粉的数量足够5个哲学家用的。</p><img src="https://img.mubu.com/document_image/48751c24-61e5-453d-9c10-ab888f3964cc-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h5 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h5><ul><li><p><font color="red">策略一</font>：饥饿时总是先拿左边的筷子，再拿右边的。（当5个哲学家同时饥饿时都拿左边的筷子，就会进入无限等待右边筷子而死锁）</p><p><img src="https://img.mubu.com/document_image/07fe6442-2278-40b8-bc57-583a348fbc16-7976057.jpg" alt="img"></p></li><li><p><font color="red">改进策略一</font>：通过发放令牌，至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。</p><img src="https://img.mubu.com/document_image/1b418ab8-258c-4853-8edc-a22d0a2c10fa-7976057.jpg" alt="img" style="zoom:67%;" /></li><li><p><font color="red">改进策略二</font>：规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子，而偶数号哲学家则相反。</p><img src="https://img.mubu.com/document_image/cca1df97-4552-4501-b810-19d05b2f8332-7976057.jpg" alt="img" style="zoom:67%;" /></li><li><p><font color="red">改进策略三</font>：采用Hoare管程实现，算法思想是将哲学家的状态分为思考、饥饿、进餐；并且仅当哲学家左右两边的筷子都可用才允许他拿筷子，否则一只筷子也不拿。</p><img src="https://img.mubu.com/document_image/715c9ce0-03a9-4fcc-b06a-3eb2d8ed37ce-7976057.jpg" alt="img" style="zoom:67%;" /><img src="https://img.mubu.com/document_image/f9709813-987a-43c4-9300-8a111df13207-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h4 id="信号量机制解题步骤"><a href="#信号量机制解题步骤" class="headerlink" title="信号量机制解题步骤"></a>信号量机制解题步骤</h4><ul><li>（1）分析进程间的制约关系</li><li>（2）设置信号量</li><li>（3）实施P、V操作。</li><li>第一步是基础、关键，第三步是核心。</li><li>掌握实现进程互斥与进程同步的第三步在形式上差异：即P、V操作总是配对出现的。</li><li>但P,V在互斥问题中总是出现在同一个进程的代码中，且紧紧夹着临界区；而在同步问题中，却是分别出现在两个合作进程的代码中，需要等消息的一方用P操作，相应的对同一信号量的V操作则在发出此消息的另一方中。</li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ul><li><p>进程之间的信息交换称为进程通信。</p></li><li><p>按通信交换的数据量多少划分为:</p><ul><li><p>低级通信：进程间交换的数据量很少，一般只传送一个和几个字节的信息，如信号量机制。缺点是：u效率低。v通信对用户不透明。</p></li><li><p>高级通信：用户可以直接利用操作系统所提供的一组通信命令，高效地传送大量数据的一种通信方式。优点是：效率高和使用方便</p><img src="https://img.mubu.com/document_image/f36a269c-cf90-429a-9474-23d25aaad646-7976057.jpg" alt="img" style="zoom:67%;" /><ul><li>共享存储器系统<ul><li>(1)基于共享数据结构的通信方式：通信进程公用某些数据结构，如生产者与消费者问题中的公共缓冲区；</li><li>(2)基于共享存储区的通信方式：多个进程可以通过对共享内存储区中数据的读操作与写操作完成进程之间的通信。</li></ul></li><li>消息机制<ul><li>直接通信方式：发送进程将消息直接发给接收进程，挂在接收进程的消息队列上，由接收进程从自己的消息队列上取下消息，完成一次消息的通信过程。</li><li>间接通信方式：通信时指明一个中间媒介，即信箱。发送者执行发送命令，将消息发到指明的信箱，接收者执行接收命令时，从指定的信箱中接收消息。</li></ul></li><li>管道<ul><li>无名管道：是操作系统提供的资源，可以被所有的进程使用。但是无名管道在使用上的限制是：它仅能用于连接具有共同祖先的进程。</li><li>有名管道：克服了无名管道使用上的限制，所有进程都可以共享对管道的操作，相互之间通过管道通信。</li></ul></li></ul></li></ul></li></ul><h4 id="进程同步方式"><a href="#进程同步方式" class="headerlink" title="进程同步方式"></a>进程同步方式</h4><ul><li>⑴ 阻塞发送、阻塞接收：用于进程间双向通信，发送进程和接收进程之间无缓冲。即通信双方联系非常紧密,得到对方的应答才能推进。</li><li>⑵ 不阻塞发送、阻塞接收：适合于那些不等待消息的到来就无法继续工作的进程。如服务器上的服务进程，平时总是处于阻塞状态，只有在请求服务的消息到达时，它们才会被唤醒以便提供服务。</li><li>⑶ 既不阻塞发送也不阻塞接收：常用于分布式系统中，因为采用阻塞方式进行通信时，一旦传递的数据丢失，将会使阻塞进程无限期地等待下去。而采用非阻塞、接收的方式就可以避免这种情况。接收进程有消息时就处理消息，无消息时继续执行</li></ul><h4 id="消息通信机制"><a href="#消息通信机制" class="headerlink" title="消息通信机制"></a>消息通信机制</h4><ul><li><p>信箱通信(间接通信)</p><ul><li>在信箱通信中，发送者创建一个消息，然后调用发送命令将消息发送到一个共享的数据结构——信箱中去，接收者调用接收命令从信箱中取出消息。</li></ul></li><li><p>消息缓冲通信(直接通信方式)</p><ul><li>消息缓冲通信过程中，一个进程将一个消息直接发送给接收进程，而接收进程执行时接收这个消息。</li><li>消息缓冲通信的通信过程如下：发送进程首先在自己地址空间的消息发送区制造一个始地址为a的消息，然后调用发送命令send(B，a)发送消息；</li><li>发送原语（send（接收者进程名，发送区首地址））；接收原语（receive（接收区首地址））是系统提供给用户实现进程通信的最基本的原语，也是构成一种具体的通信系统的主要内容，用户直接使用这些通信原语一次就能发送成千上万字节的信息。</li></ul></li><li><img src="https://img.mubu.com/document_image/2324a758-833f-4c37-8b8d-4e4de9a19e8c-7976057.jpg" alt="img" style="zoom:67%;" /><img src="https://img.mubu.com/document_image/9c05472b-9222-4671-9188-6a22caf47cee-7976057.jpg" alt="img" style="zoom:67%;" /><img src="https://img.mubu.com/document_image/e75f85d4-f5b2-4a3b-8133-9f59a61e2a49-7976057.jpg" alt="img" style="zoom:67%;" /><img src="https://img.mubu.com/document_image/ff2bfe96-541c-4126-8e88-b13513742249-7976057.jpg" alt="img" style="zoom:67%;" /></li></ul><h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><ul><li>作为并发执行的进程具有二个基本的属性：<ul><li>（1）进程既是一个拥有资源的独立单位。</li><li>（2）进程又是一个可独立调度和分派的基本单位。</li></ul></li><li>进程的缺点<ul><li>(1)进程管理开销大</li><li>(2)进程的局限性</li></ul></li><li>线程定义<ul><li>进程内一个执行单元或一个可调度实体。线程只拥有一点在运行中必不可省的资源（程序计数器、一组寄存器和栈），但它可与同属一个进程的其它线程共享进程拥有的全部资源。</li></ul></li></ul><h4 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h4><ul><li>(1)调度:在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程。现在分离了。</li><li>(2)并发性：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，因而使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统吞吐量。</li><li>(3)拥有资源：不论是传统的操作系统，还是设有线程的操作系统，进程都是拥有资源的一个独立单位，它可以拥有自己的资源。</li><li>(4)系统开销：由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O设备等。因此，操作系统所付出的开销将明显地大于在创建或撤消线程时的开销。</li></ul><h4 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h4><ul><li>线程是进程的一个组成部分。每个进程创建时通常只有一个线程，需要时可创建其他线程。</li><li>进程的多线程都在进程的地址空间活动。</li><li>资源是分给进程的，不是分给线程的。线程在执行中需要资源时，可从进程资源中划分。</li><li>处理机调度的基本单位是线程，线程之间竞争处理机。真正在CPU上运行的是线程。</li><li>线程在执行时，需要同步。</li></ul><h4 id="线程的控制"><a href="#线程的控制" class="headerlink" title="线程的控制"></a><font color="red"><strong>线程的控制</strong></font></h4><h5 id="1-线程的状态及其转换"><a href="#1-线程的状态及其转换" class="headerlink" title="1.线程的状态及其转换"></a>1.线程的状态及其转换</h5><ul><li>线程由创建而产生，由撤消而消亡，在生命期间，线程可以处于就绪状态、执行状态和阻塞状态三个基本状态中。也有状态变迁，如就绪状态→执行状态，执行状态→阻塞状态，阻塞状态→就绪状态等</li><li>但是线程没有挂起状态，这是因为线程不拥有资源，因而没有权利将整个进程或自己挂起，所以线程没有挂起状态。</li><li>多线程机制中的进程，其状态可以简单地被划分为活动状态与非活动状态。挂起属于非活动状态，即不可运行状态；活动状态是指进程中某个线程正在执行。</li><li>对进程的操作等效于对进程下的所有线程，比如挂起某进程，即将该进程中的所有线程挂起。</li></ul><h5 id="2-线程控制块"><a href="#2-线程控制块" class="headerlink" title="2.线程控制块"></a>2.线程控制块</h5><ul><li>每一个线程是一个动态对象，它表示进程中的一条控制线索，执行一系列指令操作，是一个相对独立的、可被调度运行的基本单位。</li><li>在进程的地址空间中可以有多个线程，它们可以并发执行，这就需要一张单独的表来记录线程控制与管理等信息，这张表称为线程控制表。</li><li>为了管理系统中的进程和线程，不但要有进程控制块，还要为每个线程设置一个线程控制块TCB。线程控制块由一个线程标识符和一张线程描述表组成，线程描述表记录了线程的属性和调度所需的数据。如线程状态、寄存器组（用于存放现场信息）、堆栈、以及有关调度和I&#x2F;O活动的信息。</li></ul><h5 id="3-线程控制"><a href="#3-线程控制" class="headerlink" title="3.线程控制"></a>3.线程控制</h5><ul><li>系统为了对线程进行管理，也提供了相应的线程控制原语，如线程的创建与撤销、阻塞与唤醒等。当应用程序启动执行时，首先被执行的线程称之为初始化线程，也叫做主线程。它可以根据需要再去创建若干线程。</li><li>一个线程可以通过调用创建原语来创建线程，线程创建原语要申请一个线程控制块，并初始化线程ID、线程描述表等其它有关项，排入就绪队列，最后返回一个线程标识符供以后使用。</li><li>当线程正常结束时会请求撤离，如果线程运行过程中出现错误或由于某种原因而被其它线程终止，线程也就随之消亡。撤销线程原语收回该线程的数据结构及线程控制块。</li><li>同样当线程请求某一事件时可以调用阻塞原语将自己置入阻塞态，当阻塞的事件发生，会被线程唤醒原语唤醒。</li></ul><h5 id="4-线程间的同步与通信"><a href="#4-线程间的同步与通信" class="headerlink" title="4.线程间的同步与通信"></a>4.线程间的同步与通信</h5><p>（常用的有互斥锁和信号量机制等）</p><p><strong>互斥锁</strong></p><ul><li>互斥锁是一种比较简单的同步机制，它有两种状态，即开锁和关锁状态。对互斥锁的操作命令有两条，即关锁命令（lock（L））和开锁命令（unlock（L））。由于操作互斥锁的时间和空间的开销都较少，因而它适合于频繁使用的共享数据和程序段。为共享数据设一把互斥锁L。每当线程去访问共享数据时，都先调用关锁命令lock（L），当它操作完共享数据时，再调用开锁命令。</li><li>为了减少线程被阻塞的机会，有的系统也提供互斥锁的测试操作trylock，该命令返回互斥锁的状态值。即若为开锁状态，返回一个成功码；若为关锁状态，则返回一个失败码，但并不阻塞线程。</li><li>为避免出现死锁现象，特设条件变量与一个互斥锁一起使用。</li><li>互斥锁用于短期锁定，保证对临界区互斥进入，而条件变量则用于线程的长期等待，直至所等待的资源成为可用的。</li></ul><p><strong>信号量机制</strong></p><ul><li>私用信号量用于同一进程下诸线程之间的同步。它可由请求同步的线程来创建，属于进程所有，存于进程的地址空间中，操作系统并不知道它的存在。</li><li>而公用信号量是为不同进程间或不同进程的线程之间的同步而设置的，其数据结构是存放在受保护的系统存储区中，由操作系统对它进行管理，故也称之为系统信号量。</li></ul><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><h5 id="线程类型：用户级线程、内核级线程以及混合型线程"><a href="#线程类型：用户级线程、内核级线程以及混合型线程" class="headerlink" title="线程类型：用户级线程、内核级线程以及混合型线程"></a>线程类型：用户级线程、内核级线程以及混合型线程</h5><ul><li><strong>用户级线程</strong>：是指由用户应用程序建立起来的线程，并且由用户应用程序负责所有这些用户级线程的调度执行和管理工作。而操作系统的内核完全不知道线程的存在，因而也不会参与线程的管理。用户级线程的切换发生在同一个进程的诸多线程之间，因为线程管理操作不需要内核介入，因而远比进程调度与切换好得多，切换速度也特别快。与常规的过程调用的代价是在同一量级上的。用户级线程还表现出很好的适应性。它们可以在不用修改内核的前提下，根据语言或用户的需要进行定制。</li><li>用户程序怎样才能搭建一个支持线程的运行环境呢？通常是由操作系统或某种语言如Java为用户提供一个基于多线程的用户应用程序开发环境和运行环境,称之为线程库（ThreadsLibrary），它可以支持所有用户线程的创建、调度和管理工作。操作系统首先为进入系统的程序创建一个由内核管理的进程，当该进程在线程库的环境下开始运行时，只有一个初始线程。随着主线程的执行，它可以调用线程库中的创建函数来生成新的线程。线程库按照一定的调度算法挑选就绪线程执行，并完成线程之间的切换、控制工作。</li><li><strong>系统仍然是以进程为单位进行调度的</strong>。故容易发生线程当前状态与实际状态不相吻合的情况，如某线程运行过程中请求I&#x2F;O，于是系统将该线程所在的进程置入阻塞状态。同一进程下的线程即使具备运行条件，也不会被调度；而当前线程理应是阻塞状态，但实际上仍是运行状态，因为系统不对线程进行操作。</li><li><strong>内核级线程</strong>：是指线程是在操作系统的支持下运行的，当应用程序进入内存时，内核首先为它创建一个进程和一个线程，线程运行过程中通过调用内核创建原语可以创建其它的线程。这种方式下，系统对线程的管理与传统操作系统下的进程管理是一样的。和用户级线程相比，内核支持级线程更为灵活，内核本身也可以采用线程实现。当进程中的一个线程被阻塞后，同一进程中的其它线程仍可以被调度执行。另外内核可以调度同一个进程中的若干线程到多个处理器上运行，从而提高程序执行速度和效率。但是它也有不足之处，因为线程的一切活动均由内核管理，因此即使是同一个进程下的线程之间的切换也要进行两次模式转换，所以其开销比较大。</li></ul><h5 id="比较两种线程的优缺点"><a href="#比较两种线程的优缺点" class="headerlink" title="比较两种线程的优缺点"></a>比较两种线程的优缺点</h5><ul><li>1．线程的调度与切换速度：内核支持线程的调度和切换与进程的调度和切换十分相似。</li><li>2．系统功能调用：当传统的用户进程调用一个系统功能调用时，要由用户态进入核心态，用户进程将被阻塞。当内核完成系统调用而返回时，才将该进程唤醒，继续执行。</li><li>3．线程执行时间 ：对于只设置了用户级线程的系统，调度是以进程为单位进行的。在采用轮转调度算法时，各个进程轮流执行一个时间片，这对诸进程而言似乎是公平的。</li></ul><h5 id="混合线程"><a href="#混合线程" class="headerlink" title="混合线程"></a>混合线程</h5><ul><li>⑴进程仍然是资源分配的基本单位，拥有用户地址空间、堆栈和PCB等。</li><li>⑵用户级线程是由线程库来管理的，其数目可以很多，每个仅需一个栈和程序计数器。内核并不知道它的存在，故不受内核调度程序的调度，因此切换很快。</li><li>⑶内核级线程完成内核的所有工作，是被调度并分派到一个处理机上执行的实体。</li><li>⑷轻型进程（LightWeight Process－LWP）是用户级线程和内核级线程之间的接口，可以看成是被内核创建的用户级线程。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java入门面向对象</title>
    <link href="/20200721/2d17972e/"/>
    <url>/20200721/2d17972e/</url>
    
    <content type="html"><![CDATA[<p>有关Java面向对象的基础知识笔记——摘自【实验楼】</p><span id="more"></span><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>对于一个具体的对象而言，比如一部 iPhone 6，世上还有许多跟这部手机有着同样属性或行为的对象，我们为了方便将它们归类起来，提取出他们相同的属性和行为，而我们把归类起来的这个抽象的概念，称之为类。</p><p>比如每个人就是一个对象，小张是一个对象，小明是一个对象。而每个人虽然不同，但却有许多相同的属性和行为，于是我们可以把他们抽象出来，变成一个类，比如人类。</p><p>类是封装对象的属性和行为的载体，反过来说具有相同属性和行为的一类实体被称为类。</p><p>由此可以总结出<strong>类的定义</strong>：</p><ol><li>类是相同或相似对象的一种抽象，是对象的一个模板，它描述一类对象的行为和状态。</li><li>类是具有相同属性和方法（行为）的对象的集合</li></ol><p>我们在上面反复强调对象的属性和行为，什么是对象的属性呢？什么又是对象的行为呢？</p><p><strong>属性</strong>是对象具有的特征。每个对象的每个属性都拥有特定值。我们上面讲过对象是一个具体并且确定的事物，正是对象属性的值来区分不同的对象，比如我们可以通过一个人的外貌特征区分他。</p><p>那什么是对象的<strong>行为</strong>呢？在计算机中我们通过方法去实现对象的行为，而对象的方法便是对象所具有的操作，比如人会走路、会哭泣、会学习等等都是人的行为，也就是人的方法。</p><p>类和对象之间有什么关系吗？在上面的讲解中大家应该有些了解了。类就是对象的抽象（或者模板），对象就是类的具体（或者实例）。比如手机是一个抽象的概念，它代表着类。而一部 iPhone 6 便是手机具象化处理的实体，也就是一个对象。</p><p>说了那么多，那我们如何在计算机中定义一个类，如何实现一个类呢？</p><p>我们以前说过，Java 是面向对象的语言，而他的体现就在于 Java 程序都以类 class 为组织单元。而一个类是对象的抽象，所以类由属性和方法两部分组成。</p><p><strong>定义一个类</strong>，主要有三个步骤：</p><p>1、定义类名，用于区分不同的类。如下代码中 <code>public class</code> 后面跟的就是类名。<code>class</code>是声明类的关键字，类名后面跟上大括号，大括号里面就是类的一些信息。<code>public</code> 为权限修饰符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 类名 &#123;<br>    <span class="hljs-comment">//定义属性部分（成员变量）</span><br>    属性<span class="hljs-number">1</span>的类型 属性<span class="hljs-number">1</span>;<br>    属性<span class="hljs-number">2</span>的类型 属性<span class="hljs-number">2</span>;<br>    ...<br>    <span class="hljs-comment">//定义方法部分</span><br>    方法<span class="hljs-number">1</span><br>    方法<span class="hljs-number">2</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>2、编写类的属性。对象有什么，需要通过属性来表示。属性的定义是写在类名后面的大括号里，在定义属性时，要明确属性的类型。在一个类当中可以写一个或多个属性。当然也可以不定义属性。</p><p>3、编写类的方法。方法也是写在大括号里面。可以定义一个方法或多个方法，当然也可以不定义方法。</p><p>在 <code>home/project/</code> 目录下新建文件 <code>People.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br><span class="hljs-comment">//属性（成员变量） 有什么</span><br>    <span class="hljs-type">double</span> height;  <span class="hljs-comment">//身高</span><br>    <span class="hljs-type">int</span> age;     <span class="hljs-comment">//年龄</span><br>    <span class="hljs-type">int</span> sex;    <span class="hljs-comment">//性别，0为男性，非0为女性</span><br><br><span class="hljs-comment">//方法 干什么</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我在哭！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">laugh</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我在笑！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printBaseMes</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我的身高是&quot;</span>+height+<span class="hljs-string">&quot;cm&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;我的年龄是&quot;</span>+age+<span class="hljs-string">&quot;岁&quot;</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.sex==<span class="hljs-number">0</span>)<br>            System.out.println(<span class="hljs-string">&quot;我是男性！&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">&quot;我是女性！&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个类可以包含以下<strong>类型变量</strong>：</p><ul><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li>类变量：也叫静态变量，类变量也声明在类中，方法体之外，但必须声明为 <code>static</code> 类型。</li></ul><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>创建对象的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名 对象名 = <span class="hljs-keyword">new</span> 类名();<br></code></pre></td></tr></table></figure><p>比如对 <code>People</code>这个类，我想实例化<code>LiLei</code>这个人。<code>LiLei</code> 的数据类型便是 <code>People</code> 这个类型。（类可以看成使我们自己定义的数据类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">People</span> <span class="hljs-variable">LiLei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();<br></code></pre></td></tr></table></figure><p>定义类的时候不会为类开辟内存空间，但是一旦创建了对象，系统就会在内存中为对象开辟一块空间，用来存放对象的属性值和方法。新建一个 NewObject.java 文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewObject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">LiLei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(); <span class="hljs-comment">//创建一个People对象LiLei</span><br><br>        LiLei.height =<span class="hljs-number">170</span>;<br>        LiLei.age = <span class="hljs-number">20</span>;<br>        LiLei.sex = <span class="hljs-number">1</span>;<br><br>        LiLei.printBaseMes();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">javac NewObject.java People.java</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">java NewObject</span><br>我的身高是170.0cm<br>我的年龄是20岁<br>我是女性！<br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1062timestamp1434617083799.png" alt="为对象分配内存"></p><p>创建对象后，我们就要使用对象了，使用对象无非就是对属性和方法进行操作和调用。语法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//引用对象属性</span><br>对象名.属性<br><br><span class="hljs-comment">//引用对象方法</span><br>对象名.方法<br></code></pre></td></tr></table></figure><p>例如对 LiLei 的身高（<code>length</code>）赋值，并调用 <code>cry</code> 这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">LiLei.height = <span class="hljs-number">170</span>;<br>LiLei.cry();<br></code></pre></td></tr></table></figure><p>刚刚我们引入了成员变量这个概念，那什么是成员变量呢？成员变量就是指的对象的属性，是在类中定义，来描述对象的特性。还有一种变量叫局部变量，它是由类的方法定义，在方法中临时保存数据。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1062timestamp1434619940542.png" alt="成员变量和局部变量"></p><p>在使用时注意，成员变量可以被本类的所有方法所使用，同时可以被与本类有关的其他类所使用。而局部变量只能在当前的方法中使用。</p><p>在这里我们要讲到一个关于作用域的知识了。作用域可以简单地理解为变量的生存期或者作用范围，也就是变量从定义开始到什么时候消亡。</p><ol><li>局部变量的作用域仅限于定义它的方法内。而成员变量的作用域在整个类内部都是可见的。</li><li>同时在相同的方法中，不能有同名的局部变量；在不同的方法中，可以有同名的局部变量。</li><li>成员变量和局部变量同名时，局部变量具有更高的优先级。 大家可以编写代码验证一下。</li></ol><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在面向对象中有一个非常重要的知识点，就是构造方法。每个类都有构造方法，在创建该类的对象的时候他们将被调用，如果没有定义构造方法，Java 编译器会提供一个默认构造方法。 创建一个对象的时候，至少调用一个构造方法。比如在新建一个对象 <code>new Object()</code>，括号中没有任何参数，代表调用一个无参构造方法（默认构造方法就是一个无参构造方法）。构造方法的名称必须与类名相同，一个类可以定义多个构造方法。</p><p>构造方法的具体内容：</p><p>1、构造方法的名称与类名相同，且没有返回值。它的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//与类同名，可以指定参数，没有返回值</span><br><span class="hljs-keyword">public</span> 构造方法名()&#123;<br><span class="hljs-comment">//初始化代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个构造方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-comment">//无参构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-comment">//有一个参数的构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>又例如具体的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br><span class="hljs-comment">//属性（成员变量）有什么</span><br>    <span class="hljs-type">double</span> height;     <span class="hljs-comment">//身高</span><br>    <span class="hljs-type">int</span> age;           <span class="hljs-comment">//年龄</span><br>    <span class="hljs-type">int</span> sex;       <span class="hljs-comment">//性别，0为男性，非0为女性</span><br><br>    <span class="hljs-comment">//构造函数，初始化了所有属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">(<span class="hljs-type">double</span> h, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> s)</span>&#123;<br>        height = h;<br>        age = a;<br>        sex = s;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//创建对象，调用我们自己定义的有参构造方法</span><br><span class="hljs-type">People</span> <span class="hljs-variable">XiaoMing</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(<span class="hljs-number">168</span>, <span class="hljs-number">21</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>上面的例子中通过 <code>new</code> 关键字将类实例化成对象，而 <code>new</code> 后面跟的就是构造方法。于是可以知道 <code>new + 构造方法</code> 可以创建一个新的对象。</p><p>2、如果在定义类的时候没有写构造方法，系统会默认生成一个无参构造方法，这个构造方法什么也不会做。</p><p>3、当有指定的构造方法时，系统都不会再添加无参构造方法了。</p><p>4、构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法。</p><h3 id="静态static"><a href="#静态static" class="headerlink" title="静态static"></a>静态static</h3><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>Java 中被 <code>static</code> 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。</p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String string=<span class="hljs-string">&quot;shiyanlou&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//静态成员不需要实例化 直接就可以访问</span><br>        System.out.println(StaticTest.string);<br>        <span class="hljs-comment">//如果不加static关键字 需要这样访问</span><br>        StaticTest staticTest=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticTest</span>();<br>        System.out.println(staticTest.string);<br>        <span class="hljs-comment">//如果加上static关键字，上面的两种方法都可以使用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>被 <code>static</code> 修饰的方法是静态方法，静态方法不依赖于对象，不需要将类实例化便可以调用，由于不实例化也可以调用，所以不能有 <code>this</code>，也不能访问非静态成员变量和非静态方法。但是非静态成员变量和非静态方法可以访问静态方法。</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><code>final</code> 关键字可以修饰类、方法、属性和变量</p><ol><li><code>final</code> 修饰类，则该类不允许被继承，为最终类</li><li><code>final</code> 修饰方法，则该方法不允许被覆盖（重写）</li><li><code>final</code> 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）</li><li>final 修饰变量，则该变量的值只能赋一次值，即常量</li></ol><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//静态常量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String SHI_YAN_LOU=<span class="hljs-string">&quot;shiyanlou&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>代码中经常用到 <code>private</code> 和 <code>public</code> 修饰符，权限修饰符可以用来修饰属性和方法的访问范围。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1072timestamp1434941168916.png" alt="访问范围"></p><p>如图所示，代表了不同的访问修饰符的访问范围，比如 <code>private</code> 修饰的属性或者方法，只能在当前类中访问或者使用。<code>默认</code> 是什么修饰符都不加，默认在当前类中和同一包下都可以访问和使用。<code>protected</code> 修饰的属性或者方法，对同一包内的类和所有子类可见。<code>public</code> 修饰的属性或者方法，对所有类可见。</p><p>我们可以举一个例子，比如 <code>money</code>，如果我们用 <code>private</code> 修饰代表着这是私有的，只能我自己可以使用。如果是 <code>protected</code> 代表着我可以使用，和我有关系的人，比如儿子也可以用。如果是 <code>public</code> 就代表了所有人都可以使用。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别</p></blockquote><p>这样做有什么好处？</p><ol><li>只能通过规定的方法访问数据。</li><li>隐藏类的实例细节，方便修改和实现。</li></ol><p>我们在开汽车的时候，只用去关注如何开车，我们并不在意车子是如何实现的，这就是封装。</p><p>如何去实现类的封装呢？</p><ol><li>修改属性的可见性，在属性的前面添加修饰符 (<code>private</code>)</li><li>对每个值属性提供对外的公共方法访问，如创建 getter&#x2F;setter（取值和赋值）方法，用于对私有属性的访问</li><li>在 getter&#x2F;setter 方法里加入属性的控制语句，例如我们可以加一个判断语句，对于非法输入给予否定。</li></ol><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1072timestamp1434933673483.png" alt="封装的步骤"></p><p>如果我们没有在属性前面添加任何修饰符，我们通过对象就可以直接对属性值进行修改，没有体现封装的特性。这在许多程序设计中都是不安全的，所以我们需要利用封装，来改进我们的代码。</p><p>首先在类里要将属性前添加 <code>private</code> 修饰符。然后定义 <code>getter</code> 和 <code>setter</code> 方法。修改 <code>People.java</code> 和 <code>NewObject.java</code> 的内容如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-comment">//属性（成员变量）有什么，前面添加了访问修饰符private</span><br>    <span class="hljs-comment">//变成了私有属性，必须通过方法调用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;     <span class="hljs-comment">//身高</span><br><br>    <span class="hljs-comment">//属性已经封装好了，如果用户需要调用属性</span><br>    <span class="hljs-comment">//必须用getter和setter方法进行调用</span><br>    <span class="hljs-comment">//getter和setter方法需要程序员自己定义</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//getter 方法命名是get关键字加属性名（属性名首字母大写）</span><br>    <span class="hljs-comment">//getter 方法一般是为了得到属性值</span><br>      <span class="hljs-keyword">return</span> height;<br>    &#125;<br><br>    <span class="hljs-comment">//同理设置我们的setter方法</span><br>    <span class="hljs-comment">//setter 方法命名是set关键字加属性名（首字母大写）</span><br>    <span class="hljs-comment">//setter 方法一般是给属性值赋值，所以有一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeight</span><span class="hljs-params">(<span class="hljs-type">double</span> newHeight)</span>&#123;<br>      height = newHeight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在 <code>main</code> 函数里的对象，不能再直接调用属性了，只能通过 <code>getter</code> 和 <code>setter</code> 方法进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewObject</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">LiLei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();    <span class="hljs-comment">//创建了一个People对象LiLei</span><br><br>        <span class="hljs-comment">//利用setter方法为属性赋值</span><br>        LiLei.setHeight(<span class="hljs-number">170.0</span>);<br><br>        <span class="hljs-comment">//利用getter方法取属性值</span><br>        System.out.println(<span class="hljs-string">&quot;LiLei的身高是&quot;</span>+LiLei.getHeight());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac NewObject.java People.java<br>java NewObject.java<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac NewObject.java People.java<br>$ java NewObject<br>LiLei的身高是170.0<br></code></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><code>this</code> 关键字代表当前对象。使用 <code>this.属性</code> 操作当前对象的属性，<code>this.方法</code> 调用当前对象的方法。</p><p>用 <code>private</code> 修饰的属性，必须定义 getter 和 setter 方法才可以访问到 (Eclipse 和 IDEA 等 IDE 都有自动生成 getter 和 setter 方法的功能）。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建好了 getter 和 setter 方法后，我们发现方法中参数名和属性名一样。</p><p>当成员变量和局部变量之间发生冲突时，在属性名前面添加了 <code>this</code> 关键字。 此时就代表将一个参数的值赋给当前对象的属性。同理 <code>this</code> 关键字可以调用当前对象的方法，同学们自行验证一下吧。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承可以看成是类与类之间的衍生关系。比如狗类是动物类，牧羊犬类又是狗类。于是我们可以说狗类继承了动物类，而牧羊犬类就继承了狗类。于是狗类就是动物类的子类（或派生类），动物类就是狗类的父类（或基类）。</p><p>所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">class 子类 extends 父类<br></code></pre></td></tr></table></figure><p>例如我们定义了一个 Animal 类，再创建一个 Dog 类，我们需要它继承 Animal 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们就来练习一下吧！</p><p>我们先创建一个父类 <code>Animal.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> legNum;     <span class="hljs-comment">//动物四肢的数量</span><br><br>    <span class="hljs-comment">//类方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;动物叫！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来创建一个子类<code>Dog.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dog 类继承了父类 Animal，我们 Dog 类里什么都没有写，其实它继承了父类 Animal，所以 Dog 类拥有 Animal 类的全部方法和属性（除开 private 方法和属性）。我们创建一个测试类测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        a.legNum = <span class="hljs-number">4</span>;<br>        a.bark();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Test.java Animal.java Dog.java<br>$ java Test<br>动物叫！<br></code></pre></td></tr></table></figure><p><strong>为什么需要继承？</strong></p><p>如果有两个类相似，那么它们会有许多重复的代码，导致后果就是代码量大且臃肿，后期的维护性不高。通过继承就可以解决这个问题，将两段代码中相同的部分提取出来组成一个父类，实现代码的复用。</p><p><strong>继承的特点</strong>：</p><ul><li>子类拥有父类除 <code>private</code> 以外的所有属性和方法。</li><li>子类可以拥有自己的属性和方法。</li><li>子类可以重写实现父类的方法。</li><li>Java 中的继承是单继承，一个类只有一个父类。</li></ul><blockquote><p>注：Java 实现多继承的一个办法是 <code>implements</code>（实现）接口，但接口不能有非静态的属性，这一点请注意。</p></blockquote><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code> 关键字在子类内部使用，代表父类对象。</p><ol><li>访问父类的属性 <code>super.属性名</code>。</li><li>访问父类的方法 <code>super.bark()</code>。</li><li>子类构造方法需要调用父类的构造方法时，在子类的构造方法体里<strong>最前面</strong>的位置：<code>super()</code>。</li></ol><h3 id="方法重载与重写"><a href="#方法重载与重写" class="headerlink" title="方法重载与重写"></a>方法重载与重写</h3><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。方法重载一般用于创建一组任务相似但是参数不同的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">float</span> f)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;f=&quot;</span> + f);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;s=&quot;</span> + s);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(String s1, String s2)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;s1+s2=&quot;</span>+(s1+s2));<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;s=&quot;</span>+s+<span class="hljs-string">&quot;,i=&quot;</span>+i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        test.f(<span class="hljs-number">3456</span>);<br>        test.f(<span class="hljs-number">34.56f</span>);<br>        test.f(<span class="hljs-string">&quot;abc&quot;</span>);<br>        test.f(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>);<br>        test.f(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-number">3456</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Test.java<br>$ java Test<br>i=3456<br>f=34.56<br>s=abc<br>s1+s2=abcdef<br>s=abc,i=3456<br></code></pre></td></tr></table></figure><p>方法重载有以下几种规则：</p><ul><li>方法中的参数列表必须不同。比如：参数个数不同或者参数类型不同。</li><li>重载的方法中允许抛出不同的异常</li><li>可以有不同的返回值类型，但是参数列表必须不同。</li><li>可以有不同的访问修饰符。</li></ul><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>子类可以继承父类的方法，但如果子类对父类的方法不满意，想在里面加入适合自己的一些操作时，就需要将方法进行重写。并且子类在调用方法中，优先调用子类的方法。</p><p>比如 <code>Animal</code> 类中有 <code>bark()</code> 这个方法代表了动物叫，但是不同的动物有不同的叫法，比如狗是汪汪汪，猫是喵喵喵。</p><p>当然在方法重写时要注意，重写的方法一定要与原父类的方法语法保持一致，比如返回值类型，参数类型及个数，和方法名都必须一致。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">//类方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;动物叫！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>       <span class="hljs-comment">//重写父类的bark方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;汪！汪！汪！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写个测试类来看看输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>           <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(); <span class="hljs-comment">// Animal 对象</span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();   <span class="hljs-comment">// Dog 对象</span><br><br>          <span class="hljs-type">Animal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// Dog 对象,向上转型为Animal类型，具体会在后面的内容进行详解</span><br><br>          a.bark();<span class="hljs-comment">// 执行 Animal 类的方法</span><br>         d.bark();<span class="hljs-comment">//执行 Dog 类的方法</span><br>          b.bark();<span class="hljs-comment">//执行 Dog 类的方法</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Test.java Dog.java Animal.java<br>$ java Test<br>动物叫！<br>汪！汪！汪！<br>汪！汪！汪！<br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p><p>通俗地讲，只通过父类就能够引用不同的子类，这就是多态，我们只有在运行的时候才会知道引用变量所指向的具体实例对象。</p><h4 id="多态的实现条件"><a href="#多态的实现条件" class="headerlink" title="多态的实现条件"></a>多态的实现条件</h4><p><strong>Java 实现多态有三个必要条件：继承、重写和向上转型（即父类引用指向子类对象）。</strong></p><p>只有满足上述三个条件，才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p><h4 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h4><p>Java 中多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现。</p><h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><p>要理解多态必须要明白什么是”向上转型”，比如，一段代码如下，Dog 类是 Animal 类的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();  <span class="hljs-comment">//a是父类的引用指向的是本类的对象</span><br><br><span class="hljs-type">Animal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">//b是父类的引用指向的是子类的对象</span><br></code></pre></td></tr></table></figure><p>在这里，可以认为由于 Dog 继承于 Animal，所以 Dog 可以自动向上转型为 Animal，所以 <code>b</code> 是可以指向 Dog 实例对象的。</p><blockquote><p>注：不能使用一个子类的引用去指向父类的对象，因为子类对象中可能会含有父类对象中所没有的属性和方法。</p><p>我的理解：例如 Animal属性leg、方法bark()，而在Dog中有方法eatShit()，如果写成Dog dd &#x3D; new Animal();那么dd的eatShit方法无法创建，就会报错 </p></blockquote><p>如果定义了一个指向子类对象的父类引用类型，那么它除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能。但是对于只存在于子类的方法和属性就不能获取。</p><p>新建一个 <code>Test.java</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">//父类方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;动物叫！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br><br>    <span class="hljs-comment">//子类重写父类的bark方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;汪、汪、汪！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//子类自己的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dogType</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是什么品种的狗？&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><br>        a.bark();<br>        b.bark();<br>        <span class="hljs-comment">//b.dogType();</span><br>        <span class="hljs-comment">//b.dogType()编译不通过</span><br>        d.bark();<br>        d.dogType();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Test.java<br>$ java Test<br>动物叫！<br>汪、汪、汪！<br>汪、汪、汪！<br>这是什么品种的狗？<br></code></pre></td></tr></table></figure><p>在这里，由于 <code>b</code> 是父类的引用，指向子类的对象，因此不能获取子类的方法（<code>dogType()</code> 方法）, 同时当调用 <code>bark()</code> 方法时，由于子类重写了父类的 <code>bark()</code> 方法，所以调用子类中的 <code>bark()</code> 方法。</p><p>我的理解：Animal自己是没有dogType方法的，所以<code>Animal b = new dog()</code>创建的Animal只能创建出Animal和Dog共有的，并且是Dog的内容！ </p><p><strong>因此，向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法，也会覆盖与父类中相同的方法——重写（方法名，参数都相同）。</strong></p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在定义类时，前面加上 <code>abstract</code> 关键字修饰的类叫抽象类。</p><p>抽象类中有抽象方法，这种方法是不完整的，仅有声明而没有方法体。抽象方法声明语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//f()方法是抽象方法</span><br></code></pre></td></tr></table></figure><p>那我们什么时候会用到抽象类呢？</p><ol><li>在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。也就是说抽象类是约束子类必须要实现哪些方法，而并不关注方法如何去实现。</li><li>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。</li></ol><p>所以由上可知，<strong>抽象类是限制规定子类必须实现某些方法，但不关注实现细节。</strong></p><p>那抽象类如何用代码实现呢，它的规则如下：</p><ol><li>用 <code>abstract</code> 修饰符定义抽象类。</li><li>用 <code>abstract</code> 修饰符定义抽象方法，只用声明，不需要实现。</li><li>包含抽象方法的类就是抽象类。</li><li>抽象类中可以包含普通的方法，也可以没有抽象方法。</li><li>抽象类的对象不能直接创建，通常是定义引用变量指向子类对象。</li></ol><p>我们来写一写代码吧！</p><p>1、在 <code>home/project/</code> 目录下创建一个抽象类 <code>TelePhone.java</code>。</p><p>2、填写需要子类实现的抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TelePhone</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//抽象方法,打电话</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">message</span><span class="hljs-params">()</span>; <span class="hljs-comment">//抽象方法，发短信</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3、构建子类，并实现抽象方法。新建一个 <code>CellPhone.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CellPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TelePhone</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我可以打电话！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">message</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我可以发短信！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CellPhone</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CellPhone</span>();<br>        cp.call();<br>        cp.message();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 CellPhone 类添加 <code>main</code> 方法测试运行结果。</p><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac CellPhone.java TelePhone.java<br>$ java CellPhone<br><br>我可以打电话！<br>我可以发短信！<br></code></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口用于描述类所具有的功能，而不提供功能的实现，功能的实现需要写在实现接口的类中，并且该类必须实现接口中所有的未实现方法。</p><p>接口的声明语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 interface 接口名称 [extends 其他的接口名] &#123;<br>        <span class="hljs-comment">// 声明变量</span><br>        <span class="hljs-comment">// 抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如声明一个 Animal 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Animal.java</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>        <span class="hljs-comment">//int x;</span><br>        <span class="hljs-comment">//编译错误,x需要初始化，因为是 static final 类型</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">travel</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意点</strong></p><p>在 Java8 中：</p><ul><li>接口不能用于实例化对象。</li><li>接口中方法只能是抽象方法、<code>default</code> 方法、静态方法。</li><li>接口成员是 <code>static final</code> 类型。</li><li>接口支持多继承。</li></ul><p>在 Java9 中，接口可以拥有私有方法和私有静态方法，但是只能被该接口中的 <code>default</code> 方法和静态方法使用。</p><p>多继承实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> extends 接口<span class="hljs-number">1</span>，接口<span class="hljs-number">2</span>&#123;<br><br>&#125;<br><br>修饰符 <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> implements 接口<span class="hljs-number">1</span>，接口<span class="hljs-number">2</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实现上面的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Cat.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;Cat eats&quot;</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">travel</span><span class="hljs-params">()</span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;Cat travels&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        cat.eat();<br>        cat.travel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Cat.java Animal.java<br>$ java Cat<br>Cat eats<br>Cat travels<br></code></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>将一个类的定义放在另一个类的定义内部，这就是内部类。而包含内部类的类被称为外部类。</p><p>内部类的主要作用如下：</p><ol><li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</li><li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据</li><li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便</li><li>内部类允许继承多个非接口类型（具体将在以后的内容进行讲解）</li></ol><blockquote><p>注：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为 outer 的外部类和其内部定义的名为 inner 的内部类。编译完成后出现 <code>outer.class</code> 和 <code>outer$inner.class</code> 两类。所以内部类的成员变量 &#x2F; 方法名可以和外部类的相同。</p></blockquote><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// People.java</span><br><span class="hljs-comment">//外部类People</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LiLei&quot;</span>;         <span class="hljs-comment">//外部类的私有属性</span><br>    <span class="hljs-comment">//内部类Student</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20151234&quot;</span>;               <span class="hljs-comment">//内部类的成员属性</span><br>        <span class="hljs-comment">//内部类的方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stuInfo</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;访问外部类中的name：&quot;</span> + name);<br>            System.out.println(<span class="hljs-string">&quot;访问内部类中的ID：&quot;</span> + ID);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//测试成员内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();     <span class="hljs-comment">//创建外部类对象，对象名为a</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(); <span class="hljs-comment">//使用外部类对象创建内部类对象，对象名为b</span><br>        <span class="hljs-comment">// 或者为 People.Student b = a.new Student();</span><br>        b.stuInfo();   <span class="hljs-comment">//调用内部对象的suInfo方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac People.java<br>$ java People<br>访问外部类中的name：LiLei<br>访问内部类中的ID：20151234<br></code></pre></td></tr></table></figure><p>成员内部类的使用方法：</p><ol><li>Student 类相当于 People 类的一个成员变量，所以 Student 类可以使用任意访问修饰符。</li><li>Student 类在 People 类里，所以访问范围在类里的所有方法均可以访问 People 的属性（即内部类里可以直接访问外部类的方法和属性，反之不行）。</li><li>定义成员内部类后，必须使用外部类对象来创建内部类对象，即 <code>内部类 对象名 = 外部类对象.new 内部类();</code>。</li><li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 <code>this</code> 关键字。如上述代码中：<code>a.this</code>。</li></ol><blockquote><p>注：成员内部类不能含有 <code>static</code> 的变量和方法，因为成员内部类需要先创建了外部类，才能创建它自己的。</p></blockquote><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类通常被称为嵌套类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// People.java</span><br><span class="hljs-comment">//外部类People</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LiLei&quot;</span>;         <span class="hljs-comment">//外部类的私有属性</span><br><br><span class="hljs-comment">/*外部类的静态变量。</span><br><span class="hljs-comment">Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;510xxx199X0724XXXX&quot;</span>;<br><br>    <span class="hljs-comment">//静态内部类Student</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20151234&quot;</span>;               <span class="hljs-comment">//内部类的成员属性</span><br>        <span class="hljs-comment">//内部类的方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stuInfo</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;访问外部类中的name：&quot;</span> + (<span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>().name));<br>            System.out.println(<span class="hljs-string">&quot;访问外部类中的ID：&quot;</span> + People.ID);<br>            System.out.println(<span class="hljs-string">&quot;访问内部类中的ID：&quot;</span> + ID);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//测试成员内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();   <span class="hljs-comment">//直接创建内部类对象，对象名为b</span><br>        b.stuInfo();                 <span class="hljs-comment">//调用内部对象的suInfo方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac People.java<br>$ java People<br>访问外部类中的name：LiLei<br>访问外部类中的ID：510xxx199X0724XXXX<br>访问内部类中的ID：20151234<br></code></pre></td></tr></table></figure><p>静态内部类是 <code>static</code> 修饰的内部类，这种内部类的特点是：</p><ol><li>静态内部类不能直接访问外部类的非静态成员，但可以通过 <code>new 外部类().成员</code> 的方式访问。</li><li>如果外部类的静态成员与内部类的成员名称相同，可通过 <code>类名.静态成员</code> 访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过 <code>成员名</code> 直接调用外部类的静态成员。</li><li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 <code>内部类 对象名 = new 内部类();</code>。</li></ol><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类，是指内部类定义在方法和作用域内。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// People.java</span><br><span class="hljs-comment">//外部类People</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-comment">//定义在外部类中的方法内：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">peopleInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;man&quot;</span>;  <span class="hljs-comment">//外部类方法中的常量</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20151234&quot;</span>; <span class="hljs-comment">//内部类中的常量</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;访问外部类的方法中的常量sex：&quot;</span> + sex);<br>                System.out.println(<span class="hljs-string">&quot;访问内部类中的变量ID:&quot;</span> + ID);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();  <span class="hljs-comment">//创建方法内部类的对象</span><br>        a.print();<span class="hljs-comment">//调用内部类的方法</span><br>    &#125;<br>    <span class="hljs-comment">//定义在外部类中的作用域内</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">peopleInfo2</span><span class="hljs-params">(<span class="hljs-type">boolean</span> b)</span> &#123;<br>        <span class="hljs-keyword">if</span>(b)&#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;man&quot;</span>;  <span class="hljs-comment">//外部类方法中的常量</span><br>            <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20151234&quot;</span>; <span class="hljs-comment">//内部类中的常量</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;访问外部类的方法中的常量sex：&quot;</span> + sex);<br>                    System.out.println(<span class="hljs-string">&quot;访问内部类中的变量ID:&quot;</span> + ID);<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">Student</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();  <span class="hljs-comment">//创建方法内部类的对象</span><br>            a.print();<span class="hljs-comment">//调用内部类的方法</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//测试方法内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(); <span class="hljs-comment">//创建外部类的对象</span><br>        System.out.println(<span class="hljs-string">&quot;定义在方法内：===========&quot;</span>);<br>        b.peopleInfo();  <span class="hljs-comment">//调用外部类的方法</span><br>        System.out.println(<span class="hljs-string">&quot;定义在作用域内：===========&quot;</span>);<br>        b.peopleInfo2(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac People.java<br>$ java People<br>定义在方法内：===========<br>访问外部类的方法中的常量sex：man<br>访问内部类中的变量ID:20151234<br>定义在作用域内：===========<br>访问外部类的方法中的常量sex：man<br>访问内部类中的变量ID:20151234<br></code></pre></td></tr></table></figure><p>局部内部类也像别的类一样进行编译，但只是作用域不同而已，只在该方法或条件的作用域内才能使用，退出这些作用域后无法引用的。</p><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类，顾名思义，就是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Outer.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, String city)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">nameStr</span> <span class="hljs-operator">=</span> name;<br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> nameStr;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.getInner(<span class="hljs-string">&quot;Inner&quot;</span>, <span class="hljs-string">&quot;NewYork&quot;</span>);<br>        System.out.println(inner.getName());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inner</span> &#123;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：Inner。</p><p>匿名内部类是<strong>不能加访问修饰符</strong>的。要注意的是，new 匿名类，这个类是要先定义的, 如果不先定义，编译时会报错该类找不到。</p><p>同时，在上面的例子中，当所在的方法的形参需要在内部类里面使用时，该形参必须为 <code>final</code>。这里可以看到形参 <code>name</code> 已经定义为 <code>final</code> 了，而形参 <code>city</code> 没有被使用则不用定义为 <code>final</code>。</p><p>然而，因为匿名内部类没名字，是用默认的构造函数的，无参数的，如果需要该类有带参数的构造函数，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, String city)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(name, city) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">nameStr</span> <span class="hljs-operator">=</span> name;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> nameStr;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的形参 <code>city</code>，由于它没有被匿名内部类直接使用，而是被抽象类 Inner 的构造函数所使用，所以不必定义为 <code>final</code>。</p><h3 id="包Package"><a href="#包Package" class="headerlink" title="包Package"></a>包Package</h3><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。</p><p><strong>包的作用</strong></p><ul><li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li><li>包采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。</li><li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li></ul><p>定义包语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 包名<br><span class="hljs-comment">//注意：必须放在源程序的第一行，包名可用&quot;.&quot;号隔开</span><br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在定义文件夹的时候利用&quot;/&quot;来区分层次</span><br><span class="hljs-comment">//包中用&quot;.&quot;来分层</span><br><span class="hljs-keyword">package</span> com.shiyanlou.java<br></code></pre></td></tr></table></figure><p>不仅是我们这样利用包名来区分类，系统也是这样做的。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1072timestamp1434937042272.png" alt="Java系统中的包"></p><p><strong>如何在不同包中使用另一个包中的类？</strong></p><p>使用 <code>import</code> 关键字。比如要导入包 <code>com.shiyanlou</code> 下 <code>People</code> 这个类，<code>import com.shiyanlou.People;</code>。同时如果 <code>import com.shiyanlou.*;</code> 这是将包下的所有文件都导入进来，<code>*</code> 是通配符。</p><p><strong>包的命名规范是全小写字母拼写</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java入门基础语法</title>
    <link href="/20200721/98c92646/"/>
    <url>/20200721/98c92646/</url>
    
    <content type="html"><![CDATA[<h2 id="Java基础语法-上"><a href="#Java基础语法-上" class="headerlink" title="Java基础语法(上)"></a>Java基础语法(上)</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量可以指在计算机存储器里存在值的被命名的存储空间。</p><p>变量通常是可被修改的，即可以用来表示可变的状态。这是 Java 的基本概念之一。</p><p>程序通过改变变量的值来改变整个程序的状态。为了方便使用变量，所以变量都需要命名，叫做<strong>变量名</strong>。</p><p>在 Java 中，变量需要先声明 (declare) 才能使用。在声明中，说明变量的类型，赋予变量以特别名字，以便在后面的程序中调用它。你可以在程序中的任意位置声明变量，语法格式如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">数据类型 变量名称;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>在该语法格式中，数据类型可以是 Java 语言中任意的类型，如 <code>int</code>。变量名称是该变量的标识符，需要符合标识符的命名规则，数据类型和变量名称之间使用空格进行间隔，使用 <code>;</code> 作为结束。</p><p>在 <code>/home/project/</code> 新建一个 <code>VarTest.java</code> 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VarTest</span><br>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>  &#123;<br>    System.out.println(<span class="hljs-string">&quot;Define a variable a is &quot;</span>);<br>    <span class="hljs-type">int</span> a; <span class="hljs-comment">//声明变量a</span><br>    a = <span class="hljs-number">5</span>;<br>    System.out.println(a);  <span class="hljs-comment">// 打印一个整数a</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac VarTest.java<br>$ java VarTest<br>Define a variable a is<br>5<br></code></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量代表程序运行过程中不能改变的值。我们也可以把它们理解为特殊的变量，只是它们在程序的运行过程中是不允许改变的。<strong>常量的值是不能被修改的</strong>。</p><p>Java 中的 <code>final</code> 关键字可以用于声明属性（常量），方法和类。当 <code>final</code> 修饰属性时，代表该属性一旦被分配内存空间就必须初始化，它的含义是“这是无法改变的”或者“终态的”。在变量前面添加关键字 <code>final</code> 即可声明一个常量。在 Java 编码规范中，要求常量名必须大写。</p><p>语法格式：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">final 数据类型 常量名 = 值;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p>常量也可以先声明，再进行赋值，但只能赋值一次，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> FINAL_VARIABLE;<br>FINAL_VARIABLE = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>在 <code>/home/project/</code> 下新建一个 <code>FinalVar.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalVar</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">final</span> String FINAL_STRING=<span class="hljs-string">&quot;shiyanlou&quot;</span>;<br>        System.out.println(FINAL_STRING);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac FinalVar.java<br>$ java FinalVar<br>shiyanlou<br></code></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Java 中一共八种基本数据类型，下表列出了基本数据类型的数据范围、存储格式、默认值和包装类型等。</p><table><thead><tr><th>数据类型</th><th>默认值</th><th>存储格式</th><th>数据范围</th><th>包装类型</th></tr></thead><tbody><tr><td>short</td><td>0</td><td>2 个字节</td><td>-32,768 到 32,767</td><td>Short</td></tr><tr><td>int</td><td>0</td><td>4 个字节</td><td>-2,147,483,648 到 2,147,483,647</td><td>Integer</td></tr><tr><td>byte</td><td>0</td><td>1 个字节</td><td>-128 到 127</td><td>Byte</td></tr><tr><td>char</td><td>空</td><td>2 个字节</td><td>Unicode 的字符范围：<code>\u0000</code>（即为 0）到 <code>\uffff</code>（即为 65,535）</td><td>Character</td></tr><tr><td>long</td><td>0L 或 0l</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td><td>Long</td></tr><tr><td>float</td><td>0.0F 或 0.0f</td><td>4 个字节</td><td>32 位 IEEEE-754 单精度范围</td><td>Float</td></tr><tr><td>double</td><td>0.0 或 0.0D(d)</td><td>8 个字节</td><td>64 位 IEEE-754 双精度范围</td><td>Double</td></tr><tr><td>boolean</td><td>false</td><td>1 位</td><td>true 或 false</td><td>Boolean</td></tr></tbody></table><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p><code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> 四种基本数据类型表示整数，需要注意的是 <code>long</code> 类型，使用 <code>long</code> 修饰的变量需要在数值后面加上 L 或者 l，比如 <code>long num = 1L;</code>，一般使用大写 <code>L</code>，为了避免小写 <code>l</code> 与数值 <code>1</code> 混淆。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p><code>float</code> 和 <code>double</code> 类型表示浮点数，即可以表示小数部分。需要注意的是 <code>float</code> 类型的数值后面需要加上 <code>F</code> 或者 <code>f</code>，否则会被当成 <code>double</code> 类型处理。<code>double</code> 类型的数值可以加上 <code>D</code> 或 <code>d</code>，也可以不加。</p><h4 id="char-类型"><a href="#char-类型" class="headerlink" title="char 类型"></a>char 类型</h4><p>char 类型用于表示单个字符。需要将字符用单引号括起来<code>char a = &#39;a&#39;</code>，char 可以和整数互相转换，如果字符 <code>a</code> 也可以写成<code>char a = 97</code>。也可以用十六进制表示<code>char a = &#39;\u0061&#39;</code>。</p><h4 id="boolean-类型"><a href="#boolean-类型" class="headerlink" title="boolean 类型"></a>boolean 类型</h4><p><code>boolean</code> 类型（布尔类型）用于表示真值 <code>true</code>或者假值 <code>false</code>，Java 中布尔值不能和整数类型或者其它类型互相转换。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Java 中使用 <code>String</code> 类来定义一个字符串，字符串是<strong>常量</strong>，它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。</p><p><code>String</code> 对象的初始化格式有如下两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s0</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abd&quot;</span>);<br></code></pre></td></tr></table></figure><p>String 类具有丰富的方法，比如计算字符串的长度、连接字符串、比较字符串、提取字符串等等。</p><h4 id="计算字符串长度"><a href="#计算字符串长度" class="headerlink" title="计算字符串长度"></a>计算字符串长度</h4><p><code>length()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法原型</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方法：<code>字符串标识符.length();</code> 返回一个 <code>int</code> 类型的整数（字符串中字符数，中文字符也是一个字符）。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java语言&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> s1.length();<br><span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> s2.length();<br></code></pre></td></tr></table></figure><p>则变量 <code>len1</code> 的值是 3，变量 <code>len2</code> 的值是 6。</p><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p><code>equals()</code> 方法，该方法的作用是判断两个字符串对象的内容是否相同。如果相同则返回 <code>true</code>，否则返回 <code>false</code>。</p><p><code>equals()</code> 方法比较是从第一字符开始，一个字符一个字符依次比较。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/wm.png" alt="equals比较原理"></p><p>如果想忽略掉大小写关系，比如：java 和 Java 是一样的，那怎么办呢？可以调用 <code>equalsIgnoreCase()</code> 方法，其用法与 <code>equals()</code> 一致，不过它会忽视大小写。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;用equals()比较，java和Java结果为&quot;</span>+s.equals(m));<br>        System.out.println(<span class="hljs-string">&quot;用equalsIgnoreCase()比较，java和Java结果为&quot;</span>+s.equalsIgnoreCase(m));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac StringTest.java<br>$ java StringTest<br>用equals()比较，java和Java结果为<span class="hljs-literal">false</span><br>用equalsIgnoreCase()比较，java和Java结果为<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>而使用 <code>&quot;==&quot;</code> 比较的是两个对象在内存中存储的地址是否一样。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (s1 == s2);<br></code></pre></td></tr></table></figure><p>则变量 <code>b</code> 的值是 <code>false</code>，因为 <code>s1</code> 对象对应的地址是 <code>&quot;abc&quot;</code> 的地址，而 <code>s2</code> 使用 <code>new</code> 关键字申请新的内存，所以内存地址和 <code>s1</code> 的 <code>&quot;abc&quot;</code> 的地址不一样，所以获得的值是 <code>false</code>。</p><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><p>字符串连接有两种方法：</p><ol><li>使用 <code>+</code>，比如 <code>String s = &quot;Hello &quot; + &quot;World!&quot;</code>。</li><li>使用 <code>String</code> 类的 <code>concat()</code> 方法。</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello &quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;World&quot;</span> + <span class="hljs-string">&quot;!&quot;</span>;   <span class="hljs-comment">//+号连接</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s0.concat(s1); <span class="hljs-comment">//concat()方法连接</span><br>System.out.println(s2);<br></code></pre></td></tr></table></figure><p>而且使用 <code>+</code> 进行连接，不仅可以连接字符串，也可以连接其他类型。但是要求进行连接时至少有一个参与连接的内容是字符串类型。</p><h4 id="charAt-方法"><a href="#charAt-方法" class="headerlink" title="charAt() 方法"></a>charAt() 方法</h4><p><code>charAt()</code> 方法的作用是按照索引值（规定字符串中第一个字符的索引值是 0，第二个字符的索引值是 1，依次类推），获得字符串中的指定字符。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>则变量 <code>c</code> 的值是 <code>&#39;b&#39;</code>。</p><h4 id="字符串常用提取方法"><a href="#字符串常用提取方法" class="headerlink" title="字符串常用提取方法"></a>字符串常用提取方法</h4><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>indexOf(char ch)</td><td>int</td><td>搜索字符 ch 第一次出现的索引</td></tr><tr><td>indexOf(String value)</td><td>int</td><td>搜索字符串 value 第一次出现的索引</td></tr><tr><td>lastIndexOf(char ch)</td><td>int</td><td>搜索字符 ch 最后一次出现的索引</td></tr><tr><td>lastIndexOf(String value)</td><td>int</td><td>搜索字符串 value 最后一次出现的索引</td></tr><tr><td>substring(int index)</td><td>String</td><td>提取从位置索引开始到结束的字符串</td></tr><tr><td>substring(int beginindex, int endindex)</td><td>String</td><td>提取 beginindex 和 endindex 之间的字符串部分</td></tr><tr><td>trim()</td><td>String</td><td>返回一个前后不含任何空格的调用字符串的副本</td></tr></tbody></table><blockquote><p>说明：在字符串中，第一个字符的索引为 0，子字符串包含 <code>beginindex</code> 的字符，但不包含 <code>endindex</code> 的字符。</p></blockquote><p>来写一些代码，验证一下上面的方法吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcdefabc&quot;</span>;<br>         System.out.println(<span class="hljs-string">&quot;字符a第一次出现的位置为&quot;</span>+s.indexOf(<span class="hljs-string">&#x27;a&#x27;</span>));<br>         System.out.println(<span class="hljs-string">&quot;字符串bc第一次出现的位置为&quot;</span>+s.indexOf(<span class="hljs-string">&quot;bc&quot;</span>));<br>         System.out.println(<span class="hljs-string">&quot;字符a最后一次出现的位置为&quot;</span>+s.lastIndexOf(<span class="hljs-string">&#x27;a&#x27;</span>));<br>         System.out.println(<span class="hljs-string">&quot;从位置3开始到结束的字符串&quot;</span>+s.substring(<span class="hljs-number">3</span>));<br>         System.out.println(<span class="hljs-string">&quot;从位置3开始到6之间的字符串&quot;</span>+s.substring(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac StringTest.java<br>$ java StringTest<br>字符a第一次出现的位置为0<br>字符串bc第一次出现的位置为1<br>字符a最后一次出现的位置为6<br>从位置3开始到结束的字符串defabc<br>从位置3开始到6之间的字符串def<br></code></pre></td></tr></table></figure><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>算术运算符用在数学表达式中，主要实现的是算术运算，如常见的<em>加减乘除</em>等。</p><p>表格中的例子中，变量 <code>a</code> 的值为 5，变量 <code>b</code> 的值为 3，变量 <code>i</code> 的值为 1：</p><table><thead><tr><th>算术运算符</th><th>名称</th><th>描述</th><th>类型</th><th>举例</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td>相加运算符两侧的值</td><td>双目运算符</td><td>a + b 等于 8</td></tr><tr><td>-</td><td>减法</td><td>左操作数减去右操作数</td><td>双目运算符</td><td>a - b 等于 2</td></tr><tr><td>*</td><td>乘法</td><td>相乘操作符两侧的值</td><td>双目运算符</td><td>a * b 等于 15</td></tr><tr><td>&#x2F;</td><td>除法</td><td>左操作数除以右操作数</td><td>双目运算符</td><td>a &#x2F; b 等于 1</td></tr><tr><td>%</td><td>取余</td><td>左操作数除右操作数的余数</td><td>双目运算符</td><td>a % b 等于 2</td></tr><tr><td>++</td><td>自增</td><td>操作数的值增加 1</td><td>单目运算符</td><td>++i（或 i++） 等于 2</td></tr><tr><td>–</td><td>自减</td><td>操作数的值减少 1</td><td>单目运算符</td><td>–i（或 i–） 等于 0</td></tr></tbody></table><p>其中，自增 (++) 和自减 (–) 运算符有两种写法：<strong>前缀（++i,–i）</strong>和<strong>后缀（i++,i–）</strong>。</p><ul><li>前缀自增自减法 (++i,–i): 先进行自增或者自减运算，再进行表达式运算。</li><li>后缀自增自减法 (i++,i–): 先进行表达式运算，再进行自增或者自减运算</li></ul><p>新建一个源代码文件 <code>ArithmeticOperation.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArithmeticOperation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        System.out.println(<span class="hljs-string">&quot;a + b = &quot;</span> + (a + b));<br>        System.out.println(<span class="hljs-string">&quot;a - b = &quot;</span> + (a - b));<br>        System.out.println(<span class="hljs-string">&quot;a * b = &quot;</span> + (a * b));<br>        System.out.println(<span class="hljs-string">&quot;a / b = &quot;</span> + (a / b));<br>        System.out.println(<span class="hljs-string">&quot;a % b = &quot;</span> + (a % b));<br>        System.out.println(<span class="hljs-string">&quot;a++ = &quot;</span> + (a++));<br>        System.out.println(<span class="hljs-string">&quot;++a = &quot;</span> + (++a));<br>        System.out.println(<span class="hljs-string">&quot;b-- = &quot;</span> + (b--));<br>        System.out.println(<span class="hljs-string">&quot;--b = &quot;</span> + (--b));<br>        System.out.println(<span class="hljs-string">&quot;c++ = &quot;</span> + (c++));<br>        System.out.println(<span class="hljs-string">&quot;++d = &quot;</span> + (++d));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac ArithmeticOperation.java<br>$ java ArithmeticOperation<br>a + b = 8<br>a - b = 2<br>a * b = 15<br>a / b = 1<br>a % b = 2<br>a++ = 5<br>++a = 7<br>b-- = 3<br>--b = 1<br>c++ = 3<br>++d = 4<br></code></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>Java 定义了位运算符，应用于整数类型 (<code>int</code>)，长整型 (<code>long</code>)，短整型 (<code>short</code>)，字符型 (<code>char</code>)，和字节型 (<code>byte</code>) 等类型。位运算时先转换为二进制，再按位运算。</p><p>表格中的例子中，变量 <code>a</code> 的值为 60（二进制：<code>00111100</code>），变量 <code>b</code> 的值为 13（二进制：<code>00001101</code>）：</p><table><thead><tr><th>位运算符</th><th>名称</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td><td>如果相对应位都是 1，则结果为 1，否则为 0</td><td>（a＆b），得到 12，即 0000 1100</td></tr><tr><td>丨</td><td>按位或</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（ a 丨 b ）得到 61，即 0011 1101</td></tr><tr><td>^</td><td>按位异或</td><td>如果相对应位值相同，则结果为 0，否则为 1</td><td>（a^b）得到 49，即 0011 0001</td></tr><tr><td>~</td><td>按位补</td><td>翻转操作数的每一位，即 0 变成 1，1 变成 0</td><td>（〜a）得到 -61，即 1100 0011</td></tr><tr><td>&lt;&lt;</td><td>按位左移</td><td>左操作数按位左移右操作数指定的位数</td><td>a&lt;&lt;2 得到 240，即 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>按位右移</td><td>左操作数按位右移右操作数指定的位数</td><td>a&gt;&gt;2 得到 15 即 1111</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零</td><td>左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td><td>a&gt;&gt;&gt;2 得到 15 即 0000 1111</td></tr></tbody></table><p>在 <code>/home/project</code> 目录下新建一个源代码文件 <code>BitOperation.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BitOperation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">13</span>;<br>        System.out.println(<span class="hljs-string">&quot;a &amp; b = &quot;</span> + (a &amp; b));<br>        System.out.println(<span class="hljs-string">&quot;a | b = &quot;</span> + (a | b));<br>        System.out.println(<span class="hljs-string">&quot;a ^ b = &quot;</span> + (a ^ b));<br>        System.out.println(<span class="hljs-string">&quot;~a = &quot;</span> + (~a));<br>        System.out.println(<span class="hljs-string">&quot;a &lt;&lt; 2 = &quot;</span> + (a &lt;&lt; <span class="hljs-number">2</span>));<br>        System.out.println(<span class="hljs-string">&quot;a &gt;&gt; 2 = &quot;</span> + (a &gt;&gt; <span class="hljs-number">2</span>));<br>        System.out.println(<span class="hljs-string">&quot;a &gt;&gt;&gt; 2 = &quot;</span> + (a &gt;&gt;&gt; <span class="hljs-number">2</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac BitOperation.java<br>$ java BitOperation<br>a &amp; b = 12<br>a | b = 61<br>a ^ b = 49<br>~a = -61<br>a &lt;&lt; <span class="hljs-string">2 = 240</span><br><span class="hljs-string">a &gt;&gt; 2</span> = 15<br>a &gt;&gt;&gt; 2 = 15<br></code></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符是通过运算符将操作数或等式进行逻辑判断的语句。</p><p>表格中的例子中，假设布尔变量 <code>a</code> 为真（<code>true</code>），变量 <code>b</code> 为假（<code>false</code>）：</p><table><thead><tr><th>逻辑运算符</th><th>名称</th><th>描述</th><th>类型</th><th>举例</th></tr></thead><tbody><tr><td>&amp;&amp; 或 &amp;</td><td>与</td><td>当且仅当两个操作数都为真，条件才为真</td><td>双目运算符</td><td>(a &amp;&amp; b) 或 (a &amp; b) 为假</td></tr><tr><td>|| 或 |</td><td>或</td><td>两个操作数任何一个为真，条件为真</td><td>双目运算符</td><td>（a || b) 或 (a | b) 为真</td></tr><tr><td>!</td><td>非</td><td>用来反转操作数的逻辑状态。如果条件为真，则逻辑非运算符将得到假</td><td>单目运算符</td><td>（!a）为假</td></tr><tr><td>^</td><td>异或</td><td>如果两个操作数逻辑相同，则结果为假，否则为真</td><td>双目运算符</td><td>(a ^ b) 为真</td></tr></tbody></table><p><strong><code>&amp;&amp;</code> 与 <code>||</code> 是具有短路性质，当按优先级顺序计算到当前表达式时，表达式的结果可以确定整个表达式的结果时，便不会继续向后进行判断和计算，而直接返回结果</strong>。</p><p>例如：当使用 <code>&amp;&amp;</code> 逻辑运算符时，在两个操作数都为 <code>true</code> 时，结果才为 <code>true</code>，但是当得到第一个操作为 <code>false</code> 时，其结果就必定是 <code>false</code>，这时候就不会再判断第二个操作了。在计算表达式 <code>(a &amp; b) &amp;&amp; (a | b)</code> 时，首先计算 <code>a &amp; b</code> 得到了 <code>false</code>，因为之后是 <code>&amp;&amp;</code>，任何值与 <code>false</code> 进行与操作都是 <code>false</code>，所以可以不用再计算下去，而直接返回 <code>a &amp; b</code> 的结果 <code>false</code>。</p><p>在<code>/home/project</code>目录下新建一个<code>LogicOperation.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogicOperation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        System.out.println(<span class="hljs-string">&quot;a &amp;&amp; b = &quot;</span> + (a &amp;&amp; b));<br>        System.out.println(<span class="hljs-string">&quot;a || b = &quot;</span> + (a || b));<br>        System.out.println(<span class="hljs-string">&quot;!a = &quot;</span> + (!a));<br>        System.out.println(<span class="hljs-string">&quot;a ^ b = &quot;</span> + (a ^ b));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac LogicOperation.java<br>$ java LogicOperation<br>a &amp;&amp; b = <span class="hljs-literal">false</span><br>a || b = <span class="hljs-literal">true</span><br>!a = <span class="hljs-literal">false</span><br>a ^ b = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>关系运算符</p><p>关系运算符生成的是一个 <code>boolean</code>（布尔）结果，它们计算的是操作数的值之间的关系。如果关系是真实的，结果为 <code>true</code>（真），否则，结果为 <code>false</code>（假）。</p><p>表格中的例子中，假设变量 <code>a</code> 为 3，变量 <code>b</code> 为 5：</p><table><thead><tr><th>比较运算符</th><th>名称</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>等于</td><td>判断两个操作数的值是否相等，如果相等则条件为真</td><td>(a &#x3D;&#x3D; b） 为 false</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>判断两个操作数的值是否相等，如果值不相等则条件为真</td><td>(a !&#x3D; b) 为 true</td></tr><tr><td>&gt;</td><td>大于</td><td>判断左操作数的值是否大于右操作数的值，如果是那么条件为真</td><td>(a &gt; b) 为 false</td></tr><tr><td>&lt;</td><td>小于</td><td>判断左操作数的值是否小于右操作数的值，如果是那么条件为真</td><td>(a &lt; b) 为 true</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>判断左操作数的值是否大于或等于右操作数的值，如果是那么条件为真</td><td>(a &gt;&#x3D; b) 为 false</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>判断左操作数的值是否小于或等于右操作数的值，如果是那么条件为真</td><td>(a &lt;&#x3D; b) 为 true</td></tr></tbody></table><p>除了上表列出的二元运算符，Java 还有唯一的一个三目运算符 <code>?:</code> 。</p><p>语法格式：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">布尔表达式 ？表达式 1 : 表达式 2;<br></code></pre></td></tr></table></figure><p>运算过程：如果布尔表达式的值为 <code>true</code>，则返回<strong>表达式 1</strong>的值，否则返回<strong>表达式 2</strong>的值。</p><p>在 <code>/home/project</code> 目录下新建一个源代码文件 <code>RelationalOperation.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RelationalOperation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        System.out.println(<span class="hljs-string">&quot;a == b = &quot;</span> + (a == b));<br>        System.out.println(<span class="hljs-string">&quot;a != b = &quot;</span> + (a != b));<br>        System.out.println(<span class="hljs-string">&quot;a &gt; b = &quot;</span> + (a &gt; b));<br>        System.out.println(<span class="hljs-string">&quot;a &lt; b = &quot;</span> + (a &lt; b));<br>        System.out.println(<span class="hljs-string">&quot;a &gt;= b = &quot;</span> + (a &gt;= b));<br>        System.out.println(<span class="hljs-string">&quot;a &lt;= b = &quot;</span> + (a &lt;= b));<br>        System.out.println(<span class="hljs-string">&quot;a &gt; b ? a : b = &quot;</span> + (a &gt; b ? a : b));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac RelationalOperation.java<br>$ java RelationalOperation<br>a == b = <span class="hljs-literal">false</span><br>a != b = <span class="hljs-literal">true</span><br>a &gt; b = <span class="hljs-literal">false</span><br>a &lt; b = <span class="hljs-literal">true</span><br>a &gt;= b = <span class="hljs-literal">false</span><br>a &lt;= b = <span class="hljs-literal">true</span><br>a &gt; b ? a : b = 5<br></code></pre></td></tr></table></figure><p><strong>强调</strong>：</p><ul><li><code>==</code> 和 <code>!=</code> 适用于所有的基本数据类型，其他关系运算符不适用于 <code>boolean</code>，因为 <code>boolean</code> 值只有 <code>true</code> 和 <code>false</code>，比较没有任何意义。</li><li><code>==</code> 和 <code>!=</code> 也适用于所有对象，可以比较对象的<strong>引用</strong>是否相同。</li></ul><p><strong>引用：Java 中一切都是对象，但操作的标识符实际是对象的一个引用。</strong></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Java 中的方法，可以将其看成一个功能的集合，它们是为了解决特定问题的代码组合。</p><p>方法的定义语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">访问修饰符 返回值类型 方法名(参数列表) &#123;<br>    方法体<br>&#125;<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">functionName</span><span class="hljs-params">(Object arg)</span> &#123;<br>  System.out.println(<span class="hljs-string">&quot;Hello World.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的语法说明中：</p><ol><li><strong>访问修饰符</strong>：代表方法允许被访问的权限范围， 可以是 <code>public</code>、<code>protected</code>、<code>private</code> 或者省略（<code>default</code>） ，其中 <code>public</code> 表示该方法可以被其他任何代码调用。</li><li><strong>返回值类型</strong>：方法返回值的类型，如果方法不返回任何值，则返回值类型指定为 <code>void</code> （代表无类型）；如果方法具有返回值，则需要指定返回值的类型，并且在方法体中使用 <code>return</code> 语句返回值。</li><li><strong>方法名</strong>：是方法的名字，必须使用合法的标识符。</li><li><strong>参数列表</strong>：是传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li><li><strong>方法体</strong>：方法体包含具体的语句，定义该方法的功能。</li></ol><p>根据方法是否带参、是否带返回值，可将方法分为四类：</p><ul><li>无参无返回值方法</li><li>无参带返回值方法</li><li>带参无返回值方法</li><li>带参带返回值方法</li></ul><p>当方法定义好之后，需要调用才可以生效，我们可以通过 <code>main</code> 方法（<code>main</code> 方法是 Java 程序的入口，所以需要用它来调用）来调用它，比如：</p><p>在 <code>/home/project</code> 下建立 <code>MethodDemo.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        method();<br>    &#125;<br>    <span class="hljs-comment">//这里要加上 static 关键字 因为静态方法只能调用静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;方法被调用&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac MethodDemo.java<br>java MethodDemo<br>方法被调用<br></code></pre></td></tr></table></figure><h2 id="Java基础语法-下"><a href="#Java基础语法-下" class="headerlink" title="Java基础语法(下)"></a>Java基础语法(下)</h2><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p><code>if</code> 语句是一种判断语句。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件)&#123;<br>    条件成立时执行的代码<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1051timestamp1434347907568.png" alt="if语句执行过程"  /><p><code>if...else</code> 语句当条件成立时，则执行 <code>if</code> 部分的代码块； 条件不成立时，则进入 <code>else</code> 部分。例如，如果一个月天数大于 30 天，则为大月，否则为小月。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件)&#123;<br>    代码块<span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    代码块<span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1051timestamp1434347936247.png" alt="if...else语句执行过程" style="zoom:80%;" /><p>多重 <code>if</code> 语句，在条件 1 不满足的情况下，才会进行条件 2 的判断，以此向下；当前面的条件均不成立时，最终执行 <code>else</code> 块内的代码。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件<span class="hljs-number">1</span>)&#123;<br>    代码块<span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件<span class="hljs-number">2</span>)&#123;<br>    代码块<span class="hljs-number">2</span><br>&#125;<br>...<br><span class="hljs-keyword">else</span> &#123;<br>    代码块n<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid97timestamp1437039991806.png" alt="多重if语句" style="zoom:80%;" /><blockquote><p>注意：如果 <code>if</code>（或 <code>else if</code>，或 <code>else</code>) 条件成立时的执行语句只有一条，是可以省略大括号的！但如果执行语句有多条，那么大括号就是不可或缺的。</p></blockquote><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">days</span> <span class="hljs-operator">=</span> <span class="hljs-number">31</span>;<br><span class="hljs-keyword">if</span>(days &gt; <span class="hljs-number">30</span>)<br>    System.out.println(<span class="hljs-string">&quot;本月是大月&quot;</span>);<br><span class="hljs-keyword">else</span><br>    System.out.println(<span class="hljs-string">&quot;本月是小月&quot;</span>);<br></code></pre></td></tr></table></figure><p>if 语句是可以在内层进行嵌套的。嵌套 if 语句，只有当外层 if 的条件成立时，才会判断内层 if 的条件。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(条件<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">if</span>(条件<span class="hljs-number">2</span>)&#123;<br>        代码块<span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        代码块<span class="hljs-number">2</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    代码块<span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1051timestamp1434348012040.png" alt="if的嵌套"></p><p><code>if</code> 语句练习：小明考了 78 分，60 分以上及格，80 分以上为良好，90 分以上为优秀，60 分以下要重考，编写源代码 <code>ScoreJudge.java</code>，输出小明的情况。</p><p>参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScoreJudge</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">78</span>;<br>        <span class="hljs-keyword">if</span>(score &gt;= <span class="hljs-number">60</span>)&#123;<br>            <span class="hljs-keyword">if</span>(score &gt;= <span class="hljs-number">80</span>)&#123;<br>                <span class="hljs-keyword">if</span>(score &gt;= <span class="hljs-number">90</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;成绩优秀&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;成绩良好&quot;</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;成绩及格&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;需要补考&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：所有的条件语句都是利用条件表达式的真或假来决定执行路径，Java 里不允许将一个数字作为布尔值使用，虽然这在 C 和 C++ 是允许的，如果要在布尔测试里使用一个非布尔值，需要先用一个条件表达式将其转换成布尔值，其他控制语句同理。</p></blockquote><p>编译执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">javac ScoreJudge.java</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">Java ScoreJude</span><br>成绩及格<br></code></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>当需要对选项进行等值判断时，使用 <code>switch</code> 语句更加简洁明了。比如：摇号摇到 1 的得一等奖，摇到 2 的得二等奖，摇到 3 的等三等奖，摇到其他的没有奖。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式)&#123;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<br>        代码块<span class="hljs-number">1</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>        代码块<span class="hljs-number">2</span><br>        <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-keyword">default</span>:<br>        默认执行的代码块<br>&#125;<br></code></pre></td></tr></table></figure><p>当 <code>switch</code> 后表达式的值和 <code>case</code> 语句后的值相同时，从该位置开始向下执行，直到遇到 <code>break</code> 语句或者 <code>switch</code> 语句块结束；如果没有匹配的 <code>case</code> 语句则执行 <code>default</code> 块的代码。</p><ul><li><code>defualt</code> 块不是必须的，默认为空。</li></ul><p>新建一个源代码文件<code>Draw.java</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">switch</span>(num)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;恭喜你，获得了一等奖&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            System.out.println(<span class="hljs-string">&quot;恭喜你，获得了二等奖&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            System.out.println(<span class="hljs-string">&quot;恭喜你，获得了三等奖&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            System.out.println(<span class="hljs-string">&quot;很遗憾，下次再来&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Draw.java<br>$ java Draw<br>恭喜你，获得了二等奖<br></code></pre></td></tr></table></figure><h4 id="while和do-while语句"><a href="#while和do-while语句" class="headerlink" title="while和do-while语句"></a>while和do-while语句</h4><p><code>while</code>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(条件)&#123;<br>    代码块<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code> 的执行过程是先判断，再执行。</p><ol><li>判断 <code>while</code> 后面的条件是否成立 ( <code>true</code> or <code>false</code> )</li><li>当条件成立时，执行循环内的代码。</li></ol><p>然后重复执行 <code>1</code>、<code>2</code>， 直到循环条件不成立为止。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1051timestamp1434348643037.png" alt="while的语句流程"></p><p><code>do-while</code> 语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">do</span>&#123;<br>    代码块<br>&#125;<span class="hljs-keyword">while</span>(条件);<br></code></pre></td></tr></table></figure><p><code>do-while</code> 的执行过程是先执行一次，再循环判断（所以循环内的代码至少会执行一次）。</p><ol><li>先执行一遍循环操作，然后判断循环条件是否成立。</li><li>如果条件成立，继续执行<code>1</code>、<code>2</code>，直到循环条件不成立为止。</li></ol><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1051timestamp1434348718160.png" alt="do...while的流程"></p><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">100</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;I love ShiYanlou!&quot;</span>);<br>    i++;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;I love ShiYanlou!&quot;</span>);<br>    i++;<br>&#125; <span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>练习：分别用 <code>while</code> 和 <code>do-while</code> 两种方法，编写代码，文件名为： <code>SumOfEven.java</code>。实现计算 1-1000 中所有偶数的和，并输出。验证一下两种方法你输出的结果是一致吗？</p><p>参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SumOfEven</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, i2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum2 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (i1 &lt;= <span class="hljs-number">1000</span>)&#123;     <span class="hljs-comment">//循环1000次</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == i1 % <span class="hljs-number">2</span>)&#123;   <span class="hljs-comment">//判断是否为偶数</span><br>                sum1 += i1;    <span class="hljs-comment">//将偶数加入到总数里</span><br>            &#125;<br>            i1++;              <span class="hljs-comment">//i自增1</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;用while，1到1000中，所有偶数的和为：&quot;</span>+sum1);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == i2 % <span class="hljs-number">2</span>)&#123;   <span class="hljs-comment">//在条件语句中，将数值写在前面是为了防止将==写成了=</span><br>                sum2 += i2;<br>            &#125;<br>            i2++;<br>        &#125; <span class="hljs-keyword">while</span>(i2 &lt;= <span class="hljs-number">1000</span>);<br>        System.out.println(<span class="hljs-string">&quot;用do-while，1到1000中，所有偶数的和为：&quot;</span>+sum2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac SumOfEven.java<br>$ java SumOfEven<br>用<span class="hljs-keyword">while</span>，1到1000中，所有偶数的和为：250500<br>用do-while，1到1000中，所有偶数的和为：250500<br></code></pre></td></tr></table></figure><h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p><code>for</code> 语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(循环变量初始化①; 循环条件②; 循环变量值操作③)&#123;<br>    循环操作④<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for</code> 相比 <code>while</code> 和 <code>do-while</code> 语句结构更加简洁易读，它的执行顺序：</p><ol><li>执行循环变量初始化部分（1），设置循环的初始状态，此部分在<strong>整个循环中只执行一次</strong>。</li><li>进行循环条件的判断（2），如果条件为 <code>true</code>，则执行循环体内代码（4）；如果为 <code>false</code> ，则直接退出循环。</li><li>执行循环变量值操作部分（3），对循环变量的值进行修改，然后进行下一次循环条件判断（4）。</li></ol><p>整个循环的流程可以简化为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">(1) -&gt; [(2)-&gt;(4)-&gt;(3)] -&gt; [(2)-&gt;(4)-&gt;(3)] -&gt; ... =&gt; (3) 结果为 false, 退出循环。<br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1051timestamp1434348757545.png" alt="for的流程"></p><p>例如，计算 100 以内不能被 3 整除的数之和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 保存不能被3整除的数之和</span><br><span class="hljs-comment">// 循环变量 i 初始值为 1 ,每执行一次对变量加 1，只要小于等于 100 就重复执行循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++) &#123;<br><span class="hljs-comment">// 变量 i 与 3 进行求模（取余），如果不等于 0 ，则表示不能被 3 整除</span><br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) &#123;<br>        sum = sum + i; <span class="hljs-comment">// 累加求和</span><br>    &#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;1到100之间不能被3整除的数之和为：&quot;</span> + sum);<br></code></pre></td></tr></table></figure><p>练习：编写代码，文件名为： <code>SumOfEven.java</code>，实现计算 1-1000 中所有偶数的和，并输出。</p><p>参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SumOfEven</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == i % <span class="hljs-number">2</span>)&#123;<br>                sum += i;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;用for，1到1000中，所有偶数和为：&quot;</span>+sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">javac SumOfEven.java</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">java SumOfEven</span><br>用for，1到1000中，所有偶数和为：250500<br></code></pre></td></tr></table></figure><h3 id="练习题：字符串处理"><a href="#练习题：字符串处理" class="headerlink" title="练习题：字符串处理"></a>练习题：字符串处理</h3><p>在 <code>/home/project/</code> 目录下新建文件 <code>StringUtil.java</code>，你需要实现以下需求：</p><ul><li>从控制台输入一行字符串</li><li>去除字符串中的所有空格</li><li>打印去除空格后的字符串</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：<br>    shi ya n  lou<br>输出：<br>    shiyanlou<br></code></pre></td></tr></table></figure><p>提示：<code>java.util.Scanner</code> 可以获取控制台输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//获取String值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.nextLine();<br></code></pre></td></tr></table></figure><p>我的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtil</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.nextLine();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.replaceAll(<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>答案方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtil</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//获取String值</span><br>        String a=in.nextLine();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(a);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stringBuilder.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (stringBuilder.charAt(i)==<span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                System.out.println(i);<br>                stringBuilder.deleteCharAt(i);<br>                i--;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                stringBuilder.charAt(i);<br>            &#125;<br>        &#125;<br>        System.out.println(stringBuilder.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="练习题：字符串处理-1"><a href="#练习题：字符串处理-1" class="headerlink" title="练习题：字符串处理"></a>练习题：字符串处理</h3><p>在<code>/home/project/</code>目录下新建<code>ContrastString.java</code>，你需要实现以下需求：</p><ul><li>从控制台输入字符串 a 和字符串 b</li><li>比较字符串 a 和字符 b 是否完全一致，长度，内容等完全一致。</li><li>如果完全一致，输出<code>相同</code>，如果不一致，输出<code>不同</code>。</li><li>禁止使用<code>equals</code>方法</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：<br>    abc3<br>    abc3<br>输出：<br>    相同<br></code></pre></td></tr></table></figure><p>提示：<code>java.util.Scanner</code> 可以获取控制台输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span>&#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>          <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//获取String值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.nextLine();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> in.nextLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContrastString</span>&#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//获取String值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.nextLine();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> in.nextLine();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> a.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len2</span> <span class="hljs-operator">=</span> b.length();<br><br>        <span class="hljs-keyword">if</span>(len1==len2)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len1;i++)&#123;<br>                <span class="hljs-keyword">if</span>(a.charAt(i)!=b.charAt(i))&#123;<br>                    System.out.println(<span class="hljs-string">&quot;不同&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;相同&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;不同&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContrastString</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//获取String值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> in.nextLine();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> in.nextLine();<br>        <span class="hljs-keyword">if</span> (a.length() != b.length()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;不同&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (a.charAt(i) != b.charAt(i)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;不同&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;相同&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="练习题：打印星期"><a href="#练习题：打印星期" class="headerlink" title="练习题：打印星期"></a>练习题：打印星期</h3><p>在<code>/home/project/</code>目录下新建一个源代码文件<code>PrintWeek.java</code>。</p><p>你需要实现当输入 1-7 的数字时返回对应的星期：</p><ul><li>从控制台获取一个整型参数</li><li>当输入数字 1 时输出<code>今天是星期一</code></li><li>当输入数字 2 时输出<code>今天是星期二</code></li></ul><p>以此类推</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">输入：<br>    <span class="hljs-number">1</span><br>输出：<br>    今天是星期一<br></code></pre></td></tr></table></figure><p>提示：<code>java.util.Scanner</code>可以获取控制台输入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//获取int值</span><br><span class="hljs-type">int</span> x=in.nextInt();<br></code></pre></td></tr></table></figure><p>我的&amp;答案：都是switch结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintWeek</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//获取int值</span><br>        <span class="hljs-type">int</span> x=in.nextInt();<br><br>        <span class="hljs-keyword">switch</span>(x)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                System.out.println(<span class="hljs-string">&quot;今天是星期一&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                System.out.println(<span class="hljs-string">&quot;今天是星期二&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                System.out.println(<span class="hljs-string">&quot;今天是星期三&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                System.out.println(<span class="hljs-string">&quot;今天是星期四&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                System.out.println(<span class="hljs-string">&quot;今天是星期五&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                System.out.println(<span class="hljs-string">&quot;今天是星期六&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>                System.out.println(<span class="hljs-string">&quot;今天是星期天&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>所谓数组，是有序的元素序列。若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便，把具有相同类型的若干元素按无序的形式组织起来的一种形式。这些无序排列的同类数据元素的集合称为数组。数组是用于储存多个相同类型数据的集合。– 来自百度百科</p><p>简单来说，数组就是相同数据类型的元素按一定顺序排列的集合。可以把它看成一个大的盒子，里面按顺序存放了多个数据类型相同的数据。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1052timestamp1434356533170.png" alt="数组的定义"></p><p>数组中的元素都可以通过下标来访问，<strong>下标从 0 开始，到数组长度 -1 结束</strong>。例如，可以通过 <code>ages[0]</code> 获取数组中的第一个元素 18 ，<code>ages[3]</code> 就可以取到第四个元素 10。</p><p><strong>注意</strong>：</p><p>使用数组前要声明数组。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[ ] 数组名;   <span class="hljs-comment">//或者: 数据类型 数组名[ ];</span><br></code></pre></td></tr></table></figure><p>数组名为任意合法的变量名，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> ages[];      <span class="hljs-comment">//存放年龄的数组，类型为整型</span><br><span class="hljs-type">char</span> symbol[];   <span class="hljs-comment">//存放符号的数组，类型为字符型</span><br>String [] name;  <span class="hljs-comment">//存放名称的数组，类型为字符串型</span><br></code></pre></td></tr></table></figure><p>声明数组后，需要为数组分配空间，也就是定义多大的数组。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数组名 = <span class="hljs-keyword">new</span>  数据类型 [ 数组长度 ];<br></code></pre></td></tr></table></figure><p>数组长度就是数组最多可存放元素的个数。可以在数组声明的时候初始化数组，或者在声明时就为它分配好空间，这样就不用再为数组分配空间。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] ages = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">18</span>,<span class="hljs-number">9</span>,<span class="hljs-number">33</span>,<span class="hljs-number">45</span>,<span class="hljs-number">60</span>&#125;; <span class="hljs-comment">//声明并初始化了一个整型数组，它有6个元素</span><br><span class="hljs-type">char</span> [] symbol = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">10</span>] <span class="hljs-comment">//声明并分配了一个长度为10的char型数组</span><br></code></pre></td></tr></table></figure><p>分配空间后就可以向数组中放数据了，数组中元素都是通过下标来访问的。 如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ages[<span class="hljs-number">0</span>]=<span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><p>Java 中可以将一个数组赋值给另一个数组，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] a1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span> [] a2;<br>a2 = a1;<br></code></pre></td></tr></table></figure><p>这里只是复制了一个引用，即 a2 和 a1 是相同数组的不同名称。</p><p>在<code>/home/project/</code>下新建一个<code>Test.java</code>测试一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> [] a1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">int</span> [] a2;<br>        a2 = a1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a2.length; i++)&#123;<br>            a2[i]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a1.length; i++)&#123;<br>            System.out.println(a1[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Test.java<br>$ java Test<br>2<br>3<br>4<br></code></pre></td></tr></table></figure><p>可以看到，修改 a2 的值，a1 的值也跟着变化。</p><p>数组遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> [] ages = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">33</span>, <span class="hljs-number">45</span>, <span class="hljs-number">60</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ages.length; i++)&#123; <span class="hljs-comment">//ages.length是获取数组的长度</span><br>    System.out.println(<span class="hljs-string">&quot;数组中第&quot;</span>+(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;个元素是 &quot;</span>+ages[i]); <span class="hljs-comment">//数组下标是从零开始，一定要注意</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>数组下标从 0 开始。所以数组的下标范围是 0 至 数组长度 -1。</li><li>数组不能越界访问，否则会报错。</li></ol><p>for 语句在数组内可以使用特殊简化版本，在遍历数组、集合时，foreach 更简单便捷。从英文字面意思理解 foreach 也就是“ for 每一个”的意思。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(元素类型 元素变量:遍历对象)&#123;<br>    执行的代码<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>/home/project/</code>下新建<code>JudgePrime.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JudgePrime</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">int</span> [] ages = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">9</span>, <span class="hljs-number">33</span>, <span class="hljs-number">45</span>, <span class="hljs-number">60</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> age:ages)&#123;<br>            System.out.println(<span class="hljs-string">&quot;数组中第&quot;</span>+i+<span class="hljs-string">&quot;个元素是&quot;</span>+age);<br>            i++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac JudgePrime.java<br>$ java JudgePrime<br>数组中第1个元素是12<br>数组中第2个元素是18<br>数组中第3个元素是9<br>数组中第4个元素是33<br>数组中第5个元素是45<br>数组中第6个元素是60<br></code></pre></td></tr></table></figure><h3 id="Scanner输入"><a href="#Scanner输入" class="headerlink" title="Scanner输入"></a>Scanner输入</h3><p>Java 可以使用 <code>java.util</code> 包下的<code>Scanner</code> 类来获取用户的输入。使用 <code>import java.util.Scanner;</code> 即可导入 Scanner，使用方法示例：</p><p>在 <code>/home/project</code> 目录下新建 <code>ScannerDemo.java</code> 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScannerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//获取用户输入的一行数据  返回为字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> in.nextLine();<br>        System.out.println(s);<br>        <span class="hljs-comment">//循环读取String数据，当输入exit时退出循环</span><br>        <span class="hljs-keyword">while</span> (!in.hasNext(<span class="hljs-string">&quot;exit&quot;</span>)) &#123;<br>            System.out.println(in.nextLine());<br>        &#125;<br>        <span class="hljs-comment">//关闭输入</span><br>        in.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac ScannerDemo.java<br>java ScannerDemo<br></code></pre></td></tr></table></figure><p>运行结果示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">shiyanlou<br>shiyanlou<br>aa<br>aa<br>bbb<br>bbb<br>cc<br>cc<br>exit<br></code></pre></td></tr></table></figure><p>除去以上列举的方法，其他方法可以在 API 文档中查询<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html%E3%80%82">https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html。</a></p><h3 id="练习题：用户输入"><a href="#练习题：用户输入" class="headerlink" title="练习题：用户输入"></a>练习题：用户输入</h3><p>在 <code>/home/project/</code> 目录下新建文件 <code>InputTest.java</code>，你需要完成以下需求：</p><ul><li>获取用户的输入信息（字符串）。</li><li>当用户输入 end 时，结束输入并打印用户之前输入的所有信息（输入的信息数量不超过 100 个）。</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">输入：<br>    shi<br>    yan<br>    lou<br>    end<br>输出：<br>    shi<br>    yan<br>    lou<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>使用数组保存元素。</li></ul><p>我的：直接参照上面Scanner的示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Scanner in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> in.nextLine();<br>        System.out.println(s);<br><br>        <span class="hljs-keyword">while</span> (!in.hasNext(<span class="hljs-string">&quot;end&quot;</span>)) &#123;<br>            System.out.println(in.nextLine());<br>        &#125;<br>        in.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((data[i] = in.nextLine()).equals(<span class="hljs-string">&quot;end&quot;</span>)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (String a : data) &#123;<br>            <span class="hljs-keyword">if</span> (a.equals(<span class="hljs-string">&quot;end&quot;</span>)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            System.out.println(a);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="练习题：最大最小值"><a href="#练习题：最大最小值" class="headerlink" title="练习题：最大最小值"></a>练习题：最大最小值</h3><p>现给出一串数据（313, 89, 123, 323, 313, 15, 90, 56, 39）求出最大值和最小值并输出。</p><p>在 <code>/home/project/</code> 目录下新建文件 <code>MaxAndMin.java</code>，在其中编写正确的代码。</p><p>我的&amp;答案：差别不大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxAndMin</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] data =&#123;<span class="hljs-number">313</span>, <span class="hljs-number">89</span>, <span class="hljs-number">123</span>, <span class="hljs-number">323</span>, <span class="hljs-number">313</span>, <span class="hljs-number">15</span>, <span class="hljs-number">90</span>, <span class="hljs-number">56</span>, <span class="hljs-number">39</span>&#125;;<br>        <span class="hljs-type">int</span> max= -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> min= <span class="hljs-number">10010</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;data.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(max&lt;data[i])<br>                max=data[i];<br>            <span class="hljs-keyword">if</span>(min&gt;data[i])<br>                min=data[i];<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;最大值：&quot;</span>+max+<span class="hljs-string">&quot;最小值：&quot;</span>+min);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 2.CH4-CH6概述</title>
    <link href="/20200713/598de264/"/>
    <url>/20200713/598de264/</url>
    
    <content type="html"><![CDATA[<p>继续复习计网，后面ch4-ch6是网络层、运输层、应用层，真正是计算机网络最核心的部分了，无论是学习还是面试工作，基本上网络的知识都是以这部分为主提问，一个是内容多一个是难度大，要好好吸收消化才行</p><span id="more"></span><h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><ul><li><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。网络层不提供服务质量的承诺</p><img src="https://img.mubu.com/document_image/fef357d9-d4a3-40ce-bacc-a96a930b6f00-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h3 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h3><ul><li><p>IP协议配套使用的三个协议</p><img src="https://img.mubu.com/document_image/b6ef6c35-4893-4519-9ae8-379d97d7fa15-1513806.jpg" alt="img" style="zoom: 67%;" /><ul><li><p>地址解析协议 ARP(Address Resolution Protocol)</p></li><li><p>网际控制报文协议 ICMP(Internet Control Message Protocol)</p></li><li><p>网际组管理协议 IGMP(Internet Group Management Protocol)</p></li></ul></li><li><p>各层的中间设备，将网络互相连接起来</p><img src="https://img.mubu.com/document_image/08701c85-4f06-452f-95c9-57e2204ffc39-1513806.jpg" alt="img" style="zoom: 67%;" /></li><li><p>三类IP地址</p><img src="https://img.mubu.com/document_image/25c3b814-7ae3-4eaa-a082-77d31011c26c-1513806.jpg" alt="img" style="zoom: 67%;" /><img src="https://img.mubu.com/document_image/cd4db9a8-ab70-42a8-9190-c99c85e599d8-1513806.jpg" alt="img" style="zoom: 67%;" /><img src="https://img.mubu.com/document_image/9232e06b-79c1-460a-9458-f9f7481ea567-7976057.jpg" alt="img" style="zoom: 67%;" /><img src="https://img.mubu.com/document_image/b5f65e5e-95cf-4967-88e4-4030a5ab73e3-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h3 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h3><ul><li><p>物理地址&#x2F;硬件地址&#x2F;MAC地址：物理层和数据链路层所使用的 IP地址是网络层及以上各层所使用的</p><img src="https://img.mubu.com/document_image/04c7f12a-0e46-44f1-a127-1acae8055fbd-1513806.jpg" alt="img" style="zoom: 67%;" /><img src="https://img.mubu.com/document_image/6c82df2f-f156-4e90-9400-c3bf845b0551-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><ul><li><p>地址解析协议的方法是在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新</p><img src="https://img.mubu.com/document_image/b1b1a33f-d805-46d5-b52b-c774c2194733-1513806.jpg" alt="img" style="zoom: 67%;" /></li><li><p>ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。如果目的主机和源主机不在同一个局域网上，则源主机通过ARP找到位于本局域网上的一个路由器硬件地址，把IP数据报传给这个路由器</p><img src="https://img.mubu.com/document_image/4975d4bb-f9ef-406d-97fa-9d9a068bcc7e-1513806.jpg" style="zoom: 67%;" /></li></ul><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><ul><li><p>首部由定长20字节的固定部分+可变长度的可选字段构成</p><img src="https://img.mubu.com/document_image/2f06d97c-ba5b-486c-8546-b1abb60f11bf-1513806.jpg" alt="img" style="zoom: 67%;" /></li><li><p>首部长度：单位是32位（即4字节 ，若为1111，则说明首部长度60字节），当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以补充。因此IP数据报的数据部分永远是在4字节的整数倍开始的，方便IP协议的实现</p></li><li><p>总长度：首部和 数据之和的长度，单位为字节。可表示最大长度为2^16-1&#x3D;65535字节。当超过了数据链路层中数据帧的数据字段最大长度时，需要进行分片处理</p></li><li><p>标识：被分片之后标识属于同一个IP数据报</p></li><li><p>标志： MF（more fragment）MF&#x3D;1 表示后面还有分片 DF （don’t fragment） 意思是不能分片，当DF&#x3D;0才允许分片</p></li><li><p>片位移：分片后，某片在原分组中的相对位置，片位移以8个字节为偏移单位</p><img src="https://img.mubu.com/document_image/fa582285-60be-41d7-9099-f55693943095-1513806.jpg" alt="img" style="zoom: 67%;" /></li><li><p>生存时间：跳数限制</p></li><li><p>IP层转发分组流程</p><img src="https://img.mubu.com/document_image/9a25d044-0b7e-4537-991b-b9d43ece4720-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h3 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h3><h4 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h4><img src="https://img.mubu.com/document_image/0ac1eea2-88d7-4f7b-8cbc-617cbe2571e3-1513806.jpg" alt="img" style="zoom: 67%;" /><img src="https://img.mubu.com/document_image/352bae33-428b-4574-9508-c0cec19411e7-1513806.jpg" alt="img" style="zoom: 67%;" /><ul><li><p>子网掩码</p><ul><li><p>从一个 IP数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码(subnetmask)可以找出IP地址中的子网部分。</p></li><li><p>将IP地址与子网掩码进行 与 运算，即可得到子网的网络地址。所有的网络都必须使用子网掩码，如果一个网络不划分子网，那么该网络的子网掩码就使用默认的子网掩码</p></li><li><p>子网数&#x3D;2^n -2 n为子网号的位数。减二是除去全 0和全1两种情况.划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。 ABC 类IP地址和子网主机数都需要(2^n)-2。若是CIDR则直接2^n，不用-2</p><img src="https://img.mubu.com/document_image/815a6e6d-0216-4137-872a-1b75cb79a3de-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul></li></ul><h4 id="使用子网时的分组转发"><a href="#使用子网时的分组转发" class="headerlink" title="使用子网时的分组转发"></a>使用子网时的分组转发</h4><ul><li><p>路由表需包含：目的网络地址、子网掩码和下一跳的地址</p><img src="https://img.mubu.com/document_image/324f6837-b26f-4a49-a4ce-8a3688d02904-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h4 id="无分类编制CIDR"><a href="#无分类编制CIDR" class="headerlink" title="无分类编制CIDR"></a>无分类编制CIDR</h4><ul><li><p>192.199.170.82&#x2F;27 不仅表示IP地址是192.199.170.82，而且还表示这个地址的网络的前缀有27位。192.199.170.‭010 10010‬ 取前27位，表明这个地址块的最小地址是192.199.170.64，最大地址是 192.199.170.010 11111 。</p></li><li><p>CIDR使用32位的地址掩码，掩码中1的个数就是网络前缀的长度</p><img src="https://img.mubu.com/document_image/01fd68a3-a25a-4cdd-b161-923df04830d7-1513806.jpg" alt="img" style="zoom: 67%;" /></li><li><p>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。路由聚合也称为构成超网 </p><p>- </p>  <img src="https://img.mubu.com/document_image/75abeceb-0aac-4563-bcbc-0b025f8eee6d-1513806.jpg" alt="img" style="zoom: 67%;" /></li><li><p>最长前缀匹配：目的IP地址D与路由表中两个项目的掩码做与运算之后都匹配，则选择两个匹配的地址中更具体地一个</p><p>- </p>  <img src="https://img.mubu.com/document_image/4cc7f689-e61f-46aa-8b80-7fec1a3215cc-1513806.jpg" alt="img" style="zoom: 67%;" /></li><li></li></ul><h3 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><ul><li><p>允许路由器或主机报告差错情况和提供有关异常情况的报告，更有效地转发IP数据报和提高交付成功地机会</p></li><li><p>ICMP报文是装在IP数据报中，作为其中的数据部分。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。</p><img src="https://img.mubu.com/document_image/091d5410-f894-42b4-bbb9-d75239a1c4bb-1513806.jpg" alt="img" style="zoom: 67%;" /><img src="https://img.mubu.com/document_image/fcafd995-74a7-4366-b0b0-fc02d8c1bc97-7976057.jpg" alt="img" style="zoom: 67%;" /></li></ul><h4 id="报文种类"><a href="#报文种类" class="headerlink" title="报文种类"></a>报文种类</h4><ul><li><p>ICMP差错报告报文</p><ul><li>终点不可达</li><li>时间超过 TTL超过。traceroute利用这点</li><li>参数问题。 数据报的首部中有字段的值不正确</li><li>改变路由</li></ul></li><li><p>ICMP询问报文</p><ul><li>回送请求和问答。 PING是应用层直接使用网络层ICMP的一个例子，没有通过运输层。traceroute，不断发送数据报，TTL+1，获得到达目的主机所经过的路由器IP地址和其中每一个路由器的往返时间</li><li>时间戳请求和回答 请求某台主机或路由器回答当前日期和时间</li></ul></li><li><p>路由选择协议</p><ul><li><p>静态路由选择（人工配置每一条路由） 动态路由选择 （自适应路由选择）</p></li><li><p>分层次的路由选择协议</p><ul><li><p>把整个互联网划分为许多较小的自治系统</p><ul><li>内部网关协议 IGP 域内路由选择 RIP OSPF</li><li>外部网关协议 EGP 域间路由选择 BGP</li></ul></li><li><p>RIP 基于向量的路由选择协议（内部网关协议）</p><ul><li><p>从一个路由器到直接连接的网络的距离定义为1。从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加1。不能超过15个路由器，16时不可达</p></li><li><p>距离向量算法</p><img src="https://img.mubu.com/document_image/e9b313a0-9237-459a-a6ea-81159dd7b43d-1513806.jpg" alt="img" style="zoom: 67%;" /></li><li><p>特点：</p><ul><li>1.仅和相邻路由器交换信息</li><li>2.交换的信息是当前本路由器所指的全部信息，即自己现在的路由表</li><li>3.按固定的时间间隔交换路由信息</li><li>RIP 协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）。</li></ul></li><li><p>RIP协议使用运输层的用户数据报UDP进行传送，即类似ICMP报文是塞进IP数据报的数据段里.RIP报文中的每个路由信息需要用20个字节，一个RIP报文最多包括25个路由</p></li><li><p>RIP存在的问题：当网络出现故障时，要经过比较长的时间才能将此消息传递到所有路由器。好消息传的快，坏消息传的慢</p><img src="https://img.mubu.com/document_image/1a1377fd-b8f1-45c7-b887-b5f74b330831-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul></li><li><p>OSPF 开放最短路径优先</p><ul><li>最主要的特征：使用分布式的链路状态协议</li></ul></li></ul></li><li><p>OSPF不使用UDP而是直接使用IP数据报传送</p></li></ul></li></ul><h3 id="虚拟专用网VPN和网络地址转换NAT"><a href="#虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="虚拟专用网VPN和网络地址转换NAT"></a>虚拟专用网VPN和网络地址转换NAT</h3><ul><li><p>专用地址：这些地址只能用于一个机构的内部通信，而不能用于和互联网上的主机通信。在互联网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发</p></li><li><p>VPN利用公用的互联网作为本机构各专用网之间的通信载体。</p></li><li><p>NAT技术，可以在专用网络内部使用专用IP地址，而仅在连接到互联网的计算机使用全球IP地址。</p><img src="https://img.mubu.com/document_image/6bc5b165-41df-453a-8014-5200d0ea2c56-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h2 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章 运输层"></a>第五章 运输层</h2><ul><li>网络层为主机之间提供逻辑通信，而运输层为主机进程间提供逻辑通信</li><li>端口：TCP&#x2F;IP运输层用16位端口号来标志一个端口，端口号只具有本地意义，<ul><li>服务器端使用的端口号：1.熟知端口号（系统端口号）0-1023 ，指派给TCP&#x2F;IP最重要的一些应用程序。2.登记端口号：1024-49515</li><li>客户端使用的端口号：49512-65535 仅在客户进程运行时才动态选择</li></ul></li></ul><h3 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h3><ul><li><p>无连接的、尽最大努力交付</p></li><li><p>面向报文的。UDP对应用层交下来的报文，完整的保留，加上UDP首部后交给IP层。一次发送一个报文</p></li><li><p>UDP没有拥塞控制。网络出现拥塞时不会使源主机的发送速率降低</p></li><li><p>UDP支持一对一，一对多，多对一和多对多的交互通信</p></li><li><p>UDP首部开销小。8字节</p></li><li><p>首部格式</p><img src="https://img.mubu.com/document_image/b0bb7c15-e686-4487-bc05-133675d63146-1513806.jpg" alt="img" style="zoom: 67%;" /></li><li><p>基于端口的分用</p><img src="https://img.mubu.com/document_image/a65625d3-7591-41ca-a599-8cecd33d95dc-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h3 id="传输控制协议-TCP"><a href="#传输控制协议-TCP" class="headerlink" title="传输控制协议 TCP"></a>传输控制协议 TCP</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>1.TCP是面向连接的运输层协议。应用程序在使用TCP协议之前，必须先建立TCP连接。在传送完数据后，再释放TCP连接</li><li>2.每一条TCP连接只能有两个端点，即点对点的</li><li>3.TCP提供可靠交付的服务。数据无差错，不丢失，不充分，且按序到达</li><li>4.TCP提供全双工通信</li><li>5.面向字节流。应用程序将数据传送到TCP缓存块，TCP根据对方给出的窗口值和网络拥塞程度来决定一个报文段应该包含多少个字节。</li></ul><h4 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h4><ul><li><p>TCP连接的端点叫做套接字 socket</p><ul><li><p>同一个IP 地址可以有多个不同的TCP 连接。同一个端口号也可以出现在多个不同的TCP 连接中。</p><img src="https://img.mubu.com/document_image/4b68d3fd-c857-4a0c-baf5-47fa009b88d0-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul></li></ul><h3 id="可靠传输工作原理"><a href="#可靠传输工作原理" class="headerlink" title="可靠传输工作原理"></a>可靠传输工作原理</h3><ul><li>理想的传输条件特点：1.传输信道不产生差错 2.不管发送方以多块速度发送数据，接收方总来得及处理收到的数据</li></ul><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><ul><li><p>在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。</p></li><li><p>分组和确认分组都必须进行编号。</p></li><li><p>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</p><img src="https://img.mubu.com/document_image/12ffe2a2-4367-4546-8761-712ca3875f06-1513806.jpg" alt="img" style="zoom: 67%;" /><img src="https://img.mubu.com/document_image/3415fe58-3712-428e-adfb-407139362b5f-1513806.jpg" alt="img" style="zoom: 67%;" /><img src="https://img.mubu.com/document_image/bf4948d5-f607-4ea2-a860-10f437edf319-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4><img src="https://img.mubu.com/document_image/d6db65aa-8855-4743-ab8e-b1a02198a811-1513806.jpg" alt="img" style="zoom: 67%;" /><ul><li><p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认。会出现(Go-Back-N)回退N现象</p><ul><li>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。</li></ul></li></ul><h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><ul><li><p>分为首部和数据两部分，首部前20各字节是固定的，后面又4n字节是根据需要而增加的选项</p><img src="https://img.mubu.com/document_image/10b83a16-87e3-4f75-a053-6a49b1670b7b-1513806.jpg" alt="img" style="zoom: 67%;" /></li><li><p>1.序号：TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</p></li><li><p>2.确认号：是期望收到对方的下一个报文段的数据的第一个字节的序号。 若确认号&#x3D;N，则表明：到序号N-1为止的所有数据都已正确收到</p></li><li><p>3.数据偏移（即首部长度），它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，实际上就是首部长度</p></li><li><p>4.窗口：指的是接收方的接收窗口，窗口值明确指出勒现在允许对方发送的数据量。窗口值作为接收方让发送方设置其发送窗口的值的依据。</p></li><li><p>最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” 注意MSS是每一个TCP报文段中的数据字段最大长度。MSS应该尽可能大些，只要在IP层传输时不需要再分片就行。</p></li></ul><h3 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h3><h4 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h4><ul><li><p>TCP的滑动窗口是以字节为单位的</p></li><li><p>根据 B 给出的窗口值，A 构造出自己的发送窗口。发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。</p><img src="https://img.mubu.com/document_image/f1c1022e-c2e4-47fb-a08b-dc3196e39fef-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h4 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h4><ul><li><p>报文段发出的时间——接收到相应确认的时间：报文段往返时间RTT，TCP保留了RTT的一个加权平均往返时间RTTs</p></li><li><p>新的RTTs&#x3D;(1-a) x (旧的RTTs) + a x (新的RTT样本)</p></li><li><p>0&lt;&#x3D;a&lt;&#x3D;1。若a接近0表示新的RTTs相比旧的变化不大；若接近1表示新的RTTS受新的RTT样本影响较大。推荐标准值为a&#x3D;1&#x2F;8即0.125</p></li><li><p>超时计时器设置超时重传时间RTO应略大于上面的加权平均往返时间RTO&#x3D;RTTs + 4 x RTTd（RTTd是RTT的偏差的加权平均值）</p></li><li><p>RTTd取值：第一次时RTTd为样本RTT的一半；后面的计算中RTTd&#x3D; (1-b) x (旧的RTTd) + b x | RTTs - 新的RTT样本 |。（b推荐值为1&#x2F;4即0.25）</p></li><li><p>假定发送一个报文段，设定的重传时间到了未收到确认于是再重传，之后收到了确认报文，但是我们不知道这是对原报文的确认还是对超时重传报文的确认，而两种不同的确认会导致计算出时间有较大偏差</p><ul><li>卡恩(karn)算法：在计算加权平均RTTs，只要报文段重传了，就不采用其往返时间的样本，这样得出的加权平均RTTs和RTO比较准确。（但是这样无法更新超时重传时间）</li><li>修正的卡恩算法：报文段每重传一次，就把超时重传时间RTO增大一些，具体是在取新的重传时间为旧的2倍</li></ul></li><li><p>选择确认SACK selective ACK</p></li></ul><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><ul><li><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收</p><img src="https://img.mubu.com/document_image/a412b07a-0ef6-4974-98ed-cef7e36ce92b-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p>详见博客<a href="%5Bhttp://salute61.top/2020/07/12/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/%5D(http://salute61.top/2020/07/12/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%AF%A6%E8%A7%A3/)">《TCP拥塞控制详解》</a></p><ul><li>拥塞：对资源的需求&gt;可用资源</li><li>拥塞控制的算法：慢开始、拥塞避免、快重传和快恢复</li><li>基于窗口的拥塞控制，发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量，拥塞窗口的大小取决于网络的拥塞程度。发送方让自己的发送窗口等于拥塞窗口</li><li>发送方控制拥塞窗口原则：只要网络没有出现拥塞，拥塞窗口就可以再增大一点。判断网络拥塞的依据是出现了超时</li></ul><h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><ul><li><p>由小到大逐渐增大拥塞窗口数值</p></li><li><p>每收到一个对新的报文段的确认后，就把拥塞窗口增加多一个SMSS（发送方的最大报文段）的数值</p><img src="https://img.mubu.com/document_image/3f234605-7a05-4e16-8271-8deb558712b4-1513806.jpg" alt="img" style="zoom: 67%;" /></li><li><p>使用慢开始算法后，每经过一个传输轮次 (transmission round)，拥塞窗口 cwnd 就加倍</p><img src="https://img.mubu.com/document_image/50616af3-80f0-48b9-8231-056dbcc3c1e0-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h5 id="慢开始门限"><a href="#慢开始门限" class="headerlink" title="慢开始门限"></a>慢开始门限</h5><ul><li><p>防止拥塞窗口CWND增长过大引起网络拥塞</p><img src="https://img.mubu.com/document_image/45fc9ec8-e9e6-4868-82b9-e2b9a6b0ba0d-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><ul><li>每经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1，缓慢地增大，不是像慢开始那样指数倍的增长</li></ul><h4 id="快速重传算法"><a href="#快速重传算法" class="headerlink" title="快速重传算法"></a>快速重传算法</h4><ul><li><p>发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。</p></li><li><p>防止因为个别报文段在网络中丢失（此时网络未发生拥塞）导致发送发迟迟收不到确认而超时，误认为发生了拥塞，错误的减少了cwnd，降低了传输效率</p><img src="https://img.mubu.com/document_image/6f9a1c2f-9ddd-4103-9649-d061ba5848c3-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h4 id="快速恢复算法"><a href="#快速恢复算法" class="headerlink" title="快速恢复算法"></a>快速恢复算法</h4><ul><li><p>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法</p><img src="https://img.mubu.com/document_image/f6309a3f-468a-46ef-93fc-64c445392c66-1513806.jpg" alt="img" style="zoom: 67%;" /></li></ul><h4 id="示例图"><a href="#示例图" class="headerlink" title="示例图"></a>示例图</h4><img src="https://img.mubu.com/document_image/38c9c653-bb97-4613-970c-6a829310398d-1513806.jpg" alt="img" style="zoom: 67%;" /><img src="https://img.mubu.com/document_image/2ba9fd1b-20d8-4d7d-9411-4b81de1cd851-1513806.jpg" alt="img" style="zoom: 67%;" /><img src="https://img.mubu.com/document_image/703e63a1-f731-497a-8a9f-712b5289844e-1513806.jpg" alt="img" style="zoom: 67%;" /><h3 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h3><p>详见博客<a href="%5Bhttp://salute61.top/2020/07/12/TCP%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/%5D(http://salute61.top/2020/07/12/TCP%E4%BC%A0%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/)">《TCP运输连接管理》</a></p><img src="https://img.mubu.com/document_image/e952df77-8a9c-43ff-b052-473012c16790-1513806.jpg" alt="img" style="zoom: 67%;" /><img src="https://img.mubu.com/document_image/960e20b6-dcaf-4c04-9916-48167425fb26-1513806.jpg" alt="img" style="zoom: 67%;" /><h2 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h2><h3 id="域名解析系统DNS"><a href="#域名解析系统DNS" class="headerlink" title="域名解析系统DNS"></a>域名解析系统DNS</h3><p>从域名中解析出IP地址</p><ul><li><p>递归查询：让别人帮你查</p><img src="https://img.mubu.com/document_image/f2e2994c-8430-4e7b-a689-1ed7db99260d-7976057.jpg" alt="img"  /></li><li><p>迭代查询：自己去查</p><img src="https://img.mubu.com/document_image/003ddf6d-46ae-47f1-aaec-810deb828047-7976057.jpg" alt="img"  /></li></ul><h3 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h3><ul><li><p>基于TCP和UDP的简单文件传送协议TFTP：复制整个文件。特点是若要存取一个文件就必须先获得一个本地副本；若要修改文件只能对本地副本修改，再将修改后的文件副本传回到原节点。</p></li><li><p>联机访问：多个程序使用同一文件，操作系统中的文件系统提供对共享文件的透明存取，其优点是原来处理本地文件的应用城西用来处理远程文件时无需对程序做明显改动。联机访问的代表是网络文件系统NFS</p></li><li><p>远程终端协议 TELNET 终端仿真协议</p></li><li><p>万维网WWW：一个大规模的、联机式的信息储藏所</p><ul><li>统一资源定位符 URL 表示从互联网上得到的资源位置和访问这些资源的方法。实际上就是在互联网上的资源的地址</li><li>万维网是一个分布式的超媒体系统</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档</li></ul></li><li><p>动态主机配置协议DHCP</p><ul><li>对于运行服务器软件的计算机：DHCP指派一个永久地址，而当这计算机重新启动时其地址不改变</li><li>租用期：DHCP服务器分配给DHCP客户的IP地址是临时的，因此DHCP客户只能在一段有限的时间内使用这个分配到的IP地址。DHCP客户根据据服务器提供的租用期T设置两个计时器T1,T2，它们的超过时间分别是0.5T和0.875T.当超时时间到了就要请求更新租用期</li><li>DHCP客户可以随时提前终止服务器所提供的租用期</li></ul></li></ul><h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><img src="https://img.mubu.com/document_image/7678835d-75f6-40c9-97ca-761e7e96e9ab-7976057.jpg" alt="img" style="zoom: 67%;" /><ul><li><p>简单邮件传送协议 :SMTP</p></li><li><p>邮件读取协议POP3</p></li></ul><h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><ul><li>HTTP协议本身是无连接的，使用了面向连接的TCP作为运输层协议<ul><li>HTTP&#x2F;1.0 非持续连接</li><li>HTTP1.1 持续连接 分为流水线方式和非流水线方式</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 TCP传输连接管理</title>
    <link href="/20200712/11d66177/"/>
    <url>/20200712/11d66177/</url>
    
    <content type="html"><![CDATA[<p>TCP是面向连接的协议，每次通信过程中连接的建立与释放都是必不可少的。因此TCP传输连接有三个阶段：<strong>连接建立</strong>、<strong>数据传送</strong>、<strong>连接释放</strong>。传输连接管理就是使连接建立与释放都能正常进行</p><p>在TCP连接建立过程中要解决以下三个问题：</p><p>(1)要使每一方能够确知对方的存在。</p><p>(2))要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）</p><p>(3)能够对传输实体资源（如缓存大小、连接表中的项目等）进行分配。</p><p>TCP连接采取客户端服务器C&#x2F;S方式，主动发起连接建立的叫客户端，被动建立的叫服务器端</p><span id="more"></span><h2 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h2><p>假定A是TCP客户程序，B是TCP服务器程序，初始阶段都是CLOSED状态，本例中A主动打开连接，B被动打开连接。</p><ul><li>B的TCP服务器进程创建<strong>传输控制块TCB</strong>，准备接受客户进程的连接请求，服务器进程处于LISTEN状态</li><li>A的TCP客户进程创建<strong>传输控制块TCB</strong>，向B发出连接请求，此时同步为<code>SYN=1</code>，初始序号<code>seq=x</code>，表示传送的第一个数据字节序号是x（注：SYN报文段不能携带数据，但是要<strong>消耗掉一个序号</strong>）</li><li>B收到连接请求报文段后，若同意则向A发送确认，确认报文段中<code>SYN=1，ACK=1</code>，确认号<code>ack=x+1</code>，自己选择的序号<code>seq=y</code>（注：该报文段不能携带数据，但是同样要<strong>消耗掉一个序号</strong>）</li><li>TCP客户进程A收到B的确认后，还要向B发出确认，置<code>ACK=1，ack=y+1</code>，而自己的序号为<code>seq=x+1</code>（注：ACK报文段可以携带数据，<strong>若不携带数据则不消耗序号</strong>——即下一数据报序号仍为x+1）</li><li>这时TCP连接建立，A进入established状态；B收到A的确认后，也进入established状态</li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418175824271.png" alt="image-20230418175824271" style="zoom:80%;" /><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>三次握手是为了防止已经失效的请求报文段突然又传送到了B而产生错误</p><p>下面两种情况是只有两次报文即可建立连接，即A的连接请求，B的确认报文</p><p><strong>正常情况</strong>：A发送连接请求，但是由于报文丢失而未收到确认，于是重传一次连接请求，收到确认建立连接；发送数据；关闭连接。全过程中A发送了两次请求报文，一次丢失、一次到达，没有失效的报文</p><p><strong>异常情况</strong>：A发送的第一个连接请求报文没有丢失，而是在某个网络结点滞留了，延误了一段时间才到达B，假设延误时间到在A和B的连接释放之后，此时B收到此报文以为A又要建立连接，于是向A发送确认报文同意连接，如果没有A的再次确认，B会一直认为连接建立，因此一直等待A发来数据请求！</p><p>采用三报文握手时，A不向B的确认发送确认，B收不到确认就知道A没有要建立连接。</p><h2 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h2><p>数据传输结束后，通信双方都可以释放连接，假定现在A、B都处于established状态，准备释放</p><ul><li><p>A应用进程向TCP发送连接释放报文段，并停止发送数据，主动关闭TCP连接。置<code>FIN=1，seq=u</code>（u等于A前面发送的数据最后一个字节+1），此时A进入FIN-WAIT-1状态，等待B的确认</p></li><li><p>B收到连接释放报文段就发出确认，确认号<code>ack=u+1</code>，自己的序号为<code>seq=v</code>（v等于B前面发送的数据最后一个字节+1），B进入CLOSE-WAIT状态。</p><ul><li>TCP服务器进程这时要通知高层应用进程，释放A到B方向的连接，此时TCP连接处于<strong>半关闭状态</strong>，即A已没有数据发送了，但B若要发送数据A仍要接受，从B到A方向的连接并未关闭</li></ul></li><li><p>A收到B的确认后进入FIN-WAIT-2状态，等待B发送连接释放报文</p><ul><li>若B没有要向A发送的数据，应用进程就通知TCP释放连接，B发送连接释放报文，置<code>FIN=1</code>.假定B的序号为w（半关闭状态时B又发送了一些数据，所以序号不是v+1而是w），B还要重复确认号<code>ack=u+1</code>，此时B进入LAST-ACK状态，等待A的确认</li><li>A收到B的连接释放报文段后，对此发出确认，在报文段中置<code>ACK=1</code>，确认号<code>ack=w+1</code>，而自己的序号是seq&#x3D;u+1，然后进入TIME-WAIT状态，经过<strong>时间等待计时器设置的时间2MSL</strong>后进入CLOSED状态</li></ul><p>注：MSL最长报文段寿命</p></li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418175746336.png" alt="image-20230418175746336" style="zoom:80%;" /><h3 id="为什么要等待2MSL时间"><a href="#为什么要等待2MSL时间" class="headerlink" title="为什么要等待2MSL时间"></a>为什么要等待2MSL时间</h3><p>第一：为保证A的最后一个ACK报文能到达B，这个ACK报文可能会丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK的确认，B就会超时重传该报文，在2MSL时间内A能接收到重传的报文，然后A重传一次取人，重启2MSL计时器。最后A、B都能进入CLOSED状态！这种情况下若不等待的话B就无法进入CLOSED状态</p><p>第二：防止上面提到的”失效的请求报文段“出现在笨连接中，A发送完最后一个ACK报文后，再经过2MSL时间就可以使本连接持续时间内产生的所有报文都从网络中消失，这就不会出现旧的连接请求报文</p><p>除了时间等待计时器外，TCP还有一个<strong>保活计时器</strong></p><p>假定：客户与服务器建立连接，但是后来客户主机突然出现故障，显然服务器不能收到客户发来的数据，但是不能让服务器白白等着浪费资源，可以通过保活计时器，每次收到客户端的数据，就重置保活计时器，时间通常时2小时，两小时内未收到客户端的数据就发送一个探测报文，之后每隔75秒发送一个，若连发10个都没有响应，服务器可以认定客户端故障，接着就关闭连接。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418174934159.png" alt="image-20230418174934159" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 TCP拥塞控制详解.md</title>
    <link href="/20200712/40665775/"/>
    <url>/20200712/40665775/</url>
    
    <content type="html"><![CDATA[<p>TCP的拥塞控制是TCP中最重要的部分之一，因此值得好好学习，记录下知识点以便回顾！</p><p>复习到运输层TCP就是重中之重了，而TCP的拥塞控制又是TCP中最重要的部分之一，因此值得好好学习，记录下知识点以便回顾！</p><p>按照概念、原理、方法，结合课本与ppt简单整理出我的理解</p><span id="more"></span><h2 id="拥塞的概念"><a href="#拥塞的概念" class="headerlink" title="拥塞的概念"></a>拥塞的概念</h2><p>计算机网络中的链路容量（带宽）、交换节点中的缓存和处理机等，都是网络的资源。在某段时间<strong>若对某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变坏</strong>，这种情况就叫<strong>拥塞（ 即 ∑对资源需求 &gt;可用资源 ）</strong>，拥塞会使得整个网络的吞吐量随输入负荷增大而下降。 </p><p>一般可能的想到处理方法是：1.加大节点缓存空间；2.提高链路速率。然而由于网络拥塞往往是多种因素引起的复杂问题，上面的方法可能会适得其反</p><ol><li>增大结点缓存：此时由于链路的容量和处理及速度并未提升，因此在队列中的绝大多数分组的排队等待时间会大大增加，引起大量的超时重传</li><li>提高处理速率：往往会将瓶颈转移到其他部分</li></ol><h3 id="拥塞常常趋于恶化"><a href="#拥塞常常趋于恶化" class="headerlink" title="拥塞常常趋于恶化"></a>拥塞常常趋于恶化</h3><p>如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组，<u>但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次</u>。这样会引起更多的分组流入网络和被网络中的路由器丢弃，可见拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞。</p><h3 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h3><p><strong>拥塞控制</strong>：就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载，<strong>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</strong>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p><p><strong>流量控制</strong>：往往指点对点通信量的控制，是个端到端的问题（接收端控制发送端），流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h3 id="拥塞控制的作用"><a href="#拥塞控制的作用" class="headerlink" title="拥塞控制的作用"></a>拥塞控制的作用</h3><p>图中横坐标是提供的负载，代表单位时间内输入到网络的分组数，纵坐标是网络吞吐量。</p><p>实际网络中随提供负载的增大，网络吞吐量会减缓增长直至开始下降，当负载增大到某一数值时吞吐量将为0，此时网络无法工作，这就是<strong>死锁</strong>。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418175330466.png" alt="image-20230418175330466" style="zoom:80%;" /><h3 id="开环-amp-闭环控制"><a href="#开环-amp-闭环控制" class="headerlink" title="开环&amp;闭环控制"></a>开环&amp;闭环控制</h3><p><strong>开环控制</strong>：方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。</p><p><strong>闭环控制</strong>：是基于反馈环路的概念。属于闭环控制的有以下几种措施：</p><ul><li>监测网络系统以便检测到拥塞在何时、何处发生。</li><li>将拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ul><h3 id="监测指标"><a href="#监测指标" class="headerlink" title="监测指标"></a>监测指标</h3><p>主要指标有：</p><ul><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差等等</li></ul><p>上述这些指标的上升都标志着拥塞的增长。</p><h3 id="拥塞控制的原则"><a href="#拥塞控制的原则" class="headerlink" title="拥塞控制的原则"></a>拥塞控制的原则</h3><p>只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率；但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p><h2 id="TCP的拥塞控制算法"><a href="#TCP的拥塞控制算法" class="headerlink" title="TCP的拥塞控制算法"></a>TCP的拥塞控制算法</h2><p>TCP进行拥塞控制的方法有四种，即<strong>慢开始</strong> (slow-start)、<strong>拥塞避免</strong>(congestion avoidance)、<strong>快重传</strong> (fast retransmit)、<strong>快恢复</strong> (fast recovery)</p><p>TCP采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。</p><p>TCP发送方维持一个拥塞窗口 <strong>CWND</strong> <strong>(Congestion Window)</strong></p><ul><li><p>拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。</p></li><li><p>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。</p></li><li><p>所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">真正的发送窗口值 = <span class="hljs-function"><span class="hljs-title"><span class="hljs-built_in">Min</span></span>(公告窗口值，拥塞窗口值)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h3><p>用于确定网络负载能力。基本思路：采用探测的思想，由小到大逐渐增加拥塞窗口数值。</p><p>初始拥塞窗口cwnd设置：</p><ul><li>旧的规定：刚开始时将cwnd设置为1到2个发送方的最大报文段SMSS(<strong>Sender Maximum Segment Size</strong>)的数值</li><li>新的RFC 5681把初始拥塞窗口cwnd设置为不超过2到4个SMSS的值</li></ul><p>慢开始门限**ssthresh(状态变量)**：防止拥塞窗口cwnd增长过大引起网络拥塞&#x2F;</p><p>拥塞窗口cwnd控制方法：在每收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个SMSS的数值：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">拥塞窗口cwnd每次的增加量 = <span class="hljs-built_in">min</span> (<span class="hljs-built_in">N</span>, SMSS)<br></code></pre></td></tr></table></figure><p>其中N是原先未被确认的、但现在被刚收到的确认报文段所确认的字节数。不难看出，当 N&lt;SMSS 时，拥塞窗口每次的增加量要小于SMSS，用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418175352794.png" alt="image-20230418175352794" style="zoom:80%;" /><p>注：此处的传输轮次是指——从cwnd所允许的报文段都发送 到 接收到对应的确认。例如拥塞窗口 cwnd&#x3D; 4，这时的往返时间 RTT 就是发送方连续发送4个报文段，并收到这 4个报文段的确认，总共经历的时间。</p><p>慢开始门限ssthresh用法：</p><ul><li>当cwnd&lt;ssthresh时，采用<strong>慢开始</strong></li><li>当cwnd&gt;ssthresh时，采用<strong>拥塞避免算法</strong></li><li>当cwnd&lt;ssthresh时，既可慢开始也可拥塞避免</li></ul><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p>让拥塞窗口cwnd缓慢增长，即每经过一个RTT就把cwnd+1，而不是加倍，在拥塞避免阶段<strong>加法增大</strong></p><p>无论在慢开始还是拥塞避免阶段，只要发送方判断网络出现拥塞：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ssthresh</span> <span class="hljs-operator">=</span> max(cwnd/<span class="hljs-number">2</span>，<span class="hljs-number">2</span>)<br><span class="hljs-attribute">cwnd</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>执行慢开始算法<br></code></pre></td></tr></table></figure><p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p>注：拥塞避免并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。拥塞避免是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418175413986.png" alt="image-20230418175413986" style="zoom:80%;" /><ul><li>TCP连接初始化时，拥塞窗口cwnd设置为1，图中的窗口单位不使用字节而使用报文段。慢开始门限的初始值设置为 16 个报文段，即 ssthresh &#x3D; 16。</li><li>发送端的发送窗口不能超过拥塞窗口 cwnd 和接收端窗口 rwnd 中的最小值。我们假定接收端窗口足够大，因此现在发送窗口的数值等于拥塞窗口的数值。<ul><li>发送方每收到一个对新报文段的确认 ACK，就把拥塞窗口值加 1，然后开始下一轮的传输（请注意，横坐标是传输轮次，不是时间）。因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。</li><li>当拥塞窗口 cwnd 增长到慢开始门限值ssthresh 时（图中的点1，此时拥塞窗口cwnd &#x3D; 16），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。</li><li>当拥塞窗口 cwnd &#x3D; 24 时，网络出现了超时（图中的点2），发送方判断为网络拥塞。于是调整门限值 ssthresh &#x3D; cwnd &#x2F; 2 &#x3D; 12，同时设置拥塞窗口 cwnd &#x3D; 1，进入慢开始阶段。<ul><li>按照慢开始算法，发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值加1。当拥塞窗口cwnd &#x3D; ssthresh &#x3D; 12时（图中的点3，这是新的ssthresh值），改为执行拥塞避免算法，拥塞窗口按线性规律增大。</li><li>当拥塞窗口cwnd &#x3D; 16时（图中的点4），出现了一个新的情况，就是发送方一连收到 3 个对同一个报文段的重复确认（图中记为3-ACK）。发送方改为执行<strong>快重传</strong>和<strong>快恢复</strong>算法。</li><li>在图的点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行快恢复算法。这时，发送方调整门限值ssthresh &#x3D; cwnd &#x2F; 2 &#x3D; 8，同时设置拥塞窗口cwnd &#x3D; ssthresh &#x3D; 8（见图中的点5），并开始执行拥塞避免算法。</li></ul></li></ul></li></ul><h3 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h3><p>采用<strong>快重传FR</strong>(Fast Retransmission)算法可以让发送方尽早知道发生了个别报文段的丢失。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认</p><p>发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%</p><h3 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h3><p>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法：<br>    (1) 慢开始门限 ssthresh &#x3D; 当前拥塞窗口 cwnd &#x2F; 2 ；<br>    (2) 新拥塞窗口 cwnd &#x3D; 慢开始门限 ssthresh ；<br>    (3) 开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 </p><h3 id="加法增大，乘法减小-AIMD"><a href="#加法增大，乘法减小-AIMD" class="headerlink" title="加法增大，乘法减小(AIMD)"></a>加法增大，乘法减小(AIMD)</h3><p>可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为加法增大 AI(Additive Increase)</p><p>当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为乘法减小MD (Multiplicative Decrease)</p><p>二者合在一起就是所谓的AIMD算法</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418175435699.png" alt="image-20230418175435699" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 ICMP协议应用.md</title>
    <link href="/20200709/26507caa/"/>
    <url>/20200709/26507caa/</url>
    
    <content type="html"><![CDATA[<h2 id="ICMP协议应用"><a href="#ICMP协议应用" class="headerlink" title="ICMP协议应用"></a>ICMP协议应用</h2><p>先回顾一下相关知识，ICMP协议是网际层使用的，但是它封装在了IP数据包的数据部分</p><p>ICMP报文格式：前4个字节是统一格式，共三个字段：类型、代码和检验和，后4个字节内容与具体的类型有关，最后是数据字段</p><span id="more"></span><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418174505639.png" alt="image-20230418174505639" style="zoom:80%;" /><p>ICMP报文分类：</p><ul><li>差错报告报文<ul><li>终点不可达</li><li>时间超时</li><li>参数问题</li><li>改变路由（重定向）</li></ul></li><li>询问报文<ul><li>回送请求和回答</li><li>时间戳请求和回答</li></ul></li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418174544071.png" alt="image-20230418174544071" style="zoom:80%;" /><h3 id="询问报文例子"><a href="#询问报文例子" class="headerlink" title="询问报文例子"></a>询问报文例子</h3><p>PING——分组网间探测(Packet InterNet Groper)用来测试两台主机之间的连通性，使用了ICMP回送请求和会送回答报文，PING是应用层直接使用网络层ICMP的一个例子，没有通过运输层的TCP或UDP</p><p>在cmd窗口中输入<code>ping www.baidu.com</code>，回车就可以看到结果</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230418174356254.png" alt="image-20230418174356254" style="zoom:80%;" /><p>流程：键入<code>ping  www.baidu.com</code>后，PC会一连发出四个ICMP回送请求报文，如果服务器baidu.com正常工作且响应了这个ICMP会送请求报文，那么它就会发送会送回答报文，往返的ICMP报文上有时间戳，可以得出往返时间，最后显示统计结果：发送到哪个IP地址，发送的、接受的、丢失的分组数，往返时间最小最大平均值</p><p>注：出现分组丢失时，ping指令并不会给出原因</p><h3 id="路由重定向例子"><a href="#路由重定向例子" class="headerlink" title="路由重定向例子"></a>路由重定向例子</h3><p>traceroute（在Windows中是tracert）：不断发送数据报来检测，找到故障的路由器</p><ul><li>由源主机向目的主机发送一连串的IP数据报，数据包中封装的是无法交互的UDP用户数据报。第一个数据包P1生存时间TTL设为1，P1到达第一个路由器R1时接收完后被丢弃，并向源主机发送一个<strong>ICMP时间超过差错报告报文</strong>；</li><li>源主机再发送第二个数据包P2，TTL设置为2，同理到第二个路由器R2接收完丢弃，并向源主机发送一个<strong>ICMP时间超过差错报告报文</strong>；</li><li>······重复上面的操作，当最后一个数据报到达目的主机，数据包的TTL为1。由于数据包中封装的是无法交付的UDP数据报，因此目的主机向源主机发送<strong>ICMP终点不可达差错报告报文</strong>；</li><li>最后源主机就得知了想要的路由信息：从源主机IP出发到目的主机所经过的路由器的IP地址，以及每一所需要的往返时间</li></ul><p>注：原则上经过路由器越多时间越长，但是实际上由于互联网的拥塞程度时一直变化的，也有可能出现经过更多路由器反而时间更少</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH连接虚拟机Linux</title>
    <link href="/20200708/6e919bfb/"/>
    <url>/20200708/6e919bfb/</url>
    
    <content type="html"><![CDATA[<p>看到网上的一个项目部署视频，提到配置虚拟机的Linux服务器，由于之前Linux课已经有现成的Ubuntu系统，网络配置也已经完成，只需要配置远程连接即可</p><span id="more"></span><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>Window：宿主机、ssh客户端</li><li>VMware：Ubuntu系统、ssh服务</li></ul><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>确定网络配置完成：Windows——ipconfig指令；Linux——ifconfig指令（都是在命令行中打开）</li><li>确定宿主机和虚拟机可以互相ping通</li></ul><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol><li><p>安装openssh-server。Linux中一般已安装了openssh-client，但是没有安装openssh-server（可以用ssh localhost检查一下），使用指令<code>sudo apt-get install openssh-server</code>安装即可。</p><p>我在安装时出现报错</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/ssh1.png"></p><p>发现是系统自带的openssh-client版本，与要安装的openssh-server所依赖的版本不同，所以先安装依赖的版本<code>sudo apt-get install openssh-client=1:7.6p1-4</code>，出现以下提示：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs tap">正在读取软件包列表... 完成<br>正在分析软件包的依赖关系树       <br>正在读取状态信息... 完成       <br>建议安装：<br>  keychain libpam-ssh monkeysphere ssh-askpass<br>下列软件包将被【降级】：<br>  openssh-client<br>升级了<span class="hljs-number"> 0 </span>个软件包，新安装了<span class="hljs-number"> 0 </span>个软件包，降级了<span class="hljs-number"> 1 </span>个软件包，要卸载<span class="hljs-number"> 0 </span>个软件包，有<span class="hljs-number"> 5 </span>个软件包未被升级。<br>需要下载<span class="hljs-number"> 611 </span>kB 的归档。<br>解压缩后会消耗<span class="hljs-number"> 0 </span>B 的额外空间。<br>您希望继续执行吗？ [Y/n] y<br>获取:1 http://cn.archive.ubuntu.com/ubuntu bionic/main amd64 openssh-client amd64 1:7.6p1-4 [611 kB]<br>已下载<span class="hljs-number"> 611 </span>kB，耗时 3秒 (191 kB/s)      <br>dpkg: 警告: 即将把 openssh-client 从 1:7.6p1-4ubuntu0.3 降级到 1:7.6p1-4<br>(正在读取数据库 ... 系统当前共安装有<span class="hljs-number"> 164860 </span>个文件和目录。)<br>正准备解包 .../openssh-client_1%3a7.6p1-4_amd64.deb  ...<br>正在将 openssh-client (1:7.6p1-4) 解包到 (1:7.6p1-4ubuntu0.3) 上 ...<br>正在设置 openssh-client (1:7.6p1-4) ...<br>正在处理用于 man-db (2.8.3-2ubuntu0.1) 的触发器 ...<br></code></pre></td></tr></table></figure><p>再次执行<code>sudo apt-get install openssh-server</code>即可安装成功</p></li><li><p>使用putty尝试连接成功</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/ssh2.png"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络 1.CH1-CH3概述</title>
    <link href="/20200706/7ae26181/"/>
    <url>/20200706/7ae26181/</url>
    
    <content type="html"><![CDATA[<p>这两天在复习计算机网络，前面相对简单过的很快，结合《计算机网络——谢希仁 第7版》教材和幕布上整理得非常全面的一份文档对照着看，自己再结合个人理解，对比较重点的地方修改成了自己的语言表述，整体上算是详细的！</p><p>幕布文档地址：<a href="https://mubu.com/doc/explore/27334">谢希仁《计算机网络》| 一至六章期末复习</a></p><span id="more"></span><h2 id="CH1概述"><a href="#CH1概述" class="headerlink" title="CH1概述"></a>CH1概述</h2><h3 id="三网"><a href="#三网" class="headerlink" title="三网"></a>三网</h3><ul><li>电信网（打电话的） 有线电视网 （看电视的） 计算机网络</li></ul><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>互联网的基本特点<ul><li>连通 不管相距多远的用户都好像彼此直接连通一样</li><li>资源共享</li></ul></li><li>网络把许多计算机连接在一起，而互连网则把许多网络通过路由器连接在一起。</li><li>internet 互连网，通用名词，泛指多个计算机网络互连而成的计算机网络。通信协议自行选择</li><li>Internet 互联网&#x2F;因特网 指现在全球所用的这个互连网，采用TCP&#x2F;IP协议族作为通信规则，前身是美国的ARPANET</li><li>互联网发现大概经历了三个阶段<ul><li>单个ARPANET到互连网</li><li>建成了三级结构的互联网(主干网，地区网，校园网)</li><li>逐渐形成多层次的ISP结构互联网</li></ul></li></ul><h3 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h3><ul><li>1 边缘部分 所有连接在互联网上的主机组成，这部分是用户直接使用的，用来通信（传输数据、银牌或视频）和资源共享</li><li>2 核心部分 由大量网络和连接这些网络的路由器组成，这部分为边缘部分提供服务（提供连通性和交换）</li><li>通信方式（主机A的某个进程和主机B上的另一个进程进行通信）<ul><li>客户-服务器方式 (C&#x2F;S)<ul><li>客户是服务请求方 客户程序特点:<ul><li>不需要特殊硬件和复杂操作系统</li><li>被用户调用后运行，在通信时主动向原地服务器发起通信。客户程序必须知道服务器的地址</li></ul></li><li>服务器是服务提供方 服务器程序:<ul><li>被动的等待接收客户请求。不需要直到客户程序的地址</li><li>可同时处理多个客服请求</li></ul></li></ul></li><li>对等方式 peer to peer p2p<ul><li>两台主机通信时不区分哪一个是服务请求方哪一个是服务提供方，从本质上看仍是客户——服务器方式，只是对等连接中的每一台主机既是客户又同时是服务器</li></ul></li></ul></li><li>数据交换方式<ul><li>电路交换<ul><li>交换就是按照某种方式动态地分配传输线路的资源</li><li>建立连接-&gt;通话(一直占用通信资源)-&gt;释放链接<ul><li>一条专用地物理通路，在通话地全部时间内，通话地两个用户始终占用端到端的通信资源</li></ul></li><li>缺点：计算机数据具有突发性，电路交换线路地传输效率很低</li></ul></li><li>分组交换<ul><li>采用存储转发技术原理，将报文分成一个个等长数据段，加上由一些必要的控制信息组成的首部后，就构成了分组（包），首部包含了源地目的地址等信息。</li><li>路由器进行分组的转发，每个分组在互联网中独立选择传输路径，分组到达一个路由器后，先暂时存储下来，查找转发表，然后从一条合适的链路转发出去。</li><li>优：高效、灵活、迅速、可靠</li><li>缺：时延（存储转发时排队）、开销（控制信息的携带）</li></ul></li><li>报文交换 整个报文先到相邻结点，全部存储下来后查找转发表</li></ul></li></ul><h3 id="网络类别"><a href="#网络类别" class="headerlink" title="网络类别"></a>网络类别</h3><img src="https://img.mubu.com/document_image/f569fe5e-7027-406f-a313-a31e475360d3-1513806.jpg" alt="img" style="zoom:80%;" /><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li><p>速率（数据率&#x2F;比特率）</p><ul><li>单位是bit&#x2F;s 比特每秒 k&#x3D;10^3 M&#x3D;10^6 G&#x3D;10^9 T&#x3D;10^12</li><li>注意计算机中的数据大小用字节B（Byte）作单位，1字节等于8比特，15GB的数据块以10G的速率传送，即15<em>2^30</em>8比特的数据块以10*10^9比特每秒的速率传输。</li></ul></li><li><p>带宽</p><ul><li>单位时间内网络中的某信道所能通过的“最高数据率” 单位 bit&#x2F;s</li></ul></li><li><p>吞吐量</p><ul><li>单位时间内通过某个网络的实际的数据量。对于1Gbit&#x2F;s的以太网，实际吞吐量可能是100Mbit&#x2F;s</li></ul></li><li><p>时延 （数据从网络的一段到另一端的时间）</p><ul><li>1.发送时延：主机或路由器发送数据帧所需要的时间，从发送数据的第一个比特算起，到该帧的最后一个比特发送完毕所需要的时间。发送时延&#x3D;数据帧长度（bit）&#x2F;发送速率（bit&#x2F;s）。一般发生在网络适配器中（机器内部的发送机器）</li><li>2.传播时延：电磁波在信道中传播一定的距离需要花费的时间，传播时延&#x3D;信道长度（m）&#x2F;电磁波在信道上的传播速率（m&#x2F;s）</li><li>3.处理时延：主机收到分组后进行一定的处理，如分析分组首部、从分组中提取数据部分、进行差错检验或查找适当的路由等。·</li><li>4.排队时延：分组在进入路由器后要先在输入队列中排队等待处理，待确定了转发接口后，还需要在输出队列中排队等待转发。</li><li>总时延&#x3D;发送时延+传播时延+处理时延+排队时延 不能只考虑其中的哪一项</li></ul></li><li><p>时延带宽积：时延带宽积&#x3D;传播时延*带宽 表示这样的链路可容纳多少个比特。传播时延20ms，带宽10Mbit&#x2F;s，时延带宽积为20万bit，表明连续发送数据时，当正在发送的第一个比特即将到达终点，发送端已经发送了20万个比特。</p></li><li><p>往返时间RTT ：从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。有效数据率&#x3D;数据长度&#x2F;(发送时间+RTT) 会比原来的数据率小一些</p></li><li><p>利用率：信道利用率指某信道有百分之几的时间是有数据通过的。网络利用率是全网络的信道利用率的加权平均值。当某信道的利用率增大时，该信道引起的时延也就迅速增加。</p><ul><li><p>D0 网络空闲时的时延 D1当前时延 U 利用率 则 D1&#x3D;D0&#x2F;（1-U）</p><img src="https://img.mubu.com/document_image/a36439f3-8379-4d9f-8889-57b33776fb99-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul></li></ul><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><ul><li>定义：为进行网络中的数据交换而建立的规则、标准或约定</li><li>语法：即数据与控制信息的结构或格式</li><li>语义：即需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：即事件实现顺序的详细说明</li></ul><h3 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h3><ul><li><p>定义：计算机网络的各层及其协议的集合</p></li><li><p>体系结构</p><img src="https://img.mubu.com/document_image/44e01c8a-6b34-4cfa-be90-140104c9d86b-1513806.jpg" alt="img" style="zoom:80%;" /><ul><li>应用层：应用层协议定义应用进程间通信和交互的规则；不同的网络应用需要有不同的协议应用层协议，域名系统DNS，HTTP,电子邮件STMP协议等。 数据单元:报文</li><li>运输层：提供通用的数据传输服务。<ul><li>运输层协议：传输控制协议TCP（Transmission Control Protocol）——提供面向连接的，可靠的数据传输服务，数据传输单位:报文段</li><li>用户数据报协议UDP（User Datagram Protocol）——提供无连接的，尽最大努力的数据传输服务。数据传输单位：用户数据报</li></ul></li><li>网络层：选择最佳路径，规划IP地址。传输单位：分组&#x2F;包&#x2F;IP数据报（由运输层的报文段或用户数据报封装而成）。网络层协议:IP协议和许多种路由选择协议</li><li>数据链路层：将网络层的IP数据报组装成帧</li><li>物理层：数据单位是 比特</li></ul></li><li><p>一些概念</p><ul><li><p>PDU(protocol data unit)协议数据单元：对等层次之间传送的数据单位</p><img src="https://img.mubu.com/document_image/9e025a71-4c74-4b82-b6c3-0583f3ca7df2-1513806.jpg" alt="img" style="zoom:80%;" /><img src="https://img.mubu.com/document_image/2759f205-6f66-4916-a3a8-08da4d29efa3-1513806.jpg" alt="img" style="zoom:80%;" /></li><li><p>服务访问点 SAP (Service Access Point)：同一系统相邻两层的实体进行交互的地方</p></li><li><p>服务数据单元 SDU (Service Data Unit)：层与层之间交换的数据的单位</p></li><li><p>TCP&#x2F;IP的体系结构</p><img src="https://img.mubu.com/document_image/f929c3e3-bfdd-455f-8665-03a5b31cede3-1513806.jpg" alt="img" style="zoom:80%;" /><ul><li><p>应用层和网络层都有多种协议，TCP&#x2F;IP协议可以为各式各样的应用提供服务</p><img src="https://img.mubu.com/document_image/7ad88da5-166f-41dc-ab69-37dab6cc779e-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul></li></ul></li></ul><h2 id="CH2-物理层"><a href="#CH2-物理层" class="headerlink" title="CH2 物理层"></a>CH2 物理层</h2><h3 id="物理层的主要任务"><a href="#物理层的主要任务" class="headerlink" title="物理层的主要任务"></a>物理层的主要任务</h3><ul><li>概念：为确定与传输媒体的接口有关的一些特性</li><li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等</li><li>电气特性：指明在接口电缆的各条线上出现的电压的范围</li><li>功能特性：指明某条线上出现的某一电平的意义</li><li>过程特性：指明对于不同功能的各种可能事件的出现顺序。</li></ul><h3 id="信道的交互方式"><a href="#信道的交互方式" class="headerlink" title="信道的交互方式"></a>信道的交互方式</h3><ul><li>单工信道</li><li>半双工信道</li><li>全双工信道</li></ul><h3 id="基带信号"><a href="#基带信号" class="headerlink" title="基带信号"></a>基带信号</h3><ul><li><p>概念:来自信源的信号</p></li><li><p>基带调制（编码）：对基带信号的波形进行变换，使它能够与信道特性相适应</p></li><li><p>带通调制：使用载波进行调制，把基带信号的频率搬移到较高的频段，并转换模拟信号。</p></li><li><p>带通信号：经过带通调制的信号</p></li><li><p>常用编码方式</p><img src="https://img.mubu.com/document_image/b2be1fe9-421c-4391-afe5-c14014e433cf-1513806.jpg" alt="img" style="zoom:80%;" /><img src="https://img.mubu.com/document_image/9e3760de-9d48-446e-9b00-cfeef080dd3f-1513806.jpg" alt="img" style="zoom:80%;" /></li><li><p>基本带通调制方法</p><img src="https://img.mubu.com/document_image/8ea3136f-005b-45d6-904c-503be0fef6a3-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><ul><li>限制码元在信道上的传输速率的因素<ul><li>1.信道能通过的频率范围。信号中的许多高频分量往往不能通过信道。在任何信道中，码元传输速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接受端对码元的判决成为不可能</li><li>2.信噪比<ul><li>信号的平均功率和噪声的平均功率之比 S&#x2F;N，单位为分贝 信噪比（db）&#x3D;10log10(S&#x2F;N) db</li><li>信道的极限信息传输速率<ul><li>香农公式：C&#x3D;W*log2(1+S&#x2F;N) bit&#x2F;s W为带宽（以Hz为单位），S为信号的平均功率 N为信道内部噪声功率</li><li>信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高</li><li>让每一个码元携带更多比特的信息量</li></ul></li></ul></li></ul></li></ul><h3 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h3><ul><li><p>导引型传输媒体</p><ul><li><p>1.双绞线</p><ul><li><p>模拟传输和数字传输都可使用，通信距离一般为几到几十公里</p></li><li><p>屏蔽双绞线（带金属屏蔽层）STP 无屏蔽双绞线 UTP</p></li><li><p>现在最常用的UTP是5类线，大大增加了每单位的绞合次数</p></li><li><p>优：价格便宜性能也不错</p><img src="https://img.mubu.com/document_image/03ea0665-d47e-41d7-98ce-0e4ce563396d-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul></li><li><p>2.同轴电缆</p><ul><li><p>抗干扰特性好，被广泛用于传输较高速率的数据</p></li><li><p>带宽取决于电缆质量</p><img src="https://img.mubu.com/document_image/1ee3aae0-c64f-461e-8dd0-70a71b5315d6-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul></li><li><p>3.光缆</p><ul><li><p>一条光缆可包含数十至上百根光纤</p></li><li><p>光纤是光纤通信的传输媒体，光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽</p></li><li><p>多模光纤：可以存在多条不同角度入射的光线在一条光纤中传输</p></li><li><p>单模光纤：光纤的直径减小到只有一个光的波长，使光线一直向前传播，而不会产生多次反射。</p></li><li><p>优点</p><ul><li>1.通信容量大</li><li>2.传输损耗小，中继距离长</li><li>3.抗雷电和电磁干扰性能好</li><li>无串音干扰，保密性好</li><li>体积小，重量轻（同轴电缆重）</li></ul><img src="https://img.mubu.com/document_image/f985b769-5234-494a-ba4a-9e8c651c935b-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul></li></ul></li><li><p>非导引型传输媒体</p><ul><li>将自由空间称为非引导型传输媒体”</li><li>无线传输的频段很广</li><li>短波通信：主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低</li><li>微波通信:在空间直线传播。分为 1.地面微波接力通信 2.卫星通信</li></ul></li></ul><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><img src="https://img.mubu.com/document_image/839f86d4-4937-4b8c-9bd8-0f521dcd6a60-1513806.jpg" alt="img" style="zoom:80%;" /><ul><li><p>频分复用 FDM Frequency Division Multiplexing</p><ul><li><p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p></li><li><p>频分复用的所有用户在同样的时间占用不同的带宽资源</p><img src="https://img.mubu.com/document_image/65446c01-2531-43c9-954f-be35e9e4e358-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul></li><li><p>时分复用（同步分时复用）TDM：将时间划分为一段段等长的时分复用帧。用户在每一个时分复用帧中占用固定序号的时隙。时分复用的所有用户是在不同的时间占用同样的频带宽度</p><ul><li><p>时分复用可能会造成线路资源的浪费。（用户没有发送数据时，时分复用帧依然被占用。）</p><img src="https://img.mubu.com/document_image/9ba690a4-c4c9-435a-a365-0d09b7c4b8a1-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul></li><li><p>统计时分复用 STDM statistic TDM（异步分时复用）</p><img src="https://img.mubu.com/document_image/daad6de2-4e36-425c-b94c-ff969c5ca830-1513806.jpg" alt="img" style="zoom:80%;" /></li><li><p>波分复用 WDM wavelength</p><img src="https://img.mubu.com/document_image/1a9e181d-355e-4d25-9a09-fb163bd44500-1513806.jpg" alt="img" style="zoom:80%;" /></li><li><p>码分复用（码分多址） code division Multiple Access</p><ul><li><p>各用户使用经过挑选的不同码型，因此不会造成干扰。每一个比特时间在划分成m个短的间隔，称为码片，每一个站被指派一个唯一的m bit的码片序列，如果发送1，则发送这个码片序列，如果发送0，则发送这个码片序列的反码。S-&gt;X,到达目的站X之后由X根据S的码片向量进行求内积运算，若内积值为1，则说明S发送的是1，若内积值为-1，则说明S发送的是0，若内积值为0，则说明是其他站的信号（不是S的信号）</p></li><li><p>有很强的抗干扰能力且不易被发现</p><img src="https://img.mubu.com/document_image/ae5139cb-b68d-43b7-ae1d-71a2380ef13f-1513806.jpg" alt="img" style="zoom:80%;" /><img src="https://img.mubu.com/document_image/72e5207b-2bf7-4d6f-922c-838438e9fe69-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul></li><li><p>SDH&#x2F;SONET :第一次真正实现了数字传输体制上的世界性标准，已成为公认的新一代理想的传输网体制</p></li><li><p>宽带接入技术</p></li></ul><h2 id="CH3-数据链路层"><a href="#CH3-数据链路层" class="headerlink" title="CH3 数据链路层"></a>CH3 数据链路层</h2><h3 id="数据链路层使用的信道"><a href="#数据链路层使用的信道" class="headerlink" title="数据链路层使用的信道"></a>数据链路层使用的信道</h3><ul><li>点对点信道</li><li>广播信道</li></ul><p>数据链路层传送的是帧，把网络层交下来的IP数据报添加首部和尾部封装成帧</p><h3 id="三个基本问题（数据链路层协议的共同问题）"><a href="#三个基本问题（数据链路层协议的共同问题）" class="headerlink" title="三个基本问题（数据链路层协议的共同问题）"></a>三个基本问题（数据链路层协议的共同问题）</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a><strong>封装成帧</strong></h4><ul><li><p>封装成帧 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。首尾部可以确定帧的界限(帧定界)。收到的数据有明确的帧定界符才是一个完整的帧</p><img src="https://img.mubu.com/document_image/ef3611d7-d1e8-4ce9-b365-d94487715763-1513806.jpg" alt="img" style="zoom:80%;" /><img src="https://img.mubu.com/document_image/330036b2-b4f1-4a7f-b791-1f14892457a9-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a><strong>透明传输</strong></h4><ul><li><p>上层交下来的数据，不论是什么形式的比特组合，都必须能够正确传送</p></li><li><p>如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。要采取有效措施来解决这个问题</p></li><li><p>解决方法：字节填充或字符填充</p><img src="https://img.mubu.com/document_image/bc261c7c-0988-4cc8-b4a1-39e635d386b2-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul><h4 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a><strong>差错检测</strong></h4><ul><li><p>比特差错：1 可能会变成 0 而 0 也可能变成 1。</p></li><li><p>误码率:传输错误的比特占所传输比特总数的比率</p></li><li><p>循环冗余检验 CRC</p><ul><li><p>先把数据划分为组，每组K个比特</p></li><li><p>需要传输一组数据M，得先在M后面添加n位的冗余码（即后面所得的余数）再一起发送(共k＋n位)</p></li><li><p>发送端与接受端先商定好长度为(n+1)的除数p</p></li><li><p>冗余码（FCS）：M加上n个0后除以p，得一余数，该余数就是冗余码（也称帧检验序列&#x2F;校检码）。余数的个数和添加的0的个数是一样的，都是n位</p></li><li><p>将冗余码添加到M的尾部再进行帧的发送，一共（k+n）位。</p></li><li><p>接受端对把收到的每一个帧都除以除数P，若余数等于0，则无差错，就接受。若余数不为0，则判定帧有差错，就丢弃</p></li><li><p>除数p&#x3D;1101 对应的多项式为：X^3+X^2+1</p></li><li><p>（模2运算加法不进位，采用异或的方式）</p><img src="https://img.mubu.com/document_image/eb0a0707-5eba-440d-a4ee-db4d68ef4351-7976057.jpg" alt="img" style="zoom:80%;" /></li></ul></li></ul><h3 id="PPP-点到点协议"><a href="#PPP-点到点协议" class="headerlink" title="PPP 点到点协议"></a>PPP 点到点协议</h3><p>在TCP&#x2F;IP协议族中，可靠传输由运输层的TCP协议负责，因此数据链路层的PPP协议不需要进行纠错，不需要设置序号，也不需要进行流量控制。只支持全双工链路</p><h3 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h3><ul><li><p>局域网的数据链路层</p><ul><li><p>局域网：网络为一个单位所占有，且地理范围和站点数目均有限</p></li><li><p>如何使众多用户能够合理而方便地共享通信媒体资源</p><ul><li>动态媒体接入控制——随机接入(主要)</li></ul></li><li><p>适配器：计算机与局域网的连接是通过适配器进行的</p><img src="https://img.mubu.com/document_image/4b713a5d-8206-480b-a1dc-03a52f7480a7-1513806.jpg" alt="img" style="zoom:80%;" /></li><li><p><strong>CSMA&#x2F;CD协议</strong> </p><ul><li><p>概念：载波监听多点接入&#x2F;碰撞检测 carrier sense multiple access with collision detection</p></li><li><p>以太网将许多计算机都接到一根总线上，特点：当一台计算机发送数据时，总线上的所有计算机都能检测到这个数据，总线在同一时间只允许一台计算机发送数据</p><ul><li>以太网采用较为灵活的无连接的工作方式</li><li>适配器对发送的数据帧不进行编号，也不要求对方发回确认</li><li>以太网提供的服务是尽最大努力的交付，即不可靠的交付</li><li>对有差错帧是否需要重传由高层来决定</li><li>以太网发送的数据都采用曼彻斯特码</li></ul></li><li><p>CSMA&#x2F;CD协议要点 半双工方式工作</p><ul><li>多点接入：说明这是总线型网络，有多台计算机连接在总线上</li><li>载波监听：要时刻检测总线上是否有其他计算机也在发送，在发送前，发送中，每个站都必须不停地检测信道。发送前检测是为了获得发送权，发送中检测是为了及时发现是否有其他站的发送和本站的发送的碰撞</li><li>碰撞检测：需要边发边监听，判断自己在发送数据时是否还有其他站点也在发送数据。B站在A站发送的数据未到达前发送B自己的帧</li></ul></li><li><p>在CSMA&#x2F;CD协议下，一个站不可能同时接受和发送（但必须边发送边监听）。只能进行半双工通信</p></li><li><p>发送的不确定性:以太网不能保证某一时间内一定能把自己的数据帧成功发出去</p></li><li><p>争用期&#x2F;碰撞窗口：端到端往返时间2τ，经过了争用期还没有检测到碰撞，才能肯定这次发送肯定不会发生碰撞</p></li><li><p>截断二进制指数退避</p><ul><li><p>退避r倍争用期</p><img src="https://img.mubu.com/document_image/8ffad629-e2a9-4586-9113-a3038d77f6b8-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul></li><li><p>最短帧长：争用期*速率 10Mbit&#x2F;s的以太网 争用期时长是51.2微秒 则最短帧长是512bit&#x3D;64字节</p></li></ul></li><li><p>集线器</p><ul><li>星型拓扑以太网的中心</li><li>星形以太网10 BASE-T的标准，10代表10Mb&#x2F;s的数据率，base表示连接线上的信号是基带信号，T代表双绞线，距离不超过100m 10 BASE F F代表光纤，主要用作集线器之间的远程连接</li><li>集线器特点<ul><li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享逻辑上的总线，使用的还是CSMA&#x2F;CD协议，并且在同一时刻至多只允许一个站发送数据</li><li>集线器工作在物理层，它的每个接口仅仅简单地转发比特</li></ul></li></ul></li><li><p>信道利用率： 极限利用率S(max)&#x3D;T0&#x2F;T0+b b为单程端到端时延 T0为帧本身发送时间</p></li></ul></li></ul><h3 id="MAC层"><a href="#MAC层" class="headerlink" title="MAC层"></a>MAC层</h3><ul><li><p>MAC地址（硬件地址、物理地址）</p><ul><li><p>MAC地址长度为48位（6字节），每一个站的名字 或标识符。生产适配器时，6字节的MAC地址已被固化在适配器的ROM</p></li><li><p>发往本站的帧：1.单播帧 2.广播帧 （一对全体） 3.多播帧（一对多）</p></li><li><p>混杂方式工作的以太网适配器：只要听到有帧在以太网上传输就都接受下来</p></li><li><p>MAC帧格式 最短为64位，数据报最短为46位</p><ul><li><p>以太网传输数据以帧为单位，传送各帧时，各帧之间有一定的时间间隙，以太网有帧开始界定符，但不需要使用帧结束界定符，也不需要使用字节插入来保证透明传输。</p><img src="https://img.mubu.com/document_image/03ea5d72-fdba-4ddd-b3f1-d3ccfa48b6e5-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul></li></ul></li></ul><h3 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h3><ul><li><p>网桥：工作在数据链路层，根据MAC帧的目的地址对收到的帧进行转发和过滤，当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口</p></li><li><p>为保证在任何两个站之间只有一条路径，透明网桥使用了生成树（Spanning tree）算法</p></li><li><p>以太网交换机</p><ul><li><p>实质为一个多接口的网桥</p></li><li><p>一个接口与一个单台主机或另一个以太网交换机相连。工作在全双工方式</p></li><li><p>相互通信的主机都是独占传输媒体，无碰撞地传输数据。</p></li><li><p>以太网交换机是一种即插即用设备，其内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的</p></li><li><p>不使用共享协议，没有碰撞问题，因此不使用CSMA&#x2F;CD协议，而是以全双工方式工作。但是仍采用以太网的帧结构。</p><img src="https://img.mubu.com/document_image/fbefcc08-29fc-4346-8f42-ed3505f729a6-1513806.jpg" alt="img" style="zoom:80%;" /><img src="https://img.mubu.com/document_image/9bd7d2ef-1385-4384-bb60-5e861697bd43-1513806.jpg" alt="img" style="zoom:80%;" /></li></ul></li></ul><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><ul><li>概念：在虚拟局域网上的每一个站都可以收到同一个虚拟局域网上的其他站发出的广播（连接在同一个以太网交换机上的站是不能共享的）限制了接收广播信息的计算机数，使得网络不会因为传播过多的广播信息（即所谓的”广播风暴”）而引起性能恶化</li></ul><p>高速 以太网：100BSE-T，指双绞线上传送100Mbit&#x2F;s基带信号的星型拓扑以太网</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat学习</title>
    <link href="/20200705/2911faf4/"/>
    <url>/20200705/2911faf4/</url>
    
    <content type="html"><![CDATA[<h2 id="Tomcat学习"><a href="#Tomcat学习" class="headerlink" title="Tomcat学习"></a>Tomcat学习</h2><h3 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h3><p>百度解释：Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML页面的访问请求。  简单来说Tomcat就是一个运行Java的网络服务器，也是JSP和servlet的容器</p><span id="more"></span><h3 id="下载配置"><a href="#下载配置" class="headerlink" title="下载配置"></a>下载配置</h3><p>tomcat可以在<a href="https://tomcat.apache.org/">官网</a>直接下载，点击左侧download选择版本后，再根据自己的版本选择压缩包下载即可，下载完成后解压（建议解压到D盘，C盘可能会出现拒绝访问问题）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Tomcat1.png" alt="下载地址" style="zoom: 67%;" /><p>解压完成后，在环境变量中配置，在系统变量中新建，变量名为<code>CATALINA_HOME</code>，变量值即为安装目录（是tomcat整个的安装目录！）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Tomcat2.png" style="zoom: 67%;"  ><p>然后在系统变量的path变量中添加<code>%CATALINA_HOME%\bin</code>，一路确认返回即可。</p><p>【注：使用的tomcat-9.0.36版本只需配置CATALINA_HOME，更高版本需要配置_BASE、TOMCAT_HOME等配置，不然会报错CATALINA环境变量不正确。具体内容百度】</p><p>Tomcat的运行需要JDK的支持，在命令行中输入<code>java -version</code>查看Java版本，在 JDK1.8 环境下能够正常运行，如果是在12.0版本，1.7版本，Tomcat不能够正常启动！其他JDK版本具体测试，JDK自行百度</p><p>准备好后在命令行中输入<code>startup.bat</code>即可进入tomcat<strong>（此时新产生的命令行窗口不能关闭）</strong>，在浏览器中输入<code>localhost:8080</code>查看到相应页面即成功配置！</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Tomcat3.png" style="zoom: 67%;" ><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>Tomcat的配置文件在conf&#x2F;server.xml中，可以配置主机名称、访问端口号等</p><p>常见端口号：Tomcat  8080；MySQL  3306；http  80；https  443；</p><h4 id="配置中的常见问题"><a href="#配置中的常见问题" class="headerlink" title="配置中的常见问题"></a>配置中的常见问题</h4><p>1 启动错误，一闪而退可能是端口被占用，tomcat默认的是8080端口，可以在到安装目录下的conf&#x2F;server.xml文件中修改端口</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Tomcat4.png"></p><p>2 如果出现乱码，可以在安装目录的conf文件夹下，找到logging.properties文件，打开修改UTF-8为GBK即可</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Tomcat5.png"></p><h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>部署前我们需要先了解Tomcat安装目录的文件结构，最好的方法就是在官网看文档<strong>（适用于所有软件、框架的学习）</strong>，在documentation选择自己下载的版本，进入后overview查看</p><ul><li>&#x2F;bin：启动、关闭和一些其他的脚本文件，在Unix系统是.sh文件在window是.bat文件</li><li>&#x2F;conf：存放Tomcat的各种配置文件</li><li>&#x2F;lib：存放Tomcat的支撑jar包</li><li>&#x2F;logs：日志文件默认的存放位置</li><li>&#x2F;temp：存放运行时产生的临时文件</li><li>&#x2F;webapps：存放自己web app的位置</li></ul><p>部署方式有两种：内嵌式部署、外部映射部署</p><ul><li><p>内嵌式部署：直接将你的web app放在上述的webapps目录下，然后<code>localhost:8080/你的web app文件夹/资源文件.html</code>即可查看。</p><p>具体演示：在webapps目录下新建test目录，新建一个firstweb.html文件，编写html代码，然后在浏览器中输入<code>localhost:8080/test/firstweb.html</code>即可访问</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Tomcat6.png" style="zoom:33%;" /><ul><li><p>通过WEB-INF设置首页：我们的web app不可能就一个html文件，在多个文件的情况下要设置一个首页，可以借助WEB-INF目录下的web.xml文件实现</p><p>在之前的test目录下创建second.html文件，编写代码，然后创建WEB-INF目录，新建web.xml文件，由于我们自己是不知道规范格式咋写的，可以直接将test同级目录的ROOT目录中的web.xml代码copy过来，然后加上：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"> &lt;welcome-<span class="hljs-built_in">file</span>-<span class="hljs-built_in">list</span>&gt;<br>&lt;welcome-<span class="hljs-built_in">file</span>&gt;secondweb.html&lt;/welcome-<span class="hljs-built_in">file</span>&gt;<br> &lt;/welcome-<span class="hljs-built_in">file</span>-<span class="hljs-built_in">list</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/TomcaT9.png"></p><p>然后此时可以不用再指定资源文件了，直接浏览器输入<code>localhost:8080/test</code>即可看到设置的首页</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Tomcat8.png" style="zoom:50%;" /></li></ul></li><li><p>外部映射部署：不是在webapps目录而是在其他盘中的web app文件，也可以部署到Tomcat中，分散存放web文件既可以节约资源也比较方便管理</p><p>具体演示：</p><ul><li>法一：在F盘中创建一个test2，按照之前的目录结构新建index.html，编写代码，然后打开Tom cat的conf目录下的server.xml，在Host标签下添加一行代码：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;Context <span class="hljs-attribute">path</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attribute">docBase</span>=<span class="hljs-string">&quot;&quot;</span>&gt;<br>path:表示的是访问时输入的web项目名（即是映射路径）<br>docBase：表示的是站点目录的绝对路径<br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Tomcat7.png"></p><p>打开浏览器输入<code>localhost:8080/new/index.html</code>即可</p><ul><li><p>法二：在conf的Catalina的localhost目录下新建一个new.xml文件然后配置xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Context</span></span><br><span class="hljs-tag"><span class="hljs-attr">reloadable:</span>&quot;<span class="hljs-attr">true</span>&quot;</span><br><span class="hljs-tag"><span class="hljs-attr">docBase</span>=<span class="hljs-string">&quot;F:\test2&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Context</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同样，打开浏览器输入<code>localhost:8080/new/index.html</code>即可。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决hexo部署GitHub报错问题</title>
    <link href="/20200702/c23396ba/"/>
    <url>/20200702/c23396ba/</url>
    
    <content type="html"><![CDATA[<p>解决GitHub部署遇到的一个小问题，虽然小问题却也困扰了一晚上，还要多积累啊。。。</p><span id="more"></span><p>问题描述：</p><p>之前写的一篇博客上传了就没管了，结果在网站上压根没有，重新<code>npm run deployee</code>了两遍还是没有，仔细一看才发现部署信息提示报错了（很奇怪：有时有有时无。。）——在hexo d部署时出现了<code>ssh: connect to host github.com port 22: Connection timed out</code>问题。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427165954014.png" alt="image-20230427165954014" style="zoom:80%;" /><p>遗憾的是第一次看见时我跑偏了。。只关注了下面的<code>Please make sure you have the correct access rights and the repository exists.</code>描述，然后找解决问题，发现是git服务器没有存储本地ssh密钥。因此执行了一遍操作：</p><ul><li>找到.ssh文件夹（C:\User\用户名.ssh），删除其中的known_host（直接删除）</li><li>在Git的bin目录下（一般是C:\Program File\Git\Bin）找到bash.exe输入<code>ssh-keygen -t rsa -C &quot;git的username&quot;</code>，成功就返回一些提示信息，都直接yes回车，然后生成了SSH KEY，即.ssh&#x2F;id_rsa.pub文件</li><li>将id_rsa.pub中的内容赋值，在GitHub的setting中找到SSH keys复制添加</li><li>在bash.exe中输入<code>ssh -T git@github.com</code>验证即可</li></ul><p>然鹅我最后出现的是：<code>Hi 61hhh! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>，一搜说出现这个没啥影响，好的。</p><p>再次hexo d没报错，结果还是没有，再执行hexo d又报错了：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427170007989.png" alt="image-20230427170007989" style="zoom:80%;" /><p>搜到另外的操作：</p><ul><li><p>在.ssh文件夹下使用bash，指令<code>vim config</code>，然后:wq退出</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host github.com<br><span class="hljs-keyword">User</span> <span class="hljs-title">注册github</span>的邮箱<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure></li><li><p>再执行<code>ssh -T git@github.com</code>，出现提示回车即可</p></li></ul><p>然后依旧port 443报错，那么就不是这个端口的问题了。。改回默认的22端口，然后换个操作：</p><ul><li>打开控制面板，打开：系统和安全—&gt;Windows Defender防火墙—&gt;左侧高级设置—&gt;入站规则—&gt;新建规则</li><li>依次选：端口—&gt;特定本地端口22—&gt;允许连接—&gt;域、专用、公用默认都选上—&gt;名称描述自己设置</li></ul><p>提示如下图，操作完成后可以看到如图2：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427170029473.png" alt="image-20230427170029473" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427170044822.png" alt="image-20230427170044822" style="zoom:80%;" /><p>根本的问题是：GitHub的ssh连接用到了22端口而防火墙并没有开放。（我也没动过22端口。。。真离谱）</p><p>再次尝试hexo d部署没有问题，在GitHub的代码仓库中也找到了生成的静态html文件，问题解决！</p>]]></content>
    
    
    <categories>
      
      <category>博客工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intent详解</title>
    <link href="/20200702/89a5df9d/"/>
    <url>/20200702/89a5df9d/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中使用Intent的总结"><a href="#Android中使用Intent的总结" class="headerlink" title="Android中使用Intent的总结"></a>Android中使用Intent的总结</h1><p>学习Android一开始就是活动（Activity），而Intent就是连接活动的重要组件。</p><p>Android中提供了Intent机制来协助应用间的交互与通讯，或者采用更准确的说法是，Intent不仅可用于应用程序之间，也可用于应用程序内部的activity, service和broadcast receiver之间的交互。Intent是一种运行时绑定（runtime binding)机制，它能在程序运行的过程中连接两个不同的组件。通过Intent，你的程序可以向Android表达某种请求或者意愿，Android会根据意愿的内容选择适当的组件来响应。</p><p>参考文档：</p><p><a href="https://developer.android.google.cn/guide/components/intents-filters">Intent 和 Intent 过滤器</a></p><p><a href="https://www.cnblogs.com/qianguyihao/p/3959204.html">Android组件系列—-Intent详解</a></p><span id="more"></span><h2 id="1-Intent概念"><a href="#1-Intent概念" class="headerlink" title="1 Intent概念"></a>1 Intent概念</h2><p><code>Intent</code> 是一个消息传递对象，您可以用来从其他<a href="https://developer.android.google.cn/guide/components/fundamentals#Components">应用组件</a>请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p><ul><li><p><strong>启动Activity</strong></p><p>通过将 <code>Intent</code> 传递给 <code>startActivity()</code>，可以启动新的 <code>Activity</code> 实例。<code>Intent</code> 用于描述要启动的 Activity，并携带任何必要的数据。</p><p>如果希望在 Activity 完成后收到结果，可以调用 <code>startActivityForResult()</code>。在 Activity 的 <code>onActivityResult()</code> 回调中， Activity 将结果作为单独的 <code>Intent</code> 对象接收。</p></li><li><p><strong>启动服务</strong></p><p><code>Service</code> 是一个不使用用户界面而在后台执行操作的组件。使用 Android 5.0（API 级别 21）及更高版本，您可以启动包含 <code>JobScheduler</code> 的服务。如需了解有关 <code>JobScheduler</code> 的详细信息，请参阅其 <code>API-reference documentation</code>。</p><p>对于 Android 5.0（API 级别 21）之前的版本，您可以使用 <code>Service</code> 类的方法来启动服务。通过将 <code>Intent</code> 传递给 <code>startService()</code>，您可以启动服务执行一次性操作（例如，下载文件）。<code>Intent</code> 用于描述要启动的服务，并携带任何必要的数据。</p><p>如果服务旨在使用客户端-服务器接口，则通过将 <code>Intent</code> 传递给 <code>bindService()</code>，您可以从其他组件绑定到此服务。如需了解详细信息，请参阅<a href="https://developer.android.google.cn/guide/components/services">服务</a>指南。</p></li><li><p><strong>传递广播</strong></p><p>广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 <code>Intent</code> 传递给 <code>sendBroadcast()</code> 或 <code>sendOrderedBroadcast()</code>，您可以将广播传递给其他应用。</p></li></ul><h2 id="2-Intent类型"><a href="#2-Intent类型" class="headerlink" title="2 Intent类型"></a>2 Intent类型</h2><p>Intent分为两种类型：</p><ul><li><p><strong>显示Intent</strong></p><p>即直接指明了需要交互的Activity对应的类，用于启动某个特定应用组件</p></li><li><p><strong>隐式Intent</strong></p><p>隐式 Intent 指定能够在可以执行相应操作的设备上调用任何应用的操作，相比于显式Intent，隐式Intent不指定组件名，而是指定Intent的Action、Data或Category，当启动组件时，系统会去匹配<code>AndroidManifest.xml</code>中相关的<code>Intent-filter</code>，逐一匹配满足属性的组件，不止一个满足条件时会弹出应用选择框。</p></li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230510135701302.png" alt="image-20230510135701302" style="zoom:80%;" /><h2 id="3-Intent相关属性"><a href="#3-Intent相关属性" class="headerlink" title="3 Intent相关属性"></a>3 Intent相关属性</h2><p>Intent有7个属性，其中除了Component是直接属性，其他都是可选属性：</p><ol><li>component(组件)：目的组件</li><li>action（动作）：用来表现意图的行动</li><li>category（类别）：用来表现动作的类别</li><li>data（数据）：表示与动作要操纵的数据</li><li>type（数据类型）：对于data范例的描写</li><li>extras（扩展信息）：扩展信息</li><li>Flags（标志位）：期望这个意图的运行模式</li></ol><h3 id="3-1-component（组件）"><a href="#3-1-component（组件）" class="headerlink" title="3.1 component（组件）"></a>3.1 component（组件）</h3><p>Component属性明确指定Intent的目标组件的类名称。（属于直接Intent）如果 component这个属性有指定的话，将直接使用它指定的组件。指定了这个属性以后，Intent的其它所有属性都是可选的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Activity1中点击button1跳转到Activity2</span><br>button1.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OnClickListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                <span class="hljs-comment">//创建一个意图对象</span><br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>                <span class="hljs-comment">//创建组件，通过组件来响应</span><br>                <span class="hljs-type">ComponentName</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentName</span>(MainActivity.<span class="hljs-built_in">this</span>, SecondActivity.class);<br>                intent.setComponent(component);<br>                startActivity(intent);<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><p>或者使用setClass：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br><span class="hljs-comment">//setClass函数的第一个参数是一个Context对象</span><br><span class="hljs-comment">//Context是一个类，Activity是Context类的子类，也就是说，所有的Activity对象，都可以向上转型为Context对象</span><br><span class="hljs-comment">//setClass函数的第二个参数是一个Class对象，在当前场景下，应该传入需要被启动的Activity类的class对象</span><br>intent.setClass(MainActivity.<span class="hljs-built_in">this</span>, SecondActivity.class);<br>startActivity(intent); <br></code></pre></td></tr></table></figure><p>更简单常用的是直接使用Intent的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Intent intent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(FirstActivity.<span class="hljs-built_in">this</span>,secondActivity.class);<br>startActivity(intent);<br></code></pre></td></tr></table></figure><h3 id="3-2-Action（动作）"><a href="#3-2-Action（动作）" class="headerlink" title="3.2 Action（动作）"></a>3.2 Action（动作）</h3><p>在Intent中，Action就是描述做、写等动作的，当你指明了一个Action，执行者就会依照这个动作的指示，接受相关输入，表现对应行为，产生符合的输出（实际action属性就是一个字符串标记而已）。在Intent类中，定义了一批量的动作，比如ACTION_VIEW，ACTION_PICK等， 基本涵盖了常用动作。加的动作越多，越精确。</p><p>Action 是一个用户定义的字符串，用于描述一个 Android 应用程序组件，一个 Intent Filter 可以包含多个 Action。在 AndroidManifest.xml 的Activity 定义时，可以在其 <intent-filter >节点指定一个 Action列表用于标识 Activity 所能接受的“动作”。</p><table><thead><tr><th align="left">类型</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>ACTION_MAIN</code></td><td align="left">表示程序的入口</td></tr><tr><td align="left"><code>ACTION_VIEW</code></td><td align="left">配合intent.setData(uri)使用，跳转到指定数据的界面</td></tr><tr><td align="left"><code>ACTION_DAIL</code></td><td align="left">显示Data指向的号码并在拨号界面Dailer上</td></tr><tr><td align="left"><code>ACTION_PICK</code></td><td align="left">选择一个一条的Data并且返回它，是一种精确跳转方式(满足条件的Activity只有一个)</td></tr><tr><td align="left"><code>ACTION_SEND</code></td><td align="left">发送Data到指定地方（sendto可以发送多组Data）</td></tr><tr><td align="left"><code>ACTION_EDIT</code></td><td align="left">配合intent.setData(uri)使用，根据不同数据类型的uri，跳转到可编辑的uir指定的需要修改的数据的指定页面。</td></tr><tr><td align="left"><code>ACTION_INSERT</code></td><td align="left">添加一个空的项到容器中</td></tr><tr><td align="left"><code>ACTION_SEARCH</code></td><td align="left">执行搜索</td></tr><tr><td align="left"><code>ACTION_RUN</code></td><td align="left">运行Data</td></tr></tbody></table><h3 id="3-3-category（类别）"><a href="#3-3-category（类别）" class="headerlink" title="3.3 category（类别）"></a>3.3 category（类别）</h3><p>Category属性也是作为<intent-filter>子元素来声明的。Action 和category通常是放在一起用的，例如Activity1跳转到Activity2的隐式Intent即可以采用此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//隐式Intent，Activity1中的OnClick方法</span><br>Intent intent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-string">&quot;com.example.activitytest.Action_START&quot;</span>);<br>intent.addCategory(<span class="hljs-string">&quot;com.example.activitytest.MY_CATEGORY&quot;</span>);<br>startActivity(intent);<br><br><span class="hljs-comment">//在对应的AndroidManifest.xml添加</span><br>        &lt;activity android:name=<span class="hljs-string">&quot;.secondActivity&quot;</span>&gt;<br>            &lt;intent-filter&gt;<br>                &lt;action android:name=<span class="hljs-string">&quot;com.example.activitytest.Action_START&quot;</span> /&gt;<br>                &lt;category android:name=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;<br>                &lt;category android:name=<span class="hljs-string">&quot;android.intent.category.MY_CATEGORY&quot;</span> /&gt;<br>            &lt;/intent-filter&gt;<br>        &lt;/activity&gt;<br><span class="hljs-comment">//在Intent添加类别可以添加多个类别，那就要求被匹配的组件必须同时满足这多个类别，才能匹配成功。操作Activity的时候，如果没有类别，须加上默认类别</span><br></code></pre></td></tr></table></figure><p><code>action</code>表示匹配的动作，category默认为default，即：<strong>只有<action>和<category>中的内容同时能够匹配上Intent中指定的action和category时，这个活动才能响应Intent。而如果有多个组件匹配成功，就会以对话框列表的方式让用户进行选择。</strong></p><p>常用的category添加：</p><table><thead><tr><th>类型</th><th>作用</th></tr></thead><tbody><tr><td><code>CATEGORY_DEFAULT</code></td><td>把一个组件Component设为可被implicit启动的</td></tr><tr><td><code>CATEGORY_LAUNCHER</code></td><td>把一个action设置为在顶级执行。并且包含这个属性的Activity所定义的icon将取代application中定义的icon</td></tr><tr><td><code>CATEGORY_BROWSABLE</code></td><td>当Intent指向网络相关时，必须要添加这个类别</td></tr><tr><td><code>CATEGORY_HOME</code></td><td>使Intent指向Home界面</td></tr><tr><td><code>CATEGORY_PREFERENCE</code></td><td>定义的Activity是一个偏好面板Preference Panel</td></tr></tbody></table><h3 id="3-4-data（数据）"><a href="#3-4-data（数据）" class="headerlink" title="3.4 data（数据）"></a>3.4 data（数据）</h3><ul><li>Data属性是Android要访问的数据，于前面类似也在<intent-filter>中，当有多个组件匹配成功时显示优先级高的，相同则显示列表</li><li>Data是用Uri对象来表示的，uri代表数据的地址，属于一种标识符。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//打开浏览器</span><br>Intent intent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_VIEW);<br>intent.setData(Uri.parse(<span class="hljs-string">&quot;http://salute61.top/&quot;</span>));<br>startActivity(intent);<br><span class="hljs-comment">//初始时调用系统默认的浏览器，可以在清单中修改一下匹配2个       </span><br>&lt;activity android:name=<span class="hljs-string">&quot;.ThirdActivity&quot;</span>&gt;<br>            &lt;intent-filter&gt;<br>                &lt;action android:name=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span>&gt;&lt;/action&gt;<br>                &lt;category android:name=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span>&gt;&lt;/category&gt;<br>                &lt;category android:name=<span class="hljs-string">&quot;android.intent.category.BROWSABLE&quot;</span>&gt;&lt;/category&gt;<br>                &lt;data android:scheme=<span class="hljs-string">&quot;http&quot;</span>&gt;&lt;/data&gt;<br>            &lt;/intent-filter&gt;<br>        &lt;/activity&gt;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230510135730727.png" alt="image-20230510135730727" style="zoom:80%;" /><p>注：当然匹配到的testActivity中的Activity2并没有对应的功能代码，这里只是演示，实际项目开发中不要将没有对应功能的Activity进行响应</p><p>Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。</p><p>data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法。</p><h3 id="3-5-type（数据类型）"><a href="#3-5-type（数据类型）" class="headerlink" title="3.5 type（数据类型）"></a>3.5 type（数据类型）</h3><p>如果Intent对象中既包含Uri又包含Type，则在<intent-filter>中也必须将二者都包含</p><p>Type属性用于明确指定Data属性的数据类型或MIME类型，但是通常来说，当Intent不指定Data属性时，Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，所以无需指定Type属性。</p><p>data和type属性一般只需要一个，通过setData方法会把type属性设置为null，相反设置setType方法会把data设置为null，如果想要两个属性同时设置，要使用Intent.setDataAndType()方法。</p><h3 id="3-6-extras（扩展信息）"><a href="#3-6-extras（扩展信息）" class="headerlink" title="3.6 extras（扩展信息）"></a>3.6 extras（扩展信息）</h3><p>extras可以携带完成请求操作所需的附加信息的键值对。正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的 extra。</p><p>您可以使用各种 <code>putExtra()</code> 方法添加 extra 数据，每种方法均接受两个参数：键名和值。您还可以创建一个包含所有 extra 数据的 <code>Bundle</code> 对象，然后使用 <code>putExtras()</code> 将 <code>Bundle</code> 插入 <code>Intent</code> 中。</p><p>例如，使用 <code>ACTION_SEND</code> 创建用于发送电子邮件的 Intent 时，可以使用 <code>EXTRA_EMAIL</code> 键指定<em>目标</em>收件人，并使用 <code>EXTRA_SUBJECT</code> 键指定<em>主题</em>。</p><p>向下一个活动传递数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">String data=<span class="hljs-string">&quot;使用Intent传递的数据&quot;</span>;<br>Intent intent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(FirstActivity.<span class="hljs-built_in">this</span>,secondActivity.class);<br>intent.putExtra(<span class="hljs-string">&quot;extra_data&quot;</span>,data);<br>startActivity(intent);<br><br><span class="hljs-comment">//在secondActivity中接收</span><br>Intent intent=getIntent();<br>String data=intent.getStringExtra(<span class="hljs-string">&quot;extra_data&quot;</span>);<br>Log.d(<span class="hljs-string">&quot;secondActivity&quot;</span>,data);<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230510135747866.png" alt="image-20230510135747866" style="zoom:80%;" /><p>返回数据给上一个活动（使用startActivityForResult），由于使用startActivityForResult启动了secondActivity，因此secondActivity销毁后会回调上一个活动的onActivityResult方法，因此要重写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//FirstActivity代码</span><br>Intent intent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(FirstActivity.<span class="hljs-built_in">this</span>,secondActivity.class);<br>startActivityForResult(intent,<span class="hljs-number">1</span>);<br><span class="hljs-comment">//SecondActivity中添加返回数据的逻辑</span><br>Intent intent=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>intent.putExtra(<span class="hljs-string">&quot;data_return&quot;</span>,<span class="hljs-string">&quot;secondActivity返回的数据&quot;</span>);<br>setResult(RESULT_OK,intent);<br>finish();<br><br><span class="hljs-comment">//重写onActivityResult方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityResult</span><span class="hljs-params">(<span class="hljs-type">int</span> requestCode,<span class="hljs-type">int</span> resultCode,Intent data)</span>&#123;<br>        <span class="hljs-built_in">super</span>.onActivityResult( requestCode, resultCode,data);<br>        <span class="hljs-keyword">switch</span> (requestCode)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span>(resultCode==RESULT_OK)&#123;<br>                    String returnData=data.getStringExtra(<span class="hljs-string">&quot;data_return&quot;</span>);<br>                    Log.d(<span class="hljs-string">&quot;FirstActivity&quot;</span>,returnData);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230510135810004.png" alt="image-20230510135810004" style="zoom:80%;" /><h3 id="3-7-Flag（标志位）"><a href="#3-7-Flag（标志位）" class="headerlink" title="3.7 Flag（标志位）"></a>3.7 Flag（标志位）</h3><p>一个程序启动后系统会为这个程序分配一个task供其使用，另外同一个task里面可以拥有不同应用程序的activity。那么，同一个程序能不能拥有多个task？相关知识涉及到加载activity的启动模式</p><p>注：android中一组逻辑上在一起的activity被叫做task，自己认为可以理解成一个activity堆栈。</p>]]></content>
    
    
    <categories>
      
      <category>其他记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UML建模--用例图</title>
    <link href="/20200511/208504bf/"/>
    <url>/20200511/208504bf/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>根据百度百科：用例图是指由参与者（Actor）、<a href="https://baike.baidu.com/item/%E7%94%A8%E4%BE%8B/163511">用例</a>（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图。用例图（User Case）是外部用户（被称为参与者）所能观察到的系统功能的<strong>模型图。用例图是系统的蓝图。</strong>用例图呈现了一些参与者，一些用例，以及它们之间的关系，主要用于对系统、子系统或类的功能行为进行<a href="https://baike.baidu.com/item/%E5%BB%BA%E6%A8%A1/814831">建模</a>。</p><span id="more"></span><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>用例图包含的元素如下：</p><ol><li><p>参与者（Actor）</p><p>不一定指人，它表示你开发的系统以外的，使用本系统或与本系统交互的角色。用小人形表示</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Actor.png"></p></li><li><p>用例（Use Case）</p><p>是对包括变量在内的一组动作序列的描述，系统执行这些动作，并产生传递特定参与者的价值的可观察结果。简单说用例就是外部可见的系统功能，对系统提供的服务进行描述。用椭圆表示。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/usecase.png"></p></li><li><p>容器</p><p>容器代表的就是开发的系统。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420172714300.png" alt="image-20230420172714300" style="zoom:50%;" /><p>系统边界：<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%BE%B9%E7%95%8C">系统边界</a>是用来表示正在<a href="https://baike.baidu.com/item/%E5%BB%BA%E6%A8%A1">建模</a>系统的边界。边界内表示系统的组成部分，边界外表示系统外部。系统边界在画图中用方框来表示，同时附上系统的名称，参与者画在边界的外面，用例画在边界里面。</p><p>箭头：用来表示参与者和系统通过相互发送信号或消息进行交互的关联关系。箭头尾部用来表示启动交互的一方，箭头头部用来表示被启动的一方，其中用例总是要由参与者来启动。</p></li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>用例图的作用主要由三个：</p><ol><li>获取需求</li><li>指导测试</li><li>在开发的其他工作流中起指导作用</li></ol><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>用例图中涉及的关系有四种：<strong>包含、泛化、扩展</strong></p><ol><li><p>包含关系（include）：两个或多个用例中共用一组相同的动作，这时可以将这组相同的动作抽出来作为一个独立的子用例，供多个基用例所共享。（因为子用例被抽出，基用例并非一个完整的用例，所以<strong>include关系中的基用例必须和子用例一起使用才实现完整功能。</strong>）</p><p>例如：业务中，总是存在着维护某某信息的功能，如果将它作为一个用例，那添加、修改以及删除都要在用例详述中描述，过于复杂；如果分成添加用例、修改用例和删除用例，则划分太细。这时包含关系可以用来理清关系。</p><p>【箭头指向】：include关系在用例图中使用带箭头的虚线表示(在线上标注&lt;<include>&gt;)，箭头从基用例指向子用例。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420172732551.png" alt="image-20230420172732551" style="zoom:80%;" /></li><li><p>扩展关系（extend）：假设一个用例明显地混合了两种或者两种以上的不同场景，即依据情况可能发生多种分支，则能够将这个用例分为一个基用例和一个或多个扩展子用例。这样可能会使描写叙述更加清晰。（<strong>基用例即使没有子用例的参与，也可以完成一个完整的功能</strong>）</p><p>扩展用例为基用例添加新的行为。扩展用例可以访问基用例的属性，因此它能根据基用例中扩展点的当前状态来判断是否执行自己。但是扩展用例对基用例不可见。</p><p>【箭头指向】：extend关系在用例图中使用带箭头的虚线表示(在线上标注&lt;<extend>&gt;)，箭头从子用例指向基用例。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420172749045.png" alt="image-20230420172749045" style="zoom:80%;" /></li><li><p>泛化关系（generalization）：泛化关系是一种继承关系，子用例将继承基用例的所有行为，关系和通信关系，也就是说在任何使用基用例的地方都可以用子用例来代替。</p><p>【箭头指向】：在用例图中使用空心的箭头表示，箭头方向从子用例指向基用例。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420172802314.png" alt="image-20230420172802314" style="zoom:80%;" /></li></ol><p>以下是一个小示例：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230420172820440.png" alt="image-20230420172820440" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中的let和const命令</title>
    <link href="/20200425/fa6e05a2/"/>
    <url>/20200425/fa6e05a2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在js30中看到的let和const两种声明变量的方法，记录一下二者的基本概念</p><blockquote><p>参考阮一峰的：<a href="https://es6.ruanyifeng.com/#docs/let">let 和 const 命令</a></p></blockquote><p>在ES6之前，Js只有两种作用域：<strong>全局变量</strong>和<strong>函数内局部变量</strong></p><p>ES6中引入了两个关键字：<strong>let</strong>、<strong>const</strong></p><span id="more"></span><h2 id="1-let命令"><a href="#1-let命令" class="headerlink" title="1 let命令"></a>1 let命令</h2><h3 id="1-1-块级作用域"><a href="#1-1-块级作用域" class="headerlink" title="1.1 块级作用域"></a>1.1 块级作用域</h3><p>首先它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><ul><li>使用 var 关键字声明的变量不具备块级作用域的特性，它在 {} 外依然能被访问到。</li><li>let 声明的变量只在 let 命令所在的代码块 <strong>{}</strong> 内有效，在 <strong>{}</strong> 之外不能访问。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;<br>&#125;<br>a <span class="hljs-comment">// ReferenceError: a is not defined.</span><br>b <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>块级作用域可以解决很多问题，例如：</p><ul><li>内层变量覆盖外层</li><li>循环变量用完后泄露为全局变量</li></ul><p>ES6允许块级作用域的嵌套，只要使用<code>&#123;&#125;</code>括起来，外层无法读取内层的变量（C++函数体范围概念类似）</p><p>块级作用域也使得匿名立即执行函数表达式（匿名 IIFE）不再必要了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// IIFE 写法</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> tmp = ...;<br>  ...<br>&#125;());<br><span class="hljs-comment">// 块级作用域写法</span><br>&#123;<br>  <span class="hljs-keyword">let</span> tmp = ...;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-循环作用域"><a href="#1-2-循环作用域" class="headerlink" title="1.2 循环作用域"></a>1.2 循环作用域</h3><p>使用了 <strong>var</strong> 关键字，它声明的变量是全局的，包括循环体内与循环体外，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，所以全局只有一个变量<code>i</code>，每次循环改变的是<code>i</code>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  a[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br>a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>使用 <strong>let</strong> 关键字，它声明的变量仅在块级作用域有效，每次循环都是一个新的变量，每个<code>i</code>都是不一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  a[i] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;;<br>&#125;<br>a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p><strong>注：</strong> JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。因此本轮重新声明的值可以知道上一轮的值从而开展计算。</p><p><strong>另：</strong><code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。结果成功输出3次abc，即说明循环变量的<code>i</code>和函数体内部的<code>i</code>不一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>&#125;<br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br></code></pre></td></tr></table></figure><h3 id="1-3-变量提升问题-amp-暂时性死区"><a href="#1-3-变量提升问题-amp-暂时性死区" class="headerlink" title="1.3 变量提升问题&amp;暂时性死区"></a>1.3 变量提升问题&amp;暂时性死区</h3><p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p><p>变量提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。</p><ul><li><code>var</code>声明的变量可以在声明前使用，值为<code>undefined</code>，但是按照逻辑应该是先声明后使用</li><li><code>let</code>的变量必须先声明后使用，即变量<code>a</code>在声明前就存在了，由于是<code>var</code>声明，就会先输出<code>undefined</code> ，而<code>b</code>用<code>let</code>声明，表示在声明前<code>b</code>是不存在的，若使用了就会报错。</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">//undefined</span><br><span class="hljs-keyword">var</span> a=<span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b);<span class="hljs-comment">//报错：ReferenceError</span><br>let b=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。（学过C++的还是很好理解这些概念的）</p><p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a=<span class="hljs-number">111</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>a=<span class="hljs-string">&quot;xyz&quot;</span>;<span class="hljs-comment">//报错</span><br>    <span class="hljs-keyword">typeof</span> x; <span class="hljs-comment">// ReferenceError</span><br><span class="hljs-keyword">let</span> a;<span class="hljs-comment">//在let命令声明变量tmp之前，都属于变量tmp的“死区”。</span><br>&#125;<br><br><span class="hljs-comment">//或者一些隐性的死区</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cmp</span>(<span class="hljs-params">x=y,y=<span class="hljs-number">2</span></span>)&#123;<br>    <span class="hljs-keyword">return</span> [x,y];<br>&#125;<br><span class="hljs-title function_">cmp</span>();<br><span class="hljs-comment">//因为x默认值=y，此时y还未声明，属于死区  </span><br><span class="hljs-comment">//改为x=2,y=x就不会报错</span><br></code></pre></td></tr></table></figure><h3 id="1-4-全局变量和全局对象的属性"><a href="#1-4-全局变量和全局对象的属性" class="headerlink" title="1.4 全局变量和全局对象的属性"></a>1.4 全局变量和全局对象的属性</h3><p>ES5中全局对象的属性与全局变量基本是等价的，但是也有区别，比如通过var声明的全局变量不能使用delete从 window&#x2F;global （ global是针对与node环境）上删除，不过在变量的访问上基本等价。</p><p>ES6 中做了严格的区分，使用 var 和 function 声明的全局变量依旧作为全局对象的属性，使用 <strong><code>let</code>****, <code>const</code></strong> 命令声明的全局变量不属于全局对象的属性。</p><h2 id="2-const命令"><a href="#2-const命令" class="headerlink" title="2 const命令"></a>2 const命令</h2><p>const 和 let 的作用域是一致的，不同的是 const 变量一旦被赋值，就不能再改变了，但是这并不意味着使用 const 声明的变量本身不可变，只是说它不可被再次赋值了，而且const 声明的变量必须经过<strong>初始化</strong>。即声明时就进行赋值操作，只声明不赋值会报错！</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> foo;<br><span class="hljs-comment">// SyntaxError: Missing initializer in const declaration</span><br></code></pre></td></tr></table></figure><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>const</code>实际上并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于复合类型的数据（主要是对象和数组），变量指向的是数据所在的地址，因此它保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个地址指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构就不能控制了。因此，将一个对象声明为常量必须非常小心。</p><ul><li>简单数据类型（数值，字符串，布尔值）：值保存在变量指向的那个内存地址，因此等同于常量。</li><li>复合类型的数据（对象和数组）：变量指向的是内存地址，保存的是一个指针，const只能保存这个指针地址是固定的，至于他指向的数据结构是不是可变的，就完全不能控制了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>其他记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客加密</title>
    <link href="/20200418/f0a4488f/"/>
    <url>/20200418/f0a4488f/</url>
    
    <content type="html"><![CDATA[<p>有时当我们写了一篇博客，但并不想所有人能够访问它。对于<code>WordPress</code>这很容易做到，但是对于hexo，由于是静态网页，并不能做到完全的加密。</p><p>Github上有大神做了插件可以帮助我们。地址： <a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md">GitHub</a>，可以参照他的文档配置</p><span id="more"></span><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>不知道为啥，当时正常输密码查看没问题，后来输密码没反应了。。。。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427165614097.png" alt="image-20230427165614097" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427165637092.png" alt="image-20230427165637092" style="zoom:80%;" /><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在项目根目录下，输入命令：<code>npm install hexo-blog-encrypt --save</code></p><h3 id="根目录配置"><a href="#根目录配置" class="headerlink" title="根目录配置"></a>根目录配置</h3><p>在根目录_config.yml文件中末尾配置，添加代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">##Security</span><br><span class="hljs-attr">encrypt:</span> <br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>在要加密的文章头部加上对应字段，如<code>password</code>、<code>abstract</code>、<code>message</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">hexo博客加密</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-04-18 21:04:06</span><br><span class="hljs-attr">tags:</span> <br><span class="hljs-bullet">-</span> <span class="hljs-string">web</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">学习</span><br><span class="hljs-attr">password:</span> <span class="hljs-string">ly61</span><br><span class="hljs-attr">abstract:</span> <span class="hljs-string">hello,</span> <span class="hljs-string">an</span> <span class="hljs-string">encode</span> <span class="hljs-string">try</span><br><span class="hljs-attr">message:</span> <span class="hljs-string">Type</span> <span class="hljs-string">the</span> <span class="hljs-string">password</span> <span class="hljs-string">ly61!</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ul><li>password: 是该博客加密使用的密码</li><li>abstract: 是该博客的摘要，会显示在博客的列表页</li><li>message: 这个是博客查看时，密码输入框上面的描述性文字</li></ul><h3 id="对-TOC-进行加密"><a href="#对-TOC-进行加密" class="headerlink" title="对 TOC 进行加密"></a>对 TOC 进行加密</h3><p>如果你有一篇文章使用了 TOC，你需要修改模板的部分代码。这里用 landscape 作为例子：</p><ul><li>你可以在 hexo&#x2F;themes&#x2F;landscape&#x2F;layout&#x2F;_partial&#x2F;article.ejs 找到 article.ejs。</li><li>然后找到 &lt;% post.content %&gt; 这段代码，通常在30行左右。</li><li>使用如下的代码来替代它:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;% if(post.toc == true)&#123; %&gt;<br>  &lt;div id=&quot;toc-div&quot; class=&quot;toc-article&quot; &lt;% if (post.encrypt == true) &#123; %&gt;style=&quot;display:none&quot; &lt;% &#125; %&gt;&gt;<br>    &lt;strong class=&quot;toc-title&quot;&gt;Index&lt;/strong&gt;<br>      &lt;% if (post.encrypt == true) &#123; %&gt;<br>        &lt;%- toc(post.origin, &#123;list_number: true&#125;) %&gt;<br>      &lt;% &#125; else &#123; %&gt;<br>        &lt;%- toc(post.content, &#123;list_number: true&#125;) %&gt;<br>      &lt;% &#125; %&gt;<br>  &lt;/div&gt;<br>&lt;% &#125; %&gt;<br>&lt;%- post.content %&gt;<br></code></pre></td></tr></table></figure><h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>如果不想每篇文章都输入<code>abstract</code>、<code>message</code>等字段，可以在根目录下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">encrypt:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">default_abstract:</span> <span class="hljs-string">这是一篇加密文章，内容可能是个人情感宣泄或者收费技术。如果你确实想看，请与我联系。</span><br>  <span class="hljs-attr">default_message:</span> <span class="hljs-string">输入密码，查看文章。</span><br></code></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Security</span><br><span class="hljs-attr">encrypt:</span> <span class="hljs-comment"># hexo-blog-encrypt</span><br>  <span class="hljs-attr">abstract:</span> <span class="hljs-string">有东西被加密了,</span> <span class="hljs-string">请输入密码查看.</span><br>  <span class="hljs-attr">message:</span> <span class="hljs-string">您好,</span> <span class="hljs-string">这里需要密码.</span><br>  <span class="hljs-attr">tags:</span><br>  <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">tagName</span>, <span class="hljs-attr">password:</span> <span class="hljs-string">密码A</span>&#125;<br>  <span class="hljs-bullet">-</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">tagName</span>, <span class="hljs-attr">password:</span> <span class="hljs-string">密码B</span>&#125;<br>  <span class="hljs-attr">template:</span> <span class="hljs-string">&lt;div</span> <span class="hljs-string">id=&quot;hexo-blog-encrypt&quot;</span> <span class="hljs-string">data-wpm=&quot;&#123;&#123;hbeWrongPassMessage&#125;&#125;&quot;</span> <span class="hljs-string">data-whm=&quot;&#123;&#123;hbeWrongHashMessage&#125;&#125;&quot;&gt;&lt;div</span> <span class="hljs-string">class=&quot;hbe-input-container&quot;&gt;&lt;input</span> <span class="hljs-string">type=&quot;password&quot;</span> <span class="hljs-string">id=&quot;hbePass&quot;</span> <span class="hljs-string">placeholder=&quot;&#123;&#123;hbeMessage&#125;&#125;&quot;</span> <span class="hljs-string">/&gt;&lt;label&gt;&#123;&#123;hbeMessage&#125;&#125;&lt;/label&gt;&lt;div</span> <span class="hljs-string">class=&quot;bottom-line&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script</span> <span class="hljs-string">id=&quot;hbeData&quot;</span> <span class="hljs-string">type=&quot;hbeData&quot;</span> <span class="hljs-string">data-hmacdigest=&quot;&#123;&#123;hbeHmacDigest&#125;&#125;&quot;&gt;&#123;&#123;hbeEncryptedData&#125;&#125;&lt;/script&gt;&lt;/div&gt;</span><br>  <span class="hljs-attr">wrong_pass_message:</span> <span class="hljs-string">抱歉,</span> <span class="hljs-string">这个密码看着不太对,</span> <span class="hljs-string">请再试试.</span><br>  <span class="hljs-attr">wrong_hash_message:</span> <span class="hljs-string">抱歉,</span> <span class="hljs-string">这个文章不能被校验,</span> <span class="hljs-string">不过您还是能看看解密后的内容.</span><br></code></pre></td></tr></table></figure><p>这样就不需要每篇文章都加了，它会自动填充。不过如果某一篇文章想加点不一样的也可以加上文章信息头。</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>文章信息头 &gt; <code>_config.yml</code> (站点根目录下的) &gt; 默认配置</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>对于<code>hexo-blog-encrypt2.0</code>之前的版本，无法触发渲染<code>mathjax</code>的函数，需要升级。</li><li>在部分博客中, 解密后部分元素可能无法正常显示或者表现, 这属于已知问题. 目前的解决办法是通过自行查阅自己的博客中的代码, 了解到在 onload 事件发生时调用了哪些函数, 并将这些函数挑选后写入到博客内容中.</li><li>字数统计功能会出现问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客提交Google和百度收录</title>
    <link href="/20200416/750226c4/"/>
    <url>/20200416/750226c4/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>到现在位置博客算是搭建好了，但是自己写的博客别问访问不了，Github和Coding都有反爬虫机制，搜索引擎搜不到，因此我们要让搜索引擎收录我们的网站。</p><p><strong>验证：</strong>在百度&#x2F;Google搜索框中输入<code>site:***(你的网站/域名)</code>，如果没找到说明没有被收录，Google的验证要先科学上网。</p><p><strong>收录步骤：</strong>主要分为两步，一是<code>验证网站</code>，再是<code>链接提交</code>。</p><p>下面分别说一下百度和谷歌的收录步骤。</p><span id="more"></span><h2 id="百度收录"><a href="#百度收录" class="headerlink" title="百度收录"></a>百度收录</h2><p>首先要验证网站，我们要在百度站长平台中的<a href="http://zhanzhang.baidu.com/dashboard/index">站长工具</a>去验证，步骤：</p><ul><li>输入网站（可能会有一些信息的绑定）</li><li>站点属性（自己随便选，我选了个信息技术、生活情感）</li><li>验证网站</li></ul><h3 id="验证网站"><a href="#验证网站" class="headerlink" title="验证网站"></a>验证网站</h3><p>通过验证之后百度会认为你是网站所有者，然后能做诸如自动推送、手动推送的高级功能！</p><p>验证方法有三个：</p><ul><li>文件验证</li><li>HTML验证</li><li>CNAME验证</li></ul><h4 id="1-文件验证"><a href="#1-文件验证" class="headerlink" title="(1)文件验证"></a>(1)文件验证</h4><ol><li>我选择的是第一个文件验证，按步骤下载验证文件，得到一个<code>baidu_verify_xxxxx.html</code>文件。</li><li>把这个验证文件放在<code>theme/ayer/source/</code>根目录下面，（也可以放在主题的根目录下，好象这样可以避免对应主题在构建过程中在验证文件中加入很多东西影响验证）</li><li>当我们编译网站<code>hexo generate</code>的时候，这个文件会被原封不动的拷贝到我们博客的<code>public/</code>根目录下。</li><li>重新编译部署，就可以点击验证—&gt;完成验证。</li></ol><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H3f8b0c4effb8448fabe53d2ea3b6b81bU.png" style="zoom:80%;" /><h4 id="2-HTML验证"><a href="#2-HTML验证" class="headerlink" title="(2)HTML验证"></a>(2)HTML验证</h4><p>这种方法需要根据不同的主题进行配置，不过原理一样：都是将HTML验证标签加入到博客每个页面的head里面！注意是完整的标签，而不是一部分！</p><ul><li>选择HTML验证，会出现<code>&lt;meta name=&quot;...&quot; content=&quot;...&quot;&gt;</code>标签，将完整标签加到每个博客页面的<code>&lt;head&gt;...&lt;/head&gt;</code>中间</li><li>在对应主题的配置文件中开启提交百度…</li></ul><h4 id="3-CNAME验证"><a href="#3-CNAME验证" class="headerlink" title="(3)CNAME验证"></a>(3)CNAME验证</h4><p>好像CNAME是最简单的，只要有域名即可（我有域名但是没选这个。。。直接RUSH第一个了）</p><p>具体步骤：添加一条新的CNAME解析：<strong>记录类型</strong>是<em>CNAME</em>，<strong>主机记录</strong>是你的token，，<strong>记录值</strong>是zz.baidu.com，其他默认。然后验证即可。</p><h3 id="链接提交"><a href="#链接提交" class="headerlink" title="链接提交"></a>链接提交</h3><p>接下来要做的就是<a href="http://zhanzhang.baidu.com/linksubmit/index">链接提交</a>.链接提交有<code>手动</code>和<code>自动</code>两种方法。</p><p><strong>手动提交</strong>你的站点到百度搜索，在搜索框输入<code>site:salute61.top</code>搜索不到后，下面有提交网址的选项，当然这种方法很麻烦，因为如果想让每一篇文章都能被搜索到就需要把所有的页面链接进行提交！</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H2f7b18d9dd414a85a741d4d770e3a3fdS.png"></p><p><strong>自动提交</strong>显然是更好的选择，在自己网站的站长平台可以看到三种提交方式。</p><h4 id="主动提交"><a href="#主动提交" class="headerlink" title="主动提交"></a>主动提交</h4><p>因为百度收录的效率很低，所以我在sitemap基础上增加了主动推送。</p><p><strong>主动推送：</strong>最为快速的提交方式，建议您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。</p><p>主动推送的好处：</p><ul><li><strong>及时发现：</strong>可以缩短百度爬虫发现您站点新链接的时间，使新发布的页面可以在第一时间被百度收录</li><li><strong>保护原创：</strong>对于网站的最新原创内容，使用主动推送功能可以快速通知到百度，使内容可以在转发之前被百度发现</li></ul><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H03bfde373cab4943b4d6b91a6af11d7cb.png"></p><p>首先安装插件：<code>npm install hexo-baidu-url-submit --save</code></p><p>（插件GitHub地址:<a href="https://github.com/huiwang/hexo-baidu-url-submit">https://github.com/huiwang/hexo-baidu-url-submit</a> ）</p><p>在根目录配置文件中新增字段：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">##主动推送</span><br><span class="hljs-symbol">baidu_url_submit:</span> <br><span class="hljs-symbol">    count:</span> <span class="hljs-number">100</span> <span class="hljs-meta"># 提交最新的一个链接</span><br><span class="hljs-symbol">    host:</span> http:<span class="hljs-comment">//salute61.top/ # 你注册的域名</span><br><span class="hljs-symbol">    token:</span> *** <span class="hljs-meta">#上图中的token后面的字段</span><br><span class="hljs-symbol">    path:</span> baidu_urls.txt <span class="hljs-meta">#文本文档的地址， 新链接会保存在此文本文档里</span><br></code></pre></td></tr></table></figure><p>在deploy中新增：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span>: baidu_url_submit<br></code></pre></td></tr></table></figure><p>这样执行<code>hexo deploy</code>的时候，新的链接就会被推送了。成功后可以在bash中看到：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hb6a1d85346784508ab5bfc8eccff0f5fB.png"></p><h4 id="sitemap提交"><a href="#sitemap提交" class="headerlink" title="sitemap提交"></a>sitemap提交</h4><p>选择sitemap方式时</p><h5 id="1-安装sitemap插件"><a href="#1-安装sitemap插件" class="headerlink" title="1.安装sitemap插件"></a>1.安装sitemap插件</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>hexo-generator-sitemap --save<br>npm <span class="hljs-keyword">install </span>hexo-generator-<span class="hljs-keyword">baidu-sitemap </span>--save<br><span class="hljs-comment">##一个是谷歌的，一个是百度的</span><br></code></pre></td></tr></table></figure><h5 id="2-修改博客配置文件"><a href="#2-修改博客配置文件" class="headerlink" title="2.修改博客配置文件"></a>2.修改博客配置文件</h5><p>修改url为你的博客首页，xxx.github.io或自己的域名</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hca76c42e1527487185a2fb4f31062e79O.png"></p><p>指定生成文件名和生成路径</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 自动生成sitemap</span><br><span class="hljs-symbol">sitemap:</span> <br><span class="hljs-symbol">  path:</span> sitemap.xml<br><span class="hljs-symbol">baidusitemap:</span> <br><span class="hljs-symbol">  path:</span> baidusitemap.xml<br></code></pre></td></tr></table></figure><p>配置完成后执行<code>hexo g</code>，正常情况下会在source文件夹下看到多出两个文件：<code>sitemap.xml</code>和<code>baidusitemap.xml</code>，这就是sitemap文件。</p><p>在自动提交—sitemap的输入框中，按格式填写。然后就可以了！等待一段时间让他收录，也可以访问该xml文件，查看详情</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H2ebfe3c5ab864cec938269a41b520a96S.png"></p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427170422078.png" alt="image-20230427170422078"></p><h2 id="Google收录"><a href="#Google收录" class="headerlink" title="Google收录"></a>Google收录</h2><p>先进入<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">google站点平台</a>，具体步骤与百度相同，只不过要翻墙。步骤也是<code>验证网站</code>，<code>链接提交</code>，不过我网址前缀验证进入，然后没找到验证网站的地方？？？（左侧菜单栏找遍了也没看见哪个是验证网站）</p><p>进入网站有两种方式：网域、网址前缀</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hde6a7df83385422fbbfc930a1da6d983Y.jpg.jpeg"></p><p>查了一下好像直接链接提交就行，直接提交sitemap。完成</p><p><a href="https://support.google.com/webmasters/answer/183669?hl=zh-Hans">帮助文档</a></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hc2b4ff8fb80342a489a7e889936a6d70M.png" style="zoom:80%;" /><p>然后就是等待他们收录了！</p><p>谷歌收录较快，基本我弄完一个小时就收到邮件了，而且每篇新的博客都很快就收录了！</p><p>百度得等很久。。。得近两周才搜得到</p>]]></content>
    
    
    <categories>
      
      <category>博客工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习</title>
    <link href="/20200415/e28ceec1/"/>
    <url>/20200415/e28ceec1/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这两天因为想升级博客主题，结果搞崩溃了好几次，然后发现我对于git指令很不熟悉，虽然以前用过，软工实验也写过报告，但是由于没有团队协作项目，使用起来不熟悉，着这个机会重新学习一下，不求精通，只是温习一下git的基本操作，结合之前的软工实验的git报告，加上网上教程，达到熟练掌握常用的指令即可。</p><p>参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程—廖雪峰</a>；<a href="https://www.cnblogs.com/best/archive/2017/09/07/7474442.html">一小时学会Git</a></p><p>推荐一个很有趣的网站，在教程评论下看到的：<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Braching</a></p><span id="more"></span><h2 id="1-Git安装与配置"><a href="#1-Git安装与配置" class="headerlink" title="1 Git安装与配置"></a>1 Git安装与配置</h2><h3 id="1-1-Git简述"><a href="#1-1-Git简述" class="headerlink" title="1.1 Git简述"></a>1.1 Git简述</h3><p>首先要说的是：<code>Git!=GitHub!!!</code>千万不要以为Git就是GitHub！一个是版本控制系统，一个是代码托管仓库。</p><p>Git是目前世界上最先进的分布式版本控制系统；并且Git是免费、开源的；最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper，作者是Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）。</p><p><strong>官网</strong>： <a href="https://git-scm.com/">https://git-scm.com/</a></p><p><strong>源码：</strong> <a href="https://github.com/git/git/">https://github.com/git/git/</a></p><h3 id="1-2-搭建Git环境"><a href="#1-2-搭建Git环境" class="headerlink" title="1.2 搭建Git环境"></a>1.2 搭建Git环境</h3><h4 id="1-2-1Git安装"><a href="#1-2-1Git安装" class="headerlink" title="1.2.1Git安装"></a>1.2.1Git安装</h4><p>首先要在Git官网上下载对应系统的版本，然后按提示步骤完成安装</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H5da6c37265a54867b1190bfc0b36e0d1j.png" style="zoom:80%;" /><p>安装完成后，鼠标右键就可以看到Git GUI和Git Bash了，推荐使用Git Bash，类Linux风格，而且使用命令行可以帮助我们熟悉Git的指令，至于GUI熟悉了指令以后可以自己摸索</p><p><strong>常用的Linux指令也可以在Git Bash执行：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">git --version<span class="hljs-regexp">//</span>查看版本<br>cd <span class="hljs-regexp">//</span>切换盘符<br>cd ..<span class="hljs-regexp">//</span>回退到上级目录<br>pwd<span class="hljs-regexp">//</span>打印当前目录路径<br>ll(ls)<span class="hljs-regexp">//</span>列出目录中的文件<br>touch ***<span class="hljs-regexp">//</span>新建一个***文件<br>rm ***<span class="hljs-regexp">//</span>删除***文件<br>mkdir ** <span class="hljs-regexp">//</span>新建文件夹<br>......<br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H5974392aa90748dca3543325057c141eJ.png"></p><h4 id="1-2-2-Git配置"><a href="#1-2-2-Git配置" class="headerlink" title="1.2.2 Git配置"></a>1.2.2 Git配置</h4><p>使用<code>git config -l</code>可以查看Git环境配置</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hd516afc4940940db8e24c54761cefadfM.png"></p><p>查看不同级别配置文件：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment">#查看系统config</span><br>git config <span class="hljs-params">--system</span> <span class="hljs-params">--list</span><br><span class="hljs-comment">#查看当前用户（global）配置</span><br>git config <span class="hljs-params">--global</span>  <span class="hljs-params">--list</span><br><span class="hljs-comment">#查看当前仓库配置信息</span><br>git config <span class="hljs-params">--local</span>  <span class="hljs-params">--list</span><br></code></pre></td></tr></table></figure><p>Git相关配置文件：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">1： <span class="hljs-string">/etc/gitconfig</span>：包含了适用于系统所有用户和所有项目的值。 <span class="hljs-params">--system</span> 系统级<br>2： ~<span class="hljs-string">/.gitconfig</span>：只适用于当前登录用户的配置。<span class="hljs-params">--global</span> 全局<br>3： 位于git项目目录中的<span class="hljs-string">.git/config</span>：适用于特定git项目的配置。<span class="hljs-params">--local</span>当前项目<br>注意：对于同一配置项，三个配置文件的优先级是1&lt;2&lt;3<br></code></pre></td></tr></table></figure><p><strong>设置用户标识：</strong></p><p>安装Git后首先要做的事情是设置用户名和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$ git config --<span class="hljs-keyword">global</span> user.name <span class="hljs-string">&quot;zhangguo&quot;</span>  <span class="hljs-meta">#名称</span><br>$ git config --<span class="hljs-keyword">global</span> user.email zhangguo<span class="hljs-symbol">@qq</span>.com   <span class="hljs-meta">#邮箱</span><br></code></pre></td></tr></table></figure><p>以在配置时加上–global，设置为全局配置，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="2-Git理论基础"><a href="#2-Git理论基础" class="headerlink" title="2 Git理论基础"></a>2 Git理论基础</h2><p>本部分我直接照搬了<a href="https://www.cnblogs.com/best/archive/2017/09/07/7474442.html">一小时学会Git</a>，因为他讲的很详细。</p><h3 id="2-1-Git工作区域"><a href="#2-1-Git工作区域" class="headerlink" title="2.1 Git工作区域"></a>2.1 Git工作区域</h3><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage&#x2F;Index)、资源库(Repository或Git Directory)。加上远程的git仓库(Remote Directory)就可以分为四个工作区域。其中相互关系为：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Ha7648ddd85f34d628d2e3155b0e63f07m.png" style="zoom:80%;" /><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index &#x2F; Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hcce1b8d54f634f8b94039a86e4710200r.png" style="zoom:80%;" /><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index&#x2F;Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存&#x2F;恢复WorkSpace中的临时状态。</li></ul><h3 id="2-2-Git操作流程"><a href="#2-2-Git操作流程" class="headerlink" title="2.2 Git操作流程"></a>2.2 Git操作流程</h3><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Ha8ec5d2890514721a77519937e88f24ew.png" style="zoom: 67%;" /><h3 id="2-3-图解教程"><a href="#2-3-图解教程" class="headerlink" title="2.3 图解教程"></a>2.3 图解教程</h3><p>Git的原理还是有点小复杂的，要看明白得费点功夫</p><p><a href="http://www.cnblogs.com/yaozhongxiao/p/3811130.html">图解教程中文版</a></p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hf9a115bf51cc4fa4add8ebdf5064940cg.png" style="zoom:80%;" /><h2 id="3-Git操作"><a href="#3-Git操作" class="headerlink" title="3 Git操作"></a>3 Git操作</h2><h3 id="3-1-创建仓库"><a href="#3-1-创建仓库" class="headerlink" title="3.1 创建仓库"></a>3.1 创建仓库</h3><p>有两种方法可以创建版本库：</p><p>版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><ul><li>在本地创建项目目录</li><li>克隆远程仓库到本地</li></ul><h4 id="3-1-1-本地创建"><a href="#3-1-1-本地创建" class="headerlink" title="3.1.1 本地创建"></a>3.1.1 本地创建</h4><p>首先创建一个空目录，然后使用<code>git init</code>把这个目录变成Git可管理的仓库，可以看到过了一个隐藏文件.git，这个就是Git用来跟踪管理版本库的。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hd4233891706a4f7ebc8b666732284b07j.png"></p><h4 id="3-1-2-克隆远程仓库"><a href="#3-1-2-克隆远程仓库" class="headerlink" title="3.1.2 克隆远程仓库"></a>3.1.2 克隆远程仓库</h4><p>远程克隆就是利用<code>git clone &quot;url&quot;</code>形式将远程代码仓库的代码克隆到本地，完成后就可以看到对应文件夹</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H162feeb4765d4f598e84f4bc16dea2b7S.png"></p><h3 id="3-2-Git文件操作"><a href="#3-2-Git文件操作" class="headerlink" title="3.2 Git文件操作"></a>3.2 Git文件操作</h3><h4 id="3-2-1-文件状态"><a href="#3-2-1-文件状态" class="headerlink" title="3.2.1 文件状态"></a>3.2.1 文件状态</h4><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而<strong>判断文件整体是否改变的方法就是用SHA-1算法计算文件的校验和</strong>。</p><p>文件的四个状态：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Ha29b42020bb54910ad0af45dd70e43acv.png" style="zoom:80%;" /><ul><li><strong>Untracked</strong>: 未跟踪, 此文件在本地文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<code>git add</code> 状态变为<code>Staged</code>.</li><li><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为<code>Modified</code>. 如果使用<code>git rm</code>移出版本库, 则成为<code>Untracked</code>文件</li><li><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过<code>git add</code>可进入暂存<code>staged</code>状态, 使用<code>git checkout</code> 则丢弃修改过, 返回到<code>unmodify</code>状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改</li><li><strong>Staged</strong>: 暂存状态. 执行<code>git commit</code>则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为<code>Unmodify</code>状态. 执行<code>git reset HEAD filename</code>取消暂存, 文件状态为<code>Modified</code></li></ul><h4 id="3-2-2-状态操作"><a href="#3-2-2-状态操作" class="headerlink" title="3.2.2 状态操作"></a>3.2.2 状态操作</h4><h5 id="1-查看状态"><a href="#1-查看状态" class="headerlink" title="1.查看状态"></a>1.查看状态</h5><p>可以通过指令查看文件状态：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git status <span class="hljs-regexp">//</span>查看文件状态<br><span class="hljs-regexp">//</span>可以加filename查看具体文件状态<br></code></pre></td></tr></table></figure><p>版本库（Repository）工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p>在实际操作中，要随时掌握工作区状态，就要常用<code>git status</code></p><h5 id="2-添加到暂存区"><a href="#2-添加到暂存区" class="headerlink" title="2.添加到暂存区"></a>2.添加到暂存区</h5><p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>将untracked状态的文件添加到暂存区：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 添加指定文件到暂存区</span><br>$ git <span class="hljs-built_in">add</span> [file1] [file2] <span class="hljs-built_in">..</span>.<br><span class="hljs-comment"># 添加指定目录到暂存区，包括子目录</span><br>$ git <span class="hljs-built_in">add</span> [dir]<br><span class="hljs-comment"># 添加当前目录的所有文件到暂存区</span><br>$ git <span class="hljs-built_in">add</span> .<br></code></pre></td></tr></table></figure><p><strong>举例：</strong></p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>当使用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><h5 id="3-移出暂存区"><a href="#3-移出暂存区" class="headerlink" title="3.移出暂存区"></a>3.移出暂存区</h5><p>当我们发现某一个add到暂存区的文件有误时，可以执行如下指令从暂存区移除：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git rm <span class="hljs-comment">--cached &lt;file&gt;</span><br><span class="hljs-comment">#直接从暂存区删除文件，工作区则不做出改变</span><br></code></pre></td></tr></table></figure><p>或通过重写目录树移除add文件：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">#如果已经用<span class="hljs-keyword">add</span> 命令把文件加入stage了，就先需要从stage中撤销<br>git <span class="hljs-keyword">reset</span> HEAD &lt;<span class="hljs-keyword">file</span>&gt;...<br></code></pre></td></tr></table></figure><p>更多移除的指令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#移除所有未跟踪文件<br>#一般会加上参数-df，-d表示包含目录，-f表示强制清除。<br>git clean <span class="hljs-selector-attr">[options]</span> <br><br>#只从stage中删除，保留物理文件<br>git rm <span class="hljs-attr">--cached</span> readme<span class="hljs-selector-class">.txt</span> <br><br>#不但从stage中删除，同时删除物理文件<br>git rm readme<span class="hljs-selector-class">.txt</span> <br><br>#把<span class="hljs-selector-tag">a</span>.txt改名为<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.txt</span><br>git mv <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.txt</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.txt</span> <br></code></pre></td></tr></table></figure><h5 id="4-commit提交"><a href="#4-commit提交" class="headerlink" title="4.commit提交"></a>4.commit提交</h5><p>通过add只是将文件或目录添加到了index暂存区，使用commit将暂存区的文件提交到本地仓库，每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫commit-id：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 提交暂存区到仓库区，-m 后面是本次提交的说明</span><br><span class="hljs-variable">$ </span>git commit -m [message]<br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br><span class="hljs-variable">$ </span>git commit [file1] [file2] ... -m [message]<br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区，跳过了add,对新文件无效</span><br><span class="hljs-variable">$ </span>git commit -a<br><span class="hljs-comment"># 提交时显示所有diff信息</span><br><span class="hljs-variable">$ </span>git commit -v<br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="hljs-variable">$ </span>git commit --amend -m [message]<br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="hljs-variable">$ </span>git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure><h5 id="lt-代码提交到Git仓库步骤-gt"><a href="#lt-代码提交到Git仓库步骤-gt" class="headerlink" title="&lt;代码提交到Git仓库步骤&gt;"></a><strong>&lt;代码提交到Git仓库步骤&gt;</strong></h5><ol><li><p>使用<code>git add</code>将文件加到缓存区</p><p>执行该步骤没有任何显示，即正确执行</p></li><li><p>使用<code>git commit</code>提交到本地仓库</p><p>建议加上-m，写上每次提交的说明，团队项目方便以后查看。</p></li><li><p>使用<code>git push origin master</code>将本地版本库推送到远程服务器（详细参数参照4.3.6 git push）</p></li></ol><p><strong>注：</strong>因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ git <span class="hljs-built_in">add</span> file1.txt<br>$ git <span class="hljs-built_in">add</span> file2.txt file3.txt<br>$ git commit -m <span class="hljs-string">&quot;add 3 files.&quot;</span><br></code></pre></td></tr></table></figure><p>基本</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H0db03f9a49d4440795317da4b9af5dd0G.png"></p><h5 id="5-比较代码"><a href="#5-比较代码" class="headerlink" title="5.比较代码"></a>5.比较代码</h5><p>git diff用于显示WorkSpace中的文件和暂存区文件的差异。用<code>git status</code>只能查看对哪些文件做了改动，如果要看改动了什么，可以通过<code>git diff</code>指令，比较本次修改的内容具体是啥</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">#比较本地工作区和暂存区</span><br>git <span class="hljs-keyword">diff</span><br><span class="hljs-keyword"></span><span class="hljs-comment">#比较暂存区的文件与之前已经提交过的文件</span><br>git <span class="hljs-keyword">diff </span>--<span class="hljs-keyword">cached</span><br><span class="hljs-keyword"></span><span class="hljs-comment">#比较repo与工作空间中的文件差异</span><br>git <span class="hljs-keyword">diff </span>HEAD~n<br></code></pre></td></tr></table></figure><h5 id="6-提交日志"><a href="#6-提交日志" class="headerlink" title="6.提交日志"></a>6.提交日志</h5><p>在实际工作中，我们不可能记得一个几千行的文件每次都改了什么内容，因此要借助指令查看提交历史。借助<code>git log</code>命令显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment">#查看提交日志</span><br>git <span class="hljs-keyword">log</span> [<span class="hljs-variable">&lt;options&gt;</span>] [<span class="hljs-variable">&lt;revision range&gt;</span>] [[\--] <span class="hljs-variable">&lt;path&gt;</span>…?]<br><span class="hljs-comment"># git log -1则表示显示1行。</span><br><span class="hljs-comment"># git log --graph以图形化的方式显示提交历史的关系，这就可以方便地查看提交历史的分支信息，当然是控制台用字符画出来的图形。</span><br></code></pre></td></tr></table></figure><p>还可以使用history可以查看您在bash下输入过的指令</p><p>注：我们看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号）就是之前说的SHA1计算出来的校验码</p><h5 id="7-版本回退"><a href="#7-版本回退" class="headerlink" title="7.版本回退"></a>7.版本回退</h5><p>可能某一次提交并不是自己想要的，因此可以采用版本回退，回到上一个或者更早之前的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD^</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">HEAD指向的版本总是当前的版本</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">还可以根据git <span class="hljs-built_in">log</span>中的commmit <span class="hljs-built_in">id</span>回到指定版本</span><br></code></pre></td></tr></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向对应版本。</p><p>回退后又想恢复新版本，可以使用<code>git relog</code>查看记录的每一次命令，其中会记录这个仓库中所有的分支的所有更新记录，包括已经撤销的更新。，然后就可以恢复了</p><h5 id="8-删除-x2F-恢复"><a href="#8-删除-x2F-恢复" class="headerlink" title="8.删除&#x2F;恢复"></a>8.删除&#x2F;恢复</h5><p>当我们提交代码到版本库后，如果对本地的代码进行了删除操作，通过<code>git status</code>查看到工作区与版本库就出现了不一致。</p><p>可能是就是要删除，就用如下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> ***<br>git commmit -m <span class="hljs-string">&quot;删除了***&quot;</span><br></code></pre></td></tr></table></figure><p>如果是操作失误：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">git checkout <span class="hljs-comment">-- ***</span><br><span class="hljs-comment"># git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</span><br></code></pre></td></tr></table></figure><p><strong>注：</strong>从来没有被添加到版本库就被删除的文件，是无法恢复的！</p><h2 id="4-远程仓库"><a href="#4-远程仓库" class="headerlink" title="4.远程仓库"></a>4.远程仓库</h2><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上，打个比方：一个资源服务器链接多个主机，这些主机都可以从该服务器上下载资源。我们每个人的本机就类似于主机，托管平台，例如GitHub、Coding就类似于资源服务器。</p><p>同时相较于传统的代码都是管理到本机或者内网。 一旦本机或者内网机器出问题，代码可能会丢失，使用远端代码仓库将永远存在一个备份。同时也免去了搭建本地代码版本控制服务的繁琐。 云计算时代 Git 以其强大的分支和克隆功能，更加方便了开发者远程协作。</p><h3 id="4-1-Github"><a href="#4-1-Github" class="headerlink" title="4.1 Github"></a>4.1 Github</h3><p>GitHub应该是最著名的代码托管平台了，全世界的程序员都在使用，很多优秀的开源项目也都发布在上面，因此作为程序员熟悉GitHub对我们的学习进步有很大的帮助。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H5e4830bfd6b2494c8d816bbf8e12a29fE.png"></p><p>不过由于这是国外的托管平台，因此使用起来会有一些小问题：例如访问较慢、私有仓库收费等。</p><p>不过好像就在我写这篇文章的时候，GitHub私有仓库免费了</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H17cc747c3d9d4f339a36ef3002fdc1a6O.png"></p><h3 id="4-2-Coding"><a href="#4-2-Coding" class="headerlink" title="4.2 Coding"></a>4.2 Coding</h3><p>之前并不太了解这个，还是这段时间建博客，发现部署到GitHub访问很慢，查解决方法的时候，看到的。用了一下真的很快，在国内访问速度非常的快！功能类似于码云，可以创建私有仓库(&lt;&#x3D;5个)</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H8e599157833f4fe68dcc694273416ed5u.png"></p><h3 id="4-3-远程仓库操作"><a href="#4-3-远程仓库操作" class="headerlink" title="4.3 远程仓库操作"></a>4.3 远程仓库操作</h3><p>申请到了Git远程仓库的帐号并创建了一个空的远程仓库现在我们就可以结合本地的仓库与远程仓库一起协同工作了，模拟多人协同开发</p><h4 id="4-3-1-常用操作"><a href="#4-3-1-常用操作" class="headerlink" title="4.3.1 常用操作"></a>4.3.1 常用操作</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 下载远程仓库的所有变动</span><br>$ git fetch [remote]<br><br><span class="hljs-comment"># 显示所有远程仓库</span><br>$ git remote -v<br><br><span class="hljs-comment"># 显示某个远程仓库的信息</span><br>$ git remote <span class="hljs-keyword">show </span>[remote]<br><br><span class="hljs-comment"># 增加一个新的远程仓库，并命名</span><br>$ git remote <span class="hljs-keyword">add </span>[<span class="hljs-keyword">shortname] </span>[url]<br><br><span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span><br>$ git pull [remote] [<span class="hljs-keyword">branch]</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># 上传本地指定分支到远程仓库</span><br>$ git push [remote] [<span class="hljs-keyword">branch]</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># 强行推送当前分支到远程仓库，即使有冲突</span><br>$ git push [remote] --force<br><br><span class="hljs-comment"># 推送所有分支到远程仓库</span><br>$ git push [remote] --all<br><br><span class="hljs-comment">#简单查看远程---所有仓库</span><br>git remote  （只能查看远程仓库的名字）<br><span class="hljs-comment">#查看单个仓库</span><br>git  remote <span class="hljs-keyword">show </span>[remote-<span class="hljs-keyword">branch-name]</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment">#新建远程仓库</span><br>git remote <span class="hljs-keyword">add </span>[<span class="hljs-keyword">branchname] </span> [url]<br><br><span class="hljs-comment">#修改远程仓库</span><br>git remote rename [oldname] [newname]<br><br><span class="hljs-comment">#删除远程仓库</span><br>git remote rm [remote-name]<br><br><span class="hljs-comment">#获取远程仓库数据</span><br>git fetch [remote-name] (获取仓库所有更新，但不自动合并当前分支)<br>git pull (获取仓库所有更新，并自动合并到当前分支)<br><br><span class="hljs-comment">#上传数据，如git push origin master</span><br>git push [remote-name] [<span class="hljs-keyword">branch]</span><br></code></pre></td></tr></table></figure><h4 id="4-3-2-远程git-clone"><a href="#4-3-2-远程git-clone" class="headerlink" title="4.3.2 远程git clone"></a>4.3.2 远程git clone</h4><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到<code>git clone</code>命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;版本库的网址&gt;</span><br></code></pre></td></tr></table></figure><p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为<code>git clone</code>命令的第二个参数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#以之前的博客主题下载为例</span><br><span class="hljs-comment">#themes/ayer就是指定的目录名</span><br>git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Shen-Yu/</span>hexo-theme-ayer.git  themes/ayer<br></code></pre></td></tr></table></figure><p><code>git clone</code>支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:<span class="hljs-number">61h</span>hh/JavaScript30day-challenge.git//SSH协议写法<br></code></pre></td></tr></table></figure><h4 id="4-3-3-git-remote"><a href="#4-3-3-git-remote" class="headerlink" title="4.3.3 git remote"></a>4.3.3 git remote</h4><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。</p><p>不带选项的时候，<code>git remote</code>命令列出所有远程主机。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git remote<br><br><span class="hljs-comment">#使用-v选项，可以参看远程主机的网址。</span><br><span class="hljs-variable">$ </span>git remote -v<br><br><span class="hljs-comment">#git remote show命令加上主机名，可以查看该主机的详细信息。</span><br><span class="hljs-variable">$ </span>git remote show &lt;主机名&gt;<br><br><span class="hljs-comment">#git remote add命令用于添加远程主机。</span><br><span class="hljs-variable">$ </span>git remote add &lt;主机名&gt; &lt;网址&gt;<br></code></pre></td></tr></table></figure><h4 id="4-3-4-git-fetch"><a href="#4-3-4-git-fetch" class="headerlink" title="4.3.4 git fetch"></a>4.3.4 git fetch</h4><p>一旦远程主机的版本库有了更新（即执行了commit），需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">$ git fetch <span class="hljs-attribute">&lt;远程主机名&gt;</span><br></code></pre></td></tr></table></figure><p>上面命令将某个远程主机的更新，全部取回本地。</p><p><code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p><p>默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p><h4 id="4-3-5-git-pull"><a href="#4-3-5-git-pull" class="headerlink" title="4.3.5 git pull"></a>4.3.5 git pull</h4><p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;<span class="hljs-symbol">:&lt;</span>本地分支名&gt;<br><br><span class="hljs-comment">#取回origin主机的next分支，与本地的master分支合并，需要写成下面这样</span><br><span class="hljs-variable">$ </span>git pull origin <span class="hljs-symbol">next:</span>master<br>...<br></code></pre></td></tr></table></figure><h4 id="4-3-6-git-push"><a href="#4-3-6-git-push" class="headerlink" title="4.3.6 git push"></a>4.3.6 git push</h4><p>在使用git commit命令将修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支，<code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">$ git push <span class="hljs-attribute">&lt;远程主机名&gt;</span> <span class="hljs-attribute">&lt;本地分支名&gt;</span>:<span class="hljs-attribute">&lt;远程分支名&gt;</span><br></code></pre></td></tr></table></figure><p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。</p><ol><li>git push origin master<br>如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建</li><li>git push origin ：refs&#x2F;for&#x2F;master<br>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin –delete master</li><li>git push origin<br>如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支</li><li>git push<br>如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名</li></ol><h2 id="5-分支管理"><a href="#5-分支管理" class="headerlink" title="5. 分支管理"></a>5. 分支管理</h2><p>分支管理应该是项目中经常遇到的问题了，本身也很重要，而Git的分支管理功能是非常强大的，因此分支操作要好好了解熟悉。关于分支管理，廖雪峰大佬已经讲的很好了，因此我把他的讲解引用过来，主要说说创建与合并、冲突解决，后面的分支策略、Bug分支等就用我自己的理解简单说一下。</p><p><strong>常用Git分支管理指令：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支,查看</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -r</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有本地分支和远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -a</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，但依然停留在当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，并切换到该分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，指向指定commit</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch [branch] [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --track [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到指定分支，并更新工作区</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到上一个分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch --set-upstream [branch] [remote-branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">合并指定分支到当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git merge [branch]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">选择一个commit，合并进当前分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git cherry-pick [commit]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -d [branch-name]</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除远程分支</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin --delete [branch-name]</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git branch -dr [remote/branch]</span><br></code></pre></td></tr></table></figure><h3 id="5-1-创建与合并分支"><a href="#5-1-创建与合并分支" class="headerlink" title="5.1 创建与合并分支"></a>5.1 创建与合并分支</h3><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Ha6d04b9e9fd24b399ea4d02825265a38z.png"></p><p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/He13a65570b914f05b419abc08931a709W.gif"></p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>git branch dev<br></code></pre></td></tr></table></figure><p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git checkout -b dev<br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;dev&#x27;</span><br><span class="hljs-comment">#相当于以下两条指令</span><br>$ git branch dev<br>$ git checkout dev<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;dev&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H746ce5ecf824418c959889b9b957e418o.png"></p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hf95a9fcb27a5452e922f537d7055892cQ.png"></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H16833115b2d944e4b10438a08986f700x.png"></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hed917a4e6ad74308bb79798bb4e146feH.png"></p><p>过程演示：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H4638bffc36ed420b8ac8eef62e88a33fW.gif"></p><p>以之前的软工实验截图为例，演示实际操作：</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H3e8350bc69894c8d8d8b2d21b91c40c8p.png" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H422f82153f0944c6aeba13e8d396d231X.png" style="zoom:80%;" /><h3 id="5-2-冲突解决"><a href="#5-2-冲突解决" class="headerlink" title="5.2 冲突解决"></a>5.2 冲突解决</h3><p>当我们在新建分支feature1上修改、commit，然后切回master分支后修改、commit，会照成<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H7499ff22baf54401b068503db9f70940O.png"></p><p>这时如果快速合并，就会报错：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git merge feature1<br>Auto-merging readme.txt<br><span class="hljs-keyword">CONFLICT</span> (content): Merge <span class="hljs-keyword">conflict</span> <span class="hljs-keyword">in</span> readme.txt<br>Automatic merge failed; fix conflicts <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">commit</span> the result.<br>#用git status查看错误原因，会发现是因为对同一文件的两次修改导致冲突<br></code></pre></td></tr></table></figure><p>此时对冲突文件进行修改，然后再add、commit，现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H72bdfbd2e5af4dd1b8ac5367ee35a2e3Q.png"></p><p><strong>小结：</strong>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><p>实例演示：创建新分支bbb，在bbb对文件try.txt修改提交，再切回master分支，然后master上再修改提交try.txt，此时两个分支就各自有新的提交了，合并时就会出现冲突，这时再次add然后commit提交，两个分支会走到一个点，类似于三角形。</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hebf7896d6ee841d180e18c949d05a3d4z.png" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hbdb75ce1eb654ec0bd4e1b62f62b608a5.png" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H8a909fd825ab432caf70077a6ff4b1c00.png" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/He4faa72548cd4b7db5994528c5464da7v.png" style="zoom:80%;" /><h3 id="5-3-分支策略"><a href="#5-3-分支策略" class="headerlink" title="5.3 分支策略"></a>5.3 分支策略</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H0f374a983f834c42ba7298b077e3d5a9Z.png"></p><h3 id="5-4-Bug分支"><a href="#5-4-Bug分支" class="headerlink" title="5.4 Bug分支"></a>5.4 Bug分支</h3><p>当出现Bug时，可以通过新建一个分支bug1，此时bug1内容和master一样，对bug1进行修复后，然后合并，再将这个临时分支删除，具体步骤是：</p><ul><li><code>git stash</code>存储当前工作现场</li><li>先找到出Bug的分支，在该分支上创建临时分支bug1，此时bug1&#x3D;出Bug的分支</li><li>修复Bug，提交，切回之前的分支，再完成合并，删除临时分支bug1</li><li>可以用<code>git stash list</code>查看之前的工作现场，将现场恢复，有两个方法<ol><li>用<code>git stash apply</code>恢复，恢复后并未删除stash中的内容，因此还要用<code>git stash drop</code>删除</li><li>使用<code>git stash pop</code>，恢复的同时也删除了</li></ol></li></ul><p>也可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ git stash apply <span class="hljs-symbol">stash@</span>&#123;<span class="hljs-number">0</span>&#125;<br></code></pre></td></tr></table></figure><p>假如master分支出了bug，由他引申出来的分支dev上，肯定也有相同的bug，对dev上的bug当然也可以采用上面的方法来修复，不过太麻烦了。Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git branch<br>* dev<br>  <span class="hljs-keyword">master</span><br><span class="hljs-title">$</span> git cherry-pick <span class="hljs-number">4</span>c805e2<br>[<span class="hljs-keyword">master</span> <span class="hljs-title">1d4b803</span>] fix bug <span class="hljs-number">101</span><br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">1</span> insertion(+), <span class="hljs-number">1</span> deletion(-)<br></code></pre></td></tr></table></figure><p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p><p>既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p><h3 id="5-5-feature分支"><a href="#5-5-feature分支" class="headerlink" title="5.5 feature分支"></a>5.5 feature分支</h3><p>对于一个项目，如果想添加新功能，最好新建一个feature分支，在feature分支上进行该功能开发，完成后再合并然后删除feature分支，这样能保证该功能无论开发成功与否（或者这些实验性的功能代码可能会放弃使用），都不会影响主分支。如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D </code>强行删除。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对网上的Git教程大概的学习，再加上之前的一点印象，感觉基本的Git流程操作应该是知道了，但是远谈不上熟练吧，以后多多练习多多熟悉，争取熟练Git常用的命令操作。</p><p>Git Cheat Sheet，可以打印出来备用：<a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf">Git Cheat Sheet</a></p>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将hexo博客部署到coding上</title>
    <link href="/20200414/6333e931/"/>
    <url>/20200414/6333e931/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>将博客部署到GitHub上后，我发现一个很大的问题——访问速度很慢！！！因此找了一下教程，实现双部署：GitHub对应海外，coding对应默认（其实也不可能有歪果仁看这个博客。。。）</p><p>由于网上的教程很多都是在coding改版前的，很多东西例如Pages服务、认证位置都有较大变动，因此我属实废了点功夫。。。</p><span id="more"></span><h3 id="配置coding"><a href="#配置coding" class="headerlink" title="配置coding"></a>配置coding</h3><ul><li>首先就是注册coding官网账号：<a href="https://coding.net/">coding官网</a></li><li>注册完成后创建新项目</li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/He0fc2946326c4828a2c7a145c1e495b0m.png" style="zoom:80%;" /><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Ha5b5fef975e14c3fb6869f25c14195d4y.png"></p><h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><p>由于之前GitHub已经配置过SSH key了，因此可以直接用。</p><ul><li><p>在C盘—用户—.ssh文件加下，找到之前的SSH key文件，打开复制</p></li><li><p>在coding个人设置—SHH公钥中粘贴</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hf5a8605e46b843c297e3b3565c0e9e2bn.png"></p></li></ul><h3 id="测试SSH"><a href="#测试SSH" class="headerlink" title="测试SSH"></a>测试SSH</h3><p>使用git bash测试</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ssh -T git@git<span class="hljs-selector-class">.coding</span><span class="hljs-selector-class">.net</span> <br><span class="hljs-comment">//出现Hello username You&#x27;ve connected to Coding.net by SSH successfully!表示成功</span><br><br></code></pre></td></tr></table></figure><p>若出现权限被拒绝，解决方案是：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@e</span>.coding.net<br>//首次建立连接要求信任主机，输入<span class="hljs-literal">yes</span>回车就🆗了，我已经输入过因此不显示了<br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hfa5c1e816c8d46dcb5be564ed4dfc999q.png"></p><h3 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h3><p>打开刚刚创建的项目，在右侧找到SSH，复制：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H607ff457a1a24d1c8a6312d2b22b4d03T.png"></p><p>打开我们的hexo项目根目录下的config.yml，找到部署对应的代码，粘贴：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Ha6a02a2497a14fd2aedcd4d57a4a22d7g.png"></p><p>配置完成后，部署代码：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo d -g</span><br></code></pre></td></tr></table></figure><p>就可以在coding上查看到我们的代码了！</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hb5e753659ede42ea8235f0018e8b3ccd3.png"></p><h3 id="开启静态页面功能"><a href="#开启静态页面功能" class="headerlink" title="开启静态页面功能"></a>开启静态页面功能</h3><p>coding改版后，很多功能默认是不开启的，因此初始代码仓库界面只有上图的前三项，要实现Pages功能先要开启对应的功能模块，在项目的项目设置中打开，建议直接把功能全打开</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H05f698a69b33482e8b52d296d36299ecJ.png"></p><p>然后就可以看到上面代码仓库图的那些功能了，找到持续部署，首先要完成<strong>实名认证</strong>才能创建页面，在团队管理—团队设置—高级设置 中完成实名认证。</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hf3070358fe8b456e84a09b50b694502fR.png"></p><p>完成实名认证后，就可以在持续部署—静态网页中创建了，输入项目名，选择部署来源（默认hexo的项目即可）</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H22c48fed15774816829dbe39101fa2231.png"></p><p>点击立即部署，即可访问</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hae599665c7754e43ae9a9a82c5bedcf03.png"></p><h3 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h3><p>参照之前的域名设置，首先也是ping 该网指，将得到的IP地址在阿里云DNS解析—新手引导 中输入，得到的值修改一下配置CNAME，将原来的GitHub设为境外，coding默认，等一会配置解析完成</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Ha280ebbad0d147bb8369142895327d1eJ.png"></p><p>在静态页面的右上角设置中，下拉找到自定义域名，加入我们的域名即可</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hf8584a439e2340f19f782883d5fbd54d3.png"></p><p>部署一下，就可以访问了，速度比起之前的GitHub Pages快了很多很多啊！</p>]]></content>
    
    
    <categories>
      
      <category>博客工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客绑定域名</title>
    <link href="/20200414/12cd500b/"/>
    <url>/20200414/12cd500b/</url>
    
    <content type="html"><![CDATA[<p>搭建的博客，默认域名是GitHub下的二级域名：<code>61hhh.github.io</code>，每次输入比较麻烦，而且缺少个性化，因此购买了一个域名，并绑定到博客上。</p><span id="more"></span><h3 id="域名选择"><a href="#域名选择" class="headerlink" title="域名选择"></a>域名选择</h3><p>国内的域名服务商有很多，新网，腾讯云，阿里云等。我选择的是阿里云的万网，刚好看到新用户1元购活动，就在万网上购买了心仪的域名<code>salute61.top</code>，然后进入阿里云的<code>管理控制台</code>–<code>域名</code>就可以看到了，此时域名是未认证的状态，先按提示进行实名认证(一般2小时内就可以通过)。</p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>首先要获取我们的GitHub的IP地址，直接cmd中ping自己的博客地址就可以，然后在<code>域名</code>–<code>解析</code>中，点击新手引导，将得到的IP地址填到记录栏中，修改为CNAME和A类型</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H762ccabff22a463ebdefb802e88344a4v.png"></p><h3 id="添加CNAME文件"><a href="#添加CNAME文件" class="headerlink" title="添加CNAME文件"></a>添加CNAME文件</h3><p>在hexo的source文件夹下创建CNAME文件(没有后缀！)，里面填写你的域名：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/Hccac12360b894735bfa5e68ee16784c4J.png"></p><h3 id="github设置"><a href="#github设置" class="headerlink" title="github设置"></a>github设置</h3><p>打开GitHub，找到对应仓库github.io，在setting中下拉找到GitHub Pages，在custom domain中填写你的域名，至此域名的配置就算完成啦！</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/H0479f0ae8b5c4fddb0a32241d472c795E.png"></p>]]></content>
    
    
    <categories>
      
      <category>博客工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中this的指向</title>
    <link href="/20200410/2d4e300a/"/>
    <url>/20200410/2d4e300a/</url>
    
    <content type="html"><![CDATA[<p>学习Javascript时遇到说this指针的指向问题，因此查找了一些博客教程，作为个人学习的总结。</p><p>首先要明确Js中的this指向并不是在定义时确定的，而是在具体的对象调用函数时确定，即哪个对象调用了函数，函数中的this就指向哪个对象，<strong>函数的调用方式决定了this的指向</strong>。</p><p>Js中的函数调用有：直接调用、方法调用、构造函数调用。还有特殊的例如bind()绑定后调用、通过call()、apply()调用、箭头函数调用</p><span id="more"></span><h3 id="1-直接调用"><a href="#1-直接调用" class="headerlink" title="1.直接调用"></a>1.直接调用</h3><p>直接调用，就是通过 <code>函数名(...)</code> 这种方式调用，此时函数内部的this指向的时全局对象。</p><p>(浏览器中全局对象时window，在NodeJs中全局对象时global)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;I am Leslie&#x27;s fans&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">//输出 window  即this指向全局对象window</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<span class="hljs-comment">//输出 I am Leslie&#x27;s fans</span><br>&#125;<br><span class="hljs-title function_">getName</span>();<br></code></pre></td></tr></table></figure><p>注：直接调用并不是在全局作用域下调用，任何作用域下直接通过<code>函数名(...)</code>对函数调用都称为直接调用。</p><h4 id="bind-对直接调用的影响"><a href="#bind-对直接调用的影响" class="headerlink" title="bind()对直接调用的影响"></a>bind()对直接调用的影响</h4><p><code>Function.prototype.bind()</code> 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 <code>this</code> 始终指向绑定的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj=&#123;&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>===obj);<br>&#125;<br><span class="hljs-keyword">const</span> testObj=test.<span class="hljs-title function_">bind</span>(obj);<span class="hljs-comment">//将test函数与obj对象绑定，它的this指向obj</span><br><span class="hljs-title function_">test</span>();<span class="hljs-comment">//false</span><br><span class="hljs-title function_">testObj</span>();<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="2-方法调用"><a href="#2-方法调用" class="headerlink" title="2.方法调用"></a>2.方法调用</h3><p>方法调用是指通过对象来调用其方法函数，是以<code>对象.方法函数(...)</code>的形式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Salute Leslie&quot;</span>;<br><span class="hljs-keyword">var</span> test = &#123;<br>name = <span class="hljs-string">&quot;Always salute&quot;</span>;<br><span class="hljs-attr">getName</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">//输出test  this指向的时test对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<span class="hljs-comment">//输出Always salute 即this.name并没有调用到window的name属性</span><br>&#125;<br>&#125;<br>test.<span class="hljs-title function_">getName</span>();<br></code></pre></td></tr></table></figure><p>当有多个对象调用时：虽然test1.getName是由test2.getName赋值得到，但调用的是test1，this指向test1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> test1 = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Leslie&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> test2 = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Not Leslie&#x27;</span>;<br><span class="hljs-attr">getName</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br>&#125;<br>test1.<span class="hljs-property">getName</span>=test2.<span class="hljs-property">getName</span>;<br>test1.<span class="hljs-title function_">getName</span>();<span class="hljs-comment">//输出Leslie</span><br></code></pre></td></tr></table></figure><h3 id="3-构造函数调用"><a href="#3-构造函数调用" class="headerlink" title="3.构造函数调用"></a>3.构造函数调用</h3><p>在ES5中，每个函数都可以当作构造函数，通过new调用来产生新的对象实例，其中的this指向这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Leslie&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>&#125;<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Name1</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_">getName</span>(<span class="hljs-string">&quot;Not Leslie&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newName.<span class="hljs-property">name</span>);<span class="hljs-comment">//输出Not Leslie</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<span class="hljs-comment">//输出Leslie</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Name2</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_">getName</span>(<span class="hljs-string">&quot;Not Leslie&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Name1</span>===<span class="hljs-title class_">Name2</span>);<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="4-使用call-、apply"><a href="#4-使用call-、apply" class="headerlink" title="4.使用call()、apply()"></a>4.使用call()、apply()</h3><p>call()和apply()简单来说就是会改变传入函数的this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1=&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Leslie&#x27;</span><br>&#125;;<br><span class="hljs-keyword">var</span> obj2=&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Not Leslie&#x27;</span>,<br>    <span class="hljs-attr">fn</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br>obj2.<span class="hljs-property">fn</span>.<span class="hljs-title function_">call</span>(obj1);<span class="hljs-comment">//输出Leslie</span><br><span class="hljs-comment">//虽然obj2.fn执行，但是call了obj1，动态的将this指向了obj1，相当于obj2.fn执行环境是obj1</span><br></code></pre></td></tr></table></figure><h4 id="call与apply的用途："><a href="#call与apply的用途：" class="headerlink" title="call与apply的用途："></a>call与apply的用途：</h4><ol><li>改变this的指向</li><li>方法借用</li></ol><h4 id="call与apply的区别："><a href="#call与apply的区别：" class="headerlink" title="call与apply的区别："></a>call与apply的区别：</h4><p>二者作用相同，只是参数不同</p><ul><li>call参数不固定，<code>acll(thisArg [ ,arg1,arg2,...])</code>，第一个参数是this指向，后面使用参数列表</li><li>apply参数固定，<code>apply(thisArg [,argArray])</code>，第一个参数是this指向，第二个是参数数组</li></ul><h3 id="5-箭头函数调用"><a href="#5-箭头函数调用" class="headerlink" title="5.箭头函数调用"></a>5.箭头函数调用</h3><p>首先，ES6提供的箭头函数中，并没有this，箭头函数中的this是继承的外部环境，即直接包含它的那个函数或函数表达式中的this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">arrow</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>            <span class="hljs-comment">//这里的this是test()中的this，由test()的调用方式决定</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>===obj);<br>        &#125;;<br>        <span class="hljs-title function_">arrow</span>();<br>    &#125;,<br>    <br>    <span class="hljs-title function_">getArrow</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span><span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-comment">//这里的this是getArrow()的this，由getArrow()的调用方式决定</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>===obj);<br>        &#125;;<br>    &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">test</span>();<span class="hljs-comment">//输出true</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Arrow</span>=obj.<span class="hljs-title function_">getArrow</span>();<br><span class="hljs-title class_">Arrow</span>();<span class="hljs-comment">//输出true</span><br></code></pre></td></tr></table></figure><p>它本身是没有绑定 <code>this</code> 的，它用的是直接外层函数(即包含它的最近的一层函数或函数表达式)绑定的 <code>this</code>。</p><p>注：箭头函数不能new调用，bind也不起作用。</p>]]></content>
    
    
    <categories>
      
      <category>其他记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用hexo+github Page搭建博客</title>
    <link href="/20200410/6d909da5/"/>
    <url>/20200410/6d909da5/</url>
    
    <content type="html"><![CDATA[<p>基本原理：Hexo是github上一个优秀的开源博客框架，支持markdown解析文章，有多种第三方主题插件供选择。先由hexo将.md文件生成静态网页.html文件，然后上传到你创建的个人GitHub仓库，这个仓库比较特殊，相当于是github为我们提供的展示网页的资源挂载库。因此hexo+github全程的搭建免费且便捷。我们只需要自己购买一个域名解析到对应的github-page就行了。</p><span id="more"></span><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><h4 id="1-1想法"><a href="#1-1想法" class="headerlink" title="1.1想法"></a>1.1想法</h4><p>本着好玩感兴趣的想法尝试弄一个个人博客，毕竟以前好多课考前赶的笔记都是手写的，考完试课程结束笔记本也找不到了。。。用博客的话可以写点东西留着。</p><p>本来有现成的纯小白快速搭建<a href="http://www.jianshu.com/p/e68fba58f75c">《利用 GitHub Pages 快速搭建个人博客》</a> ，一开始参考这个半小时就完成搭建了，先fork然后修改_config.yml代码，按照他的提示步骤就可以完成，并且无论是功能上还是页面布局上都比自己从零开始搭建的更加强大，不过我还是想自己从头开始尝试一下，了解一下大概的方法。</p><p>花了一下午使用hexo＋github Page搭建个人博客，也在网上参考了搭建步骤，记录一下自己的搭建过程。</p><h4 id="1-3-GitHub-page搭建的优缺点："><a href="#1-3-GitHub-page搭建的优缺点：" class="headerlink" title="1.3 GitHub page搭建的优缺点："></a>1.3 GitHub page搭建的优缺点：</h4><ol><li>全是静态文件，访问速度快</li><li>免费快捷，并且也不需要服务器和后台</li><li>可以自由绑定自己的域名</li><li>数据基于github版本管理，安全可靠，还能学习团队协作</li><li>不适合 大型网站，因为它没有使用数据库，每次运行都遍历全部文件</li><li>生成的是静态网页，要添加动态功能只能使用外部服务</li></ol><h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h3><p>&lt;1&gt;一个github账号（github网站注册即可）</p><p>&lt;2&gt;安装git bash</p><p>&lt;3&gt;安装nodejs、hexo</p><h4 id="2-1安装git-bash"><a href="#2-1安装git-bash" class="headerlink" title="2.1安装git bash"></a>2.1安装git bash</h4><p>Git是目前世界上最先进的分布式版本控制系统，无论是我们目前的搭建还是以后做项目都必须要用，下载好后建议使用git bash，而不是git GUI，有助于对指令的理解</p><ul><li><p><a href="https://gitforwindows.org/">安装地址</a>，直接下载安装即可</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-comment">--version（或git -v）查看是否安装成功</span><br></code></pre></td></tr></table></figure></li><li><p>后续若要学习git，推荐一个很全面的参考教程 <a href="https://www.baidu.com/link?url=Z8O3Sg4igVflUvqE5-hwJJjzkB34zZiXH2AEdNsItuC_Avh0lVB4MP9gn-e0CsVqqpXtcMx_--570lKkiS0xUwmX3Mqw3url-J6PF71I-i7&ck=7290.9.0.0.0.121.268.0&shh=www.baidu.com&sht=baidu&wd=&eqid=982d1239000645b1000000055e734703"><em>Git</em>简介 - 廖雪峰的官方网站</a>（当时写报告就参照他的教程写的hh）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427170157536.png" alt="image-20230427170157536" style="zoom:80%;" /></li></ul><h4 id="2-2安装NodeJs和Hexo"><a href="#2-2安装NodeJs和Hexo" class="headerlink" title="2.2安装NodeJs和Hexo"></a>2.2安装NodeJs和Hexo</h4><p>&lt;1&gt;hexo是基于nodejs的静态博客，安装要用到npm工具</p><ul><li><p><a href="https://nodejs.org/en/download/">Node.js安装包及源码</a>，按个人配置直接安装即可</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/node.png" style="zoom:80%;" /></li></ul><p>&lt;2&gt;先准备一个文件夹安装hexo（以我的D:\Blog61\HG_Blog为例），在此处git bash</p><ul><li><p>由于hexo用npm正常安装会出现卡住的情况，我们可以换源，采用淘宝的npm源：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry  https:<span class="hljs-comment">//registry.npm.taobao.org </span><br></code></pre></td></tr></table></figure></li><li><p>安装hexo命令和查看版本命令：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">安装：<span class="hljs-built_in">npm</span> -i g hexo<br>查看版本：hexo -v<br></code></pre></td></tr></table></figure></li></ul><p>​<img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/hexo-v.png" style="zoom: 67%;" /></p><ul><li><p>安装后新建一个文件夹存放你的博客（我的是D:\Blog61\HG_Blog\HEXO_File）初始化：hexo init，完成后可以看到文件</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/blogfile.png" style="zoom:80%;" /></li><li><p>文件含义：</p><ul><li><p>.deploy_git是连接git仓库后生成的文件</p></li><li><p>node_modules存放依赖包</p></li><li><p>public即为由hexo将博客生成的相关html静态文件，是要提交到github上的</p></li><li><p>scaffolds是一些通用的markdown模板</p></li><li><p>source是创建文章的地方，hexo命令生成文章在source&#x2F;_post下</p></li><li><p>themes是个人博客的主题</p></li><li><p>_config.yml是博客网站的配置</p></li></ul></li></ul><h3 id="3GitHub创建仓库连接"><a href="#3GitHub创建仓库连接" class="headerlink" title="3GitHub创建仓库连接"></a>3GitHub创建仓库连接</h3><h4 id="3-1创建仓库"><a href="#3-1创建仓库" class="headerlink" title="3.1创建仓库"></a>3.1创建仓库</h4><ul><li>新建一个仓库，命名为username.github.io(username即为自己的GitHub账号名，我的是61hhh.github.io )，每个GitHub账号只能创建一个这样可以直接按域名访问的仓库</li><li>创建成功后默认有一些示例代码，还有readme.md文件</li></ul><p>注意：</p><ol><li>命名规则必须为username.github.io，这样才能保证访问</li><li>注册账号的邮箱要验证，后面配置SSH Key要用到</li></ol><h4 id="3-2绑定域名"><a href="#3-2绑定域名" class="headerlink" title="3.2绑定域名"></a>3.2绑定域名</h4><ul><li><p>绑定域名与否都可以，不绑就采用默认的username.github.io来访问（我就没有绑定域名）</p></li><li><p>绑定域名首先要注册一个域名，在随意网站上购买，godaddy、阿里都行</p></li><li><p>配置域名有两种方式：CNAME和A记录，CNAME填写域名，A记录填写IP（详细内容等以后绑定域名再加）</p></li></ul><h4 id="3-3配置SSH-Key"><a href="#3-3配置SSH-Key" class="headerlink" title="3.3配置SSH Key"></a>3.3配置SSH Key</h4><ul><li><p>采用Github page搭建大概原理是对仓库操作，然后提交到github仓库，直接采用用户名密码方式不够安全，因此配置SSH key可以解决本地和服务器的连接问题</p></li><li><p>在git bash中输入：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span> <br></code></pre></td></tr></table></figure><p>可以在目标文件中找到生成的对应id_rsa.pub文件，用notepad++打开，复制</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427170257332.png" alt="image-20230427170257332" style="zoom:80%;" /></li><li><p>或者在bash中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> !/.ssh （切换目录）<br><span class="hljs-built_in">cat</span> id_rsa.pub（查看key）<br></code></pre></td></tr></table></figure></li><li><p>打开个人github账号，找到settings，新建SSH key，粘贴</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/GitHub-ssh.png" style="zoom: 50%;" /></li><li><p>填好后，在git bash中输入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/ssh-T.png" style="zoom:70%;" /></li><li><p>要提交就要指明用户是谁，所以要git config设置，–global表示全作用域的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;61hhh&quot;</span><br><br>git config <span class="hljs-attr">--globaluser</span><span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;1587403870@qq.com&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-修改config上传到github"><a href="#4-修改config上传到github" class="headerlink" title="4 修改config上传到github"></a>4 修改config上传到github</h3><h4 id="4-1-编辑配置文件"><a href="#4-1-编辑配置文件" class="headerlink" title="4.1 编辑配置文件"></a>4.1 编辑配置文件</h4><ul><li><p>编辑器打开_config.yml文件，简单修改一下配置（以后更多功能的增加都要记得编辑配置）</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">repo:</span> git@github.com<span class="hljs-keyword">/username/</span>username.github.io<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">branch:</span> master<br></code></pre></td></tr></table></figure></li><li><p>回到git bash中，在blog文件夹中执行</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean（清除缓存文件db<span class="hljs-variable">.json</span>和生成的静态文件public）<br><br>hexo <span class="hljs-keyword">generate</span>（生成网站静态文件到public文件夹）<br><br>hexo server（启动本地服务器，用于预览主题）<br></code></pre></td></tr></table></figure><p>注：hexo 3.0吧服务器独立，要单独安装：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">npm i hexo-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure></li><li><p>打开浏览器输入：<a href="http://localhost:4000，即为初始的博客界面">http://localhost:4000，即为初始的博客界面</a></p></li></ul><h4 id="4-2上传到github"><a href="#4-2上传到github" class="headerlink" title="4.2上传到github"></a>4.2上传到github</h4><ul><li><p>安装配置，确保文章能上传到github，此指令会生成上面的deploy_git文件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure></li><li><p>执行指令（建议每次编辑修改了都执行一遍）</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean<br><br>hexo <span class="hljs-keyword">generate</span> (hexo g)<br><br>hexo deploy (hexo d)<br></code></pre></td></tr></table></figure><p>注：deploy会要求输入github账户密码</p></li><li><p>之后在浏览器输入<a href="http://61hhh.github.io即可看到个人博客/">http://61hhh.github.io即可看到个人博客</a></p></li></ul><h3 id="5-修改配置主题"><a href="#5-修改配置主题" class="headerlink" title="5.修改配置主题"></a>5.修改配置主题</h3><ul><li><p>hexo默认主题是landscape，可以在<a href="https://hexo.io/themes/">官方主题网站</a>更换，选自己喜欢的主题</p></li><li><p>在blog文件夹中：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/xx/</span>xxx.git  themes/xxx <br></code></pre></td></tr></table></figure></li><li><p>clone的文件在blog文件夹的themes目录，修改_config.yml文件的themes：landscape为下载的主题themes:xxx，然后上传提交即可</p></li></ul><h3 id="6-写博客"><a href="#6-写博客" class="headerlink" title="6 写博客"></a>6 写博客</h3><ul><li><p>新建文章：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&#x27;文章名&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>该指令会在_posts文件夹下生成相关md文件，对md文件编辑可以开始写博客了</p></li><li><p>具体的文章编辑可以参照<a href="https://hexo.io/zh-cn/docs/writing.html">官网的介绍</a></p></li><li><p>工具可以网上查找md编写工具</p><p>tips：默认情况下，生成的博文目录会显示全部的文章内容，在指定位置加上代码可使文章显示指定摘要</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--more--&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="7-其他操作"><a href="#7-其他操作" class="headerlink" title="7 其他操作"></a>7 其他操作</h3><h4 id="7-1-常用指令"><a href="#7-1-常用指令" class="headerlink" title="7.1 常用指令"></a>7.1 常用指令</h4><p>常用的指令上面已经基本介绍了，再讲一下大概功能</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;postName&quot;</span> <span class="hljs-meta">#新建文章</span><br>hexo <span class="hljs-keyword">new</span> page <span class="hljs-string">&quot;pageName&quot;</span> <span class="hljs-meta">#新建页面</span><br>hexo generate <span class="hljs-meta">#生成静态页面至public目录</span><br>hexo <span class="hljs-keyword">server</span> <span class="hljs-meta">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br>hexo deploy <span class="hljs-meta">#将.deploy目录部署到GitHub</span><br>hexo help  <span class="hljs-meta"># 查看帮助</span><br>hexo version  <span class="hljs-meta">#查看Hexo的版本</span><br></code></pre></td></tr></table></figure><h4 id="7-2-更多操作"><a href="#7-2-更多操作" class="headerlink" title="7.2 更多操作"></a>7.2 更多操作</h4><p>​大部分操作都要求针对_config.yml文件进行配置，在此列举一些常用的（暂时没有实现。。。因为没学js。。。）</p><p>​大部分的模块网上都有，可以自己找相关的按操作提示进行</p><h5 id="7-2-1-评论"><a href="#7-2-1-评论" class="headerlink" title="7.2.1 评论"></a>7.2.1 评论</h5><ul><li>添加一个第三方评论系统</li><li>在当前主题的配置文件中找到comment，添加代码</li><li>注册评论系统，获取代码，在当前主题的layout下找到commnet新建的对应ejs模板</li><li>编辑，再部署，即可。</li></ul><h5 id="7-2-2-统计"><a href="#7-2-2-统计" class="headerlink" title="7.2.2 统计"></a>7.2.2 统计</h5><ul><li>在主题中配置analytics系统，添加代码后在对应ejs模板中编辑代码</li><li>注册baidu analytics或者google analytics，获取tracked_id，和跟踪代码</li><li>将tracked_id和url写入配置中，编辑部署即可</li></ul><h5 id="7-2-3-404页面"><a href="#7-2-3-404页面" class="headerlink" title="7.2.3 404页面"></a>7.2.3 404页面</h5><ul><li><p>github page有提供404页面的指引：<a href="https://help.github.com/articles/custom-404-Pages">Custom 404 Pages</a></p></li><li><p>直接在根目录下创建404.html（根目录指的是HEXO_File&#x2F;source）</p></li><li><p>404.html代码可以参照网上，推荐使用<a href="http://www.qq.com/404">腾讯公益404</a></p><p>注：_config.yml中的permalink_defaults属性不需要修改</p></li></ul><h3 id="8-小结"><a href="#8-小结" class="headerlink" title="8 小结"></a>8 小结</h3><p>​本来建博客是因为领了阿里云服务器，想尝试建博客，结果网上找教程跑偏了。。。建了个不需要服务器就能访问的博客，建都建了干脆搞完，下一步可以考虑部署hexo博客到服务器，或者用LAMP搭建一个真正意义上的服务器。</p><p>​感觉必须要学习前端知识了（虽然之前学过html和css。。。不过已经忘光了&#x3D;&#x3D;这边不就是没学嘛。。。），先学习一下前端，再来改进这个博客。<br>​    PS：为了优化博客踩了几天的坑，结果才发现<a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a>中有相关建站和一些进阶操作的指南。。。</p><h3 id="9-REFERENCE"><a href="#9-REFERENCE" class="headerlink" title="9 REFERENCE"></a>9 REFERENCE</h3><ul><li><a href="https://www.jianshu.com/p/05289a4bc8b2">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li><li><a href="https://hexo.io/zh-cn/docs/">hexo官方说明文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客ayer优化</title>
    <link href="/20200321/12141983/"/>
    <url>/20200321/12141983/</url>
    
    <content type="html"><![CDATA[<p>记在前面：从完成最基本的hexo博客之后，我就想着优化一下，毕竟找的主题有很多是作者没有配置留给我们自己修改的，然后再就是自己的踩坑之旅。。。</p><span id="more"></span><h2 id="添加歌单页面-aplayer实现"><a href="#添加歌单页面-aplayer实现" class="headerlink" title="添加歌单页面(aplayer实现)"></a>添加歌单页面(aplayer实现)</h2><p>使用aplyer可以帮助我们为添加的歌单页面实现歌曲解析播放，具体步骤就是：</p><p>&lt;1&gt;添加页面文件</p><p>&lt;2&gt;利用aplyer插件生成歌单解析</p><p>&lt;3&gt;配置相关文件</p><h3 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h3><p>添加歌单页就是添加一个页面，默认情况下是只有home、archives、tags页面，创建页面可以直接用指令：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> xxx (xxx为页面名)<br></code></pre></td></tr></table></figure><p>就可以创建hexo&#x2F;source&#x2F;xxx（和_post是同级目录），其中对xxx文件夹下的index.md编辑即可~</p><p>1 新建页面，命名为playlist：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> playlist<br></code></pre></td></tr></table></figure><p>2 修改hexo&#x2F;source&#x2F;playlist下的index.md文件：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">title</span>: 歌单<br><span class="hljs-attribute">date</span>: <span class="hljs-number">2020</span>-<span class="hljs-number">3</span>-<span class="hljs-number">21</span> <br><span class="hljs-attribute">type</span>: <span class="hljs-string">&quot;playlist&quot;</span><br></code></pre></td></tr></table></figure><p>3 打开主题的_config.yml文件，在menu下新建一个名为playlist的类（在nexT主题中集成了fontAwesome可以插入图标，本主题没有。。。遗憾）</p><p>注：标点符号的中英文输入要检查</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">menu:</span><br><span class="hljs-symbol">playlist:</span> <span class="hljs-keyword">/playlist/</span><br></code></pre></td></tr></table></figure><p>4.打开主题文件下的language&#x2F;zh-CN.yml添加对应中文翻译</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">playlist : 歌单<br></code></pre></td></tr></table></figure><h3 id="使用hexo-tag-aplayer"><a href="#使用hexo-tag-aplayer" class="headerlink" title="使用hexo-tag-aplayer"></a>使用hexo-tag-aplayer</h3><p>1 Aplayer是hexo上的一个插件，配置可以参考<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md">官方文档</a>，第一步安装插件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-tag-aplayer</span><br></code></pre></td></tr></table></figure><p>2 最新版的aplayer已经支持MetingJS的使用，可以直接解析网络平台歌曲，想在本插件中使用MetingJS，要先在根目录的_config.yml中配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">aplyer:</span><br><span class="hljs-attr">meting:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>3 复制想要的歌单链接：打开网易云音乐网站，找到想要的歌单，在网址中复制，例如<a href="https://music.163.com/#/my/m/music/playlist?id=817407958">https://music.163.com/#/my/m/music/playlist?id=817407958</a> 其中id就是对应歌单id，在index.md文件中编辑加入：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">aplayer</span> title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;</span><br></code></pre></td></tr></table></figure><p>上面是对应的编辑模板，其中标签参数：</p><ul><li><code>title</code> : 曲目标题</li><li><code>author</code>: 曲目作者</li><li><code>url</code>: 音乐文件 URL 地址</li><li><code>picture_url</code>: (可选) 音乐对应的图片地址</li><li><code>narrow</code>: （可选）播放器袖珍风格</li><li><code>autoplay</code>: (可选) 自动播放，移动端浏览器暂时不支持此功能</li><li><code>width:xxx</code>: (可选) 播放器宽度 (默认: 100%)</li><li><code>lrc:xxx</code>: （可选）歌词文件 URL 地址</li></ul><p>官方文档的讲解——在文章中使用 MetingJS 播放器：</p><figure class="highlight twig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs twig"><span class="language-xml"><span class="hljs-comment">&lt;!-- 简单示例 (id, server, type)  --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;%</span> <span class="hljs-name">meting</span> <span class="hljs-string">&quot;60198&quot;</span> <span class="hljs-string">&quot;netease&quot;</span> <span class="hljs-string">&quot;playlist&quot;</span> <span class="hljs-template-tag">%&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- 进阶示例 --&gt;</span></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;%</span> <span class="hljs-name">meting</span> <span class="hljs-string">&quot;60198&quot;</span> <span class="hljs-string">&quot;netease&quot;</span> <span class="hljs-string">&quot;playlist&quot;</span> <span class="hljs-string">&quot;autoplay&quot;</span> <span class="hljs-string">&quot;mutex:false&quot;</span> <span class="hljs-string">&quot;listmaxheight:340px&quot;</span> <span class="hljs-string">&quot;preload:none&quot;</span> <span class="hljs-string">&quot;theme:#ad7a86&quot;</span><span class="hljs-template-tag">%&#125;</span><br></code></pre></td></tr></table></figure><p>有关 <code>&#123;% meting %&#125;</code> 的选项列表如下:</p><table><thead><tr><th>选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td><strong>必须值</strong></td><td>歌曲 id &#x2F; 播放列表 id &#x2F; 相册 id &#x2F; 搜索关键字</td></tr><tr><td>server</td><td><strong>必须值</strong></td><td>音乐平台: <code>netease</code>, <code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code></td></tr><tr><td>type</td><td><strong>必须值</strong></td><td><code>song</code>, <code>playlist</code>, <code>album</code>, <code>search</code>, <code>artist</code></td></tr><tr><td>fixed</td><td><code>false</code></td><td>开启固定模式</td></tr><tr><td>mini</td><td><code>false</code></td><td>开启迷你模式</td></tr><tr><td>loop</td><td><code>all</code></td><td>列表循环模式：<code>all</code>, <code>one</code>,<code>none</code></td></tr><tr><td>order</td><td><code>list</code></td><td>列表播放模式： <code>list</code>, <code>random</code></td></tr><tr><td>volume</td><td>0.7</td><td>播放器音量</td></tr><tr><td>lrctype</td><td>0</td><td>歌词格式类型</td></tr><tr><td>listfolded</td><td><code>false</code></td><td>指定音乐播放列表是否折叠</td></tr><tr><td>storagename</td><td><code>metingjs</code></td><td>LocalStorage 中存储播放器设定的键名</td></tr><tr><td>autoplay</td><td><code>true</code></td><td>自动播放，移动端浏览器暂时不支持此功能</td></tr><tr><td>mutex</td><td><code>true</code></td><td>该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停</td></tr><tr><td>listmaxheight</td><td><code>340px</code></td><td>播放列表的最大长度</td></tr><tr><td>preload</td><td><code>auto</code></td><td>音乐文件预载入模式，可选项： <code>none</code>, <code>metadata</code>, <code>auto</code></td></tr><tr><td>theme</td><td><code>#ad7a86</code></td><td>播放器风格色彩设置</td></tr></tbody></table><p>关于如何设置自建的 Meting API 服务器地址，以及其他 MetingJS 配置，请参考章节<a href="https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE30-%E6%96%B0%E5%8A%9F%E8%83%BD">自定义配置</a></p><p>以我的配置为例：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">&#123;% meting <span class="hljs-string">&quot;817407958&quot;</span> <span class="hljs-string">&quot;netease&quot;</span> <span class="hljs-string">&quot;playlist&quot;</span> <span class="hljs-string">&quot;theme:<span class="hljs-subst">#FF4081</span>&quot;</span> <span class="hljs-string">&quot;mode:circulation&quot;</span> <span class="hljs-string">&quot;mutex:true&quot;</span> <span class="hljs-string">&quot;listmaxheight:340px&quot;</span> <span class="hljs-string">&quot;preload:auto&quot;</span> %&#125;<br></code></pre></td></tr></table></figure><p>就完成了歌单页的配置，（至于集成侧边栏小窗口，可以在各个页面播放音乐的网易云插件，在后面会讲到）</p><h2 id="添加网易云外链播放"><a href="#添加网易云外链播放" class="headerlink" title="添加网易云外链播放"></a>添加网易云外链播放</h2><p>使用网易云iframe插件实现外链播放，主要步骤就是：</p><ol><li>进入网易云网页端，获取外链和html代码</li><li>进入主题下的布局文件中，在你想要的位置对应的布局文件添加复制的html代码</li><li>修改主题的配置文件_config.yml</li></ol><p>该主题ayer已经实现了网易云外链播放，只需要配置一下</p><h3 id="获取外链代码"><a href="#获取外链代码" class="headerlink" title="获取外链代码"></a>获取外链代码</h3><p>进入网易云网页端，找到你想要的歌曲，可以到外链播放器，点击生成查看对应代码</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/netease.png"  style="zoom:50%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/netease2.png"  style="zoom:50%;" /><h3 id="完成相应配置"><a href="#完成相应配置" class="headerlink" title="完成相应配置"></a>完成相应配置</h3><ul><li><p>首先是添加html代码到布局文件对应位置（这里的对应位置就是你想要的位置。。一般主题里有相关的文件，ayer主题中themes&#x2F;ayer&#x2F;layout&#x2F;_partial的music.ejs文件）</p><p>ayer主题的作者已经实现了这一块代码，因此只需要把我复制的html替换</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427165250680.png" alt="image-20230427165250680" style="zoom:80%;" /></li><li><p>然后是在对应主题的_config.yml配置一下就可以了</p></li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427165307136.png" alt="image-20230427165307136" style="zoom:80%;" /><ul><li>之后就可以在博客上看到啦</li></ul><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427165323572.png" alt="image-20230427165323572" style="zoom:80%;" /><p>（注：网易云中很多歌曲由于版权保护不能生成外链播放器，在网上找的方法是：F12进入控制台查看代码找对应id，然后复制到对应配置。不过这个方法不一定可行，我照这样还是不能播放。。。所以还是要自己多试试几首歌，找到能直接生成外链播放器的吧。。。）</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427165349009.png" alt="image-20230427165349009" style="zoom:80%;" /><h2 id="使用七牛云图床"><a href="#使用七牛云图床" class="headerlink" title="使用七牛云图床"></a>使用七牛云图床</h2><p>blog中要插入图片，在网页端无法直接读取个人电脑的地址，因此要用到图床工具生成外链</p><p>图床的选择可以参考知乎上的这篇回答：<a href="https://zhuanlan.zhihu.com/p/35270383?ivk_sa=1023345p">盘点国内免费好用的图床</a></p><p>我个人的话推荐使用七牛云图床，免费10g的空间，链接速度也快</p><p>进入<a href="https://portal.qiniu.com/signup?code=1hdw91gk6g4lu">七牛云</a>注册，完成实名认证，然后创建对象存储-&gt;设置参数-&gt;上传图片生成外链</p><blockquote><p><strong>注意：</strong>七牛云注册后的试用域名只有一个月时间，之后会收回，因此要自己绑定加速域名！</p></blockquote><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/qiniu1.png" alt="创建"></p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/qiniu2.png" alt="设置参数"></p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/qiniu3.png" alt="操作"></p><p>最后就是在你的博客文章中插入外链写博客，在网站中就可以看到啦！</p><h2 id="开启打赏功能"><a href="#开启打赏功能" class="headerlink" title="开启打赏功能"></a>开启打赏功能</h2><p>原作者的ayer主题中已经自带了打赏功能，支持微信打赏和支付宝打赏。 只需要themes&#x2F;ayer&#x2F;_config.yml中填入 微信 和 支付宝 收款二维码图片地址（将你的个人支付宝、微信收款码放在对应地址）即可开启该功能。</p><p>大概代码示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏</span><br>reward_type: <span class="hljs-number">2</span><br><span class="hljs-comment"># 打赏wording</span><br>reward_wording: <span class="hljs-string">&#x27;请我喝杯咖啡吧~&#x27;</span><br><span class="hljs-comment"># 支付宝二维码图片地址，跟你设置logo的方式一样。比如：/images/alipay.jpg</span><br>alipay: <span class="hljs-regexp">/images/</span>alipay.jpg<br><span class="hljs-comment"># 微信二维码图片地址</span><br>weixin: <span class="hljs-regexp">/images/</span>wechat.jpg<br></code></pre></td></tr></table></figure><h2 id="添加百度、谷歌Analytics"><a href="#添加百度、谷歌Analytics" class="headerlink" title="添加百度、谷歌Analytics"></a>添加百度、谷歌Analytics</h2><p>百度统计和Google统计主要可以用于分析网站数据：流量、访客量等。</p><p>基本步骤就是注册账号，创建网页应用（按提示步骤来就行），获取js代码（在管理-&gt;获取代码 中即可找到js代码），添加。附上网站链接：</p><p><a href="%5Bhttps://tongji.baidu.com%5D(https://tongji.baidu.com/)">百度统计网站</a></p><p><a href="https://analytics.google.com/analytics/web/">Google统计网站</a></p><p>（说明：在ayer主题中已经集成，只需要配置一下即可。这个大部分主题都有集成吧0.0）具体位置：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">themes\ayer\lauout\_partial\google-analytics.ejs<br>themes\ayer\lauout\_partial\baidu-analytics.ejs<br></code></pre></td></tr></table></figure><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/tongji1.png" alt="image-20200322114644925"></p><p>在主题配置文件_config.yml中配置一下id：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/tongji2.png" alt="image-20200322113331239"></p><p>Google Analytics和百度类似，找到UA码复制，在.ejs文件中替换你的js代码，在_config.yml中配置id即可。配置成功后可以在控制台看到相关信息：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/tongji3.png" alt="image-20200322115142347"></p><p>网站底部的UV页面访问、PV IP访问，在localhost下数值会异常，不过部署到服务器上会重新设置。</p><h2 id="增加评论功能-Valine、Gitalk"><a href="#增加评论功能-Valine、Gitalk" class="headerlink" title="增加评论功能(Valine、Gitalk)"></a>增加评论功能(Valine、Gitalk)</h2><p>hexo博客评论系统有很多常用的有：来比力、Gitalk、畅言、valine等，多个评论系统已经下线或者是外国网站，容易被墙，所有好用的主要就Valine和Gitalk。</p><ul><li>Valine：<a href="https://github.com/xCss/Valine">https://github.com/xCss/Valine</a>  （快速高效）</li><li>Gitalk：<a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a> （注册git application）</li></ul><h3 id="1-Valine评论"><a href="#1-Valine评论" class="headerlink" title="1.Valine评论"></a>1.Valine评论</h3><p>Valin是一款快速、简洁且高效的无后端评论系统,访问快。</p><p>Valine评论使用leancloud作为线上数据库，因此要使用Valine先注册<a href="https://www.leancloud.cn/">leancloud</a>账号，然后添加应用。按步骤提示创建应用后，可以在控制台看到对应ID</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/leancloud.png"></p><p>然后在主题的_config.yml中配置，将复制得到AppID和AppKey粘贴到对应位置即可</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/leancloud2.png" alt="comment_config" style="zoom: 80%;" /><h3 id="2-Gitalk评论"><a href="#2-Gitalk评论" class="headerlink" title="2.Gitalk评论"></a>2.Gitalk评论</h3><p>要使用gitalk首先要新建一个git application，填写参数</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/gitalk1.png" alt="注册application" style="zoom:30%;" /><p>注册完成后可以在个人的settings中查看client key和 client secret，由于ayer主题已经集成gitalk插件，因此只需要复制两个key然后粘贴到主题_config.yml的对应位置</p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/gitalk2.png" alt="查看application key" style="zoom:80%;" /><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427165509984.png" alt="image-20230427165509984" style="zoom:80%;" /><p><strong>注</strong>：如果没有集成gitalk插件也可以*&#x2F;layout&#x2F;_partial&#x2F;下新建一个comment.ejs，添加相应代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- theme.libs.css.gitalk %&gt;&quot;&gt;<br>&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/my-gitalk.css&quot;&gt;<br><br>&lt;div class=&quot;card gitalk-card&quot; data-aos=&quot;fade-up&quot;&gt;<br>    &lt;div id=&quot;gitalk-container&quot; class=&quot;card-content&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;<br><br>&lt;script src=&quot;&lt;%- theme.libs.js.gitalk %&gt;&quot;&gt;&lt;/script&gt;<br>&lt;script&gt;<br>    let gitalk = new Gitalk(&#123;<br>        clientID: &#x27;&lt;%- theme.gitalk.oauth.clientId %&gt;&#x27;,<br>        clientSecret: &#x27;&lt;%- theme.gitalk.oauth.clientSecret %&gt;&#x27;,<br>        repo: &#x27;&lt;%- theme.gitalk.repo %&gt;&#x27;,<br>        owner: &#x27;&lt;%- theme.gitalk.owner %&gt;&#x27;,<br>        admin: &lt;%- JSON.stringify(theme.gitalk.admin) %&gt;,<br>        id: &#x27;&lt;%- date(page.date, &#x27;YYYY-MM-DDTHH-mm-ss&#x27;) %&gt;&#x27;,<br>        distractionFreeMode: false  // Facebook-like distraction free mode<br>    &#125;);<br><br>    gitalk.render(&#x27;gitalk-container&#x27;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在post页面添加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&#123;% elseif theme.gitalk.enable %&#125;<br>    &lt;%- partial(&#x27;_partial/comment&#x27;) %&gt;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure><p>在主题_config.yml 下添加配置代码，可以参照上面的 comment_config图片，里面下半段就是Gitalk的配置。配置好部署后就可以使用了</p><p>相比Valine，Gitalk第一次访问要登陆github账户，完成关联才能评论，因为第一次加载会自动在管理员的repo仓库下创建对应issue（当然也可以手动创建，只要有Gitalk标签和id对应标签就可以），并且每篇文章都会创建issue（如果文章多就会比较麻烦）</p><h2 id="增加看板娘功能"><a href="#增加看板娘功能" class="headerlink" title="增加看板娘功能"></a>增加看板娘功能</h2><p>要使用看板娘，首先在根目录安装live2d插件：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-helper-live2d</span><br></code></pre></td></tr></table></figure><p>然后修改根目录下 _config.yml文件，增加看板娘配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">## live2d看板娘</span><br><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span><br>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span><br>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span><br>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-wanko</span> <span class="hljs-comment">#看板娘的model</span><br>    <span class="hljs-attr">scale:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">hHeadPos:</span> <span class="hljs-number">0.5</span><br>    <span class="hljs-attr">vHeadPos:</span> <span class="hljs-number">0.618</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">superSample:</span> <span class="hljs-number">2</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">300</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span> <span class="hljs-comment">#看板娘位置</span><br>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">50</span> <span class="hljs-comment">#看板娘水平偏移量</span><br>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">100</span> <span class="hljs-comment">#看板娘垂直偏移量</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">scale:</span> <span class="hljs-comment">#0.5</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacityDefault:</span> <span class="hljs-number">0.7</span><br>    <span class="hljs-attr">opacityOnHover:</span> <span class="hljs-number">0.2</span><br></code></pre></td></tr></table></figure><p>配置完成后安装对应看板娘model的动效就可：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> live2d-widget-model-wanko<br></code></pre></td></tr></table></figure><p>可以进入<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/wang_123_zy/article/details/87181892">模型预览</a> 挑选自己喜欢的看板娘，也可以在<a href="https://github.com/xiazeyu/live2d-widget-models">模型的Github地址</a>将整个package下载</p><p>效果演示：</p><p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/live2d.png" alt="wanko"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://www.jianshu.com/p/f1005ae09e5a">Hexo添加Player播放器</a></li><li><a href="http://yansheng836.coding.me/article/eda67a25.html">hexo+yilia添加百度统计和Google统计</a></li><li><a href="https://www.jianshu.com/p/0e091bb04531">hexo-next主题优化</a></li><li><a href="https://links.jianshu.com/go?to=http://qiubaiying.vip/2017/12/19/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-Gitalk-%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/">《为博客添加 Gitalk 评论插件》</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>博客工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
