

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/iconMe.png">
  <link rel="icon" href="/images/iconMe.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="LY">
  <meta name="keywords" content="do something">
  
    <meta name="description" content="有关Java面向对象的基础知识笔记——摘自【实验楼】">
<meta property="og:type" content="article">
<meta property="og:title" content="Java入门面向对象">
<meta property="og:url" content="https://61hhh-github-io.vercel.app/20200721/2d17972e/index.html">
<meta property="og:site_name" content="Salute">
<meta property="og:description" content="有关Java面向对象的基础知识笔记——摘自【实验楼】">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1062timestamp1434617083799.png">
<meta property="og:image" content="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1062timestamp1434619940542.png">
<meta property="og:image" content="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1072timestamp1434941168916.png">
<meta property="og:image" content="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1072timestamp1434933673483.png">
<meta property="og:image" content="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1072timestamp1434937042272.png">
<meta property="article:published_time" content="2020-07-21T09:46:11.000Z">
<meta property="article:modified_time" content="2024-05-11T02:16:32.531Z">
<meta property="article:author" content="LY">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1062timestamp1434617083799.png">
  
  
  
  <title>Java入门面向对象 - Salute</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"61hhh-github-io.vercel.app","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"TdBU4bxll43AQFzEBGhrVRQy-MdYXbMMI","app_key":"MMJsM8cWGY7bEm704Dl6269n","server_url":null,"path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Salute" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Salute</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java入门面向对象"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-07-21 17:46" pubdate>
          2020年7月21日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          74 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java入门面向对象</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2024年5月11日 上午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>有关Java面向对象的基础知识笔记——摘自【实验楼】</p>
<span id="more"></span>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>对于一个具体的对象而言，比如一部 iPhone 6，世上还有许多跟这部手机有着同样属性或行为的对象，我们为了方便将它们归类起来，提取出他们相同的属性和行为，而我们把归类起来的这个抽象的概念，称之为类。</p>
<p>比如每个人就是一个对象，小张是一个对象，小明是一个对象。而每个人虽然不同，但却有许多相同的属性和行为，于是我们可以把他们抽象出来，变成一个类，比如人类。</p>
<p>类是封装对象的属性和行为的载体，反过来说具有相同属性和行为的一类实体被称为类。</p>
<p>由此可以总结出<strong>类的定义</strong>：</p>
<ol>
<li>类是相同或相似对象的一种抽象，是对象的一个模板，它描述一类对象的行为和状态。</li>
<li>类是具有相同属性和方法（行为）的对象的集合</li>
</ol>
<p>我们在上面反复强调对象的属性和行为，什么是对象的属性呢？什么又是对象的行为呢？</p>
<p><strong>属性</strong>是对象具有的特征。每个对象的每个属性都拥有特定值。我们上面讲过对象是一个具体并且确定的事物，正是对象属性的值来区分不同的对象，比如我们可以通过一个人的外貌特征区分他。</p>
<p>那什么是对象的<strong>行为</strong>呢？在计算机中我们通过方法去实现对象的行为，而对象的方法便是对象所具有的操作，比如人会走路、会哭泣、会学习等等都是人的行为，也就是人的方法。</p>
<p>类和对象之间有什么关系吗？在上面的讲解中大家应该有些了解了。类就是对象的抽象（或者模板），对象就是类的具体（或者实例）。比如手机是一个抽象的概念，它代表着类。而一部 iPhone 6 便是手机具象化处理的实体，也就是一个对象。</p>
<p>说了那么多，那我们如何在计算机中定义一个类，如何实现一个类呢？</p>
<p>我们以前说过，Java 是面向对象的语言，而他的体现就在于 Java 程序都以类 class 为组织单元。而一个类是对象的抽象，所以类由属性和方法两部分组成。</p>
<p><strong>定义一个类</strong>，主要有三个步骤：</p>
<p>1、定义类名，用于区分不同的类。如下代码中 <code>public class</code> 后面跟的就是类名。<code>class</code>是声明类的关键字，类名后面跟上大括号，大括号里面就是类的一些信息。<code>public</code> 为权限修饰符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 类名 &#123;<br>    <span class="hljs-comment">//定义属性部分（成员变量）</span><br>    属性<span class="hljs-number">1</span>的类型 属性<span class="hljs-number">1</span>;<br>    属性<span class="hljs-number">2</span>的类型 属性<span class="hljs-number">2</span>;<br>    ...<br>    <span class="hljs-comment">//定义方法部分</span><br>    方法<span class="hljs-number">1</span><br>    方法<span class="hljs-number">2</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、编写类的属性。对象有什么，需要通过属性来表示。属性的定义是写在类名后面的大括号里，在定义属性时，要明确属性的类型。在一个类当中可以写一个或多个属性。当然也可以不定义属性。</p>
<p>3、编写类的方法。方法也是写在大括号里面。可以定义一个方法或多个方法，当然也可以不定义方法。</p>
<p>在 <code>home/project/</code> 目录下新建文件 <code>People.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br><span class="hljs-comment">//属性（成员变量） 有什么</span><br>    <span class="hljs-type">double</span> height;  <span class="hljs-comment">//身高</span><br>    <span class="hljs-type">int</span> age;     <span class="hljs-comment">//年龄</span><br>    <span class="hljs-type">int</span> sex;    <span class="hljs-comment">//性别，0为男性，非0为女性</span><br><br><span class="hljs-comment">//方法 干什么</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">cry</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我在哭！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">laugh</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我在笑！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">printBaseMes</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我的身高是&quot;</span>+height+<span class="hljs-string">&quot;cm&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;我的年龄是&quot;</span>+age+<span class="hljs-string">&quot;岁&quot;</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.sex==<span class="hljs-number">0</span>)<br>            System.out.println(<span class="hljs-string">&quot;我是男性！&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">&quot;我是女性！&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个类可以包含以下<strong>类型变量</strong>：</p>
<ul>
<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li>类变量：也叫静态变量，类变量也声明在类中，方法体之外，但必须声明为 <code>static</code> 类型。</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>创建对象的语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名 对象名 = <span class="hljs-keyword">new</span> 类名();<br></code></pre></td></tr></table></figure>

<p>比如对 <code>People</code>这个类，我想实例化<code>LiLei</code>这个人。<code>LiLei</code> 的数据类型便是 <code>People</code> 这个类型。（类可以看成使我们自己定义的数据类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">People</span> <span class="hljs-variable">LiLei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();<br></code></pre></td></tr></table></figure>

<p>定义类的时候不会为类开辟内存空间，但是一旦创建了对象，系统就会在内存中为对象开辟一块空间，用来存放对象的属性值和方法。新建一个 NewObject.java 文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewObject</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">LiLei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(); <span class="hljs-comment">//创建一个People对象LiLei</span><br><br>        LiLei.height =<span class="hljs-number">170</span>;<br>        LiLei.age = <span class="hljs-number">20</span>;<br>        LiLei.sex = <span class="hljs-number">1</span>;<br><br>        LiLei.printBaseMes();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">javac NewObject.java People.java</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">java NewObject</span><br>我的身高是170.0cm<br>我的年龄是20岁<br>我是女性！<br></code></pre></td></tr></table></figure>

<p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1062timestamp1434617083799.png" srcset="/img/loading.gif" lazyload alt="为对象分配内存"></p>
<p>创建对象后，我们就要使用对象了，使用对象无非就是对属性和方法进行操作和调用。语法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//引用对象属性</span><br>对象名.属性<br><br><span class="hljs-comment">//引用对象方法</span><br>对象名.方法<br></code></pre></td></tr></table></figure>

<p>例如对 LiLei 的身高（<code>length</code>）赋值，并调用 <code>cry</code> 这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">LiLei.height = <span class="hljs-number">170</span>;<br>LiLei.cry();<br></code></pre></td></tr></table></figure>

<p>刚刚我们引入了成员变量这个概念，那什么是成员变量呢？成员变量就是指的对象的属性，是在类中定义，来描述对象的特性。还有一种变量叫局部变量，它是由类的方法定义，在方法中临时保存数据。</p>
<p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1062timestamp1434619940542.png" srcset="/img/loading.gif" lazyload alt="成员变量和局部变量"></p>
<p>在使用时注意，成员变量可以被本类的所有方法所使用，同时可以被与本类有关的其他类所使用。而局部变量只能在当前的方法中使用。</p>
<p>在这里我们要讲到一个关于作用域的知识了。作用域可以简单地理解为变量的生存期或者作用范围，也就是变量从定义开始到什么时候消亡。</p>
<ol>
<li>局部变量的作用域仅限于定义它的方法内。而成员变量的作用域在整个类内部都是可见的。</li>
<li>同时在相同的方法中，不能有同名的局部变量；在不同的方法中，可以有同名的局部变量。</li>
<li>成员变量和局部变量同名时，局部变量具有更高的优先级。 大家可以编写代码验证一下。</li>
</ol>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>在面向对象中有一个非常重要的知识点，就是构造方法。每个类都有构造方法，在创建该类的对象的时候他们将被调用，如果没有定义构造方法，Java 编译器会提供一个默认构造方法。 创建一个对象的时候，至少调用一个构造方法。比如在新建一个对象 <code>new Object()</code>，括号中没有任何参数，代表调用一个无参构造方法（默认构造方法就是一个无参构造方法）。构造方法的名称必须与类名相同，一个类可以定义多个构造方法。</p>
<p>构造方法的具体内容：</p>
<p>1、构造方法的名称与类名相同，且没有返回值。它的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//与类同名，可以指定参数，没有返回值</span><br><span class="hljs-keyword">public</span> 构造方法名()&#123;<br><span class="hljs-comment">//初始化代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面是一个构造方法的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-comment">//无参构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>    <span class="hljs-comment">//有一个参数的构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>又例如具体的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br><span class="hljs-comment">//属性（成员变量）有什么</span><br>    <span class="hljs-type">double</span> height;     <span class="hljs-comment">//身高</span><br>    <span class="hljs-type">int</span> age;           <span class="hljs-comment">//年龄</span><br>    <span class="hljs-type">int</span> sex;       <span class="hljs-comment">//性别，0为男性，非0为女性</span><br><br>    <span class="hljs-comment">//构造函数，初始化了所有属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">(<span class="hljs-type">double</span> h, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> s)</span>&#123;<br>        height = h;<br>        age = a;<br>        sex = s;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//创建对象，调用我们自己定义的有参构造方法</span><br><span class="hljs-type">People</span> <span class="hljs-variable">XiaoMing</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(<span class="hljs-number">168</span>, <span class="hljs-number">21</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>上面的例子中通过 <code>new</code> 关键字将类实例化成对象，而 <code>new</code> 后面跟的就是构造方法。于是可以知道 <code>new + 构造方法</code> 可以创建一个新的对象。</p>
<p>2、如果在定义类的时候没有写构造方法，系统会默认生成一个无参构造方法，这个构造方法什么也不会做。</p>
<p>3、当有指定的构造方法时，系统都不会再添加无参构造方法了。</p>
<p>4、构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法。</p>
<h3 id="静态static"><a href="#静态static" class="headerlink" title="静态static"></a>静态static</h3><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>Java 中被 <code>static</code> 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String string=<span class="hljs-string">&quot;shiyanlou&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//静态成员不需要实例化 直接就可以访问</span><br>        System.out.println(StaticTest.string);<br>        <span class="hljs-comment">//如果不加static关键字 需要这样访问</span><br>        StaticTest staticTest=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticTest</span>();<br>        System.out.println(staticTest.string);<br>        <span class="hljs-comment">//如果加上static关键字，上面的两种方法都可以使用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>被 <code>static</code> 修饰的方法是静态方法，静态方法不依赖于对象，不需要将类实例化便可以调用，由于不实例化也可以调用，所以不能有 <code>this</code>，也不能访问非静态成员变量和非静态方法。但是非静态成员变量和非静态方法可以访问静态方法。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><code>final</code> 关键字可以修饰类、方法、属性和变量</p>
<ol>
<li><code>final</code> 修饰类，则该类不允许被继承，为最终类</li>
<li><code>final</code> 修饰方法，则该方法不允许被覆盖（重写）</li>
<li><code>final</code> 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）</li>
<li>final 修饰变量，则该变量的值只能赋一次值，即常量</li>
</ol>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//静态常量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String SHI_YAN_LOU=<span class="hljs-string">&quot;shiyanlou&quot;</span>;<br></code></pre></td></tr></table></figure>





<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>代码中经常用到 <code>private</code> 和 <code>public</code> 修饰符，权限修饰符可以用来修饰属性和方法的访问范围。</p>
<p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1072timestamp1434941168916.png" srcset="/img/loading.gif" lazyload alt="访问范围"></p>
<p>如图所示，代表了不同的访问修饰符的访问范围，比如 <code>private</code> 修饰的属性或者方法，只能在当前类中访问或者使用。<code>默认</code> 是什么修饰符都不加，默认在当前类中和同一包下都可以访问和使用。<code>protected</code> 修饰的属性或者方法，对同一包内的类和所有子类可见。<code>public</code> 修饰的属性或者方法，对所有类可见。</p>
<p>我们可以举一个例子，比如 <code>money</code>，如果我们用 <code>private</code> 修饰代表着这是私有的，只能我自己可以使用。如果是 <code>protected</code> 代表着我可以使用，和我有关系的人，比如儿子也可以用。如果是 <code>public</code> 就代表了所有人都可以使用。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote>
<p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别</p>
</blockquote>
<p>这样做有什么好处？</p>
<ol>
<li>只能通过规定的方法访问数据。</li>
<li>隐藏类的实例细节，方便修改和实现。</li>
</ol>
<p>我们在开汽车的时候，只用去关注如何开车，我们并不在意车子是如何实现的，这就是封装。</p>
<p>如何去实现类的封装呢？</p>
<ol>
<li>修改属性的可见性，在属性的前面添加修饰符 (<code>private</code>)</li>
<li>对每个值属性提供对外的公共方法访问，如创建 getter&#x2F;setter（取值和赋值）方法，用于对私有属性的访问</li>
<li>在 getter&#x2F;setter 方法里加入属性的控制语句，例如我们可以加一个判断语句，对于非法输入给予否定。</li>
</ol>
<p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1072timestamp1434933673483.png" srcset="/img/loading.gif" lazyload alt="封装的步骤"></p>
<p>如果我们没有在属性前面添加任何修饰符，我们通过对象就可以直接对属性值进行修改，没有体现封装的特性。这在许多程序设计中都是不安全的，所以我们需要利用封装，来改进我们的代码。</p>
<p>首先在类里要将属性前添加 <code>private</code> 修饰符。然后定义 <code>getter</code> 和 <code>setter</code> 方法。修改 <code>People.java</code> 和 <code>NewObject.java</code> 的内容如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-comment">//属性（成员变量）有什么，前面添加了访问修饰符private</span><br>    <span class="hljs-comment">//变成了私有属性，必须通过方法调用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> height;     <span class="hljs-comment">//身高</span><br><br>    <span class="hljs-comment">//属性已经封装好了，如果用户需要调用属性</span><br>    <span class="hljs-comment">//必须用getter和setter方法进行调用</span><br>    <span class="hljs-comment">//getter和setter方法需要程序员自己定义</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//getter 方法命名是get关键字加属性名（属性名首字母大写）</span><br>    <span class="hljs-comment">//getter 方法一般是为了得到属性值</span><br>      <span class="hljs-keyword">return</span> height;<br>    &#125;<br><br>    <span class="hljs-comment">//同理设置我们的setter方法</span><br>    <span class="hljs-comment">//setter 方法命名是set关键字加属性名（首字母大写）</span><br>    <span class="hljs-comment">//setter 方法一般是给属性值赋值，所以有一个参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeight</span><span class="hljs-params">(<span class="hljs-type">double</span> newHeight)</span>&#123;<br>      height = newHeight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在 <code>main</code> 函数里的对象，不能再直接调用属性了，只能通过 <code>getter</code> 和 <code>setter</code> 方法进行调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewObject</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">LiLei</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();    <span class="hljs-comment">//创建了一个People对象LiLei</span><br><br>        <span class="hljs-comment">//利用setter方法为属性赋值</span><br>        LiLei.setHeight(<span class="hljs-number">170.0</span>);<br><br>        <span class="hljs-comment">//利用getter方法取属性值</span><br>        System.out.println(<span class="hljs-string">&quot;LiLei的身高是&quot;</span>+LiLei.getHeight());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">javac NewObject.java People.java<br>java NewObject.java<br></code></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac NewObject.java People.java<br>$ java NewObject<br>LiLei的身高是170.0<br></code></pre></td></tr></table></figure>





<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><code>this</code> 关键字代表当前对象。使用 <code>this.属性</code> 操作当前对象的属性，<code>this.方法</code> 调用当前对象的方法。</p>
<p>用 <code>private</code> 修饰的属性，必须定义 getter 和 setter 方法才可以访问到 (Eclipse 和 IDEA 等 IDE 都有自动生成 getter 和 setter 方法的功能）。</p>
<p>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>  <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> age;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建好了 getter 和 setter 方法后，我们发现方法中参数名和属性名一样。</p>
<p>当成员变量和局部变量之间发生冲突时，在属性名前面添加了 <code>this</code> 关键字。 此时就代表将一个参数的值赋给当前对象的属性。同理 <code>this</code> 关键字可以调用当前对象的方法，同学们自行验证一下吧。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承可以看成是类与类之间的衍生关系。比如狗类是动物类，牧羊犬类又是狗类。于是我们可以说狗类继承了动物类，而牧羊犬类就继承了狗类。于是狗类就是动物类的子类（或派生类），动物类就是狗类的父类（或基类）。</p>
<p>所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">class 子类 extends 父类<br></code></pre></td></tr></table></figure>

<p>例如我们定义了一个 Animal 类，再创建一个 Dog 类，我们需要它继承 Animal 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们就来练习一下吧！</p>
<p>我们先创建一个父类 <code>Animal.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> legNum;     <span class="hljs-comment">//动物四肢的数量</span><br><br>    <span class="hljs-comment">//类方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;动物叫！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来创建一个子类<code>Dog.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Dog 类继承了父类 Animal，我们 Dog 类里什么都没有写，其实它继承了父类 Animal，所以 Dog 类拥有 Animal 类的全部方法和属性（除开 private 方法和属性）。我们创建一个测试类测试一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        a.legNum = <span class="hljs-number">4</span>;<br>        a.bark();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Test.java Animal.java Dog.java<br>$ java Test<br>动物叫！<br></code></pre></td></tr></table></figure>

<p><strong>为什么需要继承？</strong></p>
<p>如果有两个类相似，那么它们会有许多重复的代码，导致后果就是代码量大且臃肿，后期的维护性不高。通过继承就可以解决这个问题，将两段代码中相同的部分提取出来组成一个父类，实现代码的复用。</p>
<p><strong>继承的特点</strong>：</p>
<ul>
<li>子类拥有父类除 <code>private</code> 以外的所有属性和方法。</li>
<li>子类可以拥有自己的属性和方法。</li>
<li>子类可以重写实现父类的方法。</li>
<li>Java 中的继承是单继承，一个类只有一个父类。</li>
</ul>
<blockquote>
<p>注：Java 实现多继承的一个办法是 <code>implements</code>（实现）接口，但接口不能有非静态的属性，这一点请注意。</p>
</blockquote>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code> 关键字在子类内部使用，代表父类对象。</p>
<ol>
<li>访问父类的属性 <code>super.属性名</code>。</li>
<li>访问父类的方法 <code>super.bark()</code>。</li>
<li>子类构造方法需要调用父类的构造方法时，在子类的构造方法体里<strong>最前面</strong>的位置：<code>super()</code>。</li>
</ol>
<h3 id="方法重载与重写"><a href="#方法重载与重写" class="headerlink" title="方法重载与重写"></a>方法重载与重写</h3><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。方法重载一般用于创建一组任务相似但是参数不同的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">float</span> f)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;f=&quot;</span> + f);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;s=&quot;</span> + s);<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(String s1, String s2)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;s1+s2=&quot;</span>+(s1+s2));<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;s=&quot;</span>+s+<span class="hljs-string">&quot;,i=&quot;</span>+i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        test.f(<span class="hljs-number">3456</span>);<br>        test.f(<span class="hljs-number">34.56f</span>);<br>        test.f(<span class="hljs-string">&quot;abc&quot;</span>);<br>        test.f(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>);<br>        test.f(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-number">3456</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Test.java<br>$ java Test<br>i=3456<br>f=34.56<br>s=abc<br>s1+s2=abcdef<br>s=abc,i=3456<br></code></pre></td></tr></table></figure>

<p>方法重载有以下几种规则：</p>
<ul>
<li>方法中的参数列表必须不同。比如：参数个数不同或者参数类型不同。</li>
<li>重载的方法中允许抛出不同的异常</li>
<li>可以有不同的返回值类型，但是参数列表必须不同。</li>
<li>可以有不同的访问修饰符。</li>
</ul>
<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>子类可以继承父类的方法，但如果子类对父类的方法不满意，想在里面加入适合自己的一些操作时，就需要将方法进行重写。并且子类在调用方法中，优先调用子类的方法。</p>
<p>比如 <code>Animal</code> 类中有 <code>bark()</code> 这个方法代表了动物叫，但是不同的动物有不同的叫法，比如狗是汪汪汪，猫是喵喵喵。</p>
<p>当然在方法重写时要注意，重写的方法一定要与原父类的方法语法保持一致，比如返回值类型，参数类型及个数，和方法名都必须一致。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">//类方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;动物叫！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>       <span class="hljs-comment">//重写父类的bark方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;汪！汪！汪！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>写个测试类来看看输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>           <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(); <span class="hljs-comment">// Animal 对象</span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();   <span class="hljs-comment">// Dog 对象</span><br><br>          <span class="hljs-type">Animal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">// Dog 对象,向上转型为Animal类型，具体会在后面的内容进行详解</span><br><br>          a.bark();<span class="hljs-comment">// 执行 Animal 类的方法</span><br>         d.bark();<span class="hljs-comment">//执行 Dog 类的方法</span><br>          b.bark();<span class="hljs-comment">//执行 Dog 类的方法</span><br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Test.java Dog.java Animal.java<br>$ java Test<br>动物叫！<br>汪！汪！汪！<br>汪！汪！汪！<br></code></pre></td></tr></table></figure>





<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<p>通俗地讲，只通过父类就能够引用不同的子类，这就是多态，我们只有在运行的时候才会知道引用变量所指向的具体实例对象。</p>
<h4 id="多态的实现条件"><a href="#多态的实现条件" class="headerlink" title="多态的实现条件"></a>多态的实现条件</h4><p><strong>Java 实现多态有三个必要条件：继承、重写和向上转型（即父类引用指向子类对象）。</strong></p>
<p>只有满足上述三个条件，才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>
<h4 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h4><p>Java 中多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现。</p>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><p>要理解多态必须要明白什么是”向上转型”，比如，一段代码如下，Dog 类是 Animal 类的子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();  <span class="hljs-comment">//a是父类的引用指向的是本类的对象</span><br><br><span class="hljs-type">Animal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(); <span class="hljs-comment">//b是父类的引用指向的是子类的对象</span><br></code></pre></td></tr></table></figure>

<p>在这里，可以认为由于 Dog 继承于 Animal，所以 Dog 可以自动向上转型为 Animal，所以 <code>b</code> 是可以指向 Dog 实例对象的。</p>
<blockquote>
<p>注：不能使用一个子类的引用去指向父类的对象，因为子类对象中可能会含有父类对象中所没有的属性和方法。</p>
<p>我的理解：例如 Animal属性leg、方法bark()，而在Dog中有方法eatShit()，如果写成Dog dd &#x3D; new Animal();那么dd的eatShit方法无法创建，就会报错 </p>
</blockquote>
<p>如果定义了一个指向子类对象的父类引用类型，那么它除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能。但是对于只存在于子类的方法和属性就不能获取。</p>
<p>新建一个 <code>Test.java</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">//父类方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;动物叫！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br><br>    <span class="hljs-comment">//子类重写父类的bark方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;汪、汪、汪！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//子类自己的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dogType</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是什么品种的狗？&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><br>        a.bark();<br>        b.bark();<br>        <span class="hljs-comment">//b.dogType();</span><br>        <span class="hljs-comment">//b.dogType()编译不通过</span><br>        d.bark();<br>        d.dogType();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Test.java<br>$ java Test<br>动物叫！<br>汪、汪、汪！<br>汪、汪、汪！<br>这是什么品种的狗？<br></code></pre></td></tr></table></figure>

<p>在这里，由于 <code>b</code> 是父类的引用，指向子类的对象，因此不能获取子类的方法（<code>dogType()</code> 方法）, 同时当调用 <code>bark()</code> 方法时，由于子类重写了父类的 <code>bark()</code> 方法，所以调用子类中的 <code>bark()</code> 方法。</p>
<p>我的理解：Animal自己是没有dogType方法的，所以<code>Animal b = new dog()</code>创建的Animal只能创建出Animal和Dog共有的，并且是Dog的内容！ </p>
<p><strong>因此，向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法，也会覆盖与父类中相同的方法——重写（方法名，参数都相同）。</strong></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在定义类时，前面加上 <code>abstract</code> 关键字修饰的类叫抽象类。</p>
<p>抽象类中有抽象方法，这种方法是不完整的，仅有声明而没有方法体。抽象方法声明语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//f()方法是抽象方法</span><br></code></pre></td></tr></table></figure>

<p>那我们什么时候会用到抽象类呢？</p>
<ol>
<li>在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。也就是说抽象类是约束子类必须要实现哪些方法，而并不关注方法如何去实现。</li>
<li>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。</li>
</ol>
<p>所以由上可知，<strong>抽象类是限制规定子类必须实现某些方法，但不关注实现细节。</strong></p>
<p>那抽象类如何用代码实现呢，它的规则如下：</p>
<ol>
<li>用 <code>abstract</code> 修饰符定义抽象类。</li>
<li>用 <code>abstract</code> 修饰符定义抽象方法，只用声明，不需要实现。</li>
<li>包含抽象方法的类就是抽象类。</li>
<li>抽象类中可以包含普通的方法，也可以没有抽象方法。</li>
<li>抽象类的对象不能直接创建，通常是定义引用变量指向子类对象。</li>
</ol>
<p>我们来写一写代码吧！</p>
<p>1、在 <code>home/project/</code> 目录下创建一个抽象类 <code>TelePhone.java</code>。</p>
<p>2、填写需要子类实现的抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TelePhone</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//抽象方法,打电话</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">message</span><span class="hljs-params">()</span>; <span class="hljs-comment">//抽象方法，发短信</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、构建子类，并实现抽象方法。新建一个 <code>CellPhone.java</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CellPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TelePhone</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我可以打电话！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">message</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我可以发短信！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CellPhone</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CellPhone</span>();<br>        cp.call();<br>        cp.message();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 CellPhone 类添加 <code>main</code> 方法测试运行结果。</p>
<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac CellPhone.java TelePhone.java<br>$ java CellPhone<br><br>我可以打电话！<br>我可以发短信！<br></code></pre></td></tr></table></figure>





<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口用于描述类所具有的功能，而不提供功能的实现，功能的实现需要写在实现接口的类中，并且该类必须实现接口中所有的未实现方法。</p>
<p>接口的声明语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 interface 接口名称 [extends 其他的接口名] &#123;<br>        <span class="hljs-comment">// 声明变量</span><br>        <span class="hljs-comment">// 抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如声明一个 Animal 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Animal.java</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>        <span class="hljs-comment">//int x;</span><br>        <span class="hljs-comment">//编译错误,x需要初始化，因为是 static final 类型</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">travel</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意点</strong></p>
<p>在 Java8 中：</p>
<ul>
<li>接口不能用于实例化对象。</li>
<li>接口中方法只能是抽象方法、<code>default</code> 方法、静态方法。</li>
<li>接口成员是 <code>static final</code> 类型。</li>
<li>接口支持多继承。</li>
</ul>
<p>在 Java9 中，接口可以拥有私有方法和私有静态方法，但是只能被该接口中的 <code>default</code> 方法和静态方法使用。</p>
<p>多继承实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> extends 接口<span class="hljs-number">1</span>，接口<span class="hljs-number">2</span>&#123;<br><br>&#125;<br><br>修饰符 <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> implements 接口<span class="hljs-number">1</span>，接口<span class="hljs-number">2</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现上面的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Cat.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;Cat eats&quot;</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">travel</span><span class="hljs-params">()</span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;Cat travels&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        cat.eat();<br>        cat.travel();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac Cat.java Animal.java<br>$ java Cat<br>Cat eats<br>Cat travels<br></code></pre></td></tr></table></figure>





<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>将一个类的定义放在另一个类的定义内部，这就是内部类。而包含内部类的类被称为外部类。</p>
<p>内部类的主要作用如下：</p>
<ol>
<li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</li>
<li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据</li>
<li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便</li>
<li>内部类允许继承多个非接口类型（具体将在以后的内容进行讲解）</li>
</ol>
<blockquote>
<p>注：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为 outer 的外部类和其内部定义的名为 inner 的内部类。编译完成后出现 <code>outer.class</code> 和 <code>outer$inner.class</code> 两类。所以内部类的成员变量 &#x2F; 方法名可以和外部类的相同。</p>
</blockquote>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// People.java</span><br><span class="hljs-comment">//外部类People</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LiLei&quot;</span>;         <span class="hljs-comment">//外部类的私有属性</span><br>    <span class="hljs-comment">//内部类Student</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20151234&quot;</span>;               <span class="hljs-comment">//内部类的成员属性</span><br>        <span class="hljs-comment">//内部类的方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stuInfo</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;访问外部类中的name：&quot;</span> + name);<br>            System.out.println(<span class="hljs-string">&quot;访问内部类中的ID：&quot;</span> + ID);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//测试成员内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>();     <span class="hljs-comment">//创建外部类对象，对象名为a</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(); <span class="hljs-comment">//使用外部类对象创建内部类对象，对象名为b</span><br>        <span class="hljs-comment">// 或者为 People.Student b = a.new Student();</span><br>        b.stuInfo();   <span class="hljs-comment">//调用内部对象的suInfo方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac People.java<br>$ java People<br>访问外部类中的name：LiLei<br>访问内部类中的ID：20151234<br></code></pre></td></tr></table></figure>

<p>成员内部类的使用方法：</p>
<ol>
<li>Student 类相当于 People 类的一个成员变量，所以 Student 类可以使用任意访问修饰符。</li>
<li>Student 类在 People 类里，所以访问范围在类里的所有方法均可以访问 People 的属性（即内部类里可以直接访问外部类的方法和属性，反之不行）。</li>
<li>定义成员内部类后，必须使用外部类对象来创建内部类对象，即 <code>内部类 对象名 = 外部类对象.new 内部类();</code>。</li>
<li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 <code>this</code> 关键字。如上述代码中：<code>a.this</code>。</li>
</ol>
<blockquote>
<p>注：成员内部类不能含有 <code>static</code> 的变量和方法，因为成员内部类需要先创建了外部类，才能创建它自己的。</p>
</blockquote>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>静态内部类通常被称为嵌套类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// People.java</span><br><span class="hljs-comment">//外部类People</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LiLei&quot;</span>;         <span class="hljs-comment">//外部类的私有属性</span><br><br><span class="hljs-comment">/*外部类的静态变量。</span><br><span class="hljs-comment">Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;510xxx199X0724XXXX&quot;</span>;<br><br>    <span class="hljs-comment">//静态内部类Student</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20151234&quot;</span>;               <span class="hljs-comment">//内部类的成员属性</span><br>        <span class="hljs-comment">//内部类的方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stuInfo</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;访问外部类中的name：&quot;</span> + (<span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>().name));<br>            System.out.println(<span class="hljs-string">&quot;访问外部类中的ID：&quot;</span> + People.ID);<br>            System.out.println(<span class="hljs-string">&quot;访问内部类中的ID：&quot;</span> + ID);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//测试成员内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();   <span class="hljs-comment">//直接创建内部类对象，对象名为b</span><br>        b.stuInfo();                 <span class="hljs-comment">//调用内部对象的suInfo方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac People.java<br>$ java People<br>访问外部类中的name：LiLei<br>访问外部类中的ID：510xxx199X0724XXXX<br>访问内部类中的ID：20151234<br></code></pre></td></tr></table></figure>

<p>静态内部类是 <code>static</code> 修饰的内部类，这种内部类的特点是：</p>
<ol>
<li>静态内部类不能直接访问外部类的非静态成员，但可以通过 <code>new 外部类().成员</code> 的方式访问。</li>
<li>如果外部类的静态成员与内部类的成员名称相同，可通过 <code>类名.静态成员</code> 访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过 <code>成员名</code> 直接调用外部类的静态成员。</li>
<li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建 <code>内部类 对象名 = new 内部类();</code>。</li>
</ol>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类，是指内部类定义在方法和作用域内。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// People.java</span><br><span class="hljs-comment">//外部类People</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;<br>    <span class="hljs-comment">//定义在外部类中的方法内：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">peopleInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;man&quot;</span>;  <span class="hljs-comment">//外部类方法中的常量</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20151234&quot;</span>; <span class="hljs-comment">//内部类中的常量</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;访问外部类的方法中的常量sex：&quot;</span> + sex);<br>                System.out.println(<span class="hljs-string">&quot;访问内部类中的变量ID:&quot;</span> + ID);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();  <span class="hljs-comment">//创建方法内部类的对象</span><br>        a.print();<span class="hljs-comment">//调用内部类的方法</span><br>    &#125;<br>    <span class="hljs-comment">//定义在外部类中的作用域内</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">peopleInfo2</span><span class="hljs-params">(<span class="hljs-type">boolean</span> b)</span> &#123;<br>        <span class="hljs-keyword">if</span>(b)&#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;man&quot;</span>;  <span class="hljs-comment">//外部类方法中的常量</span><br>            <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;20151234&quot;</span>; <span class="hljs-comment">//内部类中的常量</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;访问外部类的方法中的常量sex：&quot;</span> + sex);<br>                    System.out.println(<span class="hljs-string">&quot;访问内部类中的变量ID:&quot;</span> + ID);<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">Student</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();  <span class="hljs-comment">//创建方法内部类的对象</span><br>            a.print();<span class="hljs-comment">//调用内部类的方法</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//测试方法内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(); <span class="hljs-comment">//创建外部类的对象</span><br>        System.out.println(<span class="hljs-string">&quot;定义在方法内：===========&quot;</span>);<br>        b.peopleInfo();  <span class="hljs-comment">//调用外部类的方法</span><br>        System.out.println(<span class="hljs-string">&quot;定义在作用域内：===========&quot;</span>);<br>        b.peopleInfo2(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ javac People.java<br>$ java People<br>定义在方法内：===========<br>访问外部类的方法中的常量sex：man<br>访问内部类中的变量ID:20151234<br>定义在作用域内：===========<br>访问外部类的方法中的常量sex：man<br>访问内部类中的变量ID:20151234<br></code></pre></td></tr></table></figure>

<p>局部内部类也像别的类一样进行编译，但只是作用域不同而已，只在该方法或条件的作用域内才能使用，退出这些作用域后无法引用的。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类，顾名思义，就是没有名字的内部类。正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写。但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Outer.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, String city)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">nameStr</span> <span class="hljs-operator">=</span> name;<br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> nameStr;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.getInner(<span class="hljs-string">&quot;Inner&quot;</span>, <span class="hljs-string">&quot;NewYork&quot;</span>);<br>        System.out.println(inner.getName());<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Inner</span> &#123;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：Inner。</p>
<p>匿名内部类是<strong>不能加访问修饰符</strong>的。要注意的是，new 匿名类，这个类是要先定义的, 如果不先定义，编译时会报错该类找不到。</p>
<p>同时，在上面的例子中，当所在的方法的形参需要在内部类里面使用时，该形参必须为 <code>final</code>。这里可以看到形参 <code>name</code> 已经定义为 <code>final</code> 了，而形参 <code>city</code> 没有被使用则不用定义为 <code>final</code>。</p>
<p>然而，因为匿名内部类没名字，是用默认的构造函数的，无参数的，如果需要该类有带参数的构造函数，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInner</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, String city)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>(name, city) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">nameStr</span> <span class="hljs-operator">=</span> name;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> nameStr;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意这里的形参 <code>city</code>，由于它没有被匿名内部类直接使用，而是被抽象类 Inner 的构造函数所使用，所以不必定义为 <code>final</code>。</p>
<h3 id="包Package"><a href="#包Package" class="headerlink" title="包Package"></a>包Package</h3><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。</p>
<p><strong>包的作用</strong></p>
<ul>
<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>
<li>包采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。</li>
<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ul>
<p>定义包语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> 包名<br><span class="hljs-comment">//注意：必须放在源程序的第一行，包名可用&quot;.&quot;号隔开</span><br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在定义文件夹的时候利用&quot;/&quot;来区分层次</span><br><span class="hljs-comment">//包中用&quot;.&quot;来分层</span><br><span class="hljs-keyword">package</span> com.shiyanlou.java<br></code></pre></td></tr></table></figure>

<p>不仅是我们这样利用包名来区分类，系统也是这样做的。</p>
<p><img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/document-uid79144labid1072timestamp1434937042272.png" srcset="/img/loading.gif" lazyload alt="Java系统中的包"></p>
<p><strong>如何在不同包中使用另一个包中的类？</strong></p>
<p>使用 <code>import</code> 关键字。比如要导入包 <code>com.shiyanlou</code> 下 <code>People</code> 这个类，<code>import com.shiyanlou.People;</code>。同时如果 <code>import com.shiyanlou.*;</code> 这是将包下的所有文件都导入进来，<code>*</code> 是通配符。</p>
<p><strong>包的命名规范是全小写字母拼写</strong>。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java%E5%9F%BA%E7%A1%80/">#Java基础</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java入门面向对象</div>
      <div>https://61hhh-github-io.vercel.app/20200721/2d17972e/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>LY</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年7月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/20200722/83908933/" title="操作系统 2.进程管理">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统 2.进程管理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/20200721/98c92646/" title="Java入门基础语法">
                        <span class="hidden-mobile">Java入门基础语法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://lib.baomitu.com/waline/2.14.1/waline.min.css')
      Fluid.utils.createScript('https://lib.baomitu.com/waline/2.14.1/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://waline-server-61hhh.vercel.app/","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":[""],"lang":"zh-CN","emoji":["https://unpkg.com/@waline/emojis@1.1.0/tieba","https://unpkg.com/@waline/emojis@1.1.0/qq"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10,"search":false},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <span>本网站由</span> <a class="footer-support-logo" href="[https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral](https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral)" target="blank" title="又拍云"> <img height="30" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/logo/upyun-logo.png" srcset="/img/loading.gif" lazyload alt="又拍云"></a> <span>提供 CDN 加速</span> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        访问量：
        <span id="leancloud-site-pv"></span>
        
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        访客数：
        <span id="leancloud-site-uv"></span>
        
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
