---
title: 《算法笔记》基础篇(三)
tags: 算法学习
categories: 基础
abbrlink: 6ed6b5da
date: 2020-04-01 19:10:48
---

算法笔记这本书是在学算法设计课的时候同学推荐的，内容很多很好，当时边上课边看这个书把基础篇看完了，但是对应的题也没咋做。。。现在感觉都不会写题了。。再捡起来练习一下

题目比较多，我的能力也有限，慢慢来吧，一点点去学习更新 :)

参考：《算法笔记-上机训练实战指南》

> 种一棵树最好的时间是十年前，其次是现在。

> 很烦自己这种三天打鱼两天晒网的行为。。。总是一时的激情，然后抛之脑后，以后不做多的，一天一题。

<!--more-->

## 第三章-入门模拟

### 3.1简单模拟

第三章的题是简单的模拟题，没有什么算法上的问题，主要是思维上的问题。

#### PAT-B

##### 1001 害死人不偿命的(3n+1)猜想

思路：使用while循环判断n是否为1

- 如果为1，退出循环
- 不为1，判断是否为偶数，是偶数n除以2，否则n=(3*n+1)/2，step++

```c
#include<cstdio>
int main()
{
	int n,step=0;
	scanf("%d",&n);
	while(n!=1)
	{
		if(n%2==0)
		n=n/2;
		else
		n=(3*n+1)/2;
		step++;
	}
	printf("%d",step);
	return 0;
}
```

##### 1011 A+B和C

思路：输入T表示组数，在while循环中以此判断每组输入的A、B、C

- 满足A+B>C，按格式输出Case #%d:true
- 不满足，按格式输出Case: #%d:false

```c
#include<stdio.h>
int main() 
{
  long long A,B,C;
  int T;
  int number=1;
  scanf("%d",&T);
  while(T!=0)
  {
    scanf("%lld %lld %lld",&A,&B,&C);
    if(A+B>C) printf("Case #%d: true\n",number);
    else printf("Case #%d: false\n",number);
    number++;
    T--;
  }
  return 0;
}
```



##### 1016 部分A+B

思路：简单数学问题，直接暴力判断，枚举A的每一位，通过取模--%10,除10--/10

- 如果与DA相同就加到PA后

**题目数据较大，要用到long long**。。。

```c
#include<stdio.h>
#include<string.h>
int PP(long long x,int dx)
{
	int tmp=0;
	long long p=0;
	while(x!=0)
	{
		tmp=x%10;
		x=x/10;
		if(tmp==dx)
			p=p*10+tmp;
	}
	return p;
}
int main()
{
	long long A,B;
	int DA,DB,PA,PB;
	scanf("%lld %d %lld %d",&A,&DA,&B,&DB);
	PA=PP(A,DA);
	PB=PP(B,DB);
	printf("%d",PA+PB);
	return 0;
}
```



##### 1026 程序运行时间

思路：CLK_TCK=100

- 换算单位后要四舍五入，1s等于100个CLK_TCK，即c1-c2>=50进位
- 设置格式。基本换算1h-60m-3600s

```c
#include<stdio.h>
int main()
{
	int c1,c2;
	scanf("%d%d",&c1,&c2);
	int ans=c2-c1;
	if(ans%100>=50)
		ans=ans/100+1;
	else
		ans=ans/100;
	printf("%02d:%02d:%02d",ans/3600,ans%3600/60,ans%60);
	return 0;
}
```



##### 1046 划拳

思路：输入次数n，在while循环内判断，然后输出

```c
#include<stdio.h>
int main()
{
	int n,A,AH,B,BH;
	int CA=0,CB=0;
	scanf("%d",&n);
	while(n>0)
	{
		scanf("%d%d%d%d",&A,&AH,&B,&BH);
		if((AH==A+B)&&(BH!=B+A))
		{
			CB++;
		}
		else if((AH!=A+B)&&(BH==B+A))
		{
			CA++;
		}
		n--;
	}
	printf("%d %d",CA,CB);
	return 0;
}
```



##### 1008 数组元素循环右移问题

思路：数组长度n，移位m个

1. 将原数组a[n]从第n-m开始复制到b[n]的0到n-m，即右移的m位，再将a[n]从0到m-1位复制到b[n]的m到n-1位，将b[n]输出
2. 简化--直接从n-m开始输出a[n]，然后再输出0到m-1

- **最后一位不能带空格！！！**要在最后控制输出
- **m可能大于n！！！**因此要m=m%n来修正m！！！

```c
#include<stdio.h>
int main()
{
	int n,m;
	scanf("%d %d",&n,&m);
	int a[n];
	m=m%n;
	for(int i=0;i<n;i++)
	{
		scanf("%d",&a[i]);
	}
	int b[n];
	for(int i=0;i<m;i++)
	{
		b[i]=a[n-m+i];
	}
	for(int i=m;i<n;i++)
	{
		b[i]=a[i-m];
	}
	for(int i=0;i<n;i++)
	{
		printf("%d",b[i]);
		if(i<n-1)
			printf(" ");
	}
	return 0;
}
```



##### 1012 数字分类

思路：循环内依次输入N个数，判断每次输入的m

- A2由于有加减操作可能为0，因此要用bool flag来判断。(bool flag=false用GCC编译报错)

```c
#include<stdio.h>
int main()
{
	int A[1000];
	int A1=0,A2=0,A3=0,A4=0,A5=0;
	int sum=0,count=1,N;
	bool flag=false;
	scanf("%d",&N);
	for(int i=0;i<N;i++)
	{
		scanf("%d",&A[i]);
		if(A[i]%10==0)
		{
			A1+=A[i];
		}
		else if(A[i]%5==1)
		{
			if(count%2!=0)
			{
				A2+=A[i];
				count++;
			}
			else
			{
				A2-=A[i];
				count++;
			}
			flag=true;
		}
		else if(A[i]%5==2)
		{
			A3++;
		}
		else if(A[i]%5==3)
		{
			sum+=A[i];
			A4++;
		}
		else if(A[i]%5==4)
		{
			if(A[i]>A5)
				A5=A[i];
		}
	}
	
	if(A1!=0)	printf("%d ",A1);
	else	printf("N ");
	if(flag)	printf("%d ",A2);
	else	printf("N ");
	if(A3!=0)	printf("%d ",A3);
	else	printf("N ");
	if(A4!=0)	printf("%.1f ",(double)sum/A4);
	else	printf("N ");
	if(A5!=0)	printf("%d\n",A5);
	else	printf("N\n");
	return 0;
	
}
```



##### 1018 锤子剪刀布

思路：直接循环判断每次的比较

- 开始测试数据输入n个就结束了，发现要用getchar()吸收空格，但是使用getchar()后还是只能输入一半，只好换cin来输入。。。输出可以不变

```c
#include<iostream> 
#include<cstdio>
using namespace std;
int main()
{
	int n,c1=0,j1=0,b1=0,c2=0,j2=0,b2=0;
	int win=0,draw=0,lose=0;
	char a,b,amax,bmax;
	cin>>n;
	while(n--)
	{
		cin>>a>>b;
		if(a==b)
		{
			draw++;
		}
		else if((a=='C'&&b=='J')||(a=='J'&&b=='B')||(a=='B'&&b=='C'))
		{
			win++;
			if(a=='C')c1++;
			if(a=='J')j1++;
			if(a=='B')b1++;
		}
		else
		{
			lose++;
			if(b=='C')c2++;
			if(b=='J')j2++;
			if(b=='B')b2++;
		}
	}
	if(j1>=c1&&j1>=b1)amax='J';
	if(c1>=j1&&c1>=b1)amax='C';
	if(b1>=j1&&b1>=c1)amax='B';
	
	if(j2>=c2&&j2>=b2)bmax='J';
	if(c2>=j2&&c2>=b2)bmax='C';
	if(b2>=j2&&b2>=c2)bmax='B';
	
	printf("%d %d %d\n",win,draw,lose);
	printf("%d %d %d\n",lose,draw,win);
	printf("%c %c",amax,bmax);
	return 0;
}
```



##### 1010一元多项式求导

思路：一般思路都是存到数组里输出，可以读一组数据输出一次，类似1008的简化。

- 只有指数系数都不为0求导后该项才不为0，满足条件的输出
- count==0表示是0多项式，直接输出0 0

```c
#include<stdio.h>
int main()
{
	int x,z,count=0;
	while(scanf("%d%d",&x,&z)!=EOF)
	{
		if(z!=0&&z!=0)
		{
			if(count!=0)
				printf(" ");
			printf("%d ",x*z);
			printf("%d",z-1);
			count++;
		}
	}
	if(count==0)
	{
		printf("0 0");
	}
	return 0;
}
```



#### PAT-A

##### 1042 Shuffling Machine

思路：题目还是很简单的，一个原数组card保存初始卡牌位置,order用于确定位置，sub用于记录中间变化的卡牌位置。

- 题目中说到：`If the number at the *i*-th position is *j*, it means to move the card from position *i* to position *j*. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.`，即`order[i]=j`表示将card的第`i`个元素移到`j`位置上
- 一开始用的`int card[]`，将`1`到`54`输出代表卡牌做测试，结果输出很奇怪，找了半天才发现写快了，写成`for(int i=0;i++;i<54)`。。。真的吐血，注意最后一个输出无空格。

```c++
#include<iostream>
using namespace std;
int main()
{
	string sub[54];
	string card[54] = {	"S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12","S13",
						"H1", "H2", "H3", "H4", "H5", "H6", "H7", "H8", "H9", "H10", "H11", "H12","H13",
						"C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "C10", "C11", "C12","C13",
						"D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D10", "D11", "D12","D13",
						"J1", "J2"};
	
	int order[54],n;
	cin>>n;
	for(int i=0;i<54;i++)
		cin>>order[i];
	for(int step=0;step<n;step++)
	{
		for(int i=0;i<54;i++)
		{
			sub[order[i]-1]=card[i];
		}
		for(int i=0;i<54;i++)
			card[i] = sub[i];
	}
	for(int i=0;i<53;i++)
	{
		if(i==53)
			cout<<card[53];
		else
			cout<<card[i]<<" ";
	}
	
	return 0;			
}
```



##### 1046 Shortest Distance

思路：首先读懂题目，给一个数n，表示n个高速路口可供进出，并给出每个路口的距离Di表示第`i`个到第`i+1`个路口的距离，第二行给出数字M，表示有M给判断，然后下面M行内，依次输入进出口的号码，求最短距离，各个高速口是循环的形式。

- 对于给出的in、out，由于n个高速口是循环形式，可以正着走可以反着走，要判断的就是哪个方向更近而已。
- 可以通过`disto1[]`来记录每个口到高速口1的距离，最后比较正着走`tmp=disto1[out]-dis[in]`和反着走`sum-tmp`的值谁更小。

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
	int dis[100005],disto1[100005];
	int n,m,in,out,sum=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>dis[i];
		sum+=dis[i];
		disto1[i]=sum; 
	}
	cin>>m;
	for(int i=0;i<m;i++)
	{
		cin>>in>>out;
		if(in>out) swap(in,out);
		int tmp=disto1[out-1]-disto1[in-1];
		cout<<min(tmp,sum-tmp)<<endl;
	}
	return 0;
}
```



##### 1065 A+B and C

思路：由于A、B、C的范围是[2^-63,2^63]，因此可能会有两数相加溢出的情况，此时直接进行判断会出现错误，计组中讲到过正溢出和负溢出，令ans=A+B

- `A+B>=2^63`，此时一定是满足`A+B>C`，但是此时正溢出造成`A+B<0`，特判`A>0&B>0&ans<0`时输出true
- 同理当`A+B<2^-63`时，显然有`A+B<C`，但是产生负溢出，特判`A<0&B<0&ans>0`输出false
- 其余情况下只需判断ans与C的关系即可

注：我的代码最后一个判断会出现答案错误，参照《训练指南》加一个flag，if的判断对flag进行操作，最后根据flag的`true or false`来决定输出，就不会报错。（但是代码逻辑上都是一样的。。。）

```c
#include<cstdio>
int main()
{
	int T,tcase=1;
	scanf("%d",&T);
	long long a,b,c,ans;
	while(T--)
	{
		scanf("%lld %lld %lld" ,&a,&b,&c);
		ans = a+b;
		if(a>0&&b>0&&ans<0)
			printf("Case #%d: true\n",tcase++);
		else if(a<0&&b<0&&ans>0)
			printf("Case #%d: false\n",tcase++);
		else if(ans>c)
			printf("Case #%d: true\n",tcase++);
		else
			printf("Case #%d: false\n",tcase++);
	}
	return 0;
}
```



##### 1002 A+B for Polynomials

思路：用数组p[n]存储指数为n的项前面的系数a

- 注意格式要系数保留一位小数

- 一开始采用的是输入k就count+=k，然后在第二次中去减重复的（注意要在加完之后减，因为有可能系数是相反数，加完为0，这一项就不存在了），但是连题目给的测试数据都没过

  ```c
  	while(k--)
  	{//第一次参考指南，直接在多项式2中去重复
  		scanf("%d %lf",&n,&a);
  		p[n]+=a;
          if(p[i]!=0) count--;
  	}
  //题目测试数据
  2 1 2.4 0 3.2 //count=2 p[1]=2.4 p[0]=3.2
  2 2 1.5 1 0.5 //count=4 p[2]=1.5（不为0 count--） p[1]=2.4+0.5=2.9（不为0 count--）
  //正确输出应该是count=3，此时count=2
  ```

- 于是我增加了一个flag数组，用于判断指数为n的项是否在多项式1中出现过，有出现就为true，此时判断的就是在多项式1中出现过且在2加完之后不为0，此时题目的测试数据可以，提交后最后两组出现答案错误，可能是数组设置不对？由于不知道测试数据，就干脆换个方法。。。

  ```c
  	while(k--)
  	{//在多项式1中增加flag数组
  		scanf("%d %lf",&n,&a);
  		p[n]+=a;
          flag[n]=true
  	}
  	while(k--)
  	{//多项式2中去重复
  		scanf("%d %lf",&n,&a);
  		p[n]+=a;
          if(flag[n]=true&&p[i]!=0) count--;
  	}
  ```

- 前面不对count操作，直到数据输完，根据p的非零项来count++，1000的数据量也不大，就不会有错了

```c
#include<cstdio>
int main()
{
	int k,n,count=0;
	double a,p[1001]={0};
	
	scanf("%d",&k);
	while(k--)
	{
		scanf("%d %lf",&n,&a);
		p[n]+=a;
	}
	scanf("%d",&k);
	while(k--)
	{
		scanf("%d %lf",&n,&a);
		p[n]+=a;
	}
	for(int i=0;i<=1000;i++)
	{
		if(p[i]!=0)
		count++;
	}
		
	printf("%d",count);
	for(int i=1000;i>=0;i--)
	{
		if(p[i]!=0)
			printf(" %d %.1f",i,p[i]);
	}
}
```







##### 1009 Product of Polynomials

思路：同样的，用数组存储们，获取倒第一个多项式系数后，在第二次循环中与第一个相乘

```c
#include<cstdio>
struct poly{
    int exp;      
    double cof;     
}poly[1010];
double answer[2010];
int main(){
    int k,count=0;
    scanf("%d",&k);
    for(int i=0;i<k;i++){
        scanf("%d %lf",&poly[i].exp,&poly[i].cof);
    }
    scanf("%d",&k);
    for(int i=0;i<k;i++){
        int exp;
        double cof;
        scanf("%d %lf",&exp,&cof);
        for(int j=0;j<k;j++){
            answer[exp+poly[j].exp]+=cof*poly[j].cof;
        }
    }
    for(int i=0;i<=2000;i++){
        if(answer[i]!=0.0)
            count++;
    }
    printf("%d",count);
    for(int i=2000;i>=0;i--){
        if(answer[i]!=0)
            printf(" %d %0.1f",i,answer[i]);
    }
    return 0;
} 
```



### 3.2查找元素

#### PAT-B

##### 1041考试座位号

思路：利用结构体，创建一个学生结构体，存放id和考试座位号，试机座位号作为下标

```c
#include<iostream>
#include<cstdio>
using namespace std;
struct Student{
	long long id;
	int examSeat;
}testSeat[1010];
int main()
{
	int N,eSeat,seat;
	long long sid;
	cin>>N;
	while(N--)
	{
		cin>>sid>>seat>>eSeat;
		testSeat[seat].id=sid;
		testSeat[seat].examSeat=eSeat;
	}
	int m,k;
	cin>>m;
	while(m--)
	{
		cin>>k;
		cout<<testSeat[k].id<<" ";
		cout<<testSeat[k].examSeat<<endl;
	}
	return 0;
}
```



##### 1004成绩排名

思路：同样是用结构体存储学生信息，循环输入信息并判断更新

```c
#include<iostream>
#include<cstdio>
using namespace std;
struct Student{
	string name;
	string number;
	int score;
}stu[1010];
int main()
{
	int n;
	string sName,sNumber,sScore;
	int Top=-1,Bottom=101;
	int Maxflag,Minflag;
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>stu[i].name>>stu[i].number>>stu[i].score;
		if(stu[i].score>Top)
		{
			Top=stu[i].score;
			Maxflag=i;
		}
		if(stu[i].score<Bottom)
		{
			Bottom=stu[i].score;
			Minflag=i;
		}
	}
	cout<<stu[Maxflag].name<<" "<<stu[Maxflag].number<<endl;
	cout<<stu[Minflag].name<<" "<<stu[Minflag].number<<endl;
}
```



##### 1028人口普查

思路：首先判断给出的年龄数据是否为有效值，然后再进行判断

- 定义结构体human存放村民信息，定义oldest和youngest存放有效的最老和最年轻
- 设置old和young函数判断年龄是否位于1814-9-6到2014-9-6之间
- 满足条件数量count++，然后就和oldest和youngest比较、更新
- count为0表示没有有效数据，直接输出0\n，否则输出count和oldest、youngest
- 很奇怪，我的思路和上机指南是差不多的，边界判断也没问题，结果有一组答案错误。。。

```c
#include<cstdio>
struct human{
	char name[15];
	int yy,mm,dd;
};
bool young(human h)
{
	if(h.yy>2014)
		return true;
	if(h.yy==2014&&h.mm>9)
		return true;
	if(h.yy==2014&&h.mm==9&&h.dd>6)
		return true;
	return false;
}
bool old(human h)
{
	if(h.yy<1814)
		return true;
	if(h.yy==1814&&h.mm<9)
		return true;
	if(h.yy==1814&&h.mm==9&&h.dd<6)
		return true;
	return false;
}
bool Cmp(human h1,human h2)
{
	if(h1.yy>h2.yy)
		return true;
	if(h1.yy==h2.yy&&h1.mm>h2.mm)
		return true;
	if(h1.yy=h2.yy&&h1.mm==h2.mm&&h1.dd>h2.dd)
		return true;
	return false;
}
int main()
{
	int n,count=0;
	human oldest,youngest;
	oldest.yy=2014;oldest.mm=9;oldest.dd=6;
	youngest.yy=1814;youngest.mm=9;youngest.dd=6;
	human a;
	scanf("%d",&n);
	for(int i=0;i<n;i++)
	{
		scanf("%s %d/%d/%d",&a.name,&a.yy,&a.mm,&a.dd);
		if(young(a)==false&&old(a)==false)
		{
			count++;
			if(Cmp(a,oldest)==false)
				oldest=a;
			if(Cmp(a,youngest)==true)
				youngest=a;
		}
	}
	if(count) printf("%d %s %s\n",count,oldest.name,youngest.name);
	else printf("0\n");
	return 0;
}
```



##### 1032挖掘机技术哪家强

思路：设置数组school[schID]记录每个学校的总分，school[schID]+=score;

num表示编号，max表示最高总分，遍历更新

```c
#include<cstdio>
const int maxn=100010;
int school[maxn]={0};
int main()
{
	int n,schID,score;
	scanf("%d",&n);
	for(int i=0;i<n;i++)
	{
		scanf("%d%d",&schID,&score);
		school[schID]+=score;
	}
	int num=1,MAX=-1;
	for(int i=1;i<=n;i++)
	{
		if(school[i]>MAX)
		{
			MAX=school[i];
			num=i;
		}
	}
	printf("%d %d\n",num,MAX);
	return 0;
}
```



#### PAT-A

##### 1011 World Cup Betting

思路：就是对每次的输入比较大小，选择最大的输出对应序号的字符，最后做一个计算值判断即可

```C
#include<cstdio>
char S[3]={'W','T','L'};
int main()
{
	double ans = 1.0,tmp,a;
	int index ;
	for(int i=0;i<3;i++)
	{
		tmp = 0.0;
		for(int j=0;j<3;j++)
		{
			scanf("%lf",&a);
			if(a>tmp)
			{
				tmp = a;
				index = j;
			}
		}
		ans*=tmp;
		printf("%c ",S[index]);
	}
	printf("%.2f",(ans*0.65-1)*2);
	return 0;
}
```



##### 1006 Sign In and Sign Out

思路：创建一个结构体Work，存储id和签到时间属性，然后编写一个cmp函数比较时间，设置一个ans1、ans2用于设置签入和签出的时间。

- 在n个循环内输入id，再输入签入时间，cmp比较
- 再输入签出时间，cmp比较，最后输出符合条件的

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
struct Work{
	char id[20];
	int hh,mm,ss;
	
}tmp,ans1,ans2;

bool cmp(Work work1,Work work2)
{
	if(work1.hh != work2.hh) return work1.hh>work2.hh;
	if(work1.mm != work2.mm) return work1.mm>work2.mm;
	return work1.ss>work2.ss;
}

int main()
{
	int n;
	scanf("%d",&n);
	ans1.hh=24,ans1.mm=60,ans1.ss=60;
	ans2.hh=0,ans2.mm=0,ans2.ss=0;
	for(int i=0;i<n;i++){
		scanf("%s %d:%d:%d",&tmp.id,&tmp.hh,&tmp.mm,&tmp.ss);
		if(cmp(tmp,ans1)==false)
			ans1=tmp;
		scanf("%d:%d:%d",&tmp.hh,&tmp.mm,&tmp.ss);
		if(cmp(tmp,ans2)==true)
			ans2=tmp;
	}
	printf("%s %s\n",ans1.id,ans2.id);
	return 0;
}
```



##### 1036 Boys vs Girls

思路：定义一个结构体数组`stu`，将学生信息存储为属性，依次输入，再根据性别判断，更新对应key值

```c++
#include<cstdio>
#include<iostream>
using namespace std;
struct person{
	char name[15];
	char gender;
	char id[15];
	int score;
}stu[1000];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;i++)
	{
		cin>>stu[i].name>>stu[i].gender>>stu[i].id>>stu[i].score;
	}
	
	int mGrade=0;int mNum=0;int mKey=0;
	int fGrade=0;int fNum=0;int fKey=0;
	for(int i=0;i<n;i++)
	{
		if(stu[i].gender=='M'&&mNum==0){
			mGrade=stu[i].score;
			mNum++;
			mKey=i;
		}else if(stu[i].gender=='M'&&stu[i].score<mGrade){
			mGrade=stu[i].score;
			mKey=i;
		}
		
		if(stu[i].gender=='F'&&fNum==0){
			fGrade=stu[i].score;
			fNum++;
			fKey=i;
		}else if(stu[i].gender=='F'&&stu[i].score<fGrade){
			fGrade=stu[i].score;
			fKey=i;
		}
	}
	
	
	if(fNum==0) printf("Absent\n");
	else printf("%s %s\n",stu[fKey].name,stu[fKey].id);
	if(mNum==0) printf("Absent\n");
	else printf("%s %s\n",stu[mKey].name,stu[mKey].id);
	if(mNum==0||fNum==0) printf("NA\n");
	else printf("%d",stu[fKey].score-stu[mKey].score);
	return 0;
}
```



### 3.3图形输出

#### PAT-B

##### 1027打印沙漏

思路：可以将沙漏看作一个倒三角一个正三角，

- 假设三角有k行，每行符号数为1、3、5......2k-1。 则总符号数等差求和： 1+2(3+2*k-1)*(k-1)/2
- 由题2k^2-1<=n;可以解得行数k，然后依次打印倒三角正三角
- 注意：有一组答案错误，我测试了几个n，发现n=7/8时求k会为1(开根号的问题)，因该直接设k=3
- 我的基本思路是没问题的，不过还是提交有一组数据答案错误。。。找了半天也想不到为啥

```c
#include<cstdio>
#include<cmath>
int main()
{
	int n;
	char c;
	scanf("%d %c",&n,&c);
	int k;
	if(n>9||n<7)
		k=(int)sqrt((n-1.0)/2.0);
	if(n==7||n==8)
		k=2;
	int blank;
	for(int i=k;i>=1;i--)
	{
		blank=k-i;
		for(int j=0;j<blank;j++)
			printf(" ");
		for(int j=0;j<(2*i-1);j++)
			printf("%c",c);
		printf("\n");
	}
	for(int i=2;i<=k;i++)
	{
		blank=k-i;
		for(int j=0;j<blank;j++)
			printf(" ");
		for(int j=0;j<(2*i-1);j++)
			printf("%c",c);
		printf("\n");
	}
	printf("%d\n",n-(2*k*k-1));
	return 0;
}
```



##### 1036跟奥巴马学编程

思路：行数为列数的一般，即row=col/2+1或row=col/2，第一行和第row行输出n个，其他行暑促首尾两个

```c
#include<cstdio>
int main()
{
	int row,col;
	char ch;
	scanf("%d %c",&col,&ch);
	if(col%2==1)
	 row=col/2+1;
	else
	 row=col/2;
	for(int i=0;i<col;i++)
	{
		printf("%c",ch);
	}
	printf("\n");
	for(int i=2;i<row;i++)
	{
		printf("%c",ch);
		for(int j=0;j<col-2;j++)
        {
            printf(" ");
        }
		printf("%c\n",ch);
	}
	for(int i=0;i<col;i++)
	{
		printf("%c",ch);
	}
	return 0;
}
```



#### PAT-A

##### 1031 Hello World for U

思路：将字符按数组输入便于计数，计算n1、n2、n3；

- 由题`n1=n3=max{k|k<=n2 for all 3<=n2<=N}`可知n1、n3是可行条件中尽可能大的值，此时n2为尽可能小的值，由`(N-n2)/2+1<=n2`得`(N+2)/3<=n2`，所以先取`n2=(N+2)/3`，得到对应n1、n3
- 控制输出格式即可

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int main()
{
	char str[1000];
	cin>>str;
	int N=strlen(str);
	int n1,n2,n3;
	n1=n3=(N+2)/3,n2=N+2-n1-n3;
	for(int i=0;i<n1-1;i++)
	{
		printf("%c",str[i]);
		for(int j=0;j<n2-2;j++){
			printf(" ");
		}
		printf("%c\n",str[N-1-i]);
	}
	for(int i=0;i<n2;i++)
	{
		printf("%c",str[n1+-1+i]);
	}
	return 0;
}
```



### 3.5进制转换

#### PAT-B

##### 1022 D进制的A+B

思路：计算A+B，将结果转换为D进制，采用除基取余法

- 输出A+B存放的数组需要从高位到低位输出

```c
#include<cstdio>
int main()
{
    int a,b,d;
    scanf("%d%d%d",&a,&b,&d);
    int sum=a+b;
    int ans[31],num=0;
    do{
        ans[num++]=sum%d;
        sum/=d;
    }while(sum!=0);
    for(int i=num-1;i>=0;i--)
    {
        printf("%d",ans[i]);
    }
    return 0;
}
```



##### 1037 在霍格沃兹找零钱

思路：1个Galleon=17*29个Knut，1个Sickle=29个Knut，全部转换为Knut计算，将结果再转换回来即可

```c
#include<cstdlib>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
	int cost1,cost2,cost3;
	int pay1,pay2,pay3;
	scanf("%d.%d.%d %d.%d.%d",&cost1,&cost2,&cost3,&pay1,&pay2,&pay3);
	int cost=cost1*17*29+cost2*29+cost3;
	int pay=pay1*17*29+pay2*29+pay3;
	int cash=pay-cost;
	if(cash==0){
		printf("0.0.0");
	}
	else{
		if(cash<0){
			printf("-");
			cash=-cash;
		}
		int g=cash/(17*29);
		int s=(cash-g*17*29)/29;
		int k=cash-g*17*29-s*29;
		printf("%d.%d.%d",g,s,k);
	}
	return 0;
}
```



#### PAT-A

##### 1019 General Palidromic Number

思路：结合数制转换和回文数的判断

```c++
#include<cstdio>
bool judge(int z[],int num)
{
	for(int i=0;i<=num/2;i++){
		if(z[i]!=z[num-1-i]){
			return false;
		}
	}
	return true;
}
int main()
{
	int n,b,z[40],num=0;
	scanf("%d%d",&n,&b);
	do{
		z[num++]=n%b;
		n/=b;
	}while(n!=0);
	bool flag=judge(z,num);
	if(flag==true) printf("Yes\n");
	else printf("No\n");
	for(int i=num-1;i>=0;i--){
		printf("%d",z[i]);
		if(i!=0)printf(" ");
	}
	return 0;
}
```



##### 1027 Colors in Mars

思路：由于13*13=169>168；所以`x=a * 13^1 + b * 13^0`，可以开一个radix数组存储0到12，通过`a=x/13,b=x%13;`求出十三进制的a、b即可

```c++
#include<cstdio>
char radix[13]={'0','1','2','3','4','5','6','7','8','9','A','B','C'};
int main()
{
	int a,b,c;
	scanf("%d%d%d",&a,&b,&c);
	printf("#");
	printf("%c%c",radix[a/13],radix[a%13]);
	printf("%c%c",radix[b/13],radix[b%13]);
	printf("%c%c",radix[c/13],radix[c%13]);
	return 0;
}
```



##### 1058 A+B in Hogwarts

思路：题目是相当去各个部分相加然后进位，分别是2号位29进制和1号位17进制，0号位不进位

- 书上是采用取模、整除运算的方式，用长度为3的数组存储，三个数组a、b、c，结果运算：`c[i]=(a[i]+b[i]+carry)%mod`，进位运算：`carry=(a[i]+b[i]+carry)/mod`
- 我采用的是直接计算，然后判断进位，但是会有一组数据答案错误。。

```c++
#include<cstdio>
int main()
{
	int galleon1,sickle1,knut1,galleon2,sickle2,knut2;
	int a=0,b=0,c=0;
	scanf("%d.%d.%d %d.%d.%d",&galleon1,&sickle1,&knut1,&galleon2,&sickle2,&knut2);
	a+=galleon1+galleon2,b+=sickle1+sickle2,c+=knut1+knut2;
	if(c>29){
		b+=c/29;
		c%=29;
	}
	if(b>17){
		a+=b/17;
		b%=17;
	}
	printf("%d.%d.%d",a,b,c);
	return 0;
}
```



### 3.6字符串处理

#### PAT-B

##### 1006换个格式输出整数

思路：上机指南上用数组存放，其实可以直接求百、十、个位的数值，然后输出

```c
#include<stdio.h>
int main()
{
	int num;
	scanf("%d",&num);
	int i,j,k;
	i=num/100%10;
	j=num/10%10;
	k=num%10;
	for(int m=0;m<i;m++)printf("B");
	for(int m=0;m<j;m++)printf("S");
	for(int m=1;m<=k;m++)printf("%d",m);
	return 0;
} 
```



##### 1021个位数统计

思路：将数字以数组形式输入，然后strlen获取长度

- 定义ans[]数组存放0到9出现次数，最后输出不为0的数
- PAT不支持gets()函数的使用，换成cin即可

```c
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int main()
{
	char str[1000];
	cin>>str;
	int len=strlen(str);
	int ans[10]={0};
	for(int i=0;i<len;i++)
	{
		ans[str[i]-'0']++;
	}
	for(int i=0;i<10;i++)
	{
		if(ans[i]!=0)
		{
			printf("%d:%d\n",i,ans[i]);
		}
	}
	return 0;
}
```



##### 1031查验身份证

思路：

- 遍历输入的数组str，前17位判断是否为数字，是则乘权重求和，否则跳出当前循环
- 遍历完成后对求和sum取模判断，是否与第18位校验码一致

```c
#include<cstdio>
#include<cstring>
int w[20]={7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
char judge[15]={'1','0','X','9','8','7','6','5','4','3','2'};
int main()
{
	int n;
	scanf("%d",&n);
	bool flag=true;
	char str[20];
	for(int i=0;i<n;i++)
	{
		scanf("%s",str);
		int j,sum=0;
		for(j=0;j<17;j++)
		{
			if(!(str[j]>='0'&&str[j]<='9')) break;
			sum=sum+(str[j]-'0')*w[j];
		}
		if(j<17)
		{
			flag=false;
			printf("%s\n",str);
		}
		else
		{
			if(judge[sum%11]!=str[17])
			{
				flag=false;
				printf("%s\n",str);
			}
		}
	}
	if(flag==true)
		printf("All passed\n");
	return 0;
}
```



##### 1002写出这个数

思路：

- 以数组形式输入该数，累加求和sum，然后将每一位存储到数组ans中，show对应0到9输出形式
- 从高位到地位枚举ans，输出对应的show

```c
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int main()
{
	char str[110];
	cin>>str;
	int len=strlen(str);
	int sum=0;
	for(int i=0;i<len;i++)
	{
		sum+=str[i]-'0';
	}
	
	int num=0,ans[10];
	while(sum!=0)
	{
		ans[num]=sum%10;
		num++;
		sum/=10;
	}
	
	char show[10][5]={"ling","yi","er","san","si","wu","liu","qi","ba","jiu"};
	for(int i=num-1;i>=0;i--)
	{
		printf("%s",show[ans[i]]);
		if(i!=0) printf(" ");
		else printf("\n");
	}
	return 0;
}
```



##### 1009说反话

思路：cin.getline()读入一整行，然后从左至右枚举，以空格为分隔符划分单词，并以此存储到二维数组中，最后逆序输出。

```c
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int main()
{
    char str[100];
    cin.getline(str,100);
    int len=strlen(str),r=0,h=0;
    char ans[100][100];

    for(int i=0;i<len;i++)
    {
        if(str[i]!=' ')
        {
            ans[r][h++]=str[i];
        }
        else
        {
            ans[r][h]='\0';
            r++;
            h=0;
        }
    }

    for(int i=r;i>=0;i--)
    {
        printf("%s",ans[i]);
        if(i>0)
        printf(" ");
    }
    return 0;
}
```



##### 1014福尔摩斯的约会

思路：对给出的四个字符串，前两个包含DAY和HH，后两个包含MM

- 扫描前两个字符串，找到第一对相同的A-G的大写字母，其与A的距离即为星期数。
- 在上一步基础上继续找，直到找到第一队相同的0-9或A-N，转换到0-9和10-23
- 扫描后两个字符串，找到第一对相同位置的字母

**注**：

1.  1、2步中不是A-Z，而是要限定范围，即A-G或A-N；
2.  找HH是在第一步基础上往后继续找

```c
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int main()
{
	char week[7][5]={"MON","TUE","WED","THU","FRI","SAT","SUN"};
	char str1[70],str2[70],str3[70],str4[70];
	cin>>str1;
	cin>>str2;
	cin>>str3;
	cin>>str4;
	int len1=strlen(str1);
	int len2=strlen(str2);
	int len3=strlen(str3);
	int len4=strlen(str4);
	int i;
	for(i=0;i<len1&&i<len2;i++)
	{
		if(str1[i]==str2[i]&&str1[i]>='A'&&str2[i]<='G')
		{
			printf("%s",week[str1[i]-'A']);
			printf(" ");
			break;
		}
	}
	
	for(i++;i<len1&&i<len2;i++)
	{
		if(str1[i]==str2[i])
		{
			if(str1[i]>='0'&&str1[i]<='9')
			{
				printf("%02d:",str1[i]-'0');
				break;
			}
			else if(str1[i]>='A'&&str1[i]<='N')
			{
				printf("%02d:",str1[i]-'A'+10);
				break;
			}
		}
	}
	
	for(i=0;i<len3&&i<len4;i++)
	{
		if(str3[i]==str4[i])
		{
			if((str3[i]>='A'&&str3[i]<='Z')||(str3[i]>='a'&&str3[i]<='z'))
			{
				printf("%02d",i);
				break;
			}
		}
	}
	
	return 0;
}
```



##### 1024科学计数法

思路：主要就是定位指数`E`位置，然后在此基础上就可以确定左边的小数和右边的指数

- 指数为负：此时输出的形式为`0.000···0XXX`，小数点后连续的0的个数为`exp-1`，`XXX`为原来的数字部分。
- 指数为正：要考虑小数点移动后的位置

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int main()
{
	char str[10010];
	cin>>str;
	int len=strlen(str);
	if(str[0]=='-') printf("-");
	int pos=0;//定位E的位置
	while(str[pos]!='E')
	{
		pos++;
	}
	
	int exp=0;//存放指数
	for(int i=pos+2;i<len;i++)
	{
		exp=exp*10+str[i]-'0';
	}
	
	if(exp==0)//指数为0的情况
	{
		for(int i=1;i<pos;i++)
		{
			printf("%c",str[i]);
		}
	}
	
	if(str[pos+1]=='-')//若指数为负
	{
		printf("0.");
		for(int i=0;i<exp-1;i++)
		{
			printf("0");
		}
		printf("%c",str[1]);//输出除小数点外的数
        for(int i=3;i<pos;i++)
		{
			printf("%c",str[i]);
		}
	}
	else//指数为正
	{
		for(int i=1;i<pos;i++)//输出小数点移动之后的数
		{
			if(str[i]=='.')continue;//略过原小数点
			printf("%c",str[i]);//输出当前数位
			if(i==exp+2&&pos-3!=exp)
			{//原小数点和E之间的数字个数pos-3不能等于小数点右移位数exp
				printf(".");
			}
		}
        //如果指数exp较大，输出多余的0
		for(int i=0;i<exp-(pos-3);i++)
			printf("0");
	}
	return 0;
}
```



##### 1048数字加密

思路：要对两个数的每一位操作，因此用数组存储，为了从最低位0号开始，要将原数组反转

- 由于是从0开始，因此当前`i`为偶数对应数字的奇数，当前奇数对应数字偶数。满足对应条件执行相关操作。

```c++
#include<iostream>
#include<cstring>
using namespace std;
void reverse(char s[])
{
	int len= strlen(s);
	for(int i=0;i<len/2;i++)
	{
		int temp=s[i];
		s[i]=s[len-1-i];
		s[len-1-i]=temp;
	}
}
int main()
{
	char a[101],b[101],ans[101]={0};
	scanf("%s %s",a,b);
	reverse(a);
	reverse(b);
	int lenA=strlen(a);
	int lenB=strlen(b);
	int len=lenA>lenB?lenA:lenB;
	for(int i=0;i<len;i++)
	{
		int numA=i<lenA?a[i]-'0':0;
		int numB=i<lenB?b[i]-'0':0;
		if(i%2==0)
		{
			int tmp=(numA+numB)%13;
			if(tmp==10)ans[i]='J';
			else if(tmp==11)ans[i]='Q';
			else if(tmp==12)ans[i]='K';
			else ans[i]=tmp+'0';
		}
		else
		{
			int tmp=numB-numA;
			if(tmp<0)tmp+=10;
			ans[i]=tmp+'0';
		}
	}
	reverse(ans);
	puts(ans);
	return 0;
}
```



#### PAT-A

##### 1061 Dating

参照B1014福尔摩斯的约会

##### 1073 Scientific Notation

参照B1024科学计数法

##### 1001 A+B Format

思路：对输入的数字a、b求和得到sum，判断sum符号，再使用数组存储每一位输出（有一组答案错误。。）

- 判断符号输出，将sum取正数
- 数组输出从高位开始，注意0的情况

```c++
#include<cstdio>
int main()
{
	int a,b,sum;
	scanf("%d %d",&a,&b);
	sum=a+b;
	if(sum<0){
		printf("-");
		sum=-sum;
	}
	int len=0;
	int num[10];
	if(sum==0) num[len++]=0;
	do{
		num[len]=sum%10;
		sum/=10;
		++len;
	}while(sum);
	for(int i=len-1;i>=0;i--)
	{
		printf("%d",num[i]);
		if(i>0&&i%3==0)printf(",");
	}
	return 0;
}
```



##### 1005 Spell It Right

思路：用一个二维数组存放一到十的拼写，数字输入采用字符串形式，再转化为数字数组，将得到的数字数组作为下标输出对应拼写

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int main()
{
	char out[10][10]={"zero","one","two","three","four","five","six","seven","eight","nine"};
	char str[111];
	cin.getline(str,111);
	int num[10];
	int sum=0,pos=0;
	int len=strlen(str);
	for(int i=0;i<len;i++)
	{
		sum+=(str[i]-'0');
	}
	if(sum==0) printf("%s",out[0]);
	else{
		while(sum!=0){
			num[pos++]=sum%10;
			sum/=10;
		}
		for(int i=pos-1;i>=0;i--){
			printf("%s",out[num[i]]);
			if(i!=0)printf(" ");
		}
	}
	return 0;
}
```



##### 1035 Password

思路：题目意思是输入的字符串密码中，遇到有'1'转换为'@'、'O'转换为'o'、'l'转换为'L'、'0'转换为'%'，不存在修改的则按要求输出

1. 我一开始是想用string name和string pwd输入，然后调用string方法判断pwd[i]是否有指定的字符，n次输入中，每次输入都进行pwd的判断，然后count处理。但是这样有个问题：输出要先输出最后的count，然后才是count个pwd，而不能是满足条件的就输出，所以就有一个输入覆盖的问题，因此要把满足条件的先存储到一个string数组中，但是写出来的代码会崩溃。。。
2. 参考训练指南上，使用结构体存储比我的数组要好很多，n次循环输入结构体，还有 指南中使用将判断函数单独写出，结果输出count始终为0。。。最后在网上找了别人的code

```c++
#include <cstdio>
struct people{
	char name[20];
	char password[20];
	bool flag;
}p[1010];

int main () {
	int n, num = 0;
	scanf("%d", &n);
	for(int i = 0; i < n; i++) {
		scanf("%s %s", p[i].name, p[i].password);
		p[i].flag = 0;
		for(int j = 0; p[i].password[j] != '\0'; j++) {
			if(p[i].password[j] == '1') {
				p[i].password[j] = '@';
				p[i].flag = 1;
			}if(p[i].password[j] == '0') {
				p[i].password[j] = '%';
				p[i].flag = 1;
			}if(p[i].password[j] == 'l') {
				p[i].password[j] = 'L';
				p[i].flag = 1;
			}if(p[i].password[j] == 'O') {
				p[i].password[j] = 'o';
				p[i].flag = 1;
 			}
 		}
 		if(p[i].flag)
 			num ++;
	}
	if(num == 0) {
		if(n == 1)	printf("There is 1 account and no account is modified\n");
		else	printf("There are %d accounts and no account is modified\n", n);
	}
	else {
		printf("%d\n", num);
		for(int i = 0; i < n; i++) {
			if(p[i].flag)	printf("%s %s\n", p[i].name, p[i].password); 
		}
	}	
	return 0;
}
```



##### 1077 Kuchgiuse

思路：题目是找出N个字符串的公共后缀，不存在则输出nai

- 公共后缀要从后往前枚举，因此可以先采用reverse反转字符串，改为判断N个字符串的公共前缀，还有就算是要避免访问越界，可以在读入数据时，先求出所有字符串的最短长度min_len
- 枚举所有字符串在(0-min_len)范围内的字符，判断相同位置的字符串是否相同，相同则累计公共前缀长度，否则就停止，最后根据公共前缀长度来输出

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
char s[105][266];
void reverse(char * a){
    char ch;
    for(int i = 0, j = strlen(a) - 1; i < j; i++, j--){
        ch = a[i];
        a[i] = a[j];
        a[j] = ch;
    }
}
int main(){
    int N, min_len = 266;
    cin>>N;
    getchar();
    for(int i = 0; i < N; i++){
        cin.getline(s[i],266);
        min_len > strlen(s[i]) ? min_len = strlen(s[i]) : min_len = min_len;
        reverse(s[i]);
    }
    char ch; bool k; int jl = 0;
    for(int i = 0; i < min_len; i++){
        k = true;
        ch = s[0][i];
        for(int j = 1; j < N; j++){
            if(ch != s[j][i]){
                k = false;
                break;
            }
        }
        if(k) jl++;
        else break;
    }
    if(jl){
        for(int i = jl - 1; i >= 0; i--){
            cout<<s[0][i];
        }
    }else{
        cout<<"nai"<<endl;
    }
    return 0;
}
```



##### 1082 Read Number in Chinese

思路：将输入的数字按照中文形式输出，例`-12345`对应的是`Fu yi Wan liang Qian san Bai si Shi wu`，可以将数字、位数都存储为二维数组

- 设置下标left和right来处理数字的每一个节(个、万、亿)输出，即令left指向当前需要输出的位，而right指向与left同节的个位。
- 还要处理特殊位置的0，例如`-10301234`输出`Fu yi Qian ling san Shi Wan yi Qian er Bai san Shi si`，可以看到`30万`的那个`0`并未输出，`8008`输出`ba Qian ling ba`，只输出了一个`0`，可以看到字节位的0没有输出，重复的0也只输出一个
  - 可以设置bool型变量flag表示是否有累积的0。当前输出left指向的位之前，先判断该位是否位0：如果为0，则令flag位true，表示存在累计的0；如果非0，则根据flag的值来判断是否需要输出额外的0，一整个小节处理完后再输出

输出结果部分答案错误。

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
char num[10][5]={"ling","yi","er","san","si","wu","liu","qi","ba","jiu"};
char wei[5][5]={"Shi","Bai","Qian","Wan","Yi"};
int main()
{
	char str[15];
	cin.getline(str,10);
	int len=strlen(str);
	int left=0,right=len-1;
	if(str[0]=='-'){
		printf("Fu");
		left++;
	}
	while(left+4<=right){
		right-=4;
	}
	while(left<len){
		bool flag=false;
		bool isPrint=false;
		while(left<=right){
			if(left>0&&str[left]=='0'){
				flag=true;
			}else{
				if(flag==true){
					printf(" ling");
					flag=false;
				}
				if(left>0)printf(" ");
				printf("%s",num[str[left]-'0']);
				isPrint=true;
				if(left!=right){
					printf(" %s",wei[right-left-1]);
				}
			}
			left++;
		}
		if(isPrint==true&&right!=len-1){
			printf(" %s",wei[(len-1-right)/4+2]);
		}
		right+=4;
	}
	return 0;
}
```
