---
title: http协议详解
tags: 计网
categories: 基础
abbrlink: 5806080f
date: 2020-07-30 16:37:10
---

面试被问到http与https的区别，当时上课应用层主要就讲了个DNS域名系统，http一带而过https没提。。。

结果今天问面试官才知道一般还是考察应用层偏多。。。运输层网络层作为信道考察较少

今天好好总结一下HTTP

<!--more-->

### HTTP简介

超文本传输协议（英文：**H**yper**T**ext **T**ransfer **P**rotocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是面向事务的应用层协议，是万维网的数据通信的基础。

### 原理概述

HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。



### HTTP工作原理

#### 原理概念

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

<img src="http://img2.salute61.top/http1.png" style="zoom:67%;" />

每个万维网都有一个服务器进程，不断监听TCP的80端口，一边发现是否有浏览器向她发送连接建立请求，一旦监听到连接建立请求并创建了TCP连接后，浏览器就向万维网发出浏览某个页面的请求，服务器响应返回相应的页面，结束后释放TCP连接

#### 具体步骤

1. 客户端连接到Web服务器
   一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。
2. 发送HTTP请求
   通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。
3. 服务器接受请求并返回HTTP响应
   Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。
4. 释放连接TCP连接
   若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
5. 客户端浏览器解析HTML内容
   客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。



<font color="red">**例如，浏览器中输入`www.baidu.com`后流程如下：**</font>

- 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
- 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
- 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
- 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
- 释放 TCP连接;
- 浏览器将解析该 html 文本并渲染界面。



### HTTP是无状态的

HTTP是一种不保存状态,即无状态(stateless)协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别,协议对于发送过的请求或响应都不做持久化处理。同一个客户第二次访问同一个服务器页面时，服务器的响应与第一次被访问时是相同的。

无状态特性简化了服务器设计，使服务器更容易支持大量并发的HTTP请求



### HTTP是无连接的

HTTP协议本身是无连接的，即虽然HTTP使用了TCP连接，但是在通信双方交换HTTP报文之前不需要建立HTTP连接。它的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次响应一次，服务端和客户端就中断了。



HTTP请求一个万维网文档所需时间是该文档的传输时间加上两倍往返时间RTT(一个用于建立TCP连接；一个用于请求和接受文档)，<u>其中TCP建立连接的三报文握手中第三个报文段中的数据就是客户端对服务器的请求报文</u>



#### HTTP1.1持续连接

现在的http协议1.1版本不是直接就断开了，而是等一段时间，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的。

HTTP/1.1协议的持续连接有两种方式：**非流水式**和**流水方式**

非流水式：再客户收到前一个的响应后才发送下一个请求，节省了建立TCP连接所需的一个RTT时间

流水式：在收到服务器的响应报文之前就能继续发送新的请求报文，<u>客户端访问所有的对象只需花费一个RTT时间</u>



### HTTP报文格式

HTTP报文有两类：请求报文；响应报文

两种报文就是开始行不同，各内容之间用空格隔开

请求报文：方法（HTTP请求方法）、请求资源的URL、HTTP版本

响应报文：HTTP版本、状态码、描述状态的短语

![](http://img2.salute61.top/http2.png)

![](http://img2.salute61.top/http3.png)



### HTTP请求方法

**OPTION**

请求一些选项的信息。这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。

**GET**

请求读取由URL所标志的信息。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。

**HEAD**

请求读取由URL所标志的信息的首部。与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。

**POST**

给服务器添加信息（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。

**PUT**

在指明的URL下上传存储一个文档

**DELETE**

删除指定的URL所标识的资源

**TRACE**

用来进行环回测试的请求报文，主要用于测试和诊断

**CONNECT**

用于代理服务器



### HTTP状态码

状态码（Status-Code）分为五大类

| 状态码分类 | 类别&原因短语                                  |
| :--------- | ---------------------------------------------- |
| **1xx**    | 表示通知信息，如收到请求或正在处理             |
| **2xx**    | 表示成功，如接受或知道了                       |
| **3xx**    | 表示重定向，如要完成请求还必须采取进一步行动   |
| **4xx**    | 表示客户端的差错，如请求中有语法错误或不能完成 |
| **5xx**    | 表示服务器的差错，如服务器失效                 |

常见状态码：

- 200 - 请求成功
- 301 - 资源（网页等）被永久转移到其它URL（http重定向https即为301）
- 404 - 请求的资源（网页等）不存在
- 500 - 内部服务器错误
- 502 - 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应



### 浏览器实例

以点击百度为例，查看请求行和状态行的信息

#### 请求

```java
Request URL: https://www.baidu.com/  	//请求地址
Request Method: GET						//请求方法
Status Code: 200 OK						//状态码
Remote Address: 112.80.248.75:443		//地址
Referrer Policy: unsafe-url	
```

**请求标头**

```java
Accept: text/html......			//支持的数据类型
Accept-Encoding: gzip, deflate, br		//编码格式
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6	//语言环境
Cache-Control: max-age=0		//缓存控制
Connection: keep-alive			//连接
......
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36 Edg/84.0.522.49		//客户端信息
```



#### 响应

```java
Bdpagetype: 1
Bdqid: 0xfa9c8c0b0007119f
Cache-Control: private					//缓存控制
Connection: keep-alive					//连接
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
......
```





### **URL**

HTTP使用URI来传输数据和建立连接。URL(统一资源定位符)是一类特殊的URI，

一般形式：

> 协议://<主机IP>:<端口>/<路径>

以我的博客`http://salute61.top/2020/07/22/操作系统--进程管理/`为例

协议是http；www.salute61.top是对应主机服务器（默认省略了80端口）；/2020/07/22/操作系统--进程管理/是路径

后面还可以有查询（以`?`为起点，参数用`&`隔开再以`=`分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）;片段（以`#`字符为起点）



### 拓展：Cookie

上面说到过HTTP是无状态的，这样简化了服务器设计，但是实际工作中网站是希望能感识别用户的。例如网上购物时，一个用户要买多个商品，将一件商品加入购物车后还想继续浏览选购；或者网站相对某些用户的访问做限制等等。。。

要实现这些可以在HTTP中使用Cookie，表示在HTTP服务器和客户之间传递的状态信息。

**Cookie工作方式**

- 当用户A在浏览某个使用Cookie的网站时，该网站的服务器就为A产生一个唯一的识别码，并以此作为索引在服务器后端数据库中产生一个项目，然后给A的HTTP响应报文添加一个Set-Cookie首部行。
  - 例如`Set-Cookie：31d5b4c6d4c620ads15`。
- A收到响应后浏览器就在管理的特定Cookie文件中添加这一行。A以后继续浏览这个网站时，浏览器就会从Cookie文件中取出这个网站识别码并放到HTTP请求报文Cookie首部行中
  - 例如`Cookie：31d5b4c6d4c620ads15 `。
- 于是网站就能追踪用户31d5b4c6d4c620ads15（即用户A）在该网站的活动























