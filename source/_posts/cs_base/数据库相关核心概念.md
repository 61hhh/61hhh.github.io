---
title: 数据库相关核心概念
tags: 数据库
categories: 计算机基础
abbrlink: 914c342c
date: 2021-02-18 19:17:27
---
## 一、事务

### 概念

是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位

在SQL中定义事务的语句一般有：`BEGIN TRANSACTION`; `COMMIT`; `ROLLBACK`; 

一般COMMIT表示提交，即提交事务的所有操作，事务正常结束。

ROLLBACK表示回滚，即事务运行过程中发生某种故障不能继续执行，将事务对数据库中已完成的操作撤销，回滚到事务开始时的状态



### ACID特性

**原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持续性（Durability）**

- 原子性：事务是数据库的逻辑工作单位，事务中的操作要么都做要么都不做
- 一致性：事务执行的结果是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性。
- 隔离性：一个事务的执行不能被其他事务干扰。即一个事务的内部操作及其使用的数据对其他并发事务是隔离的，并发事务之间不能相互干扰
- 持续性：也称永久性（Permanence），指一个事务一旦提交，他对数据库的改变应该是永久性的

事务ACID特性可能遭到破坏的因素：

- 多个事务并行执行时，不同事物的操作交叉执行；
- 事务在运行过程中被强制停止；



事务ACID特性并不是平级的，它们的关系如下：

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对系统崩溃的情况

<img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/a58e294a-615d-4ea0-9fbf-064a6daec4b2.png" style="zoom:80%;" />



### AUTOCOMMIT

MySQL 默认采用自动提交模式。也就是说，如果不显式使用 `START TRANSACTION` 语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。



## 二、并发一致性问题

在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

### 1、丢失修改（W-W）

**丢失修改指一个事务的更新操作被另外一个事务的更新操作替换**。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。

<img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427141425200.png" alt="image-20230427141425200" style="zoom:80%;" />



### 2、读脏数据（W-R）

**读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据**。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

<img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427141408877.png" alt="image-20230427141408877" style="zoom:80%;" />



### 3、不可重复读（R-W）

**不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致**。例如：T1 读取一个数据，T2 对该数据做了修改。如果 T1 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

<img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427141450751.png" alt="image-20230427141450751" style="zoom:80%;" />



### 4、幻影读

**幻读本质上也属于不可重复读的情况**。T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。



不可重复读和幻影读的区别：

- 不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；
- 幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了



产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。

并发控制的主要技术：封锁、时间戳、乐观控制法、多版本并发控制等，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题



## 三、封锁

封锁是实现并发控制一个非常重要的技术。

### 封锁粒度

MySQL 中提供了两种封锁粒度：**行级锁**以及**表级锁**。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。



### 封锁类型

#### 1、读写锁

- 排他锁（Exclusive Lock，X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）
- 共享锁（Share Lock，S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）

有以下两个规定：

1. 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
2. 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

锁的兼容关系如下：

|   -   |  X   |  S   |
| :---: | :--: | :--: |
| **X** |  ×   |  ×   |
| **S** |  ×   |  √   |

#### 2、意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，**IX/IS 都是表锁**，**用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁**。有以下两个规定：

1. **意向共享锁（Intention Shared Lock，IS 锁）**：一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
2. **意向排他锁（Intention Exclusive Lock，IX 锁）**：一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

**意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。**



|  -   |  X   |  IX  |  S   |  IS  |
| :--: | :--: | :--: | :--: | :--: |
|  X   |  ×   |  ×   |  ×   |  ×   |
|  IX  |  ×   |  √   |  ×   |  √   |
|  S   |  ×   |  ×   |  √   |  √   |
|  IS  |  ×   |  √   |  √   |  √   |

- 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
- S 锁只和 S/IS 锁兼容
- **这里兼容关系针对的是表级锁**，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）



### 封锁协议

#### 1、三级封锁协议

##### 一级封锁协议

事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。

可以解决丢失修改问题，但是仅仅读数据是不需要加锁的，因此不能保证可重复读和不读“脏”数据

##### 二级封锁协议

在一级封锁协议的基础上，增加事务 T 读取数据 R 之前必须加 S 锁，读完可释放 S 锁。

可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。由于读完数据就释放S锁，因此不能保证可重复读

##### 三级封锁协议

在一级封锁协议基础上，增加事务 T 读取数据 R 之前必须对其加 S 锁，直到事务结束才可以释放。

可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

#### 2、两段锁协议

加锁和解锁分为两个阶段进行。

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。

**事务遵循两段锁协议是保证可串行化调度的充分条件**。例如以下操作满足两段锁协议，它是可串行化调度。

```
lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
```

但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。

```
lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
```



### MySQL隐式和显示锁定

MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

InnoDB 也可以使用特定的语句进行显示锁定：

```
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```



## 四、隔离级别

### 读未提交（READ UNCOMMITTED）

事务中的修改，即使没有提交，对其它事务也是可见的。

### 读已提交（READ COMMITTED）

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

### 可重复读（REPEATABLE READ）

指事务执行过程中看到的数据，和该事务启动时看到的数据是一致的。保证在同一个事务中多次读取同一数据的结果是一样的。

### 串行化（SERIALIZABLE）

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。



------

| 隔离级别 | 脏读 | 不可重复读 | 幻影读 |
| :------: | :--: | :--------: | :----: |
| 读未提交 |  √   |     √      |   √    |
| 读已提交 |  ×   |     √      |   √    |
| 可重复读 |  ×   |     ×      |   √    |
|  串行化  |  ×   |     ×      |   ×    |



## 五、多版本并发控制

多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于*实现读已提交和可重复读这两种隔离级别*。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

### 基本思想

在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。

在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 `CopyOnWrite` 类似。

在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。

**脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改**。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。



### 版本号

- 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号 TRX_ID ：事务开始时的系统版本号。



### 隐藏列

MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号:

- 创建版本号: 指示创建一个数据行的快照时的系统版本号；
- 删除版本号: 如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。



### undo 日志

MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。

<img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/e41405a8-7c05-4f70-8092-e961e28d3112.jpg.jpeg" style="zoom:80%;" />

MySQL 在执行增删改操作时如果没有显式开始事务，由于 AUTOCOMMIT 设置会默认将每个操作语句都当作一个事务。INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。



### ReadView

MVCC 维护了一个 ReadView 结构，主要包含了：创建 ReadView 的事务id、当前系统未提交的事务列表、最小事务id、最大事务id

<img src="https://leslie1-1309334886.cos.ap-shanghai.myqcloud.com/obsidian/image-20230427145140377.png" alt="image-20230427145140377" style="zoom:80%;" />

在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：

- TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。
- TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。
- TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：
  - 提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
  - 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。



### 快照读与当前读

1、快照读

使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销

```sql
select * from table ...;
```

2、当前读

读取的是最新的数据，需要加锁。SELECT也可以强制加锁，以下第一个语句需要加 S 锁，其它都需要加 X 锁

```sql
select * from table where ? lock in share mode;
select * from table where ? for update;
insert;
update;
delete;
```



## 六、Next-Key Locks

Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题

### Record Locks

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用

### Gap Locks

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

### Next-Key Locks

它是 **Record Locks 和 Gap Locks 的结合**，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```



## 参考

- [SQL DB - 数据库系统核心知识点](https://www.pdai.tech/md/db/sql/sql-db-theory.html)
- [数据库系统原理](http://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html)
- [事务隔离级别是怎么实现的？](https://xiaolincoding.com/mysql/transaction/mvcc.html)